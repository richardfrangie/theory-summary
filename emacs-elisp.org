#+title: EMACS Lisp
#+date: 2022-05-20

* Keybindings
** IDE
*** Combobulate
**** Navigating

| /M-p/   | f6 c | combobulate-navigate-sequence-previous   |
| /M-n/   | f6 t | combobulate-navigate-sequence-next       |
| /M-a/   | f6 h | combobulate-navigate-logical-previous    |
| /M-e/   | f6 n | combobulate-navigate-logical-next        |
|       |      |                                          |
| /C-M-u/ | f6 g | combobulate-navigate-up                  |
| /C-M-d/ | f6 r | combobulate-navigate-down                |
| /C-M-p/ | f6 m | combobulate-navigate-previous (siblings) |
| /C-M-n/ | f6 w | combobulate-navigate-next (siblings)     |
|       |      |                                          |
| /C-M-a/ | f6 d | combobulate-navigate-beginning-of-defun  |
| /C-M-e/ | f6 b | combobulate-navigate-end-of-defun        |

**** Editing

| /M-P/       | C   | combobulate-drag-up         |
| /M-N/       | T   | combobulate-drag-down       |
|           |     |                             |
| /M-<up>/    | >   | combobulate-splice-up       |
| /M-<down>/  | E   | combobulate-splice-down     |
| /M-<left>/  | O   | combobulate-splice-self     |
| /M-<right>/ | U   | combobulate-splice-parent   |
|           |     |                             |
| /M-h/       | )   | combobulate-mark-node-dwim  |
| /C-M-h/     | *   | combobulate-mark-defun      |
|           |     |                             |
| /M-k/       | k   | combobulate-kill-node-dwim  |
| /C-c o c/   | RET | combobulate-clone-node-dwim |
| /C-M-t/     | ;   | combobulate-transpose-sexps |

**** Cursor

| /C-c o t x/ | o h | combobulate-cursor-edit-node-by-text-dwim  |
| /C-c o t t/ | o t | combobulate-cursor-edit-node-type-dwim     |
| /C-c o t s/ | o n | combobulate-cursor-edit-node-siblings-dwim |
| /C-c o t c/ | o s | combobulate-cursor-edit-sequence-dwim      |
| /C-c o t q/ | o g | combobulate-cursor-edit-query              |

**** Envelope

| /M-(/       | , h | combobulate-javascript-envelope-wrap-parentheses |
| /C-c o e i/ | , t | combobulate-javascript-envelope-if-statement     |
| /C-c o e t/ | , n | combobulate-javascript-envelope-tag <..>..</..>  |
| /C-c o e e/ | , s | combobulate-javascript-envelope-expression {..}  |
|           |     |                                                  |
| /C-c o e @/ |     | combobulate-css-envelope-media-query             |
| /C-c o e =/ |     | combobulate-javascript-envelope-attr-string      |
| /C-c o e =/ |     | combobulate-javascript-envelope-attr-expression  |

**** Miscellaneous

| /C-c o o/   |       | combobulate                                   |
|           | z     | combobulate-mode                              |
|           |       |                                               |
| /C-c o x b/ |       | combobulate-xref-find-query-buffer-references |
|           |       |                                               |
| /C-c o B q/ |       | combobulate-query-builder                     |
| /C-c o B p/ |       | combobulate-query-builder-match-node-at-point |
| /C-c o B r/ |       | combobulate-query-builder-root-to-point       |
|           |       |                                               |
| /C-c o h h/ |       | combobulate-highlight-dwim-at-point           |
| /C-c o h q/ |       | combobulate-highlight-query                   |
| /C-c o h c/ |       | combobulate-highlight-clear                   |
|           |       |                                               |
| /C-p/       | C-S-c | Move to the previous field                    |
| /C-n/       | C-S-t | Move to the next field                        |
| /C-v/       |       | Toggle the current field on or off            |
| /C-i/       |       | Invert the enabled/disabled state all fields  |

**** Notes

- Html treesitter doesn't work, therefore Combobulate doesn't work either. I installed the latest version and version v.0.20.1 and neither worked

- To enable combobulate: you can enable ~mhtl-mode~, then place the cursor inside JS tag (JS code) and turn on Combobulate. This uses the JS treesiter; it's not the same as using the Html one, but at least it works

*** Eglot
**** Commands

| f6 e h   | eglot-find-implementation          |
| f6 e t   | eglot-find-declaration             |
| f6 e n   | eglot-find-typeDefinition          |
| f6 e r   | eglot-rename                       |
|          |                                    |
|          |                                    |
| f6 e TAB | eglot-format                       |
|          | eglot-format-buffer                |
|          |                                    |
|          | eglot-inlay-hints-mode             |
|          | eglot-momentary-inlay-hints        |
| f6 e u   | eglot-code-actions                 |
|          | eglot-code-action-organize-imports |
|          | eglot-code-action-quickfix         |
|          | eglot-code-action-extract          |
|          | eglot-code-action-inline           |
|          | eglot-code-action-rewrite          |
|          |                                    |
|          | eglot-semantic-tokens-mode         |
|          | eglot-show-type-hierarchy          |
|          | eglot-call-type-hierarchy          |

**** Start/Stop

| f6 e z     | eglot                                    |
| C-u f6 e z | eglot (prompt)                           |
|            |                                          |
| f6 e v     | eglot-reconnect                          |
| f6 e Z     | eglot-shutdown-all                       |
| f6 e z     | eglot-shutdown                           |
| C-u f6 e z | eglot-shutdown (not kill output buffers) |
|            |                                          |
|            | eglot-events-buffer                      |
|            | eglot-stderr-buffer                      |
|            |                                          |
|            | eglot-upgrade-eglot                      |

**** Variables

|   | eglot-server-programs (server)       |
|   | eglot-workspace-configuration        |
|   | eglot-diagnostics-map                |
|   |                                      |
|   | eglot-stay-out-of                    |
|   | eglot-ignored-server-capabilities    |
|   | eglot-report-progress                |
|   |                                      |
|   | eglot-server-initialized-hook        |
|   | eglot-connect-hook                   |
|   | eglot-managed-mode-hook              |
|   |                                      |
|   | eglot-confirm-server-initiated-edits |
|   |                                      |
|   | project--list                        |
|   |                                      |
|   | eglot-extend-to-xref                 |
|   | eglot-report-progress                |

**** Troubleshooting

|   | eglot-events-buffer                 |
|   | eglot-stderr-buffer                 |
|   |                                     |
|   | eglot-forget-pending-continuations  |
|   | eglot-signal-didChangeConfiguration |
|   |                                     |
|   | eglot-clear-status                  |
|   |                                     |
|   | eglot-events-buffer-config          |

*** Identifiers (xref)

| /M-./     | u h | xref-find-definitions                  |
| /C-x 4 ./ | u d | xref-find-definitions-other-window     |
| /C-x 5 ./ |     | xref-find-definitions-other-frame      |
|         |     |                                        |
| /M-?/     | u n | xref-find-references                   |
|         | u r | xref-find-references-and-replace       |
|         |     |                                        |
| /C-M-./   | u m | xref-find-apropos (pattern)            |
|         |     |                                        |
|         | u v | xref-query-replace-in-results          |
| /C-u M-x/ |     | xref-query-replace-in-results (regexp) |
|         |     |                                        |
| /M-,/     | u c | xref-go-back                           |
| /C-M-,/   | u t | xref-go-forward                        |
|         |     |                                        |
|         | u w | xref-pop-marker-stack                  |
|         |     |                                        |
|         | u u | tags-search                            |
|         | u p | tags-query-replace                     |
|         |     | fileloop-continue                      |
|         |     |                                        |
|         | u e | list-tags                              |
|         |     | tags-next-file                         |
|         |     | xref-etags-mode                        |
|         |     |                                        |
|         |     | xref-backend-functions (backends)      |
|         |     |                                        |
|         |     | xref-prompt-for-identifier             |
|         |     | xref-auto-jump-to-first-xref           |

*** Navigation (imenu)

| /M-g i/ | imenu                                  |
|       |                                        |
|       | imenu-auto-rescan                      |
|       |                                        |
|       | imenu-create-index-function (backends) |

*** Diagnostic (flycheck)

|               | p z | flycheck-mode                         |
| /C-c ! c/       | p v | flycheck-buffer (start explicitly)    |
| /C-c ! C-c/     | p w | flycheck-compile (run in as a shell)  |
|               |     |                                       |
| /C-c ! p/M-g p/ | p c | flycheck-previous-error               |
| /C-c ! n/M-g n/ | p t | flycheck-next-error                   |
|               | p g | flycheck-first-error                  |
| /C-c ! e/       | p u | flycheck-explain-error-at-point       |
|               |     |                                       |
| /C-c ! l/       | p p | flycheck-list-errors                  |
| /C-c ! C/       | p o | flycheck-clear                        |
| /C-u C-c ! C/   |     | flycheck-clear (interrupt)            |
|               |     |                                       |
| /C-c ! s/       |     | flycheck-select-checker               |
| /C-c ! x/       |     | flycheck-disable-checker              |
| /C-u C-c ! x/   |     | flycheck-disable-checker (re-enable)  |
|               |     |                                       |
| /C-c ! ?/       |     | flycheck-describe-checker             |
| /C-c ! v/       |     | flycheck-verify-setup                 |
| /C-c ! V/       |     | flycheck-version                      |
|               |     | flycheck-set-checker-executable       |
|               |     |                                       |
|               |     | flycheck-checker (backends)           |
|               |     | flycheck-checkers (list)              |
|               |     | flycheck-disabled-checkers (list)     |
|               |     |                                       |
|               |     | flycheck-locate-config-file-functions |
|               |     | flycheck-local-config-file-functions  |
|               |     | flycheck-config-files (customize)     |
|               |     |                                       |
|               |     | flycheck-set-checker-executable       |
|               |     |                                       |
|               |     | flycheck-display-errors-delay         |

*** Diagnostic (flymake)

|           | . z | flymake-mode                                    |
|           |     | flymake-start                                   |
| /C-u M-x/   |     | flymake-start (re-start disabled backend list)  |
|           |     |                                                 |
|           | . c | flymake-goto-prev-error                         |
|           | . t | flymake-goto-next-error                         |
|           |     |                                                 |
|           | . . | rf-flymake-show-buffer-diagnostics-other-window |
|           | . > | flymake-show-buffer-diagnostics                 |
|           | . , | flymake-show-project-diagnostics-other-window   |
|           | . < | flymake-show-project-diagnostics                |
|           |     |                                                 |
| /M-g f/     |     | consult-flymake                                 |
| /C-u M-g f/ |     | consult-flymake (all buffers)                   |
|           |     |                                                 |
|           |     | flymake-diagnostic-functions (backends)         |
|           |     | flymake-switch-to-log-buffer                    |
|           |     |                                                 |
|           |     | flymake-reporting-backends                      |
|           |     | flymake-running-backends                        |
|           |     | flymake-disabled-backends                       |
|           |     |                                                 |
|           |     | flymake-show-diagnostics-at-end-of-line         |

*** Documentation (eldoc)

| f6 i i | eldoc                                      |
| f6 i h | eldoc-doc-buffer                           |
|        | eldoc-print-current-symbol-info            |
|        |                                            |
| f6 i z | eldoc-mode                                 |
|        |                                            |
|        | eldoc-documentation-functions (backends)   |
|        | eldoc-documentation-strategy               |
|        |                                            |
|        | eldoc-display-functions                    |
|        |                                            |
|        | eldoc-idle-delay                           |
|        | eldoc-echo-area-use-multiline-p            |
|        | eldoc-echo-area-display-truncation-message |

*** Completion

| /C-M-i/M-TAB/ | completion-at-point                      |
|             |                                          |
|             | completion-at-point-functions (backends) |
|             |                                          |
|             | completion-styles                        |
|             | completion-styles-alist                  |
|             | completion-category-overrides            |
|             |                                          |
|             | completions-sort                         |

*** Project

| C-x p f   | project-find-file                         |
| C-x p g   | project-find-regexp                       |
|           | project-search (stops when finds a match) |
|           | fileloop-continue                         |
| C-x p r   | project-query-replace-regexp              |
|           |                                           |
| C-x p d   | project-find-dir                          |
| C-x p D   | project-dired                             |
| C-x p v   | project-vc-dir                            |
|           |                                           |
| C-x p C-b | project-list-buffers                      |
| C-x p k   | project-kill-buffers                      |
| C-x p p   | project-switch-project                    |
|           |                                           |
| C-x p b   | project-switch-to-buffer                  |
|           | project-forget-project                    |
|           |                                           |
| C-x p s   | project-shell                             |
| C-x p e   | project-eshell                            |
| C-x p !   | project-shell-command                     |
| C-x p &   | project-async-shell-command               |
| C-x p o   | project-any-command                       |
| C-x p c   | project-compile                           |
|           |                                           |
|           | project-list-file                         |
|           | project-vc-include-untracked              |
|           | vc-directory-exclusion-list               |
|           |                                           |
|           | project-kill-buffer-conditions            |
|           | project-kill-buffers-display-buffer-list  |
|           |                                           |
|           | project-switch-commands                   |

*** Templates

| C-<tab>   | tempel-complete (complete and expand)     |
|           | tempel-expand   (expand only exact match) |
|           | tempel-insert                             |
|           |                                           |
| TAB       | tempel-next                               |
| backtab   | tempel-previous                           |
| M-RET     | tempel-done                               |
|           | tempel-kill                               |
|           |                                           |
| C-S-<tab> | yas-expand                                |

*** Dape

| /C-c d d/ | v z | dape                       |
| /C-c d r/ | v v | dape-restart               |
|         | v Z | dape-kill                  |
|         |     |                            |
| /C-c d c/ | v h | dape-continue              |
| /C-c d n/ | v t | dape-next                  |
| /C-c d s/ | v n | dape-step-in               |
| /C-c d o/ | v c | dape-step-out              |
| /C-c d p/ | v g | dape-pause                 |
| /C-c d u/ | v s | dape-until                 |
| /C-c d d/ | v r | dape-quit                  |
| /C-c d D/ | v l | dape-disconnect-quit       |
|         |     |                            |
| /C-c d b/ | v u | dape-breakpoint-toggle     |
| /C-c d B/ | v e | dape-breakpoint-remove-all |
| /C-c d e/ | v o | dape-breakpoint-expression |
| /C-c d h/ | v a | dape-breakpoint-hits       |
| /C-c d l/ | v ' | dape-breakpoint-log        |
|         |     |                            |
| /C-c d w/ | v p | dape-watch-dwim            |
| /C-c d x/ | v . | dape-evaluate-expression   |
|         |     |                            |
| /C-c d R/ | v , | dape-repl                  |
|         |     |                            |
| /C-c d i/ | v k | dape-info (windows)        |
|         | v j | dape-many-windows          |
|         |     |                            |
| /C-c d S/ | v q | dape-select-stack          |
|         |     |                            |
|         |     | dape-configs               |

** Buffer - Minibuffer
*** Minibuffer

| /C-j/    | minibuffer-complete-and-exit      |
| /RET/    | exit-minibuffer                   |
| /M-RET/  | minibuffer-choose-completion      |
| /C-g/    | abort-recursive-edit              |
|        |                                   |
| /<up>/   | previous-history-element          |
| /<down>/ | next-history-element              |
|        |                                   |
| /M-p/    | previous-history-element          |
| /M-n/    | next-history-element              |
|        |                                   |
| /M-s/    | next-matching-history-element     |
| /M-r/    | previous-matching-history-element |
|        |                                   |
| /M-</    | minibuffer-beginning-of-buffer    |
| /M->/    | minibuffer-end-of-buffer          |
|        |                                   |
| C-,    | se-take-the-word-at-point         |

*** Buffer

| /C-x k/       | kill-buffer            |
| /C-x b/       | switch-to-buffer       |
|             |                        |
| /C-x p/       | previous-buffer        |
| /C-x c/       | next-buffer            |
|             |                        |
| /C-x ESC ESC/ | repeat-complex-command |
|             |                        |
|             | display-buffer-alist   |

*** Ibuffer

| /C-x C-b/ | ibuffer                         |
| /C-x d/   | dired (list all files)          |
|         | find-dire (all file and subdir) |
|         |                                 |
| /m/       | Mark                            |
| /u/       | Unmark                          |
| /U/       | Unmark all                      |
| /t/       | toogel                          |
| /* u/     | Mark unsaved                    |
| /* M/     | Mark by mode                    |
| /% m/     | Mark by mode using regexp       |
| /% n/     | Mark by name using regexp       |
|         |                                 |
| /S/       | Save marked buffer              |
| /D/       | Kill marked buffers             |
| /i/       | list subdirectories (on a dir)  |
|         |                                 |
| /RET/     | View the buffer on this line    |
| /o/       | As above, but in another window |
| /C-o/     | As both above,but no new window |

*** Vertico

| /TAB/   | vertico-insert     |
| /RET/   | vertico-exit       |
| /M-RET/ | vertico-exit-input |

*** Orderless

| /!/ | orderless-not            |
| /,/ | orderless-initialism     |
| /=/ | orderless-literal        |
| /^/ | orderless-literal-prefix |
| /~/ | orderless-flex           |
| /&/ | orderless-annotation     |
| /%/ | ignoring diacritics      |

| /\/   | whitespace     |
| /\b/  | boundary       |
| /\</  |                |
| /[ ]/ | any characters |

*** Consult
**** Virtual buffers

| /C-x b/   | consult-buffer              |
| /C-x 4 b/ | consult-buffer-other-window |
| /C-x 5 b/ | consult-buffer-other-frame  |
| /C-x p b/ | consult-project-buffer      |
| /C-x r b/ | consult-bookmark            |
|         | consult-recent-file         |
|         |                             |
| /* SPC/   | narrow modified buffers     |
| /b SPC/   | narrow buffers              |
| /f SPC/   | narrow recent files         |
| /m SPC/   | narrow bookmarks            |
| /p SPC/   | narrow project              |
| /r SPC/   | narrow file registers       |
| /SPC/     | narrow hidden buffers       |

**** Editing

| /M-y/ | consult-yank-pop |
|     | consult-kmacro   |

**** Register

|     | consult-register       |
| /M-'/ | consult-register-store |
| /M-#/ | consult-register-load  |

**** Navigation

|       | consult-org-heading     |
| /M-g o/ | consult-outline         |
| /M-g i/ | consult-imenu           |
| /M-g I/ | consult-imenu-multi     |
| /M-g g/ | consult-goto-line (l:c) |
| /M-g m/ | consult-mark            |
| /M-g k/ | consult-global-mark     |
|       |                         |
|       | outline-regexp          |

**** Search

| /M-s l/     | consult-line                                |
| /M-s L/     | consult-line-multi                          |
|           |                                             |
| /M-s k/     | consult-keep-line (keep/flush replacement)  |
| /! SPC/     | the filter matches the complement           |
|           |                                             |
| /M-s f/     | consult-focus-line (temporarily hide)       |
| /C-u M-s f/ | consult-focus-line (reveal again)           |
| /! SPC/     | the filter matches the complement           |
| /M-s f RET/ | consult-focus-line (reveal again,other way) |
|           |                                             |
| /M-e/       | consult-isearch-history                     |

**** Grep and find

| /C-u M-x/   | consult-find (specifies initial dir)   |
| /C-u M-x/   | consult-find (sudo dir /sudo::)        |
|           |                                        |
| /M-s d/     | consult-find                           |
| /M-s d/     | add /-- -type d/ (to find only dir)      |
| /variable/  | consult-find-args (arguments for find) |
|           | consult-fd                             |
|           | consult-locate                         |
|           |                                        |
| /M-s g/     | consult-grep                           |
| /C-u M-s g/ | consult-grep (select dir)              |
| /C-u M-s g/ | consult-grep *(select files (pattern)) |
|           |                                        |
| /M-s G/     | consult-git-grep                       |
|           | consult-ripgrep                        |
|           |                                        |
|           | #regexps#filter-string                 |
| /\SPC/      | match space literally                  |

,* Use embark: first type  ~C-u M-x consult-grep~, then the pattern (~*.el~), then =C-a= (embark select all), then =RET=, then confirm =y=, and then the string (word to looking for).

**** Compilation

|       | consult-xref    |
| /M-g f/ | consult-flymake |
|       |                 |
| /e SPC/ | show errors     |
| /w SPC/ | show warnings   |
| /n SPC/ | show notes      |

**** Histories

| /M-s/ | consult-history         |
| /M-r/ | consult-history         |
| /M-e/ | consult-isearch-history |
|     | consult-complex-command |

**** Modes

|       | consult-mode-command    |
|       | consult-minor-mode-menu |
|       |                         |
| /i SPC/ | on modes                |
| /o SPC/ | off modes               |
| /l SPC/ | local modes             |
| /g SPC/ | global modes            |

**** Miscellaneous

|   | consult-man   |
|   | consult-info  |
|   | consult-theme |

*** Embark
**** Embark

| /C-;/       | embark-dwim                 |
| /C-./       | embark-act                  |
|           |                             |
| /C-h B/     | embark-bindings             |
| /C-u C-h B/ | embark-bindings (global)    |
|           |                             |
| /C-SPC/     | mark                        |
| /SPC/       | embark-select               |
| /A/         | embark-act-all              |
| /E/         | embark-export               |
| /S/         | embark-collect              |
| /L/         | embark-live                 |
| /B/         | embark-become               |
| /q/         | embark-toggle-quit          |
| /w/         | embark-copy-as-kill         |

- Asynchronous search :: search among file *names* and then search within the matching files (~consult-find~ -> ~embark-act-all~ -> ~consult-grep~)
- To deselect embark selections, press ~embark-select~ again over selection
- To remove all selections, press ~M-x embark-act-all SPC~

**** Embark minibuffer

| /C-. C-h/ | embark buffer to minibuffer |
| /C-. C/   | +embark-consult-search-map  |
| /1/       | digit-argument              |
|         |                             |
| /C-l/     | embark-select               |
| /C-x E/   | embark-export               |
| /C-x S/   | embark-collect              |
| /C-x A/   | embark-act-all              |
| /C-w/     | re-embark-kill-buffer       |

**** Embark collect

| /a SPC/ | select candidate            |
| /a/     | embark-act                  |
| /A/     | embark-act-all              |
| /g/     | revert-buffer               |

**** Embark prog
***** Act on command

| /RET/ | helpful-callable             |
|     |                              |
| /e/   | pp-eval-expression           |
| /x/   | execute-extended-command     |
|     |                              |
| /i*/  | embark-previous-symbol       |
| /k*/  | embark-next-symbol           |
| /r/   | xref-find-references         |
|     |                              |
| /o/   | occur                        |
|     |                              |
| /d/   | embark-find-definition       |
| /I/   | Info-goto-emacs-command-node |
| /s/   | embark-info-lookup-symbol    |
| /h/   | describe-symbol              |
| /b/   | where-is                     |
| /a/   | apropos                      |
|     |                              |
| /H/   | embark-toggle-highlight      |

***** Act on defun

| /RET/     | embark-pp-eval-defun |
|         |                      |
| /e/       | embark-pp-eval-defun |
| /</       | embark-eval-replace  |
|         |                      |
| /TAB/     | indent-region        |
| /o/       | checkdoc-defun       |
|         |                      |
| /N/       | narrow-to-defun      |
| /C-x n w/ | widen (exit narrow)  |
|         |                      |
| /i*/      | backward-list        |
| /k*/      | forward-list         |
| /u*/      | backward-up-list     |
|         |                      |
| /K/       | kill-region          |
| /t*/      | transpose-sexps      |

***** Act on expression

| /RET/ | pp-eval-expression  |
|     |                     |
| /e/   | pp-eval-expression  |
|     |                     |
| /TAB/ | indent-region       |
| /</   | embark-eval-replace |
|     |                     |
| /i*/  | backward-list       |
| /k*/  | forward-list        |
| /u*/  | backward-up-list    |
|     |                     |
| /K/   | kill-region         |
| /t*/  | transpose-sexps     |

***** Act on symbol/function

| /RET/ | helpful-callable          |
| /e/   | pp-eval-expression        |
| /o/   | occur                     |
|     |                           |
| /i*/  | embark-previous-symbol    |
| /k*/  | embark-next-symbol        |
| /r/   | xref-find-references      |
|     |                           |
| /d/   | embark-find-definition    |
| /h/   | describe-symbol           |
| /a/   | apropos                   |
| /s/   | embark-info-lookup-symbol |
|     |                           |
| /$/   | ispell-word               |
| /H/   | embark-toggle-highlight   |

***** Act on identifier

| /RET/ | xref-find-definitions   |
|     |                         |
| /i*/  | embark-previous-symbol  |
| /k*/  | embark-next-symbol      |
|     |                         |
| /a/   | xref-find-apropos       |
| /r/   | xref-find-references    |
| /d/   | xref-find-definitions   |
|     |                         |
| /s/   | info-lookup-symbol      |
| /h/   | display-local-help      |
|     |                         |
| /o/   | occur                   |
| /$/   | ispell-word             |
| /H/   | embark-toggle-highlight |

***** Act on variable

| /RET/ | helpful-variable             |
|     |                              |
| /t/   | embark-toggle-variable       |
| /=/   | set-variable                 |
| /v/   | embark-save-variable-value   |
| /</   | embark-insert-variable-value |
|     |                              |
| /e/   | pp-eval-expression           |
| /o/   | occur                        |
|     |                              |
| /d/   | embark-find-definition       |
| /s/   | embark-info-lookup-symbol    |
| /h/   | describe-symbol              |
| /a/   | apropos                      |
|     |                              |
| /i*/  | embark-previous-symbol       |
| /k*/  | embark-next-symbol           |
| /r/   | xref-find-references         |
|     |                              |
| /H/   | embark-toggle-highlight      |

***** Act on library

| /RET/ | find-library      |
|     |                   |
| /l/   | load-library      |
| /f/   | find-library      |
| /L/   | locate-library    |
|     |                   |
| /a/   | apropos-library   |
| /h/   | finder-commentary |
|     |                   |
| /$/   | eshell            |

**** Embark files
***** Act on file

| /RET/ | find-file                 |
|     |                           |
| /f/   | find-file                 |
| /o/   | find-file-other-window    |
| /x/   | embark-open-externally    |
| /l/   | load-file                 |
| /=/   | ediff-files               |
| /W/   | embark-save-relative-path |
| /\/   | embark-recentf-remove     |

***** Act on region

| /n/       | narrow-to-region            |
| /C-x n w/ | widen (exit narrow)         |
| /o/       | org-table-convert-region    |
| /d/       | delete-duplicate-lines      |
| /$/       | ispell-region               |
| /F/       | whitespace-cleanup-region   |
|         |                             |
| /c/       | capitalize-region           |
| /l/       | downcase-region             |
| /u/       | upcase-region               |
|         |                             |
| /e/       | eval-region                 |
| /¦/       | shell-command-on-region     |
| /</       | embark-eval-replace         |
|         |                             |
| /TAB/     | indent-region               |
| /right/   | indent-rigidly              |
| /left/    | indent-rigidly              |
|         |                             |
| /r/       | reverse-region              |
| /m/       | apply-macro-to-region-lines |
| /h/       | shr-render-region           |

***** Act on sentence/paragraph

| /l/ | downcase-region           |
| /u/ | upcase-region             |
| /c/ | capitalize-region         |
| /F/ | whitespace-cleanup-region |
| /$/ | ispell-region             |
| /=/ | count-words-region        |

***** Act on url

| /RET/ | browse-url          |
|     |                     |
| /d/   | embark-download-url |

***** Act on buffer

| /k/ | kill-buffer                   |
| /</ | insert-buffer                 |
| /=/ | ediff-buffers                 |
| /r/ | embark-rename-buffer          |
| /$/ | eshell                        |
| /o/ | switch-to-buffer-other-window |

**** Embark org
***** Act on org-heading

| /RET/     | embark-org-heading-default-action       |
|         |                                         |
| /t*/      | org-todo                                |
| /H/       | org-insert-todo-heading-respect-content |
|         |                                         |
| /p*/      | outline-previous-visible-heading        |
| /n*/      | outline-next-visible-heading            |
|         |                                         |
| /u*/      | outline-up-heading                      |
| /o/       | rf-outline-down-heading                 |
|         |                                         |
| /b*/      | outline-backward-same-level             |
| /f*/      | outline-forward-same-level              |
|         |                                         |
| /O/       | org-clock-out                           |
| /I/       | org-clock-in                            |
|         |                                         |
| /N/       | org-narrow-to-subtree                   |
| /C-x n w/ | widen (exit narrow)                     |
| /T/       | org-tree-to-indirect-buffer             |
|         |                                         |
| /C-SPC*/  | outline-mark-subtree                    |
| /k/       | org-cut-subtree                         |
| /r/       | org-refile                              |

***** Act on org-src-block

| /RET/     | org-indent-block               |
|         |                                |
| /TAB/     | org-indent-block               |
|         |                                |
| /c/       | embark-org-copy-block-contents |
| /C-SPC/   | org-babel-mark-block           |
| /'/       | org-edit-special               |
|         |                                |
| /C-x n w/ | widen (exit narrow)            |
| /N/       | org-narrow-to-block            |
|         |                                |
| /i*/      | org-babel-previous-src-block   |
| /k*/      | org-babel-next-src-block       |
| ///       | org-babel-demarcate-block      |
|         |                                |
|         | org-babel-execute-src-block    |

***** Act on org-item

| /RET/ | org-toggle-checkbox |
|     |                     |
| /i*/  | org-previous-item   |
| /k*/  | org-next-item       |
| /c*/  | org-toggle-checkbox |

***** Act on org-plain-list

| /RET/ | org-list-repair       |
|     |                       |
| /c*/  | org-toggle-checkbox   |
| /b*/  | org-cycle-list-bullet |
| /s/   | org-sort-list         |
| /r/   | org-list-repair       |

***** Act on org-url-link

| /RET/ | org-insert-link          |
|     |                          |
| /'/   | org-insert-link          |
|     |                          |
| /i*/  | org-previous-link        |
| /k*/  | org-next-link            |
|     |                          |
|     | org-open-at-point-global |

***** Act on cell

| /i*/     | org-table-move-row-up       |
| /k*/     | org-table-move-row-down     |
| /j*/     | org-table-move-column-left  |
| /l*/     | org-table-move-column-right |
|        |                             |
| /right*/ | org-table-move-cell-right   |
| /left*/  | org-table-move-cell-left    |
| /down*/  | org-table-move-cell-down    |
| /up*/    | org-table-move-cell-up      |

** Files
*** Files

| /C-x C-f/      | find-file                           |
| /C-x C-r/      | find-file-read-ONLY                 |
| /C-x C-s/      | save-buffer                         |
| /C-x C-w/      | write-file (save-as)                |
| /C-x s/        | save-many-buffer                    |
| /C-x C-q/      | mode-edit(change-only-read or edit) |
| /C-x i/        | insert-file-in-buffer               |
|              |                                     |
| /C-x 4 f/      | find-file-other-window              |
| /C-x 4 b/      | switch-to-buffer-other-window       |
| /C-x 4 C-o/    | display-buffer(other window)        |
| /C-x 4 r/      | find-file-read-only-other-win       |
| /C-x 4 c/      | clone-inderect-buffer-other-window  |
| /C-x 4 0/      | kill-buffer-and-window              |
| /C-x 4 d/      | dired-other-window                  |
|              |                                     |
| //sudo::/name/ | sudo open file                      |

*** Dired
**** Files

| /C-x d/   | dired (list all files)                |
|         | find-dired (list all file and subdir) |
|         | dired-do-find-regexp                  |
| /C-t d/   | image-dired-display-thumbs            |
|         |                                       |
| /o/       | dired-find-file-other-window          |
| /C-o/     | dired-display-file                    |
| /v/       | dired-view-file (only read)           |
| /r/       | dired-single-buffer                   |
| /b/       | dired-single-up-directory             |
| '/!/      | dired-do-shell-command                |
| /&/       | dired-do-async-shell-command          |
| /C-x C-q/ | d-toggle-read-only (edi dire bufer)   |
|         |                                       |
| /m/       | dired-mark                            |
| /u/       | dired-unmark                          |
| /U/       | dired-unmark-all-marks                |
| /% m/     | dired-mark-files-regexp               |
| /t/       | dired-toggle-marks                    |
| /Q/       | dired-do-query-replace-regexp         |

**** Navigate

| /r/     | dired-single-buffer       |
| /b/     | dired-single-up-directory |
| /RET/   | dired-find-file           |
| /g/     | revert-buffer (refresh)   |
| '/^/    | dired-up-directory        |
| />/     | dired-next-dirline        |
| /</     | dired-prev-dirline        |
| /z/     | dired-hide-dotfiles-mode  |
| /i/     | dired-maybe-insert-subdir |
| /s/     | dired-sort-toggle-or-edit |
| /j/     | dired-goto-file           |
| /%/ / /*/ | Prefix command            |

**** Copy - Rename - Delete - Compress

| /+/ | dired-create-directory       |
| /C/ | dired-do-copy                |
| /R/ | dired-do-rename              |
| /D/ | dired-do-delete              |
| /d/ | dired-flag-file-deletion     |
| /x/ | dired-do-flagged-deletion    |
| /k/ | dired-do-kill-lines          |
| /Z/ | dired-do-compress/decompress |
| /c/ | dired-to-compress-to         |

**** Group - Symlink - Load

| /M/ | dired-do-chmod   |
| /O/ | dired-do-chown   |
| /G/ | dired-do-chgrp   |
| /T/ | dired-do-touch   |
| /S/ | dired-do-symlink |
| /L/ | dired-do-load    |

*** Bookmarks

| /C-x r m/ | bookmark-set                      |
| /C-x r M/ | bookmark-set-no-overwrite         |
| /C-x r b/ | bookmark-jump                     |
| /C-x r l/ | bookmark-bmenu-list/list-bookmark |
|         | bookmark-save                     |
|         |                                   |
| /o/       | other window                      |
| /C-o/     | switch other window               |
| /D/       | mark                              |
| /d/       | delete                            |
| /s/       | save                              |
| /r/       | rename                            |
| /x/       | execute                           |
| /a/       | ahow annotation                   |
| /m/       | mark                              |

*** Image dired

|         | /Dired Mode/                                              |
| /C-t i/   | image-dired-dired-display-image (display)               |
| /C-t x/   | image-dired-dired-display-external (display external)   |
| /C-t d/   | image-dired-display-thumbs (display thumbs)             |
| /C-t C-t/ | image-dired-dired-toggle-marked-thumbs (view inline)    |
| /C-d/     | image-dired-delete-char (delete from thumbnails buffer) |
| /r/       | image-rotate                                            |
|         |                                                         |
|         | /Image Dired Thumbnail Mode/                              |
|         | image-dired                                             |
| /n/SPC/   | image-dired-display-next                                |
| /p/DEL/   | image-dired-display-previous                            |
| /RET/     | image-dired-display-this                                |
| /C-RET/   | image-dired-thumbnail-display-external                  |
| /m/       | image-dired-mark-thumb-original-file                    |
| /d/       | image-dired-flag-thumb-original-file (mark D flag)      |
| /u/       | image-dired-unmark-thumb-original-file                  |
| /U/       | image-dired-unmark-all-marks                            |
| /x/       | image-dired-do-flagged-delete                           |
| /r/       | image-rotate                                            |
| /s/       | image-dired-display-current-image-sized                 |
| /f/       | image-dired-display-current-image-full                  |
| /w/       | image-dired-copy-filename-as-kill                       |

*** Images

| /n/       | image-next-file                       |
| /p/       | image-previous-file                   |
| /w/       | image-mode-copy-file-name-as-kill     |
|         |                                       |
| /s w/     | image-transform-fit-to-window         |
| /s s/     | image-transform-set-scale             |
| /s p/     | image-transform-set-percent           |
| /s o/     | image-transform-reset-to-original     |
| /s 0/     | image-transform-reset-to-initial      |
|         |                                       |
| /C-f/C-p/ | point motion keys (scroll buffer)     |
| /C-c C-c/ | image-toggle-display (display vs raw) |
| /C-c C-x/ | image-toggle-hex-display              |
|         |                                       |
| /m/       | image-mode-mark-file                  |
| /u/       | image-mode-unmark-file                |
|         |                                       |
| /RET/     | image-toggle-animation (starts/stop)  |
| /f/       | image-next-frame                      |
| /b/       | image-previous-frame                  |
| /F/       | image-goto-frame                      |
|         | a + image-increase-speed              |
|         | a - image-decrease-speed              |
|         | a r image-reverse-speed               |
|         | a 0 image-reset-speed                 |
|         |                                       |
| /i +/     | image-increase-size (by 20%)          |
| /i -/     | image-decrease-size (by 20%)          |
| /i r/     | image-rotate                          |
| /i h/     | image-flip-horizontally               |
| /i v/     | image-flip-vertically                 |
| /i o/     | image-save                            |
| /i c/     | image-crop                            |
| /i x/     | image-cut                             |

*** Packages

| /C-h P/ | describe-package           |
|       | list-packages              |
| /i/     | package-install            |
| /d/     | package-delete             |
| /U/     | package-menu-mark-upgrades |
| /x/     | package-menu-execute       |
| ///     | package-menu-filter-by     |
| /h/     | package-menu-quick-help    |
|       |                            |
|       | package-upgrade-all        |
|       | package-vc-upgrade-all     |

** Org
*** Heading

| /M-RET/          | org-meta-return (new heading)      |
| /C-RET/          | org-insert-heading-respect-content |
| /M-left/right/   | org-do-promote                     |
| /M-S-left/right/ | org-promote-subtree                |
| /M-up/down/      | org-metaup/down(bullet)            |
| /M-S-up/down/    | org-shiftmetaup/down(line)         |
| /C-c C-x b/      | org-tree-to-indirect-buffer        |
|                |                                    |
| /C-c C-n/        | org-next-visible-heading           |
| /C-c C-p/        | org-previous-visible-heading       |
| /C-c C-u/        | outline-up-heading                 |
| /C-c C-f/        | org-forward-heading-same-level     |
| /C-c C-b/        | org-backward-heading-same-level    |
| /C-c C-j/        | org-goto                           |
|                |                                    |
| /TAB/            | org-cycle (expand header)          |
| /S-TAB/          | org-shifttab(expandHeader)         |
| /M-# S-TAB/      | all headlines at level #           |
| /C-# C-c TAB/    | only current headlines at level #  |
| /S-TAB-TAB/      | outline-show-all                   |
| /C-u C-u TAB/    | org-set-startup-visibility         |
|                |                                    |
|                | org-toggle-narrow-to-subtree       |
| /C-x n e/        | org-narrow-to-element              |
| /C-x n s/        | org-narrow-to-subtree              |
| /C-x n b/        | org-narrow-to-block                |

*** Todo

| /C-c C-t/ / /S-right/left/ | org-todo (cursor)                       |
| /C-c ,/ / /S-up/down/      | org-priority (cursor)                   |
|                        |                                         |
| /M-S-RET/                | org-insert-todo-heading                 |
| /C-S-RET/                | org-insert-todo-heading-respect-content |
|                        |                                         |
| /- [ ]/                  | to create checkbox                      |
| /S-M-RET/                | create another checkbox                 |
| /C-c C-c/                | org-toggle-checkbox                     |
|                        |                                         |
| /C-c ./                  | org-time-stamp                          |

*** Agenda

|                | org-agenda                         |
| /C-c ./          | org-time-stamp (date)              |
| /C-u C-c ./      | org-time-stamp (datetime)          |
| /S-left / right/ | change date day (cursor)           |
| /S-up / down/    | change time (cursor)               |
| /C-c C-d/        | org-deadline (press shift to move) |
| /C-c C-s/        | org-scheduled                      |
| /C-c C-q/        | org-set-tags-command               |
| /C-c C-q/        | org-match-sparse-tree              |
| /C-c C-t/        | org-todo     (change state)        |
| /C-c ,/          | org-priority                       |
|                |                                    |
| /C-c C-c/        | Set tag (cursor)                   |
| /S-left/right/   | change state org task (cursor)     |
|                |                                    |
| /C-c [/          | org-agenda-file-to-front           |
| /C-c ]/          | org-remove-file                    |

*** Timer

| /C-c C-x C-i/   | org-clock-in         |
| /C-c C-x C-o/   | org-clock-out        |
| /C-c C-x C-x/   | org-clock-in-last    |
| /C-c C-x C-q/   | org-clock-cancel     |
| /C-c C-x C-j/   | org-clock-jump       |
|               | org-clock-report     |
|               |                      |
| /C-c C-x C-e/   | org-clock-modify-eff |
| /C-c C-x e 3/   | org-set-effort 3     |
| /C-c C-x p/     | org-set-property     |
| /C-c C-x C-d/   | org-clock-display    |
| /C-c C-c/       | set run cancel       |
|               |                      |
| /C-c C-x 0/     | org-timer-start      |
| /C-c C-x ,/     | org pause o continue |
| /C-u C-c C-x ,/ | stop timer           |
| /C-c C-x -/     | org-timer-item       |

*** Table

| /C-c ¦/     | org-table-create-or-convert-from     |
| /S-TAB/     | org-table-previous-field             |
| /S-RET/     | org-table-copy-down                  |
| /M-left/    | org-table-move-column-left           |
| /M-S-left/  | org-table-delete-column              |
| /M-S-right/ | org-table-insert-column              |
| /M-up/      | org-table-move-row-up                |
| /M-S-up/    | org-table-kill-row                   |
| /M-a/       | org-table-beginning-of-field         |
| /M-e/       | org-table-end-of-field               |
|           |                                      |
| /C-c SPC/   | org-table-blank-field                |
|           |                                      |
| /C-c ^ n/   | org-table-sort-lines numeric         |
| /C-c ^ N/   | org-table-sort-lines numeric reverse |
| /C-c ^ a/   | org-table-sort-lines alphabetic      |
| /C-c ^ A/   | org-table-sort-lines alphabetic reve |
|           |                                      |
| /C-c +/     | org-table-sum                        |
| /C-c ~/     | org-table-create-with-table.el       |
| /C-c '/     | org-edit-special (inside table)      |
| /C-c C-c </ | adjusts the column width             |

*** Miscellaneous

| /C-c -/       | org-ctrl-c-minus (cursor)          |
|             |                                    |
| /C-c '/       | org-edit-special (open bufer code) |
| /C-c C-v v/   | org-babel-expand-src-block         |
| /C-c C-v t/   | org-babel-tangle                   |
| /C-c C-c/     | org-ctrl-c (eval code)             |
| /C-x C-s/     | org-edit-src-save                  |
|             |                                    |
| /C-c C-x C-f/ | org-emphasize                      |
| /C-c C-x C-b/ | org-toggle-inline-images           |
| /C-c C-e #/   | org-export-dispatch                |
| /C-c C-o/     | org-open-at-point (go to link)     |
|             |                                    |
| /C-c C-,/     | org-insert-structure-template      |
| /C-c C-x C-l/ | org-latex-preview                  |

** Windows - Frames
*** Windows

| /C-x o/     | other-window                  |
| /C-x 0/     | delete-select-window          |
| /C-x 1/     | delete-all-other-window       |
| /C-x 2/     | split-window-below            |
| /C-x 3/     | split-window-right            |
|           |                               |
| /C-c b/     | windmove-left                 |
| /C-c n/     | windmove-down                 |
| /C-c p/     | windmove-up                   |
| /C-c f/     | windmove-right                |
|           |                               |
| /C-c left/  | winner-undo                   |
| /C-c right/ | winner-redo                   |
|           | rotate-frame-clockwise        |
|           | window-swap-states            |
|           |                               |
| /C-l/       | recenter-top-bottom           |
| /S-M-C-l/   | recenter-other-window         |
|           |                               |
| /C-x ^/     | enlarge-window                |
|           | shrink-window                 |
| /C-x }/     | enlarge-window-horizontally   |
| /C-x {/     | shrink-window-horizontally    |
| /C-x +/     | balance-windows               |

*** ace-window

| /M-o/ | ace-window (other window)             |
|     |                                       |
| d   | delete window                         |
| w   | swap windows                          |
| m   | move window                           |
| c   | copy window                           |
| b   | select buffer                         |
| B   | select buffer in the other window     |
| F   | split window fairly (vert. or horiz.) |
| V   | split window vertically               |
| H   | split window horizontally             |
| ?   | show these command bindings           |
|     |                                       |
| n   | select the previous window            |
| o   | maximize current window               |

*** Frames

| /C-x 5 o/ | switch-frame             |
| /C-x 5 0/ | delete-select-frame      |
| /C-x 5 1/ | delete-all-frames        |
| /C-x 5 2/ | make-frame-same-terminal |
|         | rotate-frame-clockwise   |

** Cursor - Scroll - Mark
*** Cursor

| /C-</         | mc/previous-next(duplicat up) |
| /C->/         | mc/mark-next(duplicate down)  |
| /C-S-c C-S-c/ | mc/edit-lines(mark to cursor) |
| /C-u C-x =/   | what-cursor-position          |

*** Move cursor

| /C-f/        | forward-char                       |
| /C-b/        | backward-char                      |
| /M-f/        | forward-word                       |
| /M-b/        | bakcward-word                      |
|            |                                    |
| /C-a/ / /home/ | beginning-of-visual-line           |
| /C-e/ / /end/  | end-of-visual-line                 |
| /M-a/        | backward-sentence                  |
| /M-e/        | end-sentence                       |
|            |                                    |
| /C-x C-x/    | exchange-point-and-mark            |
| /C-SPC/      | set-mark-command                   |
| /C-u C-SPC/  | jump into marks ring               |
| /C-x C-SPC/  | move to previous in another buffer |
| /M-r/        | move-to-window-line-top-bottom     |

|-------------+-----------+------------+----------------+------------|
| /<-----/      | /<----/     | /<---/       | /<--/            | /<-/         |
|-------------+-----------+------------+----------------+------------|
| back par    | back-sent | beg line   | back-wor       | back-cha   |
| /M-{/ / /C-up/  | /M-a/       | /C-a/ / /home/ | /M-b/ / /C/M-left/ | /C-b/ / /left/ |
|-------------+-----------+------------+----------------+------------|
| /----->/      | /---->/     | /--->/       | /-->/            | /->/         |
|-------------+-----------+------------+----------------+------------|
| forw par    | forw-sent | end line   | forw-wor       | forw-cha   |
| /M-}/ / /C-dow/ | /M-e/       | /C-e/ / /end/  | /M-f/ / /C/M-righ/ | /C-f/ / /righ/ |

|---------------------+---------------|
| /</                   | ^             |
|---------------------+---------------|
| beginning-of-buffer | previous-line |
| /M-</ / /C-home/        | /up/            |
|---------------------+---------------|
| />/                   | /v/             |
|---------------------+---------------|
| end-of-buffer       | next-line     |
| /M->/ / /C-end/         | /down/          |

*** Scroll

| /C-l/       | recenter-top-bottom   |
| /S-M-C-l/   | recenter-other-window |
| /C-M-l/     | reposition-window     |
| /C-u 7 M-</ | 70% position buffer   |

|-------------+--------------------------+--------------------|
| /^/           | /^o/                       | /<o/                 |
|-------------+--------------------------+--------------------|
| scroll-up   | scroll-other-window      | beg -buf -other -w |
| /C-v/ / /next/  | /C-M-v/ / /M-next/           | /M-home/             |
|-------------+--------------------------+--------------------|
| /v/           | /vo/                       | />o/                 |
|-------------+--------------------------+--------------------|
| scroll-down | scroll-other-window-down | end -buf -other -w |
| /M-v/ / /prior/ | /C-M-S-v/ / /M-prior/        | /M-end/              |

*** Mark

| /M-h/       | mark-paragraph                |
| /C-x h/     | mark-whole-buffer             |
|           |                               |
| /C-SPC-SPC/ | set-mark                      |
| /C-x C-x/   | exchange-point-and-mark       |
| /C-u C-SPC/ | return to point mark          |
| /C-x C-SPC/ | pop-global-mark(other buffer) |
|           |                               |
|           | cua-rectangle-mark-mode       |
|           | rectangle-mark-mode           |

*** Region

| /C-x n n/     | narrow-to-region                |
| /C-x n w/     | remove restrictions narrowing   |
|             |                                 |
| /C-=/         | er/expand-region                |
|             | /=/ to expand again /-/ to contract |
|             |                                 |
| /C-M-mouse-1/ | rectangular region              |

** Text - Help
*** Text

| /M-w/          | kill-ring-save(copy)                 |
| /C-w/          | kill-region(cut)                     |
| /C-y/          | reinsert-text-last(paste)            |
| /M-y/          | reinsert-text-befores (paste others) |
| /C-//          | deshacer(undo)                       |
| /C-g C-//      | rehacer(redo)                        |
| /C-x r k/      | kill-rectangle(cut first n char)     |
|              |                                      |
| /M-S-down/     | duplicate-things                     |
| /M-up/down/    | drag-stuff-up/down(move line)        |
| /M-left/right/ | drag-stuff-left/right                |
|              |                                      |
| /M-s h p/      | highlight-phrase                     |
| /M-s h u/      | unhilight-regexp                     |
| /C-x r s/      | copy-to-register                     |
| /C-x r i/      | insert-register                      |
| /M-%/          | query-replace                        |
| /C-q TAB/      | quoted-insert                        |
|              |                                      |
| /C-x r N/      | rectangle-number-lines               |
| /M-=/          | count-words-region                   |

*** Kill text

| /---->/       | /--->/        | /-->/         | /->/          |
| kill-sent f | kill line f | kill-word f | del char f  |
| /M-k/         | /C-k/         | /M-d/         | /C-d/         |
|-------------+-------------+-------------+-------------|
| /<-----/      | /<---/        | /<--/         | /<-/          |
| kill-region | kill line b | b kill word | del chart b |
| /C-w/         | /C-x DEL/     | /M-DEL/       | /DEL/         |
|             | /C-0 C-k/     |             |             |

*** Isearch

| /C-s/     | isearch-forward                 |
| /C-M-s/   | isearch-forward-regexp          |
| /C-s C-s/ | last search                     |
|         |                                 |
| /M-s ./   | isearch-forward-symbol-at-point |
| /M-s w/   | isearch-forward-word            |
| /M-s _/   | isearch-forward-symbol          |
| /M-x/     | toggle-case-fold-search         |


|         | /WHILE IN ISEARCH/                         |
| /C-s/     | jump to next occurrence                  |
| /C-r/     | jump to previous occurrence              |
| /C-g/     | exit and place cursor at original pos    |
| /RET/     | exit and place cursor at current pos     |
|         |                                          |
| /C-w/     | select more words to the right of cursor |
| /M-c/     | isearch-toggle-case-fold                 |
|         |                                          |
| /C-q C-j/ | enter new line                           |
| /C-q TAB/ | enter new TAB                            |

*** Abbrev mode

|            | xah-interactive-abbrev         |
|            |                                |
|            | abbrev-mode                    |
| /C-x a g/    | add-global-abbrev              |
| /C-x a -/    | inverse-add-global-abbrev      |
| /C-x a +/    | add-mode-abbrev                |
| /C-x a i l/  | inverse-add-mode-abbrev        |
| /C-u -1 M-x/ | add-global-abbrev (remove)     |
|            |                                |
|            | list-abbrevs                   |
|            | edit-abbrevs (add/remove line) |
|            | edit-abbrevs-redefine          |
|            | abbrev-edit-save-buffer        |
|            | abbrev-edit-save-to-file       |
|            |                                |
|            | read-abbrev-file               |
|            | write-abbrev-file              |
|            |                                |
| /C-M-//      | dabbrev-completion             |
|            |                                |
| /C-q SPC/    | stop abbrev from expansion     |

*Note*: to stop abbrev from expansion, insert a literal space. ~C-q SPC~ press before typing space or punctuation.

*** Dabbrev

| /M-//   | dabbrev-expand           |
| C-/M-// | dabbrev-completion       |
|       |                          |
|       | dabbrev-case-fold-search |

*Notes*:

- Cycle expansion :: if the expansion is not what you wanted, you can cycle through all possible expansions by repeatedly executing the command again.

- Continuing expansion :: once you have successfully used dabbrev-expand to expand a word, hitting <space> then immediately using dabbrev-expand again will continue to expand from the point that the expansion was found.

*** Spelling

| /M-$/ | ispell-word                       |
|     | ispell                            |
|     |                                   |
|     | ispell-comments-and-strings       |
|     | ispell-comment-or-string-at-point |
|     |                                   |
|     | ispell-message                    |
|     | flyspell-mode                     |
|     | flyspell-prog-mode                |
|     |                                   |
|     | ispell-change-dictionary          |
|     | ispell-hunspell-add-multi-dic     |
|     |                                   |
| /M-// | complete partial word             |
| /M-/  | corrects misspelled word          |

| /x/      | quit spellcheck, moveback cursor start position |
| /r word/ | replaces current word while spellchecking       |
| /?/      | display other options                           |
| /i/      | accept spelling and add to dictionary           |
| /q/      | quit                                            |
| /a/      | accept spelling for all buffers                 |
| /X/      | halt at current location                        |

*** Occur

| /RET/     | occur-mode-goto-occurrence    |
| /C-o/     | occur-mode-display-occurrence |
| /c/       | clone-buffer                  |
| /e/       | occur-edit-mode               |
| /g/       | revert-buffer                 |
| /h/       | describe-mode                 |
| /o/       | occur-mode-goto other window  |
| /q/       | quit-window                   |
| /r/       | occur-rename-buffer           |
| /DEL/     | scroll-down-command           |
| /C-c C-c/ | occur-mode-goto-occurrence    |
| /C-c C-c/ | Return to Occur mode          |

*** Help

| /C-h x/      | describe-command               |
| /C-h f/      | describe-function              |
| /C-h v/      | describe-variable              |
| /C-h k/      | describe-key                   |
| /C-h m/      | describe-mode                  |
| /C-h b/      | describe-bindings              |
| /C-u M-x/    | embark-bindings                |
|            |                                |
| /C-h c/      | describe-key-briefly           |
| /C-h s/      | describe-syntax                |
| /C-h P/      | describe-package               |
| /C-h o/      | describe-symbol                |
|            | describe-keymap                |
|            | customize-variable             |
|            |                                |
| /C-h w/      | where-is                       |
| /C-h e/      | view-echo-area-messages        |
| /C-h l/      | view-lossage (last input keys) |
| /C-h a/      | counsel-apropos(pattern)       |
|            |                                |
| /C-h C-q/    | help-quick-toggle              |
| /prefix C-h/ | display which-key bindings     |
|            |                                |
| /C-h C-h/    | help-for-help                  |
| /cmd C-h/    | what valid keys follow cmd     |

** Code
*** Magit
**** General

| /C-x g/     | magit-status                               |
| /C-x M-g/   | magit-dispatch                             |
| /C-c M-g/   | magit-file-dispatch                        |
| /C-c M-g t/ | trace the historical changes made to a def |
| /C-x p m/   | magit-project-status                       |
|           |                                            |
| /TAB/       | toggle section at point                    |
| /S-TAB/     | magit-section-cycle-global                 |
| /1...4/     | sections                                   |
| /M-1...M-4/ | all sections                               |
| /2/         | fold the sections                          |
|           |                                            |
| /RET/       | shows detailed view at point               |
| /SPC/       | shows detailed view at point other window  |
| /C-SPC/     | set-mark-command                           |
| /C-c C-c/   | magit-dispatch / save arguments            |
| /C-q/       | exit all menus                             |
|           |                                            |
| /?/         | help                                       |
| /C-h/       | in magit popup followed by a key           |
| /g/         | magit-refresh / refresh current buffer     |
| /G/         | magit-refresh-all                          |
|           |                                            |
| /!/         | magit-run / open cmd line invocation view  |
| /! !/       | invokes a git at root repository           |
| /$/         | show git cmd and output (behind-the-scene) |

- C-c M-g t :: it shows the historical logs that changed the function point is in. (So it’ll only work well if Emacs can infer the function point is in.) So if you want to trace changes made to a particular function in your git history, that’s the command to use.

**** Staging & unstaging

| /s/     | magit-stage / magit-stage-files             |
| /S/     | magit-stage-modified                        |
| /s s s/ | stage all                                   |
|       |                                             |
| /u/     | magit-unstage / magit-unstage-files         |
| /U/     | magit-unstage-all                           |
|       |                                             |
| /z/     | magit-stash                                 |
| /z z/   | create a local stash entry for the changes  |
| /z p/   | restore the stashed changes                 |
| /z a/   | keep the stash entry around                 |
|       |                                             |
| /k/     | magit-discard / discard,uncommitted,changes |
|       |                                             |
| /i/     | add file to .gitignore                      |

- In the status buffer, you can put your cursor on any *file*, *hunk*, or *line* and press ~k~ to discard the change.

**** Committing changes

| /c/n/       | magit-commit / committing popup (n new binding) |
| /c/n c/     | write a commit message                          |
| /c/n e/     | change most recent commit (amend)               |
| /c/n a/     | change most recent commit (edit message)        |
| /c/n w/     | change most recent commit (without add change)  |
| /c/n F/     | add changes to an earlier commit                |
|           |                                                 |
| /r/         | magit-rebase / rebase popup                     |
| /r i/       | rebase interactively                            |
|           |                                                 |
| /C-c C-d/   | toggle showing commit                           |
| /M-n/ / /M-p/ | cycle commit message history ring               |
|           |                                                 |
| /C-w/       | copies the commit hash of the selected commit   |
| /x/         | reset HEAD and index to a particular commit     |
| /v/         | will revert to the commit                       |
| /a/         | applies a patch of the commit to files/index    |
| /A/         | cherry picks the commit on top of working tre   |

- c/n e :: if we forgot some lines that we wanted to add to the commit, you can add them by first, stage the changes that you want to add to the commit, then press ~c e~ (Commit -> Extend). Magit will “amend” the commit with those changes without asking you to edit the commit message!

- c/n a :: if you do want to edit the commit message when adding the new files, you can do this by pressing ~c/n a~ (Commit -> Amend).

- c/n w :: If you only want to edit the commit message without adding any staged changes, use ~c/n w~ (Commit -> Reword).

*Note*: if you’ve already pushed the original commit to a remote branch, you’ll have to force-push the branch the next time because the commit histories won’t match!

- c/n F :: to add changes to an earlier commit, just stage them like you normally would and then press ~c/n F~ (Commit -> Instant Fixup). You’ll be presented with Magit’s commit log view which shows the current branch’s commits with the newest commits sorted first. Just move your cursor to the line of the commit you want to edit.

*Note*: like we talked about before, any operation that changes an existing commit will require you to force-push the branch!

**** Pushing & pulling

| /f/   | magit-fetch / fetch popup                           |
| /f p/ | fetching the origin repo without pulling changes    |
| /f u/ | fetching from upstream repo without pulling changes |
|     |                                                     |
| /F/   | magit-pull / pull                                   |
| /F p/ | pull the latest commits from the remote             |
| /F u/ | pull from an “upstream” branch/local/remote         |
| /F e/ | choose any local/remote without save as upstream    |
| /F r/ | rebasing local changes onto the new commits         |
|     |                                                     |
| /P/   | magit-push / push                                   |
| /P p/ |                                                     |
| /P u/ |                                                     |

- if you make a new commit on the current branch, you can push it to the same remote branch by pressing ~P p~ in the status buffer again. Magit remembers the branch that you pushed to the last time so you can always use ~P p~ to push there again!

- because fast-forwarding and rebasing on pulling is so common, you can instruct Magit to default to this by typing ~F C-x C-s~ after changing the settings.

- I showed how you can edit existing commits by adding more changes or rewording the commit message. If you’ve done this, the only way to push those changes to the same branch is to use the ~-f~ argument when you launch the Push panel with ~P~! *Note*: enabling this option will *overwrite* the remote branch with the commits in the local branch, so make sure you are only force-pushing to a branch that is not ~main~ or ~master~! Changing the commit history makes it really difficult for collaborators to pull your changes.

*Note*: if you make ~F p~ to pull any new changes from the remote version of the current local branch, and you receive an error saying that there are uncommitted local changes, use the ~z z~ (stash) command to stash those local changes before pulling the remote changes!

**** Branches

| /b/   | enter the branch view                         |
| /b b/ | checks out a different branch                 |
| /b l/ | creates a local branch of a remote and tracks |
| /b s/ | creates a spin-off branch                     |
| /b S/ | spin-out                                      |

- b b :: switch back to master to confirm that it has been rolled back to the original commit! Once we’re satisfied with that, we can use ~b b~ again to select the new branch we created

- b s :: create a new branch with the changes you already committed to the current branch while putting the original branch back to the commit where it started. Note: This only works when the branch you’re starting from has been pushed to the remote!

- b S :: works much the sameas spin-off but it does not change your current branch to the new branch after completing the transfer

**** Reference log

| /l/     | magit-log / log popup                   |
| /L/     | magit-log-refresh / log arguments popup |
|       |                                         |
| /l l/   | magit-log-current / opens the short log |
| /l o/   | commits from a specific branch          |
|       |                                         |
| /-G/    | tracking down the history of changes    |
| /-F/    | search messages                         |

**** Diffs

| /d/   | magit-diff / diff popup                      |
| /d d/ | tries to DWIM                                |
| /d s/ | diffs the commit against your staged changes |
| /d u/ | against your unstaged changes                |
| /D/   | magit-diff-refresh / diff arguments popup    |
|     |                                              |
| /r/   | show the diff for an range                   |
| /+/   | enlarge / magit-diff-less-context            |
| /-/   | shrink / magit-diff-more-context             |
| /0/   | reset / magit-diff-default-context           |

**** Movements

| /C-p/ | magit-previous-line            |
| /C-n/ | magit-next-line                |
|     |                                |
| /p/   | magit-section-backward         |
| /n/   | magit-section-forward          |
|     |                                |
| /M-p/ | magit-section-backward-sibling |
| /M-n/ | magit-section-forward-sibling  |

**** Miscellaneous

|     | magit-init                |
|     | magit-clone               |
|     |                           |
| /m/   | magit-merge               |
| /r/   | magit-rebase              |
|     |                           |
| /t/p/ | magit-tag (p new binding) |
|     |                           |
| /x/   | magit-reset-quickly       |
| /X/   | magit-reset               |

**** Forge

| /N/       | forge-dispatch / Forge            |
|         |                                   |
| /n/       | forge-pull                        |
|         |                                   |
| /a/       | forge-add-repository              |
|         |                                   |
| /N m c/   | forge-configure                   |
|         |                                   |
| /N m f/   | forge-topics-menu                 |
| /N l t/   | forge-list-topics                 |
|         | forge-list-issues                 |
|         | forge-list-pullreqs               |
|         |                                   |
| /N l g/   | forge-list-global-topics          |
|         |                                   |
| /N m r/   | forge-repositories-menu           |
| /N l r/   | forge-list-repositories           |
|         |                                   |
| /C-c C-v/ | visit an issue or pull-request    |
| /C-c C-w/ | same above but using a browser    |
| /C-c C-n/ | create a new post (in buffer)     |
| /C-c C-e/ | edit an existing post or metadata |

*** Sexp

| /C-M-<right>/ | C-M-n | forward-sexp         |
| /C-M-b/       | C-M-h | backward-sexp        |
|             |       |                      |
| /C-M-t/       | C-M-; | transpose-sexps      |
|             | C-M-, | raise-sexp           |
| /C-M-<back>/  | C-M-o | backward-kill-sexp   |
| /C-M-k/       | C-M-k | kill-sexp            |
|             |       |                      |
| /C-M-@/       | C-M-) | mark-sexp            |
|             | C-M-* | mark-defun           |
|             | C-M-t | prog-indent-sexp     |
|             |       |                      |
| /C-j/         | C-M-e | eval-print-last-sexp |

*** Html
**** Mix

| /C-c C-b/ | sgml-skip-tag-backward |
| /C-c C-f/ | sgml-skip-tag-forward  |
|         | mc/mark-sgml-tag-pair  |
|         | er/mark-html-attribute |
| /C-c C-t/ | sgml-tag               |
| /C-c //   | sgml-close-tag         |
| /C-c C-d/ | sgml-delete-tag        |
| /C-c C-v/ | browse-url-of-buffer   |

**** Create

| /C-c C-t/   | sgml-tag                |
|           | web-mode-element-insert |
| /C-c RET/   | html-paragraph          |
| /C-c d/     | html-div                |
| /C-c 1/     | html-headline-1         |
| /C-c 2/     | html-headline-2         |
|           | web-mode-element-wrap   |
|           | web-mode-snippet-insert |
|           |                         |
|           | web-mode-file-link      |
| /C-c C-c h/ | html-href-anchor        |
| /C-c C-c n/ | html-name-anchor        |
| /C-c C-c #/ | html-id-anchor          |
| /C-c C-c i/ | html-image              |
| /C-c C-c u/ | html-unordered-list     |
| /C-c C-c o/ | html-ordered-list       |
| /C-c C-c l/ | html-list-item          |

**** Edit

| /C-c //   | sgml-close-tag          |
| /C-c C-a/ | sgml-attributes         |
|         | web-mode-element-rename |
|         | web-mode-element-kill   |
|         | web-mode-buffer-indent  |

**** Navigate

| /C-c C-b/ | sgml-skip-tag-backward    |
| /C-c C-f/ | sgml-skip-tag-forward     |
|         | web-mode-navigate         |
|         | web-mode-element-previous |
|         | web-mode-element-next     |
|         |                           |
| /C-c C-d/ | sgml-delete-tag           |

**** Mark

|         | mc/mark-sgml-tag-pair   |
|         | er/mark-html-attribute  |
|         | web-mode-fold-or-unfold |
| /C-c TAB/ | sgml-tags-invisible     |

**** Browser

| /C-c C-v/ | browse-url-of-buffer         |
|         | browse-url-of-region         |
|         | browse-url-of-firefox        |
|         | impatient-mode               |
|         | run-skewer                   |
|         | skewer-mode                  |
|         | skewer-html-mode             |
|         | js2-mode                     |
|         | skewer-repl                  |
|         |                              |
| /C-x C-e/ | Evaluatebeforepoint          |
| /C-M-x/   | Evaluatetop-levelaroundpoint |
| /C-c C-k/ | Loadthecurrentbuffer         |
| /C-c C-z/ | SelecttheREPLbuffer          |

*** Emacs
**** Navigation

| /C-M-b/left/  | backward-sexp             |
| /C-M-f/right/ | forward-sexp              |
|             |                           |
| /C-M-u/up/    | backward-up-list          |
| /C-M-d/down/  | down-list                 |
|             |                           |
| /C-M-a/       | beginning-of-defun        |
| /C-M-e/       | end-of-defun              |
| /C-M-h/       | mark-defun                |
| /M-m/         | back-to-indentation       |
|             |                           |
| /C-M-k/       | kill-sexp                 |
| /C-M-t/       | transpose-sexp            |
| /C-M-SPC/     | mark-sexp                 |
| /C-M-z/       | paredit-wrap-sexp         |
| /C-=/         | er/expand-region          |
|             | /=/ expand again /-/ contract |
|             |                           |
| /M-s/         | paredit-splice-sexp       |
| /M-J/         | paredit-join-sexp         |
| /M-;/         | paredit-comment-dwim      |

**** Evaluate

| /C-x C-e/     | eval-last-expression    |
| /C-u C-x C-e/ | eval-print-last-sexp    |
| /C-M-x/       | eval-defun (within)     |
| /M-:/         | eval-expression (print) |
|             | eval-region             |
|             | eval-buffer             |
| /ielm/        | emacs lisp shell (REPL) |

**** Debug

|                | debug-on-error               |
| /M-x debu func/  | debug-on-entry (d)           |
|                | cancel-debug-on-entry        |
| /M-x edebu func/ | edebug-defun(within/next to) |
| /C-x C-e/        | to revaluate & cancel edebug |

*** Treemacs

|   | treemacs-add-project                 |
|   | treemacs-remove-project-from-workspa |
|   | treemacs-switch-workspace            |
|   | treemacs-resize-icons                |

*** Prodigys

|       | prodigy                   |
|       | rc-create-prodigy-service |
|       |                           |
| '$    | process' output           |
|       |                           |
| c     | all commands              |
| c r   | restart the service       |
| c j d | open dired                |
| c j d | open magit                |

*** lsp-mode
**** Lsp

|         | lsp                            |
| /C-u M-x/ | lsp (prompt server)            |
|         | lsp-deferred                   |
|         | lsp-rename                     |
|         | lsp-format-region              |
|         | lsp-format-buffer              |
|         | lsp-execute-code-action        |
|         | lsp-headerline-breadcrumb-mode |

**** Code navigation

|   | lsp-find-definition          |
|   | lsp-find-references          |
|   | lsp-ui-peek-find-definitions |
|   | lsp-ui-peek-find-references  |

**** Treemacs

|         | lsp-treemacs-errors-list               |
|         | lsp-treemacs-symbols                   |
|         | lsp-treemacs-references                |
|         | lsp-treemacs-implementations           |
|         | lsp-treemacs-call-hierarchy            |
| /C-u M-x/ | lsp-treemacs-call-hierarchy (outgoing) |
|         | lsp-treemacs-type-hierarchy            |
|         | lsp-treemacs-deps-list                 |

**** Help

|   | lsp-doctor                   |
|   | lsp-describe-session         |
|   | lsp-ui-doc-focus-frame       |
|   | lsp-ui-doc-unfocus-frame     |
|   | lsp-register-custom-settings |

*** dap-mode
**** Start

|   | dap-debug               |
|   | dap-debug-last          |
|   | dap-debug-recent        |
|   | dap-debug-edit-template |
|   | dap-go-to-output-buffer |

**** Breakpoints

|     | dap-breakpoint-toggle                        |
|     | dap-breakpoint-delete                        |
|     | dap-breakpoint-add                           |
|     | dap-breakpoint-condition                     |
|     | dap-breakpoint-hit-condition                 |
|     | dap-breakpoint-log-message                   |
|     |                                              |
| /RET/ | dap-ui-breakpoints-goto (cursor)             |
| /d/   | dap-ui-breakpoints-delete (cursor)           |
| /D/   | dap-ui-breakpoints-delete-selected           |
| /m/   | bui-list-mark (breakpoint under point)       |
| /u/   | bui-list-unmark (breakpoint under point)     |
| /U/   | bui-list-unmark-all (breakpoint under point) |

**** Navigation

|   | dap-continue           |
|   | dap-next               |
|   | dap-step-out           |
|   | dap-step-in            |
|   | dap-disconnect         |
|   |                        |
|   | dap-stop-thread        |
|   | dap-restart-frame      |
|   |                        |
|   | dap-switch-stack-frame |
|   | dap-switch-thread      |
|   | dap-switch-session     |

**** Windows

|   | dap-ui-locals             |
|   | dap-ui-sessions           |
|   | dap-ui-breakpoints        |
|   | dap-ui-expressions        |
|   | dap-ui-repl               |
|   |                           |
|   | dap-ui-show-many-windows  |
|   | dap-ui-hide-many-windows  |
|   |                           |
|   | dap-ui-expressions-add    |
|   | dap-ui-expressions-remove |
|   |                           |
|   | dap-tm-loaded-sources     |

**** Evaluating

|   | dap-eval                |
|   | dap-eval-region         |
|   | dap-eval-thing-at-point |

** Key
*** Choices

|            | /KEY OVERVIEW/                         |
| /M-x/        | command by name                      |
| /C-letter/   | frequently command                   |
| /M-letter/   | less frequently cmd                  |
| /C-x keys/   | globally command                     |
| /C-c keys/   | major-mode specific command          |
| /C-h keys/   | help or info                         |
| /C-M keys/   | lisp coding command                  |
|            |                                      |
|            | /AVOID KEYBINDING/                     |
| /C-?/        | due technical implementation         |
| /F1/ / /C-h/   | special status emacs help system     |
| /ESC/ / /C-[/  | ESC is tied C-[ complicated meanings |
| /C-S-letter/ | in text terminal cannot distinguish  |
| /C-m/ / /RET/  | these are tied together              |
| /C-j/ / /TAB/  | these are tied together              |
|            |                                      |
|            | /KEY SPACE FOR USERS/                  |
| /F5/ - /F9/    |                                      |
| /C-c letter/ |                                      |

*** Syntax
**** 1 Modifier

| /M-a/    | Alt + a    |
| /C-a/    | Ctrl + a   |
| /A/      | Shift + a  |
| /s-a/    | Super + a  |
| /H-a/    | Hyper + a  |
| /S-<f3>/ | Shift + F3 |

**** 1 Modifier + Special Key

| /M-<f3>/ | Alt + F3   |
| /C-<f3>/ | Ctrl + F3  |
| /S-<f3>/ | Shift + F3 |
| /M-<up>/ | Alt + ↑    |
| /C-<up>/ | Ctrl + ↑   |
| /S-<up>/ | Shift + ↑  |

**** 2 Modifier Keys

| /M-A/        | Alt + Shift + a               |
| /C-A/        | Ctrl + Shift + a              |
| /C-M-a/      | Ctrl + Alt + a                |
| /M-#/        | Alt + Shift + 3 / Alt + #     |
| /C-#/        | Ctrl + Shift + 3 / Ctrl + #   |
| /C-M-3/      | Ctrl + Alt + 3                |
| /C-S-<kp-3>/ | Ctrl + Shift + “number pad 3” |

**** 3 Modifier Keys

| /C-M-S-a/    | Ctrl + Alt + Shift + a                  |
| /C-M-!/      | Ctrl + Alt + Shift + 1 / Ctrl + Alt + ! |
| /C-M-S-<up>/ | Ctrl + Alt + Shift + ↑                  |

**** Function, and Numberpad keys

| /<f3>/   | F3 key                  |
| /<kp-3>/ | the key 3 on number pad |

**** Arrows, Home, End, Cluster

| /<left>/   | left arrow                  |
| /<right>/  | right arrow                 |
| /<up>/     | up arrow                    |
| /<down>/   | down arrow                  |
| /<next>/   | page down key               |
| /<prior>/  | page up key                 |
| /<insert>/ | Ins key                     |
| /<delete>/ | Del key ⌦ (forward delete) |
| /<home>/   |                             |
| /<end>/    |                             |
| /<menu>/   |                             |

**** Enter, Return, Space, Backspace Keys

| /<backspace>/ | backspace key ⌫                       |
| /SPC/         | Space key                              |
| /<return>/    | Enter/Return key while in GUI          |
|             | emacs (usually auto translated to RET) |

**** Find Key Syntax
~Alt+x describe-key~ prompt user to type a key sequence, and display the key syntax and command bound to it, if any.

key sequence can be a single key, or any sequence with modifier keys.

For example, suppose you want to know the syntax for the key press of =Ctrl+Alt+t=.

~Alt+x describe-key~ press =Ctrl+Alt+t=, emacs prints “ ~C-M-t~ runs the command transpose-sexps”. That means, " ~C-M-t~" is the key syntax.

Emacs has a lot syntax variations for a given key combination, but the one printed by ~describe-key~ is guaranteed to work.

*Note* that some Linux predefines some Super keybinding. You need to take them off before emacs can see it. Best way to check is simply try define the key in emacs first and see if it works.

*** Characters

| /C-u C-x =/   | what-cursor-position           |
| /C-x 8 RET/   | insert-char                    |
|             | describe-char (cursor)         |
|             |                                |
| /C-q/         | quoted-insert (literaly)       |
| /C-q C-j/     | insert Line Feed char          |
| /C-q C-m/     | insert carriage char           |
| /C-q TAB/     | insert tab char                |
| /C-q C-i/     | insert tab char                |
| /C-q C-[/     | insert escape char             |
|             |                                |
| /\n/  (C-j)   | line feed (newline)            |
| /\r/  (C-m)   | carriage return (<RET>)        |
| /\b/  (C-h)   | backspace (<BS>)               |
| /\t/  (C-i)   | character tabulation (<TAB>)   |
| \v  (C-k)   | line tabulation (vertical TAB) |
| /\f/  (C-l)   | form feed (control-L)          |
| \a  (C-g)   | bell (control-g)               |
| /\e/  (C-[)   | escape (<ESC>)                 |
| /\d/          | delete (<DEL>)                 |
| \s          | space (<SPC>)                  |
| \\          | backslash character (\)        |
|             |                                |
| /\u3501/      | unicode 3501                   |
| /\C-/         | control                        |
| /\M-/         | meta                           |
| /\M-\C-a/     | Control-Meta-A                 |
|             |                                |
| /?x/          |                                |
| /?\n/         |                                |
| /?\"/         |                                |
|             |                                |
| /C-\/         | toggle-input-method (toggle)   |
| /C-S-e <SPC>/ | emoticons                      |
| /C-x 8 e e/i/ | emoji-insert                   |
| /C-x 8 e s/   | emoji-search                   |
| /C-x 8 e l/   | emoji-list                     |
| /C-x 8 e d/   | emoji-describe                 |

** Terminals
*** Eshell

| /M-r/            | eshell history           |
| /M-n/            | eshell-next-matching     |
| /M-p/            | eshell-previous-matching |
| /C-c C-n/        | eshell-next-prompt       |
| /C-c C-p/        | eshell-previous-prompt   |
| /C-c C-l/        | eshell-list-history      |
|                | counsel-esh-history      |
| /C-2 M-x eshell/ | open second eshell       |
|                |                          |
|                | pcomplete-list           |

*** Shell

| /C-x C-c/                | save-buffers-kill-terminal        |
| /M-!/                    | shell-command                     |
| /C-u M-!/                | shell cmd(sameBuffer)             |
|                        |                                   |
|                        | /VTERM/                             |
| /C-n/                    | next command                      |
| /C-p/                    | previous command                  |
| /C-2 M-x vterm/          | open different vterm              |
|                        |                                   |
|                        | /TERM/                              |
| /C-c C-k/                | char-mode                         |
| /C-c C-j/                | line-mode                         |
| /C-2 M-x term/           | open different term               |

*** Terminal

| /emacs -q/                 | open without load init file         |
| /emacs -q -l path/         | open with differen init file        |
| /emacs -nw/                | open in terminal                    |
| /emacs -Q -nw/             | open in terminal vanilla            |
| /emacs -Q -f package-init/ | open and initializes the ELPA packa |
| /emacs --user/             | open user diferent file             |
| /emacs --no-desktop/       | open without last session file      |
|                          |                                     |
| /emacs --no-site-file/     | dont load site-wide site-start.el   |
| /emacs --load="path"/      | execute the elisp file at path      |
| /emacs --batch --load/     | dont launch emacs as a editor       |
| /emacs --script path/      | run like --batch with --load=path   |
| /emacs --script nam.el/    | run emacs lisp script in shell      |
| /emacs --init-directory/   | run setting user-emacs-directory    |

** Miscellaneous
*** Register

| /C-x r s/   | copy-to-register                        |
| /C-x r r/   | copy-rectangle-to-register              |
| /C-x r n/   | number-to-register                      |
| /C-x r SPC/ | point and buffer to register            |
|           |                                         |
| /C-x C-k x/ | kmacro-to-register                      |
| /C-x r w/   | window to-register                      |
| /C-x r f/   | frameset-to-register                    |
|           |                                         |
| /C-x r SPC/ | point-to-register                       |
| /C-x r j/   | jump-to-register                        |
| /C-x r i/   | insert-register                         |
|           |                                         |
| /C-x r m/   | bookmark-set                            |
| /C-x r l/   | bookmark-bmenu-list                     |
| /C-x r b/   | counsel-bookmark                        |
|           | bookmark-save                           |
|           |                                         |
| /C-1 C-c/   | copies the region into register 1 (CUA) |
| /C-2 C-v/   | yanks the contents of register 2 (CUA)  |

*** Kmacro

| /F3/C-x (/    | kmacro-start-macro(sequence) |
| /F4/C-x )/    | kmacro-end-or-call-macro     |
|             |                              |
| /C-x e/       | kmacro-end-and-call-macro    |
| /C-u 5 C-x e/ | repeat 5 times kmacro        |
|             |                              |
| /C-x C-k n/   | kmacro-name-last-macro       |
| /C-x C-k C-n/ | kmacro-cycle-ring-next       |
|             |                              |
|             | call-last-kbd-macro (call)   |
|             | name-last-kbd-macro (save)   |
| /M-x name/    | call the macro /name/          |
|             |                              |
| /C-x C-k C-e/ | kmacro-edit-macro            |
| /C-x C-k l/   | kmacro-edit-lossage          |
| /C-x C-k SPC/ | kmacro-step-edit-macro       |
|             |                              |
| /M-x .../     | apply-macro-to-region-lines  |
|             |                              |
|             | /STEPS KMACRO FUNCTION CMMD/   |
| /F3/          | start kmacro                 |
| /C-4 M-x/     | call eval-expresion          |
| /F4/          | end kmacro                   |

*Note*:  if you call ~apply-macro-to-region-lines~ make sure that when you record a macro, best to start by putting cursor at beginning of a line, record the macro, and end with cursor the same line. No need to move to next line.

*Note*: to move to the next logical line (line with a line return at the end), move to end of line first, then right cursor moves it to beginning of next line. Because if you have Emacs: Visual Line Mode on, down arrow may move to the next visual line.

*** Commands

| /C-x z/       | repeat                             |
| /C-x ESC ESC/ | repeat-complex-command             |
|             |                                    |
| /M-x/         | execute- extend-command            |
| /M-S-x/       | execute- extend-command-for-buffer |

*** Calc

| /E/        | exp(x)                         |
| /Q/        | sqrt(x)                        |
| /L/        | ln(x)                          |
| /I C/      | arccos(x)                      |
| /S/        | sin(x)                         |
| /B/        | log_b(x)                       |
|          |                                |
| /m d/      | degree mode                    |
| /m r/      | radian mode                    |
| /m a/      | numerical mode                 |
| /m s/      | symbolic mode                  |
| /m f/      | fraction mode                  |
| /m a/ / /'/  | algebraic mode                 |
|          |                                |
| /P/        | pi number                      |
| /pi M-RET/ | pi number (algebraic mode)     |
| /N/        | eval numerical aprox           |
| /$/        | reference index of stack       |
|          | 1: pi/6 -> sin($1) => 1/2      |
| /c r/      | convert degrees radians        |
| /c d/      | convert radians degrees        |
|          |                                |
| /TAB/      | exchange order results         |
| /=/        | eval expressions               |
| /M-RET/    | calc-last-args                 |
| /t d/      | calc-trail-display             |
| /t y/      | calc-trail-yank                |
| /t p/      | calc-trail-previous            |
| /t n/      | calc-trail-next                |
| /t b/      | calc-trail-backwards           |
| /t f/      | calc-trail-forwards            |
| /C-x * q/  | quick-calc                     |
|          |                                |
| /d 0/      | to turn display into decimal   |
| d 2      | to turn display into binary    |
| /d 6/      | to turn display into hexa      |
| /16#FF/    | to turn FF into decimal        |
| /d f 3/    | display 3 digits after decimal |
| /d f 0/    | display 0 digits after decimal |

*** Artist

|             | artist-mode                     |
| /C-c C-c/     | exits artis mode                |
| /C-c C-a p/   | art poly-line                   |
| /RET/         | artist-key-set-point            |
| /C-u RET/     | for final segment               |
|             |                                 |
| /C-c C-a C-o/ | artist-select-operation         |
| /C-c C-a C-f/ | artist-select-fill-char         |
| /C-c C-a C-l/ | artist-select-line-char         |
|             |                                 |
| /C-c C-a C-r/ | artist-toggle-rubber-banding    |
| /C-c C-a C-t/ | artist-toggle-trim-line-endings |
| /C-c C-a C-s/ | artist-toggle-borderless-shapes |
|             |                                 |
| />/           | set unset arrow begin           |
| /</           | set unset arrow end             |
|             |                                 |
| /C-c </       | move left                       |
| /C-c >/       | move right                      |
| /C-c ^/       | move up                         |
| /C-c ./       | move down                       |

*** Misc

| /C-x -/ / /+/   | zoom-in/out                        |
| /F10/         | menu-bar-open                      |
| /ESC x/       | same /M-x/ in no GUI term            |
|             |                                    |
| /C-x C-c/     | finish-sesion                      |
| /C-x C-c/     | save-buffers-kill-terminal         |
|             | save-buffers-kill-emacs            |

* My keys
** Meta
*** M-

| M-$    |                                      |
| M-&    | make-frame-command                   |
| M-[    | split-window-below                   |
| M-{    | query-replace                        |
| M-}    | replace-string                       |
| M-(    | delete-window                        |
| M-=    | ispell-word                          |
| M-*    | xah-select-line                      |
| M-)    | rf-expand-region                     |
| M-+    | xah-select-block                     |
| M-]    | xah-select-text-in-quote             |
| M-!    |                                      |
| M-#    |                                      |
| M-DEL  |                                      |
|        |                                      |
| M-TAB  | ^completion-at-point                 |
| M-;    | xah-fill-or-unfill                   |
| M-,    | backward-kill-word                   |
| M-.    | xah-delete-current-text-block        |
| M-p    | kill-word                            |
| M-y    | xah-pop-local-mark-ring              |
| M-f    | isearch-forward                      |
| M-g    | backward-word                        |
| M-c    | previous-line                        |
| M-r    | forward-word                         |
| M-l    | nil                                  |
| M-/    |                                      |
| M-@    |                                      |
|        |                                      |
| M-CAPS |                                      |
| M-a    | other-frame                          |
| M-o    | delete-backward-char                 |
| M-e    | other-window                         |
| M-u    | delete-forward-char                  |
| M-i    | cua-rectangle-mark-mode              |
| M-d    | xah-beginning-of-line-or-block       |
| M-h    | backward-char                        |
| M-t    | next-line                            |
| M-n    | forward-char                         |
| M-s    | ergoemacs-beginning-or-end-of-buffer |
| M--    |                                      |
| M-\    |                                      |
| M-RET  |                                      |
|        |                                      |
| M-'    | xah-toggle-letter-case               |
| M-q    | +cape-prefix-map                     |
| M-j    | xah-shrink-whitespaces               |
| M-k    | kill-line                            |
| M-x    | ^execute-extended-command            |
| M-b    | xah-end-of-line-or-block             |
| M-m    | xah-backward-left-bracket            |
| M-w    | xah-forward-right-bracket            |
| M-v    | xah-goto-matching-bracket            |
| M-z    | ~evilnc-comment-or-uncomment-lines   |
|        |                                      |
| M-SPC  |                                      |

+ prefix
^ default commands
~ use-package commands
,# system bindings
- check commands

*** M-S-

| M-~          |                                        |
| M-%          | delete-frame                           |
| M-7          | split-window-right                     |
| M-5          | query-replace-regexp                   |
| M-3          | replace-regexp                         |
| M-1          | delete-other-windows                   |
| M-9          | ispell                                 |
| M-0          |                                        |
| M-2          |                                        |
| M-4          |                                        |
| M-6          |                                        |
| M-8          |                                        |
| M-`          |                                        |
| M-S-DEL      |                                        |
|              |                                        |
| M-S-TAB      |                                        |
| M-:          |                                        |
| M-<          |                                        |
| M->          |                                        |
| M-P          |                                        |
| M-Y          | mp-exchange-point-and-mark-no-activate |
| M-F          | xah-search-current-word                |
| M-G          |                                        |
| M-C          | ~drag-stuff-up                         |
| M-R          |                                        |
| M-L          | winner-undo                            |
| M-?          | winner-redo                            |
| M-^          |                                        |
|              |                                        |
| M-S-CAPS     |                                        |
| M-A          |                                        |
| M-O          |                                        |
| M-E          | ~ace-window                            |
| M-U          |                                        |
| M-I          |                                        |
| M-D          | scroll-down-command                    |
| M-H          | ~drag-stuff-left                       |
| M-T          | ~drag-stuff-down                       |
| M-N          | ~drag-stuff-right                      |
| M-S          | ergoemacs-end-or-beginning-of-buffer   |
| M-_          |                                        |
| M-¦          |                                        |
| M-S-<return> | ~rf-duplicate-thing-wrapper            |
|              |                                        |
| M-"          |                                        |
| M-Q          | +rectangle-related-map                 |
| M-J          | +switch-resize-windows-repeat-map      |
| M-K          | rf-backward-kill-line                  |
| M-X          | execute-extended-command-for-buffer    |
| M-B          | scroll-up-command                      |
| M-M          |                                        |
| M-W          |                                        |
| M-V          |                                        |
| M-Z          |                                        |
|              |                                        |
| M-S-SPC      |                                        |

*** M-<cluster>

| M-<up>     | ~drag-stuff-up                    |
| M-<down>   | ~drag-stuff-down                  |
| M-<left>   | ~drag-stuff-left                  |
| M-<right>  | ~drag-stuff-right                 |
|            |                                   |
| M-<home>   | ^beginning-of-buffer-other-window |
| M-<end>    | ^end-of-buffer-other-window       |
| M-<prior>  | ^scroll-other-window-down         |
| M-<next>   | ^scroll-other-window              |
|            |                                   |
| M-<insert> |                                   |
| M-<delete> |                                   |
|            |                                   |
| M-<f6>     | #Switch windows                   |

*** M-S-<cluster>

| M-S-<up>     |                              |
| M-S-<down>   |                              |
| M-S-<left>   |                              |
| M-S-<right>  |                              |
|              |                              |
| M-S-<home>   |                              |
| M-S-<end>    |                              |
| M-S-<prior>  |                              |
| M-S-<next>   |                              |
|              |                              |
| M-S-<insert> | ~consult-yank-from-kill-ring |
| M-S-<delete> | xah-cut-all-or-region        |

*** C-M-

| C-M-$    |                              |
| C-M-&    |                              |
| C-M-[    |                              |
| C-M-{    |                              |
| C-M-}    |                              |
| C-M-(    |                              |
| C-M-=    |                              |
| C-M-*    | mark-defun                   |
| C-M-)    | mark-sexp                    |
| C-M-+    |                              |
| C-M-]    |                              |
| C-M-!    |                              |
| C-M-#    |                              |
| C-M-DEL  |                              |
|          |                              |
| C-M-TAB  |                              |
| C-M-;    | transpose-sexps              |
| C-M-,    | raise-sexp                   |
| C-M-.    |                              |
| C-M-p    |                              |
| C-M-y    |                              |
| C-M-f    | isearch-backward             |
| C-M-g    |                              |
| C-M-c    |                              |
| C-M-r    |                              |
| C-M-l    |                              |
| C-M-/    |                              |
| C-M-@    |                              |
|          |                              |
| C-M-caps |                              |
| C-M-a    |                              |
| C-M-o    | backward-kill-sexp           |
| C-M-e    | eval-print-last-sexp         |
| C-M-u    |                              |
| C-M-i    |                              |
| C-M-d    |                              |
| C-M-h    | backward-sexp                |
| C-M-t    | prog-indent-sexp             |
| C-M-n    | forward-sexp                 |
| C-M-s    | rf-swap-org-header-with-text |
| C-M--    |                              |
| C-M-\    |                              |
| C-M-RET  |                              |
|          |                              |
| C-M-'    |                              |
| C-M-q    |                              |
| C-M-j    |                              |
| C-M-k    | kill-sexp                    |
| C-M-x    |                              |
| C-M-b    |                              |
| C-M-m    |                              |
| C-M-w    | save-buffers-kill-terminal   |
| C-M-v    |                              |
| C-M-z    |                              |
|          |                              |
| C-M-SPC  |                              |

*** C-M-<cluster>

| C-M-<insert> | xah-copy-all-or-region |

*** C-M-S-

| C-M-S-f | rf-fold-org-english-headers  |
| C-M-S-s | rf-swap-org-header-with-text |

** Control
*** C-

| C-$     | #Switch applications            |
| C-&     | ~consult-register-load          |
| C-[     | DO NOT USE. BLOCKS THE META KEY |
| C-{     | ~magit-status                   |
| C-}     |                                 |
| C-(     |                                 |
| C-=     | calc                            |
| C-*     | eshell                          |
| C-)     | dired-jump                      |
| C-+     | ibuffer                         |
| C-]     | ^esc                            |
| C-!     |                                 |
| C-#     |                                 |
| C-DEL   | ^backward-kill-word             |
|         |                                 |
| C-<tab> | ~tempel-complete                |
| C-;     |                                 |
| C-,     | ~embark-act                     |
| C-.     | ~embark-dwim                    |
| C-p     | +consult-goto-map               |
| C-y     | undo-redo                       |
| C-f     | ~consult-line                   |
| C-g     | ^keyboard-quit                  |
| C-c     | ^mode-specific-map              |
| C-r     | find-file                       |
| C-l     | ^recenter-top-bottom            |
| C-/     |                                 |
| C-@     |                                 |
|         |                                 |
| C-caps  |                                 |
| C-a     | mark-whole-buffer               |
| C-o     | ^open-line                      |
| C-e     | rf-eval-last-sexp-or-region     |
| C-u     | ^universal-argument             |
| C-i     | ^tab                            |
| C-d     | nil                             |
| C-h     | ^help-map                       |
| C-t     | switch-to-previous-buffer       |
| C-n     | ~consult-buffer                 |
| C-s     | save-buffer                     |
| C--     | save-some-buffers               |
| C-\     |                                 |
| C-RET   |                                 |
|         |                                 |
| C-'     | repeat                          |
| C-q     | ^quoted-insert                  |
| C-j     | ^newline indent (major-modes)   |
| C-k     | +consult-search-map             |
| C-x     | ^ctl-x-map                      |
| C-b     | ~vertico-repeat                 |
| C-m     | ^newline                        |
| C-w     | xah-close-current-buffer        |
| C-v     | xah-paste-or-paste-previous     |
| C-z     | undo                            |
|         |                                 |
| C-SPC   | ^set-mark-command               |

*** C-S-

| C-~      | #Switch windows of an application |
| C-%      | ~consult-register-store           |
| C-7      |                                   |
| C-5      |                                   |
| C-3      |                                   |
| C-1      |                                   |
| C-9      |                                   |
| C-0      | shell-command                     |
| C-2      | dired-jump-other-window           |
| C-4      |                                   |
| C-6      |                                   |
| C-8      |                                   |
| C-`      |                                   |
| C-S-DEL  |                                   |
|          |                                   |
| C-S-TAB  | ~yas-expand                       |
| C-:      |                                   |
| C-<      | widen                             |
| C->      | xah-narrow-to-region              |
| C-p      |                                   |
| C-S-y    |                                   |
| C-S-f    | ~consult-line-multi               |
| C-S-g    |                                   |
| C-S-c    |                                   |
| C-S-r    | find-file-other-window            |
| C-S-l    |                                   |
| C-?      |                                   |
| C-^      |                                   |
|          |                                   |
| C-S-CAPS |                                   |
| C-S-a    |                                   |
| C-S-o    | xah-open-in-external-app          |
| C-S-e    | eval-expression                   |
| C-S-u    |                                   |
| C-S-i    |                                   |
| C-S-d    | scroll-other-window-down          |
| C-S-h    |                                   |
| C-S-t    | xah-open-last-closed              |
| C-S-n    | ~consult-buffer-other-window      |
| C-S-s    | write-file                        |
| C-_      | save-buffers-kill-terminal        |
| C-¦      |                                   |
| C-S-RET  |                                   |
|          |                                   |
| C-"      |                                   |
| C-S-q    | +google-translate-map             |
| C-S-j    |                                   |
| C-S-k    |                                   |
| C-S-x    |                                   |
| C-S-b    | scroll-other-window               |
| C-S-m    |                                   |
| C-S-w    | kill-buffer                       |
| C-S-v    | ~consult-yank-from-kill-ring      |
| C-S-z    |                                   |
|          |                                   |
| C-S-SPC  |                                   |

*** C-<cluster>

| C-<up>     | ^backward-paragrap          |
| C-<down>   | ^forward-paragrap           |
| C-<left>   | ^left-word                  |
| C-<right>  | ^right-word                 |
|            |                             |
| C-<home>   | ^beginning-of-buffer        |
| C-<end>    | ^end-of-buffer              |
| C-<prior>  | previous-buffer             |
| C-<next>   | next-buffer                 |
|            |                             |
| C-<insert> | xah-copy-line-or-region-mod |
| C-<delete> | ^kill-word                  |
|            |                             |
| C-<f6>     | ~expand-abbrev              |

*** C-S-<cluster>

| C-S-<up>     |                          |
| C-S-<down>   |                          |
| C-S-<left>   |                          |
| C-S-<right>  |                          |
|              |                          |
| C-S-<home>   | -backward-sentence       |
| C-S-<end>    | -forward-sentence        |
| C-S-<prior>  | xah-previous-user-buffer |
| C-S-<next>   | xah-next-user-buffer     |
|              |                          |
| C-S-<insert> | rf-yank-recently-window  |
| C-S-<delete> |                          |

*** C-c

| C-c ~    |                      |
| C-c %    |                      |
| C-c 7    |                      |
| C-c 5    |                      |
| C-c 3    |                      |
| C-c 1    |                      |
| C-c 9    |                      |
| C-c 0    |                      |
| C-c 2    |                      |
| C-c 4    |                      |
| C-c 6    |                      |
| C-c 8    |                      |
| C-c `    |                      |
| C-c DEL  |                      |
|          |                      |
| C-c TAB  |                      |
| C-c :    |                      |
| C-c <    |                      |
| C-c >    |                      |
| C-c p    |                      |
| C-c y    |                      |
| C-c f    | ~magit-file-dispatch |
| C-c g    | ~magit-dispatch      |
| C-c c    |                      |
| C-c r    |                      |
| C-c l    |                      |
| C-c ?    |                      |
| C-c ^    |                      |
|          |                      |
| C-c CAPS |                      |
| C-c a    |                      |
| C-c o    |                      |
| C-c e    |                      |
| C-c u    |                      |
| C-c i    |                      |
| C-c d    | +~dape-key-prefix    |
| C-c h    |                      |
| C-c t    |                      |
| C-c n    |                      |
| C-c s    |                      |
| C-c _    |                      |
| C-c ¦    |                      |
| C-c RET  |                      |
|          |                      |
| C-c "    |                      |
| C-c q    |                      |
| C-c j    |                      |
| C-c k    |                      |
| C-c x    |                      |
| C-c b    |                      |
| C-c m    |                      |
| C-c w    |                      |
| C-c v    |                      |
| C-c z    |                      |
|          |                      |
| C-c SPC  |                      |

** Cluster
*** <cluster>

| <up>     | ^previous-line          |
| <down>   | ^next-line              |
| <left>   | ^left-char              |
| <right>  | ^right-char             |
|          |                         |
| <home>   | ^move-beginning-of-line |
| <end>    | ^move-end-of-line       |
| <prior>  | ^scroll-down-command    |
| <next>   | ^scroll-up-command      |
|          |                         |
| <insert> | ^overwrite-mode         |
| <delete> | ^delete-char            |

*** S-<cluster>

| <escape>   | keyboard-escape-quit        |
|            |                             |
| S-<insert> | xah-paste-or-paste-previous |
| S-<delete> | xah-cut-line-or-region-mod  |

** Function keys
*** <f >

| F1  | #Switch to last window      | s-`        |
| F2  | xah-copy-line-or-region-mod | C-<insert> |
| F3  | xah-cut-line-or-region-mod  | S-<delete> |
| F4  | xah-paste-or-paste-previous | S-<insert> |
|     |                             |            |
| F5  | #Switch emacs               | F5         |
| F6  | keyboard-quit               | C-g        |
| F7  | undo                        | C-z        |
| F8  | switch-to-previous-buffer   | C-t        |
|     |                             |            |
| F9  | #Switch/Launch firefox      | F9         |
| F10 | previous-buffer             | C-<prior>  |
| F11 | next-buffer                 | C-<next>   |
| F12 | #Switch/Launch chromium     | F12        |

*** S-<f >

| S-F1  |                          |             |
| S-F2  |                          |             |
| S-F3  |                          |             |
| S-F4  |                          |             |
|       |                          |             |
| S-F5  |                          |             |
| S-F6  |                          |             |
| S-F7  |                          |             |
| S-F8  | xah-open-last-closed     | S-C-t       |
|       |                          |             |
| S-F9  |                          |             |
| S-F10 | xah-previous-user-buffer | C-S-<prior> |
| S-F11 | xah-next-user-buffer     | C-S-<next>  |
| S-F12 |                          |             |

*** M-<f >

| M-F1  |                              |              |
| M-F2  | xah-copy-all                 | M-C-<insert> |
| M-F3  | xah-cut-all                  | M-S-<delete> |
| M-F4  | ~consult-yank-from-kill-ring | M-S-<insert> |
|       |                              |              |
| M-F5  |                              |              |
| M-F6  | #Switch windows              |              |
| M-F7  |                              |              |
| M-F8  |                              |              |
|       |                              |              |
| M-F9  |                              |              |
| M-F10 |                              |              |
| M-F11 |                              |              |
| M-F12 |                              |              |

** Keypad
*** kp-

| rotate - press    | #KC_VOLD/VOLU - KC_SLEP          |
| TO(1)             | #Turn on layer 1                 |
| <XF86Launch5>/f14 | #Switch application              |
| <XF86Launch6>/f15 | #Hide all normal windows         |
|                   |                                  |
| <kp-equal>        | ~consult-buffer                  |
| <kp-divide>       |                                  |
| <kp-multiply>     |                                  |
| <kp-subtract>     | rf-recently-not-visible-buffer   |
|                   |                                  |
| <kp-7>            | ~mc/mark-next-like-this          |
| <kp-8>            | rf-last-interactive-command      |
| <kp-9>            | kmacro-end-or-call-macro         |
| <kp-add>          | switch-to-previous-buffer        |
|                   |                                  |
| <kp-4>            | rf-find-or-switch-to-javascript  |
| <kp-5>            | rf-find-or-switch-to-shell       |
| <kp-6>            | rf-find-or-switch-to-emacs-elisp |
|                   |                                  |
| <kp-1>            | rf-find-or-switch-to-todo        |
| <kp-2>            | eshell                           |
| <kp-3>            | scratch-buffer                   |
|                   |                                  |
| <kp-0>            | other-window                     |
| <kp-decimal>      | #temporarily most used command   |
| <kp-enter>        | #Click                           |

*** kp-S

| rotate - press      | #KC_VOLD/VOLU - KC_SLEP             |
| TO(1)               | #Turn on layer 1                    |
| S-<XF86Launch5>/f14 |                                     |
| S-<XF86Launch6>/f15 |                                     |
|                     |                                     |
| S-<kp-equal>        | find-file                           |
| S-<kp-divide>       |                                     |
| S-<kp-multiply>     |                                     |
| S-<kp-subtract>     |                                     |
|                     |                                     |
| S-<kp-7>            | ~mc/mark-previous-like-this         |
| S-<kp-8>            |                                     |
| S-<kp-9>            | kmacro-start-macro                  |
| S-<kp-add>          |                                     |
|                     |                                     |
| S-<kp-4>            | rf-find-or-switch-to-html-css-seo   |
| S-<kp-5>            | rf-find-or-switch-to-gnu-linux      |
| S-<kp-6>            | rf-find-or-switch-to-init           |
|                     |                                     |
| S-<kp-1>            | rf-find-or-switch-to-archive        |
| S-<kp-2>            | #Switch to application 4 (terminal) |
| S-<kp-3>            | rf-find-or-switch-to-english        |
|                     |                                     |
| S-<kp-0>            |                                     |
| S-<kp-decimal>      |                                     |
| S-<kp-nter>         |                                     |

*** kp-C

| rotate - press      | #KC_VOLD/VOLU - KC_SLEP          |
| TO(1)               | #Turn on layer 1                 |
| C-<XF86Launch5>/f14 |                                  |
| C-<XF86Launch6>/f15 |                                  |
|                     |                                  |
| C-<kp-equal>        |                                  |
| C-<kp-divide>       |                                  |
| C-<kp-multiply>     |                                  |
| C-<kp-subtract>     |                                  |
|                     |                                  |
| C-<kp-7>            |                                  |
| C-<kp-8>            |                                  |
| C-<kp-9>            |                                  |
| C-<kp-add>          |                                  |
|                     |                                  |
| C-<kp-4>            |                                  |
| C-<kp-5>            |                                  |
| C-<kp-6>            |                                  |
|                     |                                  |
| C-<kp-1>            |                                  |
| C-<kp-2>            |                                  |
| C-<kp-3>            | rf-find-or-switch-to-layout-maps |
|                     |                                  |
| C-<kp-0>            |                                  |
| C-<kp-decimal>      |                                  |
| C-<kp-enter>        |                                  |

** Mouse keys

| <mouse-8> | TAB |

** Lisp maps
*** completion-preview-active-mode-map

| M-i | nil                         |
| M-l | completion-preview-complete |

*** cua--rectangle-keymap

| C-S-c | cua-resize-rectangle-up    |
| C-S-t | cua-resize-rectangle-down  |
| C-S-h | cua-resize-rectangle-left  |
| C-S-n | cua-resize-rectangle-right |
| C-S-d | cua-resize-rectangle-bol   |
| C-S-b | cua-resize-rectangle-eol   |

*** ibuffer-mode-map

| M-o   | nil                                        |
|       |                                            |
| o     | ibuffer-visit-buffer-other-window-noselect |
| C-o   | ibuffer-visit-buffer-other-window          |
| C-M-o | ibuffer-visit-buffer-1-window              |
|       |                                            |
| c     | ibuffer-backward-line                      |
| t     | ibuffer-forward-line                       |
| p     | ibuffer-toggle-marks                       |

*** image-mode-map

| c | image-previous-file |
| t | image-next-file     |

*** isearch-mode-map

| <left>  / C-S-h | isearch-repeat-backward  |
| <right> / C-S-n | isearch-repeat-forward   |
| <up>            | isearch-ring-retreat     |
| <down>          | isearch-ring-advance     |
|                 |                          |
| C-v             | isearch-yank-kill        |
| S-<insert>      | isearch-yank-kill        |
|                 |                          |
| C-S-v           | isearch-yank-pop-only    |
| M-S-<insert>    | isearch-yank-pop-only    |
|                 |                          |
| <escape>        | isearch-abort            |
|                 |                          |
|                 | isearch-toggle-case-fold |
|                 | isearch-toggle-regexp    |
|                 | isearch-query-replace    |

*** mhtml-mode-map

| <f6> e | eglot-prefix-map    |
| <f6> u | xref-prog-map       |
| <f6> p | flycheck-prefix-map |
| <f6> . | flymake-prefix-map  |
| <f6> i | eldoc-prog-map      |

*** minibuffer-local-isearch-map

| <left>  / C-S-h | isearch-reverse-exit-minibuffer |
| <right> / C-S-n | isearch-forward-exit-minibuffer |

*** minibuffer-local-map

| nil   | M-n / M-p / M-r / M-s            |
|       |                                  |
| C-,   | se-take-the-word-at-point        |
|       |                                  |
| C-S-h | previous-line-or-history-element |
| C-S-n | next-history-element             |
|       |                                  |
| M-s   | vertico-first                    |
| M-S   | vertico-last                     |

*** rectangle-related-map

| h | yank-rectangle                       |
| t | kill-rectangle                       |
| n | copy-rectangle-as-kill               |
|   |                                      |
| g | picture-yank-rectangle-from-register |
| c | copy-rectangle-to-register           |

*** rmail-summary-mode-map

| c   | rmail-summary-previous-msg  |
| n   | rmail-summary-continue      |
| t   | rmail-summary-next-msg      |
| p   | rmail-summary-toggle-header |
|     |                             |
| M-n | nil                         |
| M-i | rmail-summary-next-all      |
| M-s | nil                         |
| M-e | rmail-summary-search        |

*** switch-resize-repeat-map

| c | windmove-up                 |
| t | windmove-down               |
| h | windmove-left               |
| n | windmove-right              |
|   |                             |
| C | enlarge-window              |
| T | shrink-window               |
| H | shrink-window-horizontally  |
| N | enlarge-window-horizontally |
|   |                             |
| b | balance-windows             |

** Usage package keys
*** ace-window

| M-E | ace-window |

*** cape

| M-q | cape-prefix-map |

*** combobulate
**** prog-mode-map

| <f6> z | combobulate-mode |

**** combobulate

| C-c o | combobulate-key-prefix |

**** combobulate-key-map

| nil      | M-<up>/M-<down>/M-<left>/M-<right>               |
| nil      | M-n/M-k/M-h/M-e/M-a/M-N/M-P                      |
|          |                                                  |
| <f6> c   | combobulate-navigate-sequence-previous           |
| <f6> t   | combobulate-navigate-sequence-next               |
| <f6> h   | combobulate-navigate-logical-previous            |
| <f6> n   | combobulate-navigate-logical-next                |
| <f6> g   | combobulate-navigate-up                          |
| <f6> r   | combobulate-navigate-down                        |
| <f6> m   | combobulate-navigate-previous                    |
| <f6> w   | combobulate-navigate-next                        |
| <f6> d   | combobulate-navigate-beginning-of-defun          |
| <f6> b   | combobulate-navigate-end-of-defun                |
|          |                                                  |
| <f6> C   | combobulate-drag-up                              |
| <f6> T   | combobulate-drag-down                            |
| <f6> >   | combobulate-splice-up                            |
| <f6> E   | combobulate-splice-down                          |
| <f6> O   | combobulate-splice-self                          |
| <f6> U   | combobulate-splice-parent                        |
| <f6> )   | combobulate-mark-node-dwim                       |
| <f6> *   | combobulate-mark-defun                           |
| <f6> k   | combobulate-kill-node-dwim                       |
| <f6> RET | combobulate-clone-node-dwim                      |
| <f6> ;   | combobulate-transpose-sexps                      |
|          |                                                  |
| <f6> o h | combobulate-cursor-edit-node-by-text-dwim        |
| <f6> o t | combobulate-cursor-edit-node-type-dwim           |
| <f6> o n | combobulate-cursor-edit-node-siblings-dwim       |
| <f6> o s | combobulate-cursor-edit-sequence-dwim            |
| <f6> o g | combobulate-cursor-edit-query                    |
|          |                                                  |
| <f6> , h | combobulate-javascript-envelope-wrap-parentheses |
| <f6> , t | combobulate-javascript-envelope-if-statement     |
| <f6> , n | combobulate-javascript-envelope-tag              |
| <f6> , s | combobulate-javascript-envelope-expression       |

**** combobulate-cursor-key-map

| C-S-c | combobulate-cursor-prev-field |
| C-S-t | combobulate-cursor-next-field |

**** combobulate-javascript-map

| nil | '= |

*** consult
**** consult

| <kp-equal>   | consult-buffer              |
| C-n          | consult-buffer              |
| C-S-n        | consult-buffer-other-window |
|              |                             |
| C-f          | consult-line                |
| C-S-f        | consult-line-multi          |
|              |                             |
| C-S-v        | consult-yank-from-kill-ring |
| M-S-<insert> | consult-yank-from-kill-ring |
|              |                             |
| C-(          | consult-register-store      |
| C-1          | consult-register-load       |

**** minibuffer-local-map

| C-d | consult-history |

**** isearch-mode-map

| C-f   | consult-isearch-history |
| C-F   | consult-line            |
| C-M-f | consult-line-multi      |

**** consult-goto-map

| h | consult-imenu          |
| t | consult-imenu-multi    |
|   |                        |
| g | consult-outline        |
| c | consult-org-heading    |
|   |                        |
| d | goto-last-change       |
| f | consult-goto-line      |
|   |                        |
| n | consult-project-buffer |
| r | consult-bookmark       |
|   |                        |
| p | consult-flycheck       |
| . | consult-flymake        |
| , | consult-compile-error  |
|   |                        |
| m | consult-mark           |
| w | consult-global-mark    |

**** consult-search-map

| u | consult-grep            |
| e | consult-ripgrep         |
| o | consult-git-grep        |
|   |                         |
| h | consult-fd              |
| g | rf-consult-fd           |
| t | consult-find            |
| c | rf-consult-find         |
| n | consult-locate          |
|   |                         |
| d | consult-history         |
| f | consult-isearch-history |
| w | consult-complex-command |
|   |                         |
| m | consult-minor-mode-menu |
|   |                         |
| i | consult-man             |
| y | consult-info            |
|   |                         |
| k | consult-keep-lines      |
| j | consult-focus-lines     |
|   |                         |
| p | consult-yasnippet       |
|   |                         |
| . | consult-kmacro          |
|   |                         |
| } | consult-register        |

*** dabbrev

| C-M-<tab>         | dabbrev-completion |
| C-M-<iso-lefttab> | dabbrev-expand     |

*** dape
**** dape-prefix-map

| z | dape                       |
| v | dape-restart               |
| Z | dape-kill                  |
|   |                            |
| h | dape-continue              |
| t | dape-next                  |
| n | dape-step-in               |
| c | dape-step-out              |
| g | dape-pause                 |
| s | dape-until                 |
| r | dape-quit                  |
| l | dape-disconnect-quit       |
|   |                            |
| u | dape-breakpoint-toggle     |
| e | dape-breakpoint-remove-all |
| o | dape-breakpoint-expression |
| a | dape-breakpoint-hits       |
| ' | dape-breakpoint-log        |
|   |                            |
| p | dape-watch-dwim            |
| . | dape-evaluate-expression   |
|   |                            |
| , | dape-repl                  |
| k | dape-info                  |
| j | dape-many-windows          |
| q | dape-select-stack          |

*** dired
**** dired-mode-map

| DEL     | dired-up-directory                      |
|         |                                         |
| c       | dired-previous-line                     |
| t       | dired-next-line                         |
| p       | dired-do-compress-to                    |
| n       | dired-toggle-marks                      |
| z       | ew-dired-dotfiles-toggle                |
| C-z     | dired-undo                              |
|         |                                         |
| '_      | xah-dired-rename-space-to-underscore    |
| '-      | xah-dired-rename-space-to-hyphen        |
|         |                                         |
| C-d d   | image-dired-display-thumbs              |
| C-d t   | image-dired-tag-files                   |
| C-d r   | image-dired-delete-tag                  |
| C-d j   | image-dired-jump-thumbnail-buffer       |
| C-d i   | image-dired-dired-display-image         |
| C-d x   | image-dired-dired-display-external      |
| C-d a   | image-dired-display-thumbs-append       |
| C-d .   | image-dired-display-thumb               |
| C-d c   | image-dired-dired-comment-files         |
| C-d f   | image-dired-mark-tagged-files           |
| C-d C-d | image-dired-dired-toggle-marked-thumbs  |
| C-d e   | image-dired-dired-edit-comment-and-tags |
|         |                                         |
| C-t     | switch-to-previous-buffer               |

*** drag-stuff

| M-<up>    | drag-stuff-up    |
| M-<down>  | drag-stuff-down  |
| M-<left>  | drag-stuff-left  |
| M-<right> | drag-stuff-right |
|           |                  |
| M-C       | drag-stuff-up    |
| M-T       | drag-stuff-down  |
| M-H       | drag-stuff-left  |
| M-N       | drag-stuff-right |

*** duplicate-thing

| S-<return> | rf-duplicate-thing-wrapper |

*** eglot
**** prog-mode-map

| <f6> e z | eglot |

**** eglot-mode-map

| <f6> e h   | eglot-find-implementation |
| <f6> e t   | eglot-find-declaration    |
| <f6> e n   | eglot-find-typeDefinition |
| <f6> e r   | eglot-rename              |
|            |                           |
| <f6> e TAB | eglot-format              |
|            |                           |
| <f6> e u   | eglot-code-actions        |
|            |                           |
| <f6> e v   | eglot-reconnect           |
| <f6> e Z   | eglot-shutdown-all        |
| <f6> e z   | eglot-shutdown            |

*** eldoc
**** prog-mode-map

| <f6> i i | eldoc                           |
| <f6> i h | eldoc-doc-buffer                |
| <f6> i z | eldoc-mode                      |

*** embark
**** embark

| C-,   | embark-act        |
| C-.   | embark-dwim       |
| C-h B | embark-bindings   |
|       |                   |
| ,     | *embark-cycle-key |

**** minibuffer-local-map

| C-t | embark-select         |
| C-a | embark-act-all        |
| C-e | embark-export         |
| C-s | embark-collect        |
| C-w | re-embark-kill-buffer |
|     |                       |
| C-l | embark-live           |
| C-b | embark-become         |

**** embark-expression-map

| p n | nil           |
|     |               |
| c   | backward-list |
| t   | forward-list  |
| ,   | kill-region   |

**** embark-identifier-map

| p n | nil                    |
|     |                        |
| c   | embark-previous-symbol |
| t   | embark-next-symbol     |

**** embark-symbol-map

| RET | helpful-callable |

**** embark-variable-map

| RET | helpful-variable |

**** embark-org-src-block-map

| p n | nil                            |
|     |                                |
| RET | org-indent-block               |
| c   | org-babel-previous-src-block   |
| t   | org-babel-next-src-block       |
| g   | embark-org-copy-block-contents |
| f   | org-babel-tangle               |

**** embark-org-item-map

| p n | nil               |
|     |                   |
| c   | org-previous-item |
| t   | org-next-item     |

**** embark-org-link-map

| p n | nil               |
|     |                   |
| RET | org-insert-link   |
| c   | org-previous-link |
| t   | org-next-link     |

**** embark-heading-map

| c | outline-previous-visible-heading |
| t | outline-next-visible-heading     |
| h | outline-backward-same-level      |
| n | outline-forward-same-level       |
| g | outline-up-heading               |
| r | rf-outline-down-heading          |

**** embark-org-heading-map

| nil | t / h / n / p / r                  |
|     |                                    |
| t   | outline-next-visible-heading       |
| h   | outline-backward-same-level        |
| n   | outline-forward-same-level         |
| r   | rf-outline-down-heading            |
|     |                                    |
| f   | org-insert-heading-respect-content |
| o   | org-todo                           |
| y   | org-refile                         |

**** embark-org-table-cell-map

| ^ v < > | nil                         |
| RET     | org-table-blank-field       |
| c       | org-table-move-row-up       |
| t       | org-table-move-row-down     |
| h       | org-table-move-column-left  |
| n       | org-table-move-column-right |
|         |                             |
| j       | org-table-copy-down         |
| q       | org-table-insert-hline      |

*** eshell
**** eshell-mode-map

| C-d | pcomplete-list |

**** eshell-hist-mode-map

| TAB   | nil                                       |
|       |                                           |
| C-S-c | eshell-previous-matching-input-from-input |
| C-S-t | eshell-next-matching-input-from-input     |
| C-S-d | eshell-list-history                       |

**** esh-autosuggest-active-map

| nil | C-f / M-f                     |
|     |                               |
| M-n | company-complete-selection    |
| M-r | esh-autosuggest-complete-word |

*** evil-nerd-commenter

| M-z | evilnc-comment-or-uncomment-lines |

*** expand-region

| '* | expand-region-contract-fast-key |
| +  | expand-region-reset-fast-key    |

*** flycheck
**** prog-mode-map

| <f6> p z | flycheck-mode |

**** flycheck-mode-map

| <f6> p c | flycheck-previous-error         |
| <f6> p t | flycheck-next-error             |
| <f6> p g | flycheck-first-error            |
| <f6> p p | flycheck-list-errors            |
|          |                                 |
| <f6> p u | flycheck-explain-error-at-point |
| <f6> p o | flycheck-clear                  |
| <f6> p w | flycheck-compile                |
| <f6> p v | flycheck-buffer                 |

**** flycheck-error-list-mode-map

| c | flycheck-error-list-previous-error |
| c | previous-line                      |
| t | flycheck-error-list-next-error     |
| t | next-line                          |

*** flymake
**** prog-mode-map

| . z | flymake-mode |

**** flymake-mode-map

| <f6> . c | flymake-goto-prev-error                         |
| <f6> . t | flymake-goto-next-error                         |
| <f6> . . | rf-flymake-show-buffer-diagnostics-other-window |
| <f6> . > | flymake-show-buffer-diagnostics                 |
| <f6> . , | flymake-show-project-diagnostics-other-window   |
| <f6> . < | flymake-show-project-diagnostics                |

*** google-translate-map

| h | google-translate-at-point                |
| t | google-translate-query-translate         |
| g | google-translate-at-point-reverse        |
| c | google-translate-query-translate-reverse |

*** helpful-mode-map

| c | backward-button |
| t | forward-button  |

*** js
**** js-mode-map

| <f6> j | rf-js-save-eval-print  |
| <f6> q | rf-js-console-log-wrap |

*** magit
**** magit

| C-{   | magit-status        |
| C-c g | magit-dispatch      |
| C-c f | magit-file-dispatch |

**** magit-mode-map

|     | nil           | C-w                            |
|     |               |                                |
| C-w | C-<insert>    | magit-copy-section-value       |
|     |               |                                |
| M-p | C-S-c         | magit-section-backward-sibling |
| M-n | C-S-t         | magit-section-forward-sibling  |
|     |               |                                |
| c   | n             | magit-commit                   |
| t   | p             | magit-tag                      |
| p   | c             | magit-section-backward         |
| n   | t             | magit-section-forward          |
|     |               |                                |
| '^  | S-<backspace> | magit-section-up               |

*** marginalia
**** minibuffer-local-map

| M-A | marginalia-cycle |

*** markdown-mode
**** markdown-mode-map
qwerty
| C-c C-e | markdown-do |

*** multiple-cursors

| <kp-7>        | mc/mark-next-like-this     |
| S-<kp-7>      | mc/mark-previous-like-this |
| C-S-<mouse-1> | mc/add-cursor-on-click     |

*** org
**** org-mode-map

| nil             | C-S-up / C-S-down         |
| nil             | S-<return> / S-RET        |
| nil             | M-h / M-} / M-{ / C-,     |
|                 |                           |
| C-c C-d         | rf-outline-down-heading   |
|                 |                           |
| <kp-multiply>   | rf-org-emphasize-bold     |
| <kp-divide>     | rf-org-emphasize-code     |
| S-<kp-multiply> | rf-org-emphasize-italic   |
| S-<kp-divide>   | rf-org-emphasize-verbatim |
|                 |                           |
| <f6>            | *rf-org-leader-map        |

**** rf-org-leader-map

| '* | rf-org-emphasize-code                   |
| ') | rf-org-emphasize-bold                   |
| '+ | rf-org-emphasize-italic                 |
| '] | rf-org-emphasize-verbatim               |
|    |                                         |
| c  | org-previous-visible-heading            |
| t  | org-next-visible-heading                |
| h  | org-backward-heading-same-level         |
| n  | org-forward-heading-same-level          |
| g  | org-up-element                          |
| r  | rf-outline-down-heading                 |
|    |                                         |
| k  | org-cut-subtree                         |
|    |                                         |
| d  | org-previous-link                       |
| b  | org-next-link                           |
|    |                                         |
| ,  | org-insert-link                         |
| ;  | org-store-link                          |
|    |                                         |
| e  | org-table-create-or-convert-from-region |
| u  | org-insert-structure-template           |
|    |                                         |
| .  | org-narrow-to-subtree                   |
| m  | org-return-and-maybe-indent             |
|    |                                         |
| j  | org-table-copy-down                     |

*** prodigy
**** prodigy-view-mode-map

| p | prodigy-mark-tag |

**** prodigy-mode-map

| C-w   | nil                      |
| R     | prodigy-refresh          |
| c     | prodigy-prev             |
| t     | prodigy-next             |
| M-s   | prodigy-first            |
| M-S   | prodigy-last             |
| C-S-c | prodigy-prev-with-status |
| C-S-t | prodigy-next-with-status |
| C-d   | prodigy-copy-cmd         |

*** sgml-mode
**** html-mode-map
qwerty
| M-o | nil             |
| M-i | facemenu-keymap |

*** tempel
**** tempel

| C-<tab> | tempel-complete  |

**** tempel-map

| TAB     | tempel-next     |
| backtab | tempel-previous |
| M-RET   | tempel-done     |
| C-d     | tempel-kill     |

*** treemacs
**** treemacs-mode-map

| M-<tab> | treemacs-TAB-action |

*** vertico
**** vertico-map

| C-S-h     | previous-history-element |
| C-S-n     | next-history-element     |
|           |                          |
| S-<prior> | previous-history-element |
| S-<next>  | next-history-element     |

*** vertico-directory
**** vertico-map

| RET   | vertico-directory-enter       |
| DEL   | vertico-directory-delete-char |
| M-DEL | vertico-directory-delete-word |

*** vertico-repeat
**** vertico-repeat

| C-b | vertico-repeat |

**** vertico-map

| C-S-c     | vertico-repeat-previous  |
| C-S-t     | vertico-repeat-next      |
|           |                          |
| <prior>   | vertico-repeat-previous  |
| <next>    | vertico-repeat-next      |

*** xref
**** prog-mode-map

| <f6> u h | xref-find-definitions              |
| <f6> u d | xref-find-definitions-other-window |
| <f6> u n | xref-find-references               |
| <f6> u r | xref-find-references-and-replace   |
| <f6> u m | xref-find-apropos                  |
| <f6> u v | xref-query-replace-in-results      |
|          |                                    |
| <f6> u c | xref-go-back                       |
| <f6> u t | xref-go-forward                    |
| <f6> u w | xref-pop-marker-stack              |
|          |                                    |
| <f6> u u | tags-search                        |
| <f6> u p | tags-query-replace                 |
| <f6> u e | list-tags                          |

*** yas-keymap

| TAB     | nil                            |
| <tab>   | nil                            |
|         |                                |
| C-<tab> | yas-next-field-or-maybe-expand |

*** yas-minor-mode-map

| TAB       | nil        |
| <tab>     | nil        |
|           |            |
| C-<tab>   | yas-expand |
| C-M-<tab> | yas-expand |

* Elisp
** Proccesing
*** Summary
Whenever you give an editing command to Emacs Lisp, such as the command to move the cursor or to scroll the screen, you are evaluating an expression, the first element of which is a function. *This is how Emacs works*.

- Lisp programs are made up of expressions, which are lists or single atoms.
- Lists are made up of zero or more atoms or inner lists, separated by whitespace and surrounded by parentheses. A list can be empty.
- Atoms are multi-character symbols, like ~forward-paragraph~, single character symbols like ~+~, strings of characters between double quotation marks like ~"string"~ , or numbers ~4~.
- A number evaluates to itself.
- A string between double quotes also evaluates to itself.
- When you evaluate a symbol by itself, its value is returned.
- When you evaluate a list, the Lisp interpreter looks at the first symbol in the list and then at the function definition bound to that symbol. Then the instructions in the function definition are carried out.
- A single-quote ‘ ~'~ ’ tells the Lisp interpreter that it should return the following expression as written, and not evaluate it as it would if the quote were not there.
- Arguments are the information passed to a function. The arguments to a function are computed by evaluating the rest of the elements of the list of which the function is the first element.
- A function always returns a value when it is evaluated (unless it gets an error); in addition, it may also carry out some action that is a side effect. In many cases, a function’s primary purpose is to create a side effect.

*** Run a program
A list in Lisp—any list—is a program ready to run. If you run it, the computer will do one of three things: do nothing except return to you the list itself; send you an error message; or, treat the first symbol in the list as a command to do something.

The single [[quote]], when it precedes a list, it tells Lisp to do nothing with the list, other than take it as it is written. But if there is no quote preceding a list, the first item of the list is special: it is a command for the computer to obey. (In Lisp, these commands are called functions.)

The list ~(+ 2 2)~ did not have a quote in front of it, so Lisp understands that the ~+~ is an instruction to do something with the rest of the list: add the numbers that follow.

*** The lisp interpreter
What the Lisp interpreter does when we command it to evaluate a list is, first it looks to see whether there is a [[quote]] before the list; if there is, the interpreter just gives us the list. On the other hand, if there is no quote, the interpreter looks at the first element in the list and sees whether it has a function definition. If it does, the interpreter carries out the instructions in the function definition. Otherwise, the interpreter prints an error message.

In addition to lists, the Lisp interpreter can evaluate a symbol that is not quoted and does not have parentheses around it. The Lisp interpreter will attempt to determine the symbol’s value as a [[Variable]].

If the function that the Lisp interpreter is looking at is not a special form, and if it is part of a list, the Lisp interpreter looks to see whether the list has a list inside of it. If there is an inner list, the Lisp interpreter first figures out what it should do with the inside list, and then it works on the outside list. If there is yet another list embedded inside the inner list, it works on that one first, and so on. It always works on the innermost list first. The *interpreter works on the innermost list first*, to evaluate the result of that list.

Otherwise, the *interpreter works left to right*, from one expression to the next.

** Definitions
*** atoms
Es el objeto más simple de Emacs, se evalúan a sí mismos, por lo que evaluar estos objetos simplemente se devolverá a sí mismos.

Este término proviene del significado histórico de la palabra átomo, que significa *indivisible*. Es cualquier cosa  que no sea una [[cons cell]], por ejemplo, ~forward-paragraph~,  ~+~,  ~string~, ~1234~, entre otros.

#+begin_src

         cons
   atoms ---> cons cell ---> list

  "atoms" con la función "cons" crea "cons cell" y estos pueden crear "list"

 "a" "b" -> (cons "a" "b") = ("a" . "b") -> '("a" . ("b" . nil)) = ("a" "b")

#+end_src

*** Symbol
**** Definition
A symbol, like ~+~, is not itself the set of instructions for the computer to carry out. Instead, the symbol is used, perhaps temporarily, *as a way of locating the definition* or set of instructions. A symbol can have only one function definition attached to it at a time.

A symbol that has a function definition is called, simply, a function (although, properly speaking, the definition is the function and the symbol refers to it.)

You might imagine a symbol as being a chest of drawers. The function definition is put in one drawer,  the value in another, and so on (what is put in each drawer is the address). What is put in the drawer holding the value can be changed without affecting the contents of the drawer holding the function definition, and vice versa.

In addition to its name, symbol definition, and variable value, a symbol has a drawer for a property list which can be used to record other information.

#+begin_src

  (setq bouquet '(rose violet buttercup))

  Symbol bouquet

           Chest of Drawers            Contents of Drawers

            __   o0O0o   __
          /                 \
         ---------------------
        |    directions to    |            [map to]
        |     symbol name     |             bouquet
        |                     |
        +---------------------+
        |    directions to    |
        |  symbol definition  |             [none]
        |                     |
        +---------------------+
        |    directions to    |            [map to]
        |    variable value   |             (rose violet buttercup)
        |                     |
        +---------------------+
        |    directions to    |
        |    property list    |
        |                     |
        +---------------------+
        |/                   \|

#+end_src

**** The concept of symbols in lisp
*∑XAH*
LISP differs from most programing languages such as C, Java, Perl, Python, in that it deals with symbols, as opposed to just variables and values.

In practice, this means that in lisp, variables can be manipulated in its un-evaluated state. The situation is like the need for the “evaluate” command in many languages, where the programer can built code as strings and do ~evaluate(string)~ to achieve meta-programing. In lisp, variable's unevaluated form are always available. You just put a apostrophe in front of it. This is why lisp refers to variable or function names as “symbols”. This makes meta-programing more powerful.

For example, in most languages, once you defined ~x=3~, you cannot manipulate the variable “ ~x~ ” because it gets evaluated to 3 right away. If you want, you have to build a string "~x~" and manipulate this string, then finally use something like ~evaluate(string)~ to achieve the effect. In most languages, the use of ~evaluate()~ breaks down quickly because the language is not designed for doing it. It's slow, difficult to debug, and there lacks many facilities for such meta programing.

The ability to meta-program has many applications. For example, when you need to take user input as code (such as math formulas), or need to manipulate math expressions, or writing programs that modify itself at run-time. Lisp macros is a direct result of the ability to manipulate symbols.


Each lisp symbol has the following “cells” to store things:

- “ *name* ” cell → a string, typically the same as the symbol.
- “ *value* ” cell → stores the symbol's value, typically when the symbol is used as variable.
- “ *function* ” cell → stores function definition object or lisp macros.
- “ *property list* ” cell → typically hold a list of name/value pairs. It is used for syntax coloring strings, for function's state, etc.

A symbol's {value, function} cell may be empty, it's said to be “void”. When you try to get a cell's value that's void, it's a lisp error. (a empty cell is not the same as having value of nil.)

In normal coding, you don't need to worry about any of these. The only thing that's useful for most elisp code is property list, but many other higher-level functions do it for you. (i.e. add, remove, properties.)

Understanding Lisp Symbol cells is important when you do advanced lisp programing. ➢ for example: macros, create and calling functions at run-time, function inside functions, manipulate evaluation, implementing a language, or any sort of meta-programing. If you don't have a need, you should not exploit these facilities in your program. keep your program normal and simple.

*** cons cell
A cons cell is a data object that represents an ordered pair. That is, it has two slots, and each slot holds, or refers to, some Lisp object. One slot is known as the CAR "Contents of the Address part of Register number", and the other is known as the CDR "Contents of the Decrement part of Register number".

We say that “the CAR of this cons cell is” whatever object its CAR slot currently holds, and likewise for the CDR.

Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell. These objects are called [[atoms]].

The names CAR and CDR derive from the history of Lisp. The original Lisp implementation ran on an IBM 704 computer which divided words into two parts, the address and the decrement; CAR was an instruction to extract the contents of the address part of a register, and CDR an instruction to extract the contents of the decrement. By contrast, *cons cells are named for the function cons that creates them*, which in turn was named for its purpose, the construction of cells.

Aunque cons cell se puede usar para contener pares de datos ordenados, se usan más comúnmente para construir estructuras de datos compuestas más complejas, en particular listas y árboles binarios.

#+begin_src

  cons cell = (cons "abc" "def") = ("abc" . "def")

      car     cdr
   +-------+-------+
   | "abc" | "def" |
   +-------+-------+

      car     cdr           car     cdr
   +-------+-------+     +-------+-------+
   | "abc" |    -------> | "def" |  nil  |
   +-------+-------+     +-------+-------+

#+end_src

*** Dotted pair notation
Is a general syntax for cons cells that represents the CAR and CDR explicitly. In this syntax, ~(a . b)~ stands for a cons cell whose CAR is the object ~a~ and whose CDR is the object ~b~. Dotted pair notation is more general than list syntax because the CDR does not have to be a list. However, it is more cumbersome in cases where list syntax would work.

In dotted pair notation, the list ~(1 2 3)~ is written as ~(1 . (2 . (3 . nil)))~. For /nil/ *-terminated lists, you can use either notation*, but list notation is usually clearer and more convenient. When printing a list, the *dotted pair* notation *is only used if the CDR of a cons cell is not a* /list/.

Nota: al trabajar con dotted notation evaluando resultados se debe colocar [[quote]] antes ~'(rose . violet)~.

#+begin_src

  (rose . violet)

    --- ---
   |   |   |--> violet
    --- ---
     |
     |
      --> rose

#+end_src

You can *combine* dotted pair notation with list notation to represent conveniently a chain of cons cells with a *non-nil final CDR*. You write a dot after the last element of the list, followed by the CDR of the final cons cell.

#+begin_src

  (rose violet . buttercup) = (rose . (violet . buttercup))

    --- ---      --- ---
   |   |   |--> |   |   |--> buttercup
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet

  The syntax (rose . violet . buttercup) is invalid

#+end_src

The list ~(rose violet)~ is equivalent to ~(rose . (violet))~

#+begin_src

    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet

#+end_src

The three-element list ~(rose violet buttercup)~ = ~(rose . (violet . (buttercup)))~

#+begin_src

    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup

#+end_src

As a somewhat peculiar side effect of ~(a b . c)~ and ~(a . (b . c))~ being equivalent, for consistency this means that if you replace ~b~ here with the empty sequence, then it follows that ~(a . c)~ and ~(a . ( . c))~ are equivalent, too. This also means that ~( . c)~ is equivalent to ~c~, but this is seldom used.

*** S-expression
Is an expression, in a like-named notation, for nested list (tree-structured) data.

In the usual parenthesized syntax of Lisp, an S-expression is classically defined as

- an atom of the form ~x~, or
- an expression of the form ~(x . y)~ where ~x~ and ~y~ are S-expressions.

This definition reflects LISP's representation of a list as a series of "cells", each one an ordered pair. In plain lists, y points to the next cell (if any), thus forming a list. The recursive clause of the definition means that both this representation and the S-expression notation can represent any binary tree.

#+begin_src

  Tree data structure representing the S-expression (* 2 (+ 3 4)).

       o
      / \
     *   o
        / \
       2   o
          / \
         o  nil
        / \
       +   o
          / \
         3   o
            / \
           4  nil

#+end_src

*** list
Lists in Lisp are not a primitive data type, they are built up from cons cells. A list is a series of [[cons cell]], linked together so that the CDR slot of each cons cell holds either the next cons cell or the empty list. The empty list is actually the symbol ~nil~.

Hence, the CDR of a proper list is always a proper list. The CDR of a nonempty proper list is a proper list containing all the elements except the first.

Upon reading, each object inside the parentheses becomes an element of the list. That is, a cons cell is made for each element. The CAR slot of the cons cell holds the element, and its CDR slot refers to the next cons cell of the list, which holds the next element in the list. The CDR slot of the last cons cell is set to hold ~nil~.

Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a list structure.

This forms the basis of a simple, singly linked list structure whose contents can be manipulated with ~cons~, ~car~, and ~cdr~. Note that ~nil~ is the only list that is not also a cons pair.

A list is kept using a series of pairs of pointers. A pointer itself is quite simply the electronic address of what is pointed to. Hence, a list is kept as a series of electronic addresses.

#+begin_src

  (cons 1 (cons 2 (cons 3 nil))) = (list 1 2 3) = (1 2 3) = '(1 2 3)

  (1 . (2 . (3 . nil))) ---> Dotted Pair Notation

   +------+------+   +------+------+   +------+------+
   |  *   |   *----->|  *   |   *----->|  *   |   *-----> nil
   +--|---+------+   +--|---+------+   +--|---+------+
      |                 |                 |
      v                 v                 v
      1                 2                 3


  In the computer, the electronic address of ‘1’ is recorded in a
  segment of computer memory along with the address that gives the
  electronic address of where the atom ‘2’ is located; and that address
  (the one that tells where ‘2’ is located) is kept along with an
  address that tells where the address for the atom ‘3’ is located.

              sketched in a different manner
    --------------       --------------       --------------
   | car  | cdr   |     | car  | cdr   |     | car  | cdr   |
   |  1   |   o-------->|  2   |   o-------->|  3   |  nil  |
   |      |       |     |      |       |     |      |       |
    --------------       --------------       --------------
  add of 1 add to 2     add of 2 add to 3    add of 3   nil
  Each arrow points to what the address is the address of, either an
  atom or another pair of addresses.

   *--*--*--nil
   |  |  |
   1  2  3

  Binary tree
       *
      / \
     1   *
        / \
       2   *
          / \
         3  nil

#+end_src

A list with no elements in it is the empty list. Here is the list ~(A ())~, or equivalently ~(A nil)~

#+begin_src

    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> A        --> nil

#+end_src

Here is a more complex, the three-element list, ~((pine needles) oak maple)~, the first element of which is a two-element list:

#+begin_src

    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
     |             --> oak      --> maple
     |
     |     --- ---      --- ---
      --> |   |   |--> |   |   |--> nil
           --- ---      --- ---
            |            |
            |            |
             --> pine     --> needles


    sketched in a different manner
   --------------       --------------       --------------
  | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
  |   o   |   o------->| oak   |   o------->| maple |  nil |
  |   |   |      |     |       |      |     |       |      |
   -- | ---------       --------------       --------------
      |
      |
      |        --------------       ----------------
      |       | car   | cdr  |     | car     | cdr  |
       ------>| pine  |   o------->| needles |  nil |
              |       |      |     |         |      |
               --------------       ----------------

#+end_src

#+begin_src emacs-lisp

  (list
   (re-search-forward "The \\(cat \\)")
   (match-beginning 0)
   (match-beginning 1))
  ;;     => (t 9 13)
  ;;
  ;; ---------- Buffer: foo ----------
  ;; I read "The cat -!-in the hat comes back" twice.
  ;;         ^   ^
  ;;         9  13
  ;; ---------- Buffer: foo ----------

#+end_src

*** Association list type
An association list or alist is a specially-constructed list whose elements are cons cells. In each element, the CAR is considered a key, and the CDR is considered an associated value. (In some cases, the associated value is stored in the CAR of the CDR.)

#+begin_src emacs-lisp

  ;; sets the variable alist-of-colors to an alist of three elements.
  ;; In the first element, rose is the key and red is the value.
  (setq alist-of-colors
        '((rose . red) (lily . white) (buttercup . yellow)))

#+end_src

*Association Lists by Xah*
An association list, or alist for short, records a mapping from keys to values. It is a list of cons cells called associations: the CAR of each cons cell is the key, and the CDR is the associated value.

Here is an example of an alist. The key ~pine~ is associated with the value ~cones~; the key ~oak~ is associated with ~acorns~; and the key ~maple~ is associated with ~seeds~.

#+begin_src emacs-lisp

  ((pine . cones)
   (oak . acorns)
   (maple . seeds))

#+end_src

Both the values and the keys in an alist may be any Lisp objects. For example, in the following alist, the symbol ~a~ is associated with the number ~1~, and the string ~"b"~ is associated with the list ~(2 3)~, which is the CDR of the alist element:

#+begin_src emacs-lisp

  ((a . 1) ("b" 2 3))

#+end_src

Sometimes it is better to design an alist to store the associated value in the CAR of the CDR of the element. Here is an example of such an alist:

#+begin_src emacs-lisp

  ((rose red) (lily white) (buttercup yellow))

#+end_src

Here we regard ~red~ as the value associated with ~rose~. One advantage of this kind of alist is that you can store other related information—even a list of other items—in the CDR of the CDR. One disadvantage is that you cannot use ~rassq~ to find the element containing a given value. When neither of these considerations is important, the choice is a matter of taste, as long as you are consistent about it for any given alist.

The same alist shown above could be regarded as having the associated value in the CDR of the element; the value associated with ~rose~ would be the list ~(red)~.

Association lists are often used to record information that you might otherwise keep on a stack, since new associations may be added easily to the front of the list. When searching an association list for an association with a given key, the first one found is returned, if there is more than one.

In Emacs Lisp, it is not an error if an element of an association list is not a cons cell. The alist search functions simply ignore such elements. Many other versions of Lisp signal errors in such cases.

Note that property lists are similar to association lists in several respects. A property list behaves like an association list in which each key can occur only once.

*** Variable
A symbol can have a value attached to it just as it can have a function definition attached to it. The value of a symbol can be any expression in Lisp, such as a symbol, number, list, or string. A symbol that has a value is often called a variable.

The variable ~fill-column~ illustrates a symbol with a value attached to it, this symbol is set to some value, usually ~70~.

A symbol can have any value attached to it or, to use the jargon, we can *bind* the variable to a value: to a number, such as ~72~; to a string, ~"such as this"~ ; to a list, such as ~(spruce pine oak)~ ; we can even bind a variable to a function definition.

*** Macro
A macro is a construct defined in Lisp, which differs from a function in that it translates a Lisp expression into another expression that is to be evaluated in place of the original expression. For example, [[if]], [[when]], and so on.

Macros enable you to define new *control constructs* and other language features. A macro is defined much like a function, but instead of telling how to compute a value, it tells *how to compute another Lisp expression* which will in turn compute the value. We call this expression the expansion of the macro.

Macros can do this because they operate on the unevaluated expressions for the arguments, not on the argument values as functions do. They can therefore construct an expansion containing these argument expressions or parts of them.

Suppose we would like to define a Lisp construct to increment a variable value, much like the ~++~ operator in C. We would like to write ~(inc x)~ and have the effect of ~(setq x (1+ x))~. Here’s a macro definition that does the job:

#+begin_src emacs-lisp

  (defmacro inc (var)
    (list 'setq var (list '1+ var)))

#+end_src

When this is called with ~(inc x)~, the argument var is the symbol ~x~ — *not the value of* ~x~, as it would be in a function. The body of the macro uses this to construct the expansion, which is ~(setq x (1+ x))~. Once the macro definition returns this expansion, Lisp proceeds to evaluate it, thus incrementing x.

*** Classification of emacs lisp function
On a separate subject, Emacs Lisp functions are classified into several types.

- *Function* = Most common. Written in elisp. Usually ~(defun …)~
- *Primitive* = elisp function written in C. ➢ for example: {~list~, ~car~, ~append~, ~point~, ~defun~, …}. Typically the most fundamental ones.
- *lambda expression* = ➢ for example: ~(lambda …)~. Usually temp functions.
- *special for* m = a function that doesn't eval in the normal way. ➢ for example: {~if~, ~cond~, ~and~, ~or~, ~while~, ~progn~}. (normally, arguments to a function are all evaluated first.)
- *macro* = Similar to “special form”, but user-defined. i.e. the arguments are not eval'd, and you can manipulate them and eval them.
- *command* = functions that can be called by ~command-execute~. Typically, ~(defun …)~ with ~(interactive …)~ clause. All functions you can call by ~M-x~ are commands.

*** Vector
**** Introduction
Emacs lisp has a ~vector~ datatype.

- Vector has constant random access time.
- Elements cannot be added or removed.
- Element's value can be changed.
- Vector elements can be any other lisp object.

**** List vs Vector
Lisp's ~list~ and ~vector~ both are subtypes of the “sequences” datatype. Many functions, such as {~elt~, ~mapcar~}, work on any sequence type. Here's their primary differences:

- *Vector*: Access time to any element is constant.
- Vector's length cannot change. (if you create a new copy of a vector, the time required is proportional to the vector's length)

- *List*: Access time to a element is proportional to the distance of the element's position in the list.
- List's length can grow by prepending with ~cons~, and can have the first element dropped by ~cdr~. These operations have constant time.

Lisp culture is to almost always use list. I recommend using vector as much as possible. Use list ONLY IF you need to constantly grow the lis.

#+begin_src

     _____________________________________________
    |                                             |
    |          Sequence                           |
    |  ______   ________________________________  |
    | |      | |                                | |
    | | List | |             Array              | |
    | |      | |    ________       ________     | |
    | |______| |   |        |     |        |    | |
    |          |   | Vector |     | String |    | |
    |          |   |________|     |________|    | |
    |          |  ____________   _____________  | |
    |          | |            | |             | | |
    |          | | Char-table | | Bool-vector | | |
    |          | |____________| |_____________| | |
    |          |________________________________| |
    |_____________________________________________|

#+end_src

*** Dynamic vs lexical binding
**** Dynamic binding
By default, the local variable bindings made by Emacs are dynamic bindings. When a variable is *dynamically bound,* its current binding at any point in the execution of the Lisp program is simply *the most recently-created dynamic local binding* for that symbol, or the global binding if there is no such local binding.

#+begin_src emacs-lisp

  (defvar x -99)  ; x receives an initial value of -99.

  (defun getx ()
    x)            ; x is used free in this function.

  (let ((x 1))    ; x is dynamically bound.
    (getx))       ; => 1

  ;; After the let form finishes, x reverts to its
  ;; previous value, which is -99.

  (getx)          ; =>  -99

#+end_src

Note: Converting to Lexical Binding
Converting an Emacs Lisp program to lexical binding is easy. First, add a file-local variable setting of lexical-binding to t in the header line of the Emacs Lisp source file. Second, check that every variable in the program which needs to be dynamically bound has a variable definition, so that it is not inadvertently bound lexically.

**** Lexical binding
A *lexically-bound* variable has lexical scope, meaning that any reference to the variable must be located textually *within the binding construct*.

#+begin_src emacs-lisp

  (let ((x 1))    ; x is lexically bound.
    (+ x 3))      ; => 4

  (defun getx ()
    x)            ; x is used free in this function.

  (let ((x 1))    ; x is lexically bound.
    (getx))       ; => error→ Symbol's value as variable is void: x

#+end_src

Here, the variable ~x~ has no global value. When it is lexically bound within a ~let~ form, it can be used in the textual confines of that ~let~ form. But it can not be used from within a ~getx~ function called from the ~let~ form, since the function definition of ~getx~ occurs outside the ~let~ form itself.

Each binding construct defines a lexical environment, specifying the variables that are bound within the construct and their local values. When the Lisp evaluator wants the current value of a variable, it looks first in the lexical environment; if the variable is not specified in there, it looks in the symbol’s value cell, where the dynamic value is stored.

(Internally, the lexical environment is an alist of symbol-value pairs, with the final element in the alist being the symbol t rather than a cons cell. Such an alist can be passed as the second argument to the eval function, in order to specify a lexical environment in which to evaluate a form. Most Emacs Lisp programs, however, should not interact directly with lexical environments in this way; only specialized programs like debuggers.)

Lexical bindings have indefinite extent. Even after a binding construct has finished executing, its lexical environment can be “kept around” in Lisp objects called closures. A [[closure]] is created when you define a named or anonymous function with lexical binding enabled.

When a closure is called as a function, any lexical variable references within its definition use the retained lexical environment. Here is an example:

#+begin_src emacs-lisp

  (defvar my-ticker nil)   ; We will use this dynamically bound
                           ; variable to store a closure.

  (let ((x 0))             ; x is lexically bound.
    (setq my-ticker (lambda ()
                      (setq x (1+ x)))))
  ;; (closure ((x . 0) t) ()
  ;;   (setq x (1+ x)))

  (funcall my-ticker) ;; => 1

  (funcall my-ticker) ;; => 2

  (funcall my-ticker) ;; => 3

  x                   ; Note that x has no global value.
  ;; => error→ Symbol's value as variable is void: x

#+end_src

The ~let~ binding defines a lexical environment in which the variable ~x~ is locally bound to ~0~. Within this binding construct, we define a lambda expression which increments ~x~ by one and returns the incremented value. This lambda expression is automatically turned into a closure, in which the lexical environment lives on even after the ~let~ binding construct has exited. Each time we evaluate the closure, it increments ~x~, using the binding of ~x~ in that lexical environment.

Note that unlike dynamic variables which are tied to the symbol object itself, the relationship between lexical variables and symbols is only present in the interpreter (or compiler). Therefore, functions which take a symbol argument (like symbol-value, boundp, and set) can only retrieve or modify a variable’s dynamic binding (i.e., the contents of its symbol’s value cell).

**** Using lexical binding
When loading an Emacs Lisp file or evaluating a Lisp buffer, lexical binding is enabled if the buffer-local variable lexical-binding is non-nil:

Variable: lexical-binding
If this buffer-local variable is non-nil, Emacs Lisp files and buffers are evaluated using lexical binding instead of dynamic binding. (However, special variables are still dynamically bound.) If nil, dynamic binding is used for all local variables. This variable is typically set for a whole Emacs Lisp file, as a file local variable. Note that unlike other such variables, this one must be set in the first line of a file.

When evaluating Emacs Lisp code directly using an eval call, lexical binding is enabled if the lexical argument to eval is non-nil.

Even when lexical binding is enabled, certain variables will continue to be dynamically bound. These are called special variables. Every variable that has been defined with ~defvar~, ~defcustom~ or ~defconst~ is a special variable. All other variables are subject to lexical binding.

Using ~defvar~ without a value, it is possible to bind a variable dynamically just in one file, or in just one part of a file while still binding it lexically elsewhere. For example:

#+begin_src emacs-lisp

  (let (_)
    (defvar x)      ; Let-bindings of x will be dynamic within this let.
    (let ((x -99))  ; This is a dynamic binding of x.
      (defun get-dynamic-x ()
        x)))

  (let ((x 'lexical)) ; This is a lexical binding of x.
    (defun get-lexical-x ()
      x))

  (let (_)
    (defvar x)
    (let ((x 'dynamic))
      (list (get-lexical-x)
            (get-dynamic-x))))
  ;; =>  (lexical dynamic)

#+end_src

Note that since this is a function, it can only return non-nil for variables which are permanently special, but not for those that are only special in the current lexical scope.

** Variables
*** let
Declare that a list of variables is for use within the body of the ~let~ and give them an initial value; then evaluate the rest of the expressions in the body of the let and return the value of the last one. Inside the body of the ~let~, the Lisp interpreter does not see the values of the variables of the same names that are bound outside of the ~let~.

A ~let~ expression is a list of three parts.
- The first part is the symbol ~let~.
- The second part is a list, called a /varlist/, each element of which is either a symbol by itself or a two-element list, the first element of which is a symbol.
- The third part of the let expression is the body of the let.

The symbols in the varlist have the initial value of ~nil~.

#+begin_src emacs-lisp

  (let varlist body…)
  (let (variable variable variable ...) body...)


  ;; varlist composed of two-element lists
  (let ((variable value)
        (variable value)
        …)
    body…)

  (let ((zebra "stripes")
        (tiger "fierce"))
    (message "One kind of animal has %s and another is %s."
             zebra tiger))
  ;; "One kind of animal has stripes and another is fierce."


  (let ((birch 3)
        pine
        fir
        (oak 'some))
    (message
     "Here are %d variables with %s, %s, and %s value."
     birch pine fir oak))
  ;; "Here are 3 variables with nil, nil, and some value."

#+end_src

*** let*
It enables Emacs to set each variable in its varlist in *sequence*, one after another. Its critical feature is that variables later in the varlist can make use of the values to which Emacs set variables earlier in the varlist.

#+begin_src emacs-lisp

  (let* ((foo 7)
         (bar (* 3 foo)))
    (message "`bar' is %d." bar)) ;; => "‘bar’ is 21."

#+end_src

*** set
To set the value of a symbol, Emacs lisp uses the ~set~ function which return and sets the value as a side effect. The symbol (which can be viewed as a variable) is bound to the value.

Note also, that when you use ~set~, you need to quote both arguments to ~set~, unless you want them evaluated. When you use ~set~ without quoting its first argument, the first argument is evaluated before anything else is done.

#+begin_src emacs-lisp

  (set 'flowers '(rose violet daisy buttercup))
  ;; => (rose violet daisy buttercup)

#+end_src

*** setq
Sets the value of its first argument to the value of the second argument. Is just like [[set]] except that the first argument is quoted automatically, so you don’t need to type the quote mark yourself.

Also, ~setq~ can be used to assign different values to different variables. The first argument is bound to the value of the second argument, the third argument is bound to the value of the fourth argument, and so on.

In summary, when a Lisp variable is set to a value, it is provided with the address of the list to which the variable refers.

#+begin_src emacs-lisp

  (setq x 1)
  ;; => x = 1

  (setq a 3 b 2 c 7)
  ;; a=3, b=2, c=7

  (setq flor '(rosa violeta))
  ;; flor = (rosa violeta)

  (setq trees '(pine fir oak maple)
        herbivores '(gazelle antelope zebra))
  ;; trees = (pine fir oak maple)
  ;; herbivores = (gazelle antelope zebra)

  (setq flor (list 'rosa 'violeta))
  ;; flor = (rosa violeta)

#+end_src

When a variable is set to a list, it stores the address of the first box in the variable.

#+begin_src

  (setq bouquet '(rose violet buttercup))

  bouquet
       |
       |     ___ ___      ___ ___      ___ ___
        --> |___|___|--> |___|___|--> |___|___|--> nil
              |            |            |
              |            |            |
               --> rose     --> violet   --> buttercup

#+end_src

Symbols consist of more than pairs of addresses, but the structure of a symbol is made up of addresses. Indeed, the symbol bouquet consists of a group of address-boxes, one of which is the address of the printed word ~bouquet~, a second of which is the address of a function definition attached to the symbol, if any, a third of which is the address of the first pair of address-boxes for the list ~(rose violet buttercup)~, and so on. Here we are showing that the symbol’s third address-box points to the first pair of address-boxes for the list.

#+begin_src

  (setq flowers (cdr bouquet))

  bouquet        flowers
    |              |
    |     ___ ___  |     ___ ___      ___ ___
     --> |   |   |  --> |   |   |    |   |   |
         |___|___|----> |___|___|--> |___|___|--> nil
           |              |            |
           |              |            |
            --> rose       --> violet   --> buttercup

#+end_src

*** defvar
Is similar to [[setq]] in that it sets the value of a variable. It is unlike ~setq~ in two ways: first, it only sets the value of the variable if the variable *does not* already have a value. If the variable already has a value, ~defvar~ does not override the existing value (this is actually useful: packages can define their variables with ~defvar~ and you can set values for them before the package gets loaded! Your settings will not be overridden by the default value). Second, ~defvar~ has a documentation string.

*Note*: When you specified a variable using the ~defvar~ special form, you could distinguish a variable that a user might want to change from others by typing an asterisk, ~*~, in the first column of its documentation string ~(defvar variable "*Buffer name ...")~.

#+begin_src emacs-lisp

  ;; kill-ring is defined by defvar
  (defvar kill-ring nil "...")


  ;; variable defined with a conditional construction
  (defvar X-axis-label-spacing
    (if (boundp 'graph-blank)
        (* 5 (length graph-blank))
      5)
    "Number of units from one X axis label to next.")

#+end_src

*** defvar vs setq
[[https://stackoverflow.com/questions/3855862/setq-and-defvar-in-lisp][stackoverflow]]

[[defvar]] introduces a dynamic variable while [[setq]] is used to assign a value to a dynamic or lexical variable. The value of a dynamic variable is looked up in the environment that calls the function, while the value of a lexical variable is looked up in the environment where the function was defined. The following example will make the difference clear:

#+begin_src emacs-lisp

  ;; dynamic variable sample
  (defvar *x* 100)
  ;; *X*
  (defun fx () *x*)
  ;; FX
  (fx)
  ;; 100
  (let ((*x* 500)) (fx)) ;; gets the value of *x* from the dynamic scope.
  ;; 500
  (fx) ;; *x* now refers to the global binding.
  ;; 100

  ;; example of using a lexical variable
  > (let ((y 200))
     (let ((fy (lambda () (format t "~a~%" y))))
       (funcall fy) ;; => 200
       (let ((y 500))
         (funcall fy) ;; => 200, the value of lexically bound y
         (setq y 500) ;; => y in the current environment is modified
         (funcall fy)) ;; => 200, the value of lexically bound y, which was
                       ;; unaffected by setq
       (setq y 500) => ;; value of the original y is modified.
       (funcall fy))) ;; => 500, the new value of
                      ;;y in fy's defining environment.

#+end_src

Dynamic variables are useful for passing around a default value.

*** fset
Set SYMBOL's function definition to DEFINITION, and return DEFINITION.

Emacs Lisp maintains different namespaces for variables and functions so ~fset~ must be used for functions.

#+begin_src emacs-lisp

  ;; Since lambdas are literals and we can assign variable names to
  ;; literals we can set the lambda function.
  (fset 'cube (lambda (x) (* x x x))) (lambda (x) (* x x x))
  (cube 5) ;; => 125


  ;; Sets the function symbol yes-or-or-no-p to the definition y-or-n-p
  ;; and returns the definition y-or-n-p
  (fset 'yes-or-no-p 'y-or-n-p)

#+end_src

** Special forms
*** progn
Evaluate each argument in sequence and then return the value of the last.

Sometimes you need to group several expressions together as one single expression. This can be done with ~progn~.

The purpose of ~(progn …)~ is similar to a block of code ~{…}~ in C-like languages. It is used to group together a bunch of expressions into one single parenthesized expression.

The preceding expressions are evaluated only for the side effects they perform. The values produced by them are discarded.

#+begin_src emacs-lisp

  (progn
    body…)


  (progn 1 2 3 4) ;; => 4


  ;; Most of the time it's used inside “if”. For example:
  (if something
      (progn ; true
        …
        )
    (progn ; else
      …
      )
    )

#+end_src

*** save-excursion
Record the values of *point and the current buffer* before evaluating the body of this special form. Restore the value of point and buffer afterward.

~save-excursion~ restores the value of point even if something goes wrong in the code inside of it.

#+begin_src emacs-lisp

  (save-excursion
    first-expression-in-body
    second-expression-in-body
    third-expression-in-body
    …
    last-expression-in-body)


  ;; often occurs within the body of a let expression
  (let varlist
    (save-excursion
      body…))


  (message "We are %d characters into this buffer."
           (- (point)
              (save-excursion
                (goto-char (point-min)) (point))))

#+end_src

*** save-restriction
Record whatever narrowing is in effect in the current buffer, if any, and restore that narrowing after evaluating the arguments.

When the Lisp interpreter meets with ~save-restriction~, it executes the code in the body of the ~save-restriction~ expression, and then undoes any changes to narrowing that the code caused.

Note: when you use both ~save-excursion~ and ~save-restriction~, one right after the other, you should use ~save-excursion~ outermost. If you write them in reverse order, you may fail to record narrowing in the buffer to which Emacs switches after calling ~save-excursion~.

#+begin_src emacs-lisp

  (save-restriction
    body… )


  ;; when written together should be written like this
  (save-excursion
    (save-restriction
      body…))

#+end_src

*** widen
This function undoes any [[narrowing]] the current buffer.

*** quote
This special form quote returns object, as written, without evaluating it. This provides a way to include constant symbols and lists, which are not self-evaluating objects, in a program. (It is not necessary to quote self-evaluating objects such as numbers, strings, and vectors.)

Because quote is used so often in programs, Lisp provides a convenient read syntax for it. An apostrophe character ~'~ followed by a Lisp object (in read syntax) expands to a list whose first element is quote, and whose second element is the object. Thus, the read syntax ~'x~ is an abbreviation for ~(quote x)~.

#+begin_src emacs-lisp

  (quote (+ 1 2)) ;; => (+ 1 2)
  (quote foo)     ;; => foo
  'foo            ;; => foo

  ;; Although the expressions both yield lists equal
  (list '+ 1 2) ;; => (+ 1 2) ;; is a freshly-minted mutable list
  '(+ 1 2)      ;; => (+ 1 2) ;; is a list built from conses that might
                              ;; be shared and shouldn't be modified

#+end_src

*** nil
Is both a symbol (false) ~nil~ and an empty list ~()~. In Emacs Lisp, any value that is not ~nil~ —is not the empty list—is considered true.

For convenience, the symbol ~nil~ is considered to have ~nil~ as its CDR (and also as its CAR).

** Booleans
*** or
Evaluate each argument in sequence, and return the value of the first argument that is not ~nil~; if none return a value that is not ~nil~, return ~nil~.

#+begin_src emacs-lisp

  (or   1 2) ;; => 1
  (or nil 2) ;; => 2

#+end_src

*** and
Evaluate each argument in sequence, and if any are ~nil~, return ~nil~; if none are ~nil~, return the value of the last argument.

*** not
Is a function that returns true if its argument is ~false~ and false if its argument is ~true~.

** Comparing
*** <,>,<=,>=
Tests whether its first argument is smaller than its second argument. Its behavior is similar to these, ~>~, ~<=~, ~>=~ and ~=~. In all cases, both arguments must be numbers or markers.

*** /=
Not equal. It is for comparing *numbers only*.

*** equal
It tests if two values have the same datatype and value.

Test whether two *objects* are the same. ~equal~ uses one meaning of the word “same” and [[eq]] uses another: ~equal~ returns true if the two objects have a similar structure and contents, such as two copies of the same book. On the other hand, ~eq~, returns true if both arguments are actually the same object.

The ~eq~ function is similar to the ~equal~ function in that it is used to test for equality, but differs in that it determines whether two representations are actually the same object inside the computer, but with different names. ~equal~ determines whether the structure and contents of two expressions are the same.

Compara recursivamente el contenido de los objetos si son enteros, cadenas, marcadores, vectores, vectores bool, objetos de función de código de bytes, tablas de caracteres, registros u objetos de fuente.

| /a/     | /b/     | /eq/  | /equal/ | /=/     | /string=/ |
|-------+-------+-----+-------+-------+---------|
| 5     | 5     | t   | t     | t     | error   |
| 5     | 5.0   | nil | nil   | t     | error   |
| “a”   | “a”   | nil | t     | error | t       |
| “a”   | ‘a    | nil | nil   | error | t       |
| a     | a     | t   | t     | error | error   |
| “a”   | “A”   | nil | nil   | error | nil     |
| (1 2) | (1 2) | nil | t     | error | error   |

#+begin_src emacs-lisp

  (equal 3 3)   ;; => t
  (equal 3 3.0) ;; => nil
  (eq 3 3)      ;; => t
  (eq 3 3.0)    ;; => nil

  (equal '(1 (2 (3))) '(1 (2 (3)))) ; => t
  (eq    '(1 (2 (3))) '(1 (2 (3)))) ; => nil

  (equal (point-marker) (point-marker)) ; => t
  (eq    (point-marker) (point-marker)) ; => nil

  ;; General way to test inequality.
  (not (equal 3 4)) ; ⇒ t

  ;; example of testing a "string"
  (equal "stringHere" ((substring (car variable) -1))) ;; variable may be string

  ;; example of testing a "t"
  (eq t (car someVariable)) ;; variable may be "t"

#+end_src

*** eq
Test whether two *objects* are the same.

~eq~ uses one meaning of the word “same” and [[equal]] uses another: ~eq~, returns true if both arguments are actually the same object. On the other hand, ~equal~ returns true if the two objects have a similar structure and contents, such as two copies of the same book.

The ~eq~ function is similar to the ~equal~ function in that it is used to test for equality, but differs in that it determines whether two representations are actually the same object inside the computer, but with different names. ~equal~ determines whether the structure and contents of two expressions are the same.

Dos argumentos con el mismo contenido o elementos no son necesariamente equivalentes entre sí, son equivalentes solo si son el mismo objeto, lo que significa que un cambio en los contenidos de uno se reflejará en el mismo cambio en los contenidos del otro.

| /a/     | /b/     | /eq/  | /equal/ | /=/     | /string=/ |
|-------+-------+-----+-------+-------+---------|
| 5     | 5     | t   | t     | t     | error   |
| 5     | 5.0   | nil | nil   | t     | error   |
| “a”   | “a”   | nil | t     | error | t       |
| “a”   | ‘a    | nil | nil   | error | t       |
| a     | a     | t   | t     | error | error   |
| “a”   | “A”   | nil | nil   | error | nil     |
| (1 2) | (1 2) | nil | t     | error | error   |

#+begin_src emacs-lisp

  (eq    '(1 (2 (3))) '(1 (2 (3)))) ; => nil
  (equal '(1 (2 (3))) '(1 (2 (3)))) ; => t

  (eq    (point-marker) (point-marker)) ; => nil
  (equal (point-marker) (point-marker)) ; => t

#+end_src

*** string-lessp
Tests whether its first argument is smaller than the second argument. A shorter, alternative name for the same function (a defalias) is ~string<~.

The arguments to ~string-lessp~ must be strings or symbols; the ordering is lexicographic, so case is significant. The print names of symbols are used instead of the symbols themselves.

An empty string, ~""~, a string with no characters in it, is smaller than any string of characters.

*** string-equal
Provides the corresponding test for equality. Its shorter, alternative name is ~string=~.

Can be used to compare string and symbol.

#+begin_src emacs-lisp

  (string-equal "abc" 'abc) ; ⇒ t

#+end_src

** Conditionals
*** if
Evaluate the first argument to the function; if it is true, evaluate the second argument; else evaluate the third argument, if there is one.

#+begin_src emacs-lisp

  (if true-or-false-test
      action-to-carry-out-if-test-is-true)


  (if (> 5 4)                             ; if-part
      (message "5 is greater than 4!"))   ; then-part

#+end_src

*** if–then–else
An [[if]] expression may have an optional third argument, called the else-part, for the case when the true-or-false-test returns false.

#+begin_src emacs-lisp

  (if true-or-false-test
      action-to-carry-out-if-the-test-returns-true
    action-to-carry-out-if-the-test-returns-false)


  (if (> 4 5)                               ; if-part
      (message "4 falsely greater than 5!") ; then-part
    (message "4 is not greater than 5!"))   ; else-part


  ;; example of doing nothing when "if" is true but doing
  ;; something when we have "else" part
  (if (> 4 5)
      () ;; then do nothing
    (message "4 is not greater than 5!"))

#+end_src

*** when
Is an [[if]] without the possibility of an else clause. In your mind, you can replace ~when~ with ~if~ and understand what goes on. That is what the Lisp interpreter does. Technically speaking, ~when~ is a Lisp [[Macro]].

#+begin_src emacs-lisp

  (when test expr1 expr2 …)


  ;; Its meaning is the same as
  (if test (progn expr1 expr2 …)).

#+end_src

*** unless
If COND yields nil, do BODY, else return nil.

Is an [[if]] without a then-part clause, just the else-part.

*Note*: ~unless~ (si no) is the inverse of ~if~ , such that ~unless foo~ means the same thing as ~if (not foo)~.

#+begin_src emacs-lisp

  (unless nil
    5) ;; => 5
  (unless t
    5) ;; => nil

#+end_src

*** cond
Try each clause until one succeeds.

Each clause looks like ~(CONDITION BODY...)~.  ~CONDITION~ is evaluated and, if the value is ~non-nil~, this clause succeeds: then the expressions in ~BODY~ are evaluated and the last one's value is the value of the ~cond-form~. If a clause has one element, as in ~(CONDITION)~, then the ~cond-form~ returns ~CONDITION's~ value, if that is ~non-nil~. If no clause succeeds, cond returns ~nil~.

#+begin_src emacs-lisp

  (cond CLAUSES...)


  (cond ( (> 5 10) 55)
        ( (< 5 10) 100)
        ( (= 5  5) 200) ) ;; 100

#+end_src

*** condition-case
Es usada para manejar condicionalmente errores que pueden surgir al aplicar otras funciones, por ejemplo, al ejecutar la función kill-region en un buffer de solo lectura, ella maneja el error no cortando la información (no puede al ser buffer read-only) pero si copiandola para agregarla al kill-ring.

It takes three arguments.

The first is the var argument, is sometimes bound to a variable that contains information about the error. However, if that argument is nil, that information is discarded.

The second argument determines what should happen when everything works correctly.

If an error occurs, among its other actions, the function generating the error signal will define one or more error condition names.

The third argument is an error handler. An error handler has two parts, a condition-name and a body. If the condition-name part of an error handler matches a condition name generated by an error, then the body part of the error handler is run.

#+begin_src emacs-lisp

  (condition-case
      var              ;; information
      bodyform         ;; If no errors, run only this code
    error-handler…)  ;; but, if errors, run this other code

#+end_src

** Loops and recursion
*** while
The ~while~ special form tests whether the value returned by evaluating its first argument is true or false. If the value returned by evaluating the first argument is ~false~, the Lisp interpreter skips the rest of the expression and does not evaluate it. If the value is ~true~, the Lisp interpreter evaluates the body of the expression and then again tests whether the first argument to while is ~true~ or ~false~, repeating the proccess.

#+begin_src emacs-lisp

  (while true-or-false-test
    body…)


                                          ; Incrementing Loop
  set-count-to-initial-value
  (while (< count desired-number) ; true-or-false-test
    body…
    (setq count (1+ count)))      ; incrementer
  ; the expression (1+ count) is te same (+ 1 count)


  ;; Printing a list
  (setq animals '(gazelle giraffe lion tiger))
  (defun print-elements-of-list (list)
    "Print each element of LIST on a line of its own."
    (while list
      (print (car list))
      (setq list (cdr list))))
  (print-elements-of-list animals)
  ;; => gazelle
  ;;    giraffe
  ;;    lion
  ;;    tiger
  ;;    nil

#+end_src

*** dolist
Automatically shortens the list each time it loops—takes the ~cdr~ of the list—and binds the ~car~ of each shorter version of the list to the first of its arguments.

#+begin_src emacs-lisp

  ;; Evaluate BODY with VAR bound to each car from LIST, in turn.
  ;; Then evaluate RESULT to get return value, default nil.
  ;; RESULT is optional
  (dolist (var list [result])
    body)


  (dolist (var '(0 2 4 6))
    (princ var))
  ;; 0246nil

  (let ((result "nothing"))
    (dolist (var '(0 2 4 6) result)
      (princ var)))
  ;; 0246"nothing"


  (defun reverse-list-with-dolist (list)
    "Using dolist, reverse the order of LIST."
    (let (result)  ; make sure list starts empty
      (dolist (var list result)
        (setq result (cons var result)))))

  ;; the same function using while
  (defun reverse-list-with-while (list)
    "Using while, reverse the order of LIST."
    (let (result)
      (while list
        (setq result (cons (car list) result))
        (setq list (cdr list)))
      result))

#+end_src

*** dotimes
Loops a specific number of times: you specify the number. ~dotimes~ is useful when you want to go thru a list with a index.

#+begin_src emacs-lisp

  (dotimes (var n) body) ;; run body, with var set to 0 to n-1


  (dotimes (var n result) body) ;; returns result


  (dotimes (number 5)
    (insert (message "%d" number)))
  ;; => 01234nil (supongo que de último imprime nil porque dotimes
  ;; viene del ciclo while que imprime nil cuando no se cumple la
  ;; condicion tru-false)


  (let (value)      ; otherwise a value is a void variable
    (dotimes (number 3)
      (setq value (cons number value)))
    value)
  ;; =>  (2 1 0)

#+end_src

*** Recursive
A recursive function typically contains a conditional expression which has three parts:

- A ~true-or-false-test~ that determines whether the function is called again, here called the ~do-again-test~.
- The name of the function. When this name is called, a new instance of the function is created and told what to do.
- An expression that returns a different value each time the function is called, here called the ~next-step-expression~. Consequently, the argument (or arguments) passed to the new instance of the function will be different from that passed to the previous instance. This causes the conditional expression, the ~do-again-test~, to test false after the correct number of repetitions.

*Note* that although we say that the function “calls itself”, what we mean is that the Lisp interpreter assembles and instructs a *new instance* of the program. The new instance is a clone of the first, but is a separate individual.

#+begin_src emacs-lisp

  (defun name-of-recursive-function (argument-list)
    "documentation…"
    (if do-again-test
        body…
      (name-of-recursive-function
       next-step-expression)))


  (defun print-elements-recursively (list)
    "Print each element of LIST on a line of its own.
    Uses recursion."
    (when list                        ; do-again-test
      (print (car list))              ; body
      (print-elements-recursively     ; recursive call
       (cdr list))))                  ; next-step-expression

  (print-elements-recursively '(1 2 3 4)) ;; => 1 2 3 4


  (defun sum-nfirst-number-recursively (number)
    "Return the sum of the numbers 1 through NUMBER inclusive."
    (if (= number 1)                    ; do-again-test
        1                               ; then-part
      (+ number                         ; else-part
         (sum-nfirst-number-recursively ; recursive call
          (1- number)))))               ; next-step-expression

  (sum-nfirst-number-recursively 4) ;; => 10


  ;; This function is a bit odd (novice practice). The next one is better.
  (defun rf-sum-list-recursively (list)
    "Return the sum of the numbers in a LIST."
    (let ((result 0)) ;; VARIABLE para poder entregar el resultado
      ;; si no se se coloca, el último resultado sería el "nil"
      ;; que arroja el condicional "if" al fallar el último valor
      ;; que rompe la recursividad
      (if (not (eq (car list) nil)) ;; CONDICIONAL que rompe la recursividad
          (setq result
                (+ (car list) (rf-sum-list-recursively (cdr list)))))
      ;; FUNCIÓN que llama la recursividad variando el parámetro
      result))

  (rf-sum-list-recursively '(1 2 3 4)) ;; => 10

  ;; Enhanced function.
  (defun rf-sum-list-recursively (list)
    "Return the sum of the numbers in a LIST."
    (if (not list)
        0
      (+ (car list) (rf-sum-list-recursively (cdr list)))))

  (rf-sum-list-recursively '(1 2 3 4 5)) ;; 15

  ;; The same function but using a loop.
  (defun rf-sum-list (list)
    "Return the sum of the numbers in a LIST."
    (let ((res 0))
      (while list
        (setq res  (+ res (car list))
              list (cdr list)))
      res))

  (rf-sum-list '(1 2 3 4 5)) ;; 15

#+end_src

*** Recursive Patterns
**** every
In the every recursive pattern, an action is performed on every element of a list.

The pattern is:

If a list be empty, return ~nil~.
Else, act on the beginning of the list (the ~car~ of the list)
- through a recursive call by the function on the rest (the ~cdr~) of the list,
- and, optionally, combine the acted-on element, using ~cons~, with the results of acting on the rest.

#+begin_src emacs-lisp

  (defun square-each (list)
    "Square each of a LIST, recursively."
    (if (not list)                 ; do-again-test
        nil
      (cons
       (* (car list) (car list))
       (square-each (cdr list))))) ; next-step-expression

  (square-each '(1 2 3)) ;; => (1 4 9)

#+end_src

**** accumulate
In the accumulate recursive pattern, an action is performed on every element of a list and the result of that action is accumulated with the results of performing the action on the other elements.

The pattern is:

If a list be empty, return ~zero~ or some other constant.
Else, act on the beginning of the list (the ~car~ of the list),
- and combine that acted-on element, using ~+~ or some other combining function, with
- a recursive call by the function on the rest (the ~cdr~) of the list.

#+begin_src emacs-lisp

  (defun add-elements (list)
    "Add the elements of LIST together."
    (if (not list)
        0
      (+ (car list) (add-elements (cdr list)))))

  (add-elements '(1 2 3 4)) ;; => 10

#+end_src

**** keep
In the keep recursive pattern, each element of a list is tested; the element is acted on and the results are kept only if the element meets a criterion.

The pattern has three parts:

If a list be empty, return ~nil~.
Else, if the beginning of the list (the ~car~ of the list) passes a test
    - act on that element and combine it, using ~cons~ with
    - a recursive call by the function on the rest (the ~cdr~) of the list.
      Otherwise, if the beginning of the list (the ~car~ of the list) fails the test
      - skip on that element,
      - and, recursively call the function on the rest (the ~cdr~) of the list.

#+begin_src emacs-lisp

  (defun keep-three-letter-words (word-list)
    "Keep three letter words in WORD-LIST."
    (cond
     ;; First do-again-test: stop-condition
     ((not word-list) nil)
     ;; Second do-again-test: when to act
     ((eq 3 (length (symbol-name (car word-list))))
      ;; combine acted-on element with recursive call on shorter list
      (cons (car word-list) (keep-three-letter-words (cdr word-list))))
     ;; Third do-again-test: when to skip element;
     ;;   recursively call shorter list with next-step expression
     (t (keep-three-letter-words (cdr word-list)))))

  (keep-three-letter-words '(one two three four five six))
  ;; => (one two six)

#+end_src

**** No deferment solution
The solution to the problem of deferred operations is to write in a manner that does not defer operations (the phrase /tail recursive/ is used to describe such a process, one that uses constant space). This requires writing to a different pattern, often one that involves writing two function definitions, an initialization function and a helper function.

The initialization function sets up the job; the helper function does the work.

*Note*: this is also called [[~/Documents/todo.org::Tail call][tail recursive]].

Here are the two function definitions for adding up numbers. They are so simple, I find them hard to understand.

#+begin_src emacs-lisp

  (defun triangle-initialization (number)
    "Return the sum of the numbers 1 through NUMBER inclusive.
  This is the initialization component of a two function
  duo that uses recursion."
    (triangle-recursive-helper 0 0 number))


  (defun triangle-recursive-helper (sum counter number)
    "Return SUM, using COUNTER, through NUMBER inclusive.
  This is the helper component of a two function duo
  that uses recursion."
    (if (> counter number)
        sum
      (triangle-recursive-helper (+ sum counter)  ; sum
                                 (1+ counter)     ; counter
                                 number)))        ; number
  (triangle-initialization 7)
  ;; (triangle-recursive-helper  0   0   7)  ;; Immediately call
  ;;   (triangle-recursive-helper  1   1   7)
  ;;     (triangle-recursive-helper  3   2   7)
  ;;       (triangle-recursive-helper  6   3   7)
  ;;         (triangle-recursive-helper 10   4   7)
  ;;           (triangle-recursive-helper 15   5   7)
  ;;             (triangle-recursive-helper 21   6   7)
  ;;               (triangle-recursive-helper 28   7   7)
  ;;               => 28
  ;;             => 28
  ;;           => 28
  ;;         ...
  ;; => 28
  ;; This is optimized by the compiler.

  ;; The same recursion function without deferments
  (defun triangle-recursively (number)
    "Return the sum of the numbers 1 through NUMBER inclusive.
  Uses recursion."
    (if (= number 1)                    ; do-again-test
        1                               ; then-part
      (+ number                         ; else-part
         (triangle-recursively          ; recursive call
          (1- number)))))               ; next-step-expression

  (triangle-recursively 7)
  ;; (+ 7 (triangle-recursively 6)) ;; Wait for a new value
  ;; (+ 7 6 (triangle-recursively 5))
  ;; (+ 7 6 5 (triangle-recursively 4))
  ;; (+ 7 6 5 4 (triangle-recursively 4))
  ;; (+ 7 6 5 4 3 (triangle-recursively 4))
  ;; (+ 7 6 5 4 3 2 (triangle-recursively 4))
  ;; (+ 7 6 5 4 3 2 1)
  ;; => 28

#+end_src

Deferments solution allows an interpreter or compiler to reorganize the execution which would ordinarily look like this:

#+begin_src

  call triangle-initialization (7)
    call triangle-recursive-helper  (0   0   7)
      call triangle-recursive-helper  (1   1   7)
        call triangle-recursive-helper  (3   2   7)
          call triangle-recursive-helper  (6   3   7)
            call triangle-recursive-helper (10   4   7)
              call triangle-recursive-helper (15   5   7)
                call triangle-recursive-helper (21   6   7)
                  call triangle-recursive-helper (28   7   7)
                  return 28
                return 28
              return 28
            ...
    return 28

#+end_src

into the more efficient variant, in terms of both space and time:

#+begin_src

  call triangle-initialization (7)
    call triangle-recursive-helper  (0   0   7)
    replace arguments with  (1   1   7)
    replace arguments with  (3   2   7)
    replace arguments with  (6   3   7)
    replace arguments with (10   4   7)
    replace arguments with (15   5   7)
    replace arguments with (21   6   7)
    replace arguments with (28   7   7)
    return 28
  return 28

#+end_src

This reorganization saves space because no state except for the calling function's address needs to be saved, either on the stack or on the heap, and the call stack frame for ~triangle-recursive-helper~ is reused for the intermediate results storage. This also means that the programmer need not worry about running out of stack or heap space for extremely deep recursions. In typical implementations, the tail-recursive variant will be substantially faster than the other variant, but only by a constant factor.

Some programmers working in functional languages will rewrite recursive code to be tail recursive so they can take advantage of this feature. This often requires addition of an "accumulator" argument (~sum~ in the example) to the function.

** Functions
*** defun
In Lisp, a symbol such as ~mark-whole-buffer~ has code attached to it that tells the computer what to do when the function is called. This code is called the function definition and is created by evaluating a Lisp expression that starts with the symbol ~defun~.

A function definition has up to five parts following the word ~defun~:

- The name of the symbol to which the function definition should be attached.
- A list of the arguments that will be passed to the function. If no arguments will be passed to the function, this is an empty list, ~()~.
- Documentation describing the function. (optional)
- An expression to make the function interactive so you can use it by typing ~M-x~ and then the name of the function. (optional)
- The code that instructs the computer what to do: the body of the function definition.

It is helpful to think of the five parts of a function definition as being organized in a template, with slots for each part:

#+begin_src emacs-lisp

  (defun function-name (arguments…)
    "One sentence summary of what this command do, no more than 67 chars.

  More details here. Be sure to mention the return value if relevant.
  Lines here should not be longer than 70 chars,
  and don't indent them.

  • ARG1 is…. Parameters should be all caps.
  • See URL `http://example.com/' (clickable url)
  • See `dired' (clickable command name)
  • See `(emacs) Dired'. (link to info doc)
  • Type \\[dired] to go into dired. (key of a command.)
  • clickable list of all keys of a given keymap name.
  \\{c-mode-map}
  • \\<c-mode-map> No visible effect. Tell emacs to use this keymap for
  displaying keys in the rest of this inline doc."
    (interactive argument-passing-info)     ; optional
    body…)


  (defun multiply-by-seven (number)
    "Multiply NUMBER by seven."
    (* 7 number))

#+end_src

#+begin_src emacs-lisp

  (defun triangulo (numero)
    "Devuelve la suma de números desde el 1 hasta e incluyendo a NUMERO."
    (let ((total 0))
      (while (> numero 0)
        (setq total (+ total numero))
        (setq numero (1- numero)))
      total))


  (defun cuadrado-de-cada-uno (lista-de-numeros)
    "El cuadrado de cada elemento en LISTA DE NUMEROS, recursivamente."
    (if (not lista-de-numeros)		; prueba-hazlo-de-nuevo
        nil
      (cons
       (* (car lista-de-numeros) (car lista-de-numeros))
       (cuadrar-cada-uno (cdr lista-de-numeros))))) ; expresion-del-siguiente-paso

#+end_src

*** Parameters
Emacs's function parameter's features and syntax is very basic. It is simply a list of items. If you want optional parameters, just add ~&optional~. Any parameter after that will be optional.

#+begin_src emacs-lisp

  ;; defining a function with 2 optional params named cc and dd
  (defun myfun (aa bb &optional cc dd)
    ""
    (let ((varOptional (or cc 5))))) ;; if send cc, put it on, if not, do not
  ;; When you call, a and b are required, c and d are optional.
  ;; When a optional parameter is not given, its value is nil.

#+end_src

If you want to give a argument to some optional parameters but not all, use ~nil~ for those you don't care.

#+begin_src emacs-lisp

  ;; calling a function with 3rd parameter omitted
  (myfun "mya" "myb" nil "myd")

#+end_src

If a function received a ~nil~ as argument for one of its optional parameter, there is no way for a function to know if it is specified by user or omitted.

Elisp also support the *unspecified number of parameters*. It is done by adding ~&rest~ similar to ~&optional~. You can have both ~&optional~ and ~&rest~, in that order.

*** interactive
Declare to the interpreter that the function can be used interactively (by typing ~M-x~ and then the name of the function).

This special form may be followed by a string with one or more parts that pass the information to the arguments of the function, in sequence. These parts may also tell the interpreter to prompt for information. Parts of the string are separated by newlines,  ~\n~ (can be use with a [[prefix argument]] like this ~C-u 3 M-x multiply-by-seven~).

The ~(interactive …)~ is used to fill out the parameters, when your function is called by user interactively (as opposed to from a lisp program).

- p :: The *numeric prefix argument*. It will pass converted numerical value of ~current-prefix-arg~ to your function's first argument. Prefix arg converted to number. Does not do I/O.
- P :: *Prefix arg in raw* form. It will pass the value of ~current-prefix-arg~ to your function's first argument. Does not do I/O.
- b :: The *name* of an existing *buffer*.
- f :: The *name* of an existing *file*.
- r :: *Point and the mark*, as two numeric arguments, smallest first. This is the only code letter that specifies two successive arguments rather than one.
- s :: Any *string*.  Does not inherit the current input method.

*Tech detail*: In emacs, “commands” are a subset of “functions”. Commands are functions that can be called interactively (by typing ~M-x~). A function is a command when its definition contains the ~(interactive …)~ clause.

*Note*: to create keybindings, the function need to be a command (i.e. ~interactive~) .

#+begin_src emacs-lisp

  (defun multiply-by-seven (number)       ; Interactive version.
    "Multiply NUMBER by seven."
    (interactive "p") ;; current-prefix-arg
    (message "The result is %d" (* 7 number)))
  ;; "C-u 3 M-x multiply-by-seven" => 21
  ;; 1 if universal-argument isn't called


  (defun f (x)
    "print argument received"
    (interactive "P")
    (message "%s" x)) ;; value of x is from universal argument
  ;; nil if universal-argument isn't called


  (defun multiple-hello (someone num)
    "Say hello to SOMEONE via M-x hello, for NUM times."
    ;;(interactive "code_letter_and_promp_string")
    (interactive "sWho do you want to say hello to? \nnHow many times?")
    ;; "s" prompt user for a string as argument.
    ;; "n" prompt user for a number as argument.
    ;; "\n" part that separates the arguments.
    (dotimes (i num)
      (insert (message "Hello %s!\n" someone))))
  ;; "s" is any string "n" number read using minibuffer
  ;; "M-x multiple-hello Carlos 2"
  ;; => Hello Carlos!
  ;;    Hello Carlos!


  ;;The following is a basic function definition taking region as arg.
  (defun myFunction (myStart myEnd)
    "Prints region start and end positions"
    (interactive "r")
    ;; "r" for commands that takes 2 arguments, the beginning and
    ;; ending positions of the current region..
    (message "Region begin at: %d, end at: %d" myStart myEnd))

#+end_src

One way to use the ~interactive~ function is for it to return a list. This list's element will be fed to the function as arguments.

#+begin_src emacs-lisp

  ;; Interesting quick example of the behavior of the interactive function
  (defun xah/wrap-html-tag (tagName &optional className ξid)
    ;;(interactive (list …))
    (interactive '(1 2 3))
    (message "uno %s dos %s tercer %s" tagName className ξid))
  ;; => 1 dos 2 tercer 3

#+end_src

Sometimes you do not want your function's parameter spec to explicitly contain universal argument, because it is not relevant to the function. So, ~(interactive "P")~ is not appropriate.

Example of a command that we want to create a HTML tag like this:

#+begin_src html

  cat
  ↓
  <div>cat</div>
  or
  <div class="xyz">cat</div>
  or
  <div id="id8295" class="xyz">cat</div>

#+end_src

#+begin_src emacs-lisp

  (defun xah/wrap-html-tag (tagName &optional className ξid)
    "Add a HTML tag to beginning and ending of current word or text selection.

  When preceded with `universal-argument',
  no arg = prompt for tag, class.
  2 = prompt for tag, id.
  any = prompt for tag, id, class.

  When called interactively,
  Default id value is 「id‹random number›」.
  Default class value is 「xyz」.

  When called in lisp program, if className is nil or empty string, don't add the attribute. Same for ξid."
    (interactive
     (cond
      ((equal current-prefix-arg nil)     ; universal-argument not called
       (list
        (read-string "Tag (span):" nil nil "span") ))
      ((equal current-prefix-arg '(4))    ; C-u
       (list
        (read-string "Tag (span):" nil nil "span")
        (read-string "Class (xyz):" nil nil "xyz") ))
      ((equal current-prefix-arg 2)       ; C-u 2
       (list
        (read-string "Tag (span):" nil nil "span")
        (read-string "id:" nil nil (format "id%d" (random (expt 2 28 ))))
        ))
      (t                                  ; all other cases
       (list
        (read-string "Tag (span):" nil nil "span")
        (read-string "Class (xyz):" nil nil "xyz")
        (read-string "id:" nil nil (format "id%d" (random (expt 2 28 )))))))))
  ;; now, all the parameters of your function is filled.
  ;; code body here

#+end_src

*** lambda
Is the symbol for an anonymous function, a function without a name. Every time you use an anonymous function, you need to include its whole body. It let you define a function in the middle of your code.

The read syntax ~#'~ is a short-hand for using ~function~.

#+begin_src emacs-lisp

  (lambda (arg-variables)
    [documentation-string]
    [interactive-declaration]
    body-forms)


  (lambda (x y) (+ x y))
  ;; is a function that takes two arguments, x and y, and returns their sum.

  ;; these are some of the ways of calling the function
  (funcall (lambda (x y) (+ x y)) 5 3) ;; => 8
  ((lambda (x y) (+ x y)) 5 3) ;; => 8


  ;; If we want to multiply 3 by 7, we can write:
  (multiply-by-seven 3)
  \_______________/ ^
  |         |
  function  argument
  ;; Similarly, we can write:
  ((lambda (number) (* 7 number)) 3)
  \____________________________/ ^
  |                |
  anonymous function     argument


  ;; We had a function multiply-by-seven; it multiplied its argument by 7.
  (defun multiply-by-seven (number)
    (* 7 number))
  ;; The anonymous equivalent of multiply-by-seven is:
  (lambda (number) (* 7 number))


  ;; The following forms are all equivalent:
  (lambda (x) (* x x))
  (function (lambda (x) (* x x)))
  #'(lambda (x) (* x x))

  ;; Note:
  ;; function (aka #') is used to quote functions, whereas quote (aka ')
  ;; is used to quote data.


  ;; Example of a lambda function using interactive special form
  ;; Define keys to open frequently used files
  (global-set-key
   (kbd "<f8> <f8>")
   (lambda ()
     (interactive)
     (find-file "~/.emacs.d/my-keybinding.el")))

#+end_src

*** funcall
~funcall function &rest arguments~

Call first argument as a function, passing remaining ARGUMENTS to it, and returns whatever FUNCTION returns.

Since funcall is a function, all of its ARGUMENTS, including FUNCTION, are evaluated before funcall is called. This means that you can use any expression to obtain the function to be called. It also means that funcall does not see the expressions you write for the arguments, only their values. These values are not evaluated a second time in the act of calling function; the operation of funcall is like the normal procedure for calling a function, once its arguments have already been evaluated.

The argument FUNCTION must be either a Lisp function or a primitive function. Special forms and macros are not allowed, because they make sense only when given the unevaluated argument expressions. funcall cannot provide these because, as we saw above, it never knows them in the first place.

#+begin_src emacs-lisp

  (setq f 'list)          ;; list
  (funcall f 'x 'y 'z)    ;; (x y z)
  (funcall f 'x 'y '(z))  ;; (x y (z))

  (funcall 'and t nil)    ;; error → Invalid function: #<subr and>(special form)

  (apply 'max '(1 2 3 4)) ;; 4
  (funcall 'max '(1 2 3 4))
  ;; => error because "funcall" would pass that argument to the function "max"
  ;; which precisely cannot recive the list as an argument while "apply" does,
  ;; "apply" passes each value of the list as an individual argument.

#+end_src

*** apply
~apply~ calls function with arguments, just like [[funcall]] but with one difference: the last of arguments is a list of objects, which are passed to function as separate arguments, rather than a single list. We say that apply spreads this list so that each individual element becomes an argument.

~apply~ with a single argument is special: the first element of the argument, which must be a non-empty list, is called as a function with the remaining elements as individual arguments. Passing two or more arguments will be faster.

~apply~ returns the result of calling function. As with funcall, function must either be a Lisp function or a primitive function; special forms and macros do not make sense in apply.

#+begin_src emacs-lisp

  (setq f 'list)     ;; => list
  (apply f 'x 'y 'z) ;; => error→ Wrong type argument: listp, z


  (apply '+ 1 2 '(3 4)) ;; => 10
  (apply '+ '(1 2 3 4)) ;; => 10


  (apply 'append '((a b c) nil (x y z) nil)) ;; => (a b c x y z)
  ;; append sends each argument as an individual argument in itself.
  (apply '(+ 3 4)) ;; => 7
  (apply '(lambda (x) (+ x 5)) '(6)) ;; => 11


  (apply 'max '(1 2 3 4)) ;; => 4
  (funcall 'max '(1 2 3 4))
  ;; => error because "funcall" would pass that argument to the function "max"
  ;; which precisely cannot recive the list as an argument while "apply" does,
  ;; "apply" passes each value of the list as an individual argument.

#+end_src

*** High-order
Functions that take other functions as arguments.

#+begin_src emacs-lisp

  (defun transform-unless-zero (fn n)
    (if (= n 0) 0
      (funcall fn n)))


  (transform-unless-zero (lambda (n) (+ 1 n)) 7) ;; => 8

#+end_src

*** closure
Emacs can optionally enable lexical binding of variables. When lexical binding is enabled, any named function that you create (e.g., with ~defun~), as well as any anonymous function that you create using the ~lambda~ macro or the function special form or the ~#'~ syntax, is automatically converted into a *closure*.

A closure is a function that also carries a record of the lexical environment that existed when the function was defined. When it is invoked, any lexical variable references within its definition use the retained lexical environment. In all other respects, closures behave much like ordinary functions; in particular, they can be called in the same way as ordinary functions.

Currently, an Emacs Lisp closure object is represented by a list with the symbol closure as the first element, a list representing the lexical environment as the second element, and the argument list and body forms as the remaining elements:

#+begin_src emacs-lisp

  ;; lexical binding is enabled.
  (lambda (x) (* x x))
  ;; => (closure (t) (x) (* x x))

#+end_src

However, the fact that the internal structure of a closure is exposed to the rest of the Lisp world is considered an internal implementation detail. For this reason, we recommend against directly examining or altering the structure of closure objects.

#+begin_src emacs-lisp

  (defvar my-ticker nil)   ; We will use this dynamically bound
                           ; variable to store a closure.


  (let ((x 0))             ; x is lexically bound.
    (setq my-ticker (lambda ()
                      (setq x (1+ x)))))
  ;; (closure ((x . 0) t) ()
  ;;   (setq x (1+ x)))

  (funcall my-ticker) ;; => 1
  (funcall my-ticker) ;; => 2
  (funcall my-ticker) ;; => 3

  x                   ; Note that x has no global value.
  ;; => error→ Symbol's value as variable is void: x

#+end_src

*** defadvice
Advising Emacs Lisp Functions

When you need to modify a function defined in another library, or when you need to modify a hook like foo-function, a process filter, or basically any variable or object field which holds a function value, you can use the appropriate setter function, such as fset or defun for named functions, setq for hook variables, or set-process-filter for process filters, but those are often too blunt, completely throwing away the previous value.

The advice feature lets you add to the existing definition of a function, by advising the function. This is a cleaner method than redefining the whole function.

#+begin_src emacs-lisp

  (defun my-double (x)
    (* x 2))

  (my-double 5) ;; 10


  (defun my-increase (x)
    (+ x 1))
  (advice-add 'my-double :filter-return #'my-increase)

  (my-double 5) ;; 11

#+end_src

** Functions-
*** buffer-
**** current-buffer
Return the buffer in which Emacs is active; it may not be the buffer that is visible on the screen.

**** buffer-name
Without an argument, return the name of the buffer, as a string.

**** buffer-file-name
Without an argument, return the name of the file the buffer is visiting.

**** other-buffer
Return the most recently selected buffer.

**** switch-to-buffer
Select a buffer for Emacs to be active in and display it in the current window so users can look at it.

**** find-file-noselect
Reads the named file into a buffer and returns the buffer.

Útil para cuando se le pasa el nombre de un archivo como argumento a una función y esta retorna el nombre del buffer, con este nombre se puede setear el buffer con la función  [[set-buffer]] y así trabajar temporalmente en ese buffer.

#+begin_src emacs-lisp

  (defun lengths-list-file (filename)
    "Return list of definitions' lengths within FILE.
  The returned list is a list of numbers.
  Each number is the number of words or
  symbols in one function definition."

    (message "Working on `%s' ... " filename)
    (save-excursion
      (let ((buffer (find-file-noselect filename))
            (lengths-list))
        (set-buffer buffer)
        (setq buffer-read-only t)
        (widen)
        (goto-char (point-min))
        (while (re-search-forward "^(defun" nil t)
          (setq lengths-list
                (cons (count-words-in-defun) lengths-list)))
        (kill-buffer buffer)
        lengths-list)))

  (lengths-list-file
   "/usr/share/emacs/27.1/lisp/emacs-lisp/lisp.el.gz")
  ;; => (110 42 118 112 39 50 80 255 239 278 285 37 ...)

#+end_src

**** set-buffer
Switch the attention of Emacs to another buffer, but does not redisplay it on the screen.

Para trabajar temporalmente en otro buffer, cambia la atencion al buffer que
se le indique pero no lo muestra en pantalla, trabaja en segundo plano por así decirlo.

**** get-buffer
Find a named buffer or create one if a buffer of that name does not exist. The get-buffer function returns nil if the named buffer does not exist.

**** get-buffer-create
Return the buffer specified by BUFFER-OR-NAME, creating a new one if needed.

**** save-buffer
Save current buffer in visited file if modified.

#+begin_src emacs-lisp

  ;; Example:
  ;; Given a file of many lines, like this:

  ;; at_target(integer tnum, vector targetpos, vector ourpos)

  ;; For each line, create a file of the same name as first part of
  ;; the line ➢ for example: 〔at_target.txt〕
  ;; The file content should be the whole line, with other static
  ;; text, like this:

  ;; # --
  ;; at_target(integer tnum, vector targetpos, vector ourpos)
  ;; {
  ;; $0
  ;; }


  ;; First, we define few global vars.
  ;; input file
  (setq inputFile "xx_event_forms.txt")

  ;; other vars
  (setq splitPos 0) ;; cursor position of split, for each line
  (setq fName "")
  (setq restLine "")
  (setq moreLines t ) ;; whether there are more lines to parse

  ;; Now, we open the file, like this:
  ;; open the file
  (find-file inputFile)
  (goto-char 1) ;; needed in case the file is already open.

  ;; Now, we loop thru the lines, like this:
  (while moreLines
    (search-forward "(")

    (setq splitPos (1- (point)))
    (beginning-of-line)
    (setq fName (buffer-substring-no-properties (point) splitPos))

    (end-of-line)
    (setq restLine (buffer-substring-no-properties splitPos (point) ))

    ;; create the file
    (find-file fName)
    (insert "# --\n")
    (insert fName restLine "\n{\n$0\n}" )
    (save-buffer)
    (kill-buffer (current-buffer)) ;; close the input file

    (setq moreLines (= 0 (forward-line 1))))

#+end_src

**** with-current-buffer
Temporarily sets a buffer as current to work with. Execute the forms in BODY with BUFFER-OR-NAME temporarily current

Notes: ~find-file~, ~write-file~, or any function that visits a file has many unwanted side-effects, and it can be up to 40 times slower. Here's example of side-effects:

- It keeps undo info.
- It syntax color the buffer.
- It displays the file. (very slow if you have ~global-linum-mode~, etc.)
- It may have tons of hooks added by others. (~desktop-save-mode~, ~recentf-mode~, ~tabbar-mode~, ~snippet-mode~ (~yasnippet~), …)
- It may do backup.

#+begin_src emacs-lisp

  (with-current-buffer "xyz"
    ;; do something here. delete/insert text, etc.
    )

#+end_src

**** with-temp-buffer
Create a temporary buffer, and evaluate BODY there like progn.

Elisp has a buffer data type that's powerful and flexible, and you have over 3 thousand functions that acts on text in a buffer. When you have a string, and you need to do more than just getting substring or number of chars, put it in a temp buffer.

Notes:
- with temp buffer, emacs doesn't do syntax-coloring (which is very slow), disables undo, or any other thing emacs normally do when opening a file for interactive edit.
- I think the difference between ~with-temp-buffer~ and ~with-output-to-temp-buffer~ is that latter works inside the buffer and then outputs the result in that buffer while the other just works inside the buffer but then kills the buffer.

#+begin_src emacs-lisp

  ;; process string in a temp buffer
  (setq myStr "some big string here you need to process")
  (setq myStrNew
        (with-temp-buffer
          (insert myStr)
          ;; code to manipulate your string as buffer text
          ;; …
          (buffer-string))) ; get result


  ;; read-only processing a file without user interaction
  (defun my-process-file (fPath)
    "Process the file at path FPATH …"
    (with-temp-buffer fPath
                      (insert-file-contents fPath)
                      ;; process it …
                      ) )

  ;; write to file ONLY when you actually changed the file
  (defun my-process-file (fPath)
    "Process the file at path FPATH …"
    (let ((fileChanged-p nil))
      (with-temp-buffer
        (insert-file-contents fPath)

        ;; process text
        ;; set fileChanged-p to t or nil

        (when fileChanged-p (write-region 1 (point-max) fPath)))))

#+end_src

**** with-output-to-temp-buffer
Bind standard-output to buffer BUFNAME, eval BODY, then show that buffer.

Note: I think the difference between ~with-temp-buffer~ and ~with-output-to-temp-buffer~ is that latter works inside the buffer and then outputs the result in that buffer while the other just works inside the buffer but then kills the buffer.

#+begin_src emacs-lisp

  ;; Example script

  ;; -*- coding: utf-8 -*-
  ;; 2010-11-03
  ;; add 「title="product title"」 to amazon links on a HTML page.


  ;; Example:
  ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20">amazon</a>
  ;; =>
  ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20" title="Dr. Strangelove; movie">amazon</a>


  ;; rough steps:
  ;; find amazon link of the form
  ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20">amazon</a>

  ;; find a Wikipedia link above it, of this form
  ;; <a href="http://en.wikipedia.org/wiki/Dr._Strangelove">Dr. Strangelove</a>
  ;; extract the movie title

  ;; insert the attribute
  ;; title="…"
  ;; into the amazon link. Like this
  ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20" title="Dr. Strangelove; movie">amazon</a>

  (setq outputBuffer "*xah output*" )
  (with-output-to-temp-buffer outputBuffer

    (find-file "~/web/xahlee_org/Periodic_dosage_dir/skina/nelci_skina.html" )
    (goto-char 1)

    (while
        (search-forward-regexp "<a class=\"amz\" href=\"http://www.amazon.com/dp/[^\"]+?\">amazon</a>"  nil t)

      (progn
        ;; set points for amazon link
        (backward-char 11)
        (setq amzLinkInsertPoint (point) )

        ;; get title from preceding Wikipedia link
        (search-backward-regexp
         "<a href=\"http://...wikipedia.org/wiki/[^\"]+?\">\\([^<]+?\\)</a>")
        (setq titleText (match-string 1 ) )

        (when (yes-or-no-p titleText)
          (goto-char amzLinkInsertPoint)
          (insert (concat " title=\"" titleText "; movie\"")) )
        )

      (progn (print "not found"))
      )

    (princ "Done deal!")
    )

#+end_src

**** buffer-size
Return the number of characters in the current buffer.

**** buffer-string
This function returns the contents *of the entire accessible portion* of the current buffer, as a string.

#+begin_src emacs-lisp

  (defun get-string-from-file (filePath)
    "Return filePath's file content."
    (with-temp-buffer
      (insert-file-contents filePath)
      (buffer-string)))

#+end_src

**** buffer-substring
Return the contents of part of the current buffer as a string.

#+begin_src emacs-lisp

  ;; ---------- Buffer: foo ----------
  ;; This is the contents of buffer foo
  ;;
  ;; ---------- Buffer: foo ----------

  (buffer-substring 1 10)
  ;; => "This is t"

  (buffer-substring (point-max) 10)
  ;; => "he contents of buffer foo\n"

#+end_src

If the text being copied has any text properties, these are copied into the string along with the characters they belong to. However, overlays (see Overlays) in the buffer and their properties are ignored, not copied.

For example, if Font-Lock mode is enabled, you might get results like these:

#+begin_src emacs-lisp

  (buffer-substring 1 10)
  ;; => #("This is t" 0 1 (fontified t) 1 9 (fontified t))

#+end_src

**** buffer-substring-no-properties
Emacs's string can have text properties for the purposes of syntax coloring, button, clickable link, etc. if you are doing text processing, usually you don't need text properties.

The ~buffer-substring-no-properties~ function just return a plain string without these properties.

Note: most function that take string as argument can also accept a string that has properties. The function simply ignore the properties.

#+begin_src emacs-lisp

  ;; get the string from buffer
  (setq myStr (buffer-substring-no-properties startPos endPos))

  (defun xah/html-get-html-file-title (fname)
    "Return FNAME <title> tag's text.
  Assumes that the file contains the string
  “<title>…</title>”."
    (with-temp-buffer
      (insert-file-contents fname nil nil nil t)
      (goto-char 1)
      (buffer-substring-no-properties
       (search-forward "<title>") (- (search-forward "</title>") 8))))

#+end_src

**** insert-buffer-substring
Copy a region of text from a buffer that is passed to the function as an
argument and insert the region into the current buffer.

**** mark-whole-buffer
Mark the whole buffer as a region.

**** buffer-modified-p
Return t if BUFFER was modified since its file was last read or saved.

**** ibuffer
Begin using Ibuffer to edit a list of buffers.

**** bufferp
Return t if its argument is a buffer; otherwise return nil.

*** string-
**** message
Print a message in the echo area. The first argument is a string that can contain ~%s~, ~%d~, or ~%c~ to print the value of arguments that follow the string.

- %s :: must be a string or a symbol
- %d :: must be a number
- %c :: must be an ASCII code number; it will be printed as the character with that ASCII code

If there is more than one ~%s~ in the quoted string, the value of the first argument following the quoted string is printed at the location of the first ~%s~ and the value of the second argument is printed at the location of the second ~%s~ and so on.

#+begin_src emacs-lisp

  (message "The name of this buffer is: %s." (buffer-name))
  ;; => "The name of this buffer is: Emacs.org."


  (message "There are %d %s in the office!"
           (- fill-column 14) "pink elephants")
  ;; => "There are 56 pink elephants in the office!"


  (message "%s has %d line%s, %d word%s, and %d character%s."
           str
           lines (if (= lines 1) "" "s")
           words (if (= words 1) "" "s")
           chars (if (= chars 1) "" "s"))
  ;; => "Region has 5 lines, 26 words, and 167 characters."

#+end_src

**** format
How a lisp object is converted to string for printing is done by the ~format~ function. It takes a input string, and several other arguments of lisp objects, and output a string.

#+begin_src emacs-lisp

  ;; print a date format in yyyy-mm-dd, padding with leading “0”
  ;; format yyyy-mm-dd, ISO 8601 format
  (print (format "%04d-%02d-%02d" 2012 4 10))
  ;; -> "2012-04-10"

  ;; %x means print a number in hex.
  (format "%04x" 1) ;; => "0001"
  (format "%02x" 1) ;; => "01"
  (format "%01x" 1) ;; => "1"
  (format "%x"   1) ;; => "1"
  (format "%1x"  1) ;; => "1"
  (format "%2x"  1) ;; => " 1"
  (format "%4x"  1) ;; => "   1"

  (defun xah/insert-random-uuid ()
    "Insert a random UUID.
  Example of a UUID: 1df63142-a513-c850-31a3-535fc3520c3d

  WARNING: this is a simple implementation. The chance of generating
  the same UUID is much higher than a robust algorithm.."
    (interactive)
    (insert
     (format "%04x%04x-%04x-%04x-%04x-%06x%06x"
             (random (expt 16 4))
             (random (expt 16 4))
             (random (expt 16 4))
             (random (expt 16 4))
             (random (expt 16 4))
             (random (expt 16 6))
             (random (expt 16 6)))))


  (defun wikipedia-url-to-link (url)
    "Return the URL as HTML link string.
  Example:
   http://en.wikipedia.org/wiki/Emacs%20Lisp
  becomes
   <a href=\"http://en.wikipedia.org/wiki/Emacs%20Lisp\">Emacs Lisp</a>
  "
    (let ((linkText url))
      ;; ...
      (format "<a href=\"%s\">%s</a>" url linkText)))


  ;; How to convert between Decimal and Hexadecimal.
  (format "%x" 10)  ; decimal to hex. Returns 「a」
  (format "%d" #xa) ; hex 「a」 to decimal. Returns 「10」.

#+end_src

**** print
Output the printed representation of OBJECT, with newlines around it.

The “OBJECT” is any elisp object you want to print. It can be any lisp datatype, such as string, number, list, buffer, frame, …, etc.

Note: output can be read back by function ~read~.

There're also other similar functions:
~prin1~ like ~print~, but does not add newline at end.
~princ~ print without newline nor delimiters. For human reading.

#+begin_src emacs-lisp

  (print '("x" "y")) ;; => ("x" "y")
  (princ '("x" "y")) ;; => (x y)
  (prin1 '("x" "y")) ;; => ("x" "y")

#+end_src

**** princ
Output the printed representation of OBJECT, any Lisp object.

#+begin_src emacs-lisp

  ;; -*- coding: utf-8 -*-
  ;; 2011-07-15
  ;; go thru a file, check if all brackets are properly matched.
  ;; ➢ for example: good: (…{…}… “…”…)
  ;; bad: ( [)]
  ;; bad: ( ( )

  (setq inputFile "xx_test_file.txt" ) ; a test file.
  (setq inputDir "~/web/xahlee_org/p/time_machine/") ; must end in slash

  (defvar matchPairs '() "a alist. For each pair,
  the car is opening char, cdr is closing char.")
  (setq matchPairs '(
                     ("(" . ")")
                     ("{" . "}")
                     ("[" . "]")
                     ("“" . "”")
                     ("‹" . "›")
                     ("«" . "»")
                     ("【" . "】")
                     ("〖" . "〗")
                     ("〈" . "〉")
                     ("《" . "》")
                     ("「" . "」")
                     ("『" . "』")
                     )
        )

  (defvar searchRegex "" "regex string of all pairs to search.")
  (setq searchRegex "")
  (mapc
   (lambda (mypair) ""
     (setq searchRegex (concat searchRegex (regexp-quote (car mypair)) "|"
                               (regexp-quote (cdr mypair)) "|") )
     )
   matchPairs)

  (setq searchRegex (substring searchRegex 0 -1)) ; remove the ending “|”

  (setq searchRegex (replace-regexp-in-string "|" "\\|" searchRegex t t))
  ; change | to \\| for regex “or” operation

  (defun my-process-file (fPath)
    "Process the file at FPATH …"
    (let (myBuffer myStack ξchar ξpos)

      (setq myStack '() ) ; each entry is a vector [char position]
      (setq ξchar "") ; the current char found

      (when t
  ;; (not (string-match "/xx" fPath)) ; in case you want to skip certain files

        (setq myBuffer (get-buffer-create " myTemp"))
        (set-buffer myBuffer)
        (insert-file-contents fPath nil nil nil t)

        (goto-char 1)
        (while (search-forward-regexp searchRegex nil t)
          (setq ξpos (point)  )
          (setq ξchar (buffer-substring-no-properties ξpos (- ξpos 1))  )

  ;; (princ (format "-----------------------------\nfound char: %s\n" ξchar) )

          (let ((isClosingCharQ nil) (matchedOpeningChar nil) )
            (setq isClosingCharQ (rassoc ξchar matchPairs))
            (when isClosingCharQ (setq matchedOpeningChar
                                       (car isClosingCharQ) ) )

  ;; (princ (format "isClosingCharQ is: %s\n" isClosingCharQ) )
  ;; (princ (format "matchedOpeningChar is: %s\n" matchedOpeningChar) )

            (if
                (and
                 (car myStack) ; not empty
                 (equal (elt (car myStack) 0) matchedOpeningChar )
                 )
                (progn
  ;; (princ (format "matched this top item on stack: %s\n" (car myStack)) )
                  (setq myStack (cdr myStack) )
                  )
              (progn
;; (princ (format "did not match this top item on stack: %s\n" (car myStack)) )
                (setq myStack (cons (vector ξchar ξpos) myStack) ) )
              )
            )
          ;; (princ "current stack: " )
          ;; (princ myStack )
          ;; (terpri )
          )

        (when (not (equal myStack nil))
          (princ "Error file: ")
          (princ fPath)
          (print (car myStack) )
          )
        (kill-buffer myBuffer)
        )
      ))

  (require 'find-lisp)

  (let (outputBuffer)
    (setq outputBuffer "*xah match pair output*" )
    (with-output-to-temp-buffer outputBuffer
      ;; (my-process-file inputFile) ; use this to test one one single file
      (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
                                          ; do all HTML files
      (princ "Done deal!")))

#+end_src

**** insert
Insert the arguments, either strings or characters, at point.

#+begin_src emacs-lisp

  ;; insert string at current cursor position
  (insert "i ♥ cats")

#+end_src

**** insert-char
Insert COUNT copies of CHARACTER.

**** delete-char
Delete the following N characters (previous if N is negative).

**** concat
Links together or unites two or more strings of text to produce a string. The arguments are strings.

#+begin_src emacs-lisp

  (concat "a" "b") ;; => "ab"

#+end_src

**** substring
The function returns a substring of the first argument. This function takes three arguments. Its first argument is the string of characters, the second and third arguments are numbers that indicate the beginning (inclusive) and end (exclusive) of the substring.

You can think of the substring function as a kind of atom smasher since it takes an otherwise indivisible atom (string) and extracts a part.

#+begin_src emacs-lisp

  (substring "The quick brown fox jumped." 16 19) ;; => "fox"

#+end_src

**** split-string
Split STRING into substrings bounded by matches for SEPARATORS.

#+begin_src emacs-lisp

  (defun read-lines (filePath)
    "Return a list of lines of a file at filePath."
    (with-temp-buffer
      (insert-file-contents filePath)
      (split-string (buffer-string) "\n" t)))

  ;; Once you have a list, you can use mapcar to process each element in
  ;; the list. If you don't need the resulting list, use mapc.

  ;; Note: in elisp, it's more efficient to process text in a buffer than
  ;; doing complicated string manipulation with string data type. But, if
  ;; your lines are all short and you don't need to know the text that
  ;; comes before or after current line, then, list of lines can be easier
  ;; to work with.

#+end_src

**** string-fill
Try to word-wrap STRING so that no lines are longer than LENGTH.

**** string-match
Returns the *index* of the start of the first match for the regular expression regexp in string, or ~nil~ if there is no match. If start is non-~nil~, the search starts at that index in string.

#+begin_src emacs-lisp

  (string-match
   "quick" "The quick brown fox jumped quickly.")   ;; => 4

  (string-match
   "quick" "The quick brown fox jumped quickly." 8) ;; => 27

  (defun xah/drop-last-slashed-substring (path)
    "Drop the last path separated by “/”.
  For example:
  “/a/b/c/d” → “/a/b/c”
  “/a/b/c/d/” → “/a/b/c/d”
  “/” → “”
  “//” → “/”
  “” → “”"
    (if (string-match "\\(.*/\\)+" path)
        (substring path 0 (1- (match-end 0)))
      path))

#+end_src

**** search-forward
Search for a *string*, and if the string is found, *move point*. With a regular expression, use the similar [[re-search-forward]].

~search-forward~ and ~re-search-forward~ take four arguments:

1. The string or regular expression to search for.
2. Optionally, the limit of the search.
3. Optionally, what to do if the search fails, return nil or an error message.
4. Optionally, how many times to repeat the search; if negative, the search goes backwards.

Note: Due the way computers are built, the Lisp interpreter may treat a single character as being different from a string of characters. Inside the computer, a single character has a different electronic format than a string of one character. (A single character can often be recorded in the computer using exactly one byte; but a string may be longer, and the computer needs to be ready for this.)

In emacs buffer, newline char is ~\n~. So, you can use ~(search-forward "\n")~ if you really need to find the end of line character.

#+begin_src emacs-lisp

  (search-forward "target-string"
                  limit-of-search
                  what-to-do-if-search-fails
                  repeat-count)


  ;; idiom for string replacement in current buffer;
  (let ((case-fold-search t)) ; or nil

    (goto-char (point-min))
    (while (search-forward "myStr1" nil t) (replace-match "myReplaceStr1"))

    (goto-char (point-min))
    (while (search-forward "myStr2" nil t) (replace-match "myReplaceStr2"))
    ;; repeat for other string pairs
    )
  ;; if you need regexp, use search-forward-regexp


  ;; You want to do more than one pair of find/replace strings
  ;;    & → &amp;
  ;;    < → &lt;
  ;;    > → &gt;
  (defun replace-html-chars-region (begin end)
    "Replace “<” to “&lt;” etc in region."
    (interactive "r")
    (save-restriction
      (narrow-to-region begin end)

      (goto-char (point-min))
      (while (search-forward "&" nil t) (replace-match "&amp;" nil t))

      (goto-char (point-min))
      (while (search-forward "<" nil t) (replace-match "&lt;" nil t))

      (goto-char (point-min))
      (while (search-forward ">" nil t) (replace-match "&gt;" nil t))))

#+end_src

**** search-backward
Search backward from point for STRING. Move cursor to the location of a string, returns the new position.

**** current-word
This function returns the symbol (or word) at or near point, as a string. The return value includes no text properties.

**** symbol-name
Return SYMBOL's name, a string.

**** thing-at-point
Return the thing around or next to point, as a string.

The argument thing is a symbol which specifies a kind of syntactic entity (symbol, list, sexp, defun, filename, url, word, sentence, whitespace, line, page, and others).

~thing-at-point~ does have some annoyances. For example, when getting a line, it'll normally include the newline char "\n", but not if the line is at the end of buffer.

Note: emacs's concept of “symbol” is like a “identifier”. It usually includes a to z, 0 to 9, underscore “_”, and sometimes hyphen “-”. The exact charset of “symbol” depends on current major mode's Syntax Table.

#+begin_src emacs-lisp

  ;; ---------- Buffer: foo ----------
  ;; Gentlemen may cry ``Pea∗ce! Peace!,''
  ;; but there is no peace.
  ;; ---------- Buffer: foo ----------

  (thing-at-point 'word)
  ;; => "Peace"
  (thing-at-point 'line)
  ;; => "Gentlemen may cry ``Peace! Peace!,''\n"
  (thing-at-point 'whitespace)
  ;; => nil

  (defun xah/print-current-word-and-line ()
    "print current word and line."
    (interactive)
    (message "%s and %s" (thing-at-point 'word))
    (thing-at-point 'line))

  ;; Without thing-at-point
  (defun xah/print-current-word-2 ()
    "print current word."
    (interactive)
    (let (p1 p2)
      (save-excursion
        (skip-chars-backward "-a-z0-9")
        (setq p1 (point))
        (skip-chars-forward "-a-z0-9")
        (setq p2 (point))
        (message "%s" (buffer-substring-no-properties p1 p2)))))

  ;; grab the current “symbol”.
  (setq myStr (thing-at-point 'symbol))

  ;; If you are writing PHP reference lookup command, and the cursor is on
  ;; p in print_r($y);, you want to grab the whole “print_r” not just
  ;; “print”.

  ;; Here's a example of PHP reference lookup command that grabs by
  ;; “symbol” if there's no active region.
  (defun xah/php-lookup ()
    "Look up current word in PHP ref site in a browser.

  If a region is active (a phrase), lookup that phrase."
    (interactive)
    (let (myWord myUrl)
      (setq myWord
            (if (use-region-p)
                (buffer-substring-no-properties (region-beginning)
                                                (region-end))
              (thing-at-point 'symbol)))
      (setq myUrl
            (concat "http://us.php.net/" myWord))
      (browse-url myUrl)))

#+end_src

**** make-string
Return a newly created string of length LENGTH, with INIT in each element.

#+begin_src emacs-lisp

  (make-string 3 65) ;; => "AAA"

  (make-string 3 ? ) ;; => "   "

#+end_src

**** char-equal
Return t if two characters match, optionally ignoring case.

**** char-before
Return character in current buffer preceding position POS.

Similar functions is ~char-after~.

**** fill-paragraph
Fill paragraph at or after point.

#+begin_src emacs-lisp

  ;; This example shows how to temporarily change a pre-defined variable's
  ;; value, then call a function whose behavior depends on the var.
  (defun remove-line-breaks ()
    "Remove line endings in current paragraph."
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))

#+end_src

**** gnus-url-unhex-string
Remove %XX, embedded spaces, etc in a url.

#+begin_src emacs-lisp

  (require 'gnus-util) ; for gnus-url-unhex-string

  (defun xah/wikipedia-url-to-link (url)
    "Return the URL as HTML link string.
  Example:
   http://en.wikipedia.org/wiki/Emacs%20Lisp
  becomes
   <a href=\"http://en.wikipedia.org/wiki/Emacs%20Lisp\">Emacs Lisp</a>
  "
    (let ((linkText url))
                          ; decode percent encoding. ➢ for example: %20
      (setq linkText (gnus-url-unhex-string linkText nil))
                                          ; get last part
      (setq linkText (car (last (split-string linkText "/"))))
                                          ; low line → space
      (setq linkText (replace-regexp-in-string "_" " " linkText ))
      (format "<a href=\"%s\">%s</a>" url linkText)))

#+end_src

*** regexp-
**** looking-at
Return t for true if the text directly following *point* matches the argument, which should be a regular expression.

This function does not move point, but it updates the match data, which you can access using [[match-beginning]] and [[match-end]].

#+begin_src emacs-lisp

  (looking-at "The cat in the hat$") ;; => t
  ;; The cat in the hat comes back" twice.

#+end_src

**** re-search-forward
Search for a *pattern* (regular expression), and if the pattern is found, *move point* to rest just after it. With a string, use the similar [[search-forward]].

~search-forward~ and ~re-search-forward~ take four arguments:

1. A regular expression that specifies the pattern to search for. (Remember to put quotation marks around this argument!)
2. Optionally, the limit of the search.
3. Optionally, what to do if the search fails, return nil or an error message.
4. Optionally, how many times to repeat the search; if negative, the search goes backwards.

#+begin_src emacs-lisp

  (re-search-forward "\*+ *" nil t)
  ;; This function moves ahead of the match string
  ;; (1 or more * and 0 or more blanks) and returns the
  ;; point number or nil in case of no match, instead of error.


  ;; This lets you select current block of text. (a block here is text
  ;; between empty lines.)
  (defun xah/select-current-block ()
    "Select the current block of text between blank lines.
  URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
  Version 2016-07-22"
    (interactive)
    (let (-p1)
      (progn
        (if (re-search-backward "\n[ \t]*\n" nil "move")
            (progn (re-search-forward "\n[ \t]*\n")
                   (setq -p1 (point)))
          (setq -p1 (point)))
        (re-search-forward "\n[ \t]*\n" nil "move"))
      (set-mark -p1)))


  (defun xah/select-block ()
    "Select the current/next block of text between blank lines.
  If region is active, extend selection downward by block.
  URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
  Version 2016-07-22"
    (interactive)
    (if (region-active-p)
        (re-search-forward "\n[ \t]*\n" nil "move")
      (xah-select-current-block)))


  ;; Sometimes when you you write text, you duplicate words—as with “you
  ;; you” near the beginning of this sentence. I call the function for
  ;; detecting duplicated words, the-the.
  (defun the-the ()
    "Search forward for for a duplicated word."
    (interactive)
    (message "Searching for for duplicated words ...")
    (push-mark)

    ;; This regexp is not perfect
    ;; but is fairly good over all:
    (if (re-search-forward
         "\\b\\([^@ \n\t]+\\)[ \n\t]+\\1\\b" nil 'move)
        (message "Found duplicated word.")
      (message "End of buffer")))

#+end_src

**** search-forward-regexp
Is a function alias and interactive for [[re-search-forward]].

*Xah*
Put your cursor to the right of the closing parenthesis, then call ~eval-last-sexp~. If your regex matches, it'll move cursor to the last char of the matched text. If you get a lisp error saying search failed, then your regex didn't match. If you get a lisp syntax error, then you probably screwed up on the backslashs.

One interesting aspect about ~search-forward-regexp~ is that you must use 2 backslashes to represent one backslash. This is because backslash in emacs string needs a backslash to represent it. Then, this string is passed to emacs's regex engine.

#+begin_src emacs-lisp

  (defun xah/clean-Mathematica-graphics-buffer ()
    "Remove whitespace, truncate numbers, of current buffer of Mathematica graphics file.
  This command does several find/replace on the current buffer.
  Removing spaces, removing new lines, truncate numbers to 3 decimals,
  e.g., 0.123456 -> 0.123.
  \
  \\
  The goal of these replacement is to reduce the file size of a Mathematica Graphics file (.mgs) that are read over the net by JavaView."
    (interactive)

    (goto-char 1)
    (while (search-forward "\n" nil t) (replace-match "" nil t))

    (goto-char 1)
    (while (search-forward-regexp "  +" nil t) (replace-match " " nil t))

    (goto-char 1)
    (while (search-forward ", " nil t) (replace-match "," nil t))

    (goto-char 1)
    (while (search-forward-regexp "\\([0-9]\\)\\.\\([0-9][0-9][0-9]\\)[0-9]+" nil t) (replace-match "\\1.\\2" t nil)))

#+end_src

**** match-beginning
Return the *position* of the start of the text found by the *last* regular expression search.

#+begin_src emacs-lisp

  (let ((case-fold-search nil) p1 p2)
    (re-search-forward "\\([0-9]+\\)")
    (setq p1 (match-beginning 1))
    (setq p2 (match-end 1))
    (buffer-substring-no-properties p1 p2))
  ;; lots sample text 123 abc
  ;; => "123"

#+end_src

**** match-end
Return *position* of end of text matched by *last* search.

#+begin_src emacs-lisp

  (string-match "\\(qu\\)\\(ick\\)"
                "The quick fox jumped quickly.") ;; => 4

  (match-end 1)             ; The end of the match
  ;;   => 6                 ;   with `qu' is at index 6.

  (match-end 2)             ; The end of the match
  ;;   => 9                 ;   with `ick' is at index 9.

#+end_src

**** match-data
Return a list describing what the last search matched.

**** perform-replace
This function is the guts of ~query-replace~ and related commands. It searches for occurrences of from-string and *replaces* some or all of them. If query-flag is ~nil~, it replaces all occurrences; otherwise, it asks the user what to do about each one.

**** replace-match
This function *replaces* the buffer text matched by the last search, with replacement. It applies only to buffers; you can't use ~replace-match~ to replace a substring found with [[string-match]].

To control letter case of the replacement, use the optional arguments in your ~replace-match~ function. To control the letter case of search, locally set ~case-fold-search~ to ~t~ or ~nil~.

#+begin_src emacs-lisp

  (defun replace-greek-region (start end)
    "Replace “alpha” to “α” and other greek letters in current region."
    (interactive "r")
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (while (search-forward " alpha" nil t) (replace-match " α" nil t))
      (goto-char (point-min))
      (while (search-forward " beta" nil t) (replace-match " β" nil t))
      (goto-char (point-min))
      (while (search-forward " gamma" nil t) (replace-match " γ" nil t))))

  ;; remove js links in html file
  (while (search-forward "<script src=\"http://...</script>" nil t)
    (replace-match ""))

#+end_src

**** replace-regexp-in-string
Replace all matches for REGEXP with REP in STRING.

#+begin_src emacs-lisp

  ;; replace that
  ;; <img src="my_cat.png" alt="" width="832" height="513">
  ;; with that
  ;; <img src="my_cat.png" alt="my cat" width="832" height="513">

  ;; give regex search pattern
  ;; (let regexp "<img src=\"\\([^\"]+?\\)\" alt=\"\" width=\"\\([0-9]+\\)\" height=\"\\([0-9]+\\)\">")

  (search-forward-regexp regexp nil t)

  (concat
   "<img src=\""(match-string 1)"\"

   alt=\""(replace-regexp-in-string ".png" ""
      (replace-regexp-in-string "_" " " (match-string 1)))"\"

   width=\""(match-string 2)"\"

   height=\""(match-string 3)"\">"
   )

  ;; To replace this but in all files of a directory do this

  ;; List and Mark Files in Subdirectories

  ;; Call find-dired, then give the dir name, then give -name "*html". The
  ;; result is all HTML files in that dir and subdir. (open files)

  ;; Now, mark the files you want, by calling dired-mark-files-regexp 【%
  ;; m】. Then give the pattern \.html. This marks all HTML files.  Dired
  ;; Query Replace by Regexp (mark files)

  ;; To do regexp replace on dired marked files, call
  ;; dired-do-query-replace-regexp.

#+end_src

**** regexp-quote
This function returns a *regular expression string* that matches exactly string and nothing else. This allows you to request an exact string match when calling a function that wants a regular expression.

#+begin_src emacs-lisp

  (regexp-quote "^The cat$")
  ;; => "\\^The cat\\$"

#+end_src

One use of ~regexp-quote~ is to combine an exact string match with context described as a regular expression. For example, this searches for the string which is the value of string, surrounded by whitespace:

#+begin_src emacs-lisp

  (re-search-forward
   (concat "\\s " (regexp-quote string) "\\s "))

#+end_src

**** skip-chars-forward
Move point forward, stopping before a char not in STRING, or at pos LIM. Returns the distance traveled.

*NOTE:* STRING is like the inside of a [...] in a regular expression except that ] is never special and \ quotes ^, - or \ (but not at the end of a range; quoting is never needed there).
Thus, *with arg "a-zA-Z", this skips letters stopping before first nonletter. With arg "^a-zA-Z", skips nonletters stopping before first letter*.

#+begin_src emacs-lisp

  ;; Placing point (24) just after the expession
  (skip-chars-forward "h")hhhh hhhh
  ;; => 4 (jump first 4 h)
  (skip-chars-forward "h") hhhh hhhh
  ;; => 0 (no match)
  (skip-chars-forward "^h")hhhh hhhh
  ;; => 0 (no match)
  (skip-chars-forward "^h") hhhh hhhh
  ;; => 1 (jump first 1 space)


  (defun xah/select-inside-quotes ()
    "Select text between double straight quotes
  on each side of cursor."
    (interactive)
    (let (p1 p2)
      ;; p1 is set to the position of the double quote to the left of cursor
      (skip-chars-backward "^\"")
      (setq p1 (point))
      (skip-chars-forward "^\"")
      (setq p2 (point))

      (goto-char p1)
      (push-mark p2)
      (setq mark-active t)))


  (defun xah/delete-enclosed-text ()
    "Delete texts between any pair of delimiters."
    (interactive)
    (save-excursion
      (let (p1 p2)
        (skip-chars-backward "^([<>“") (setq p1 (point))
        (skip-chars-forward "^)]<>”") (setq p2 (point))
        (delete-region p1 p2))))

#+end_src

**** skip-chars-backward
Move point backward, stopping after a char not in STRING, or at pos LIM.

#+begin_src emacs-lisp

  ;; turn on highlight selection
  (transient-mark-mode 1)

  (defun xah/select-current-word ()
    "Select the word under cursor.
  “word” here is considered any alphanumeric sequence with “_” or “-”."
    (interactive)
    (let (pt)
      (skip-chars-backward "-_A-Za-z0-9")
      (setq pt (point))
      (skip-chars-forward "-_A-Za-z0-9")
      (set-mark pt)))

#+end_src

**** string-match
~(string-match REGEXP STRING &optional START)~

Return index of start of first match for REGEXP in STRING, or nil.

#+begin_src emacs-lisp

  (string-match "i" (system-name)) ;; => 3

  (system-name) ;; => "debian"

#+end_src

**** match-string
Return string of text matched by last search.

Whenever you call regex functions such as [[re-search-forward]], [[string-match]], [[replace-regexp-in-string]], [[search-forward-regexp]], the captured text is stored in ~match-string~.

NUM an is integer.

- 0 means the whole matched text.
- 1 means first captured group.
- 2 means second captured group.
  etc.

#+begin_src emacs-lisp

  (setq xx "swimming in sea")

  (string-match "\\([a-z]+?ing\\) " xx)

  (match-string 1 xx)
  ;; => "swimming"

#+end_src

#+begin_src html

  <!-- Suppose you have thousands of links like this: -->

  <a href="…/this_and_that">this_and_that</a>

  <!-- you want to change the link text so that _ is replaced by space,
       like this: -->

  <a href="…/this_and_that">this and that</a>

  <!-- First, you need to use regex find / replace to match the
       links. Then, you need a function to to transform the matched
       pattern. -->

#+end_src

*Call Function in Replacement String*

You can use a function as your replacement string.

In the replace string prompt, give ~\,(function_name)~, where ~function_name~ is your elisp function.

The function needs no argument. Its return value is used as the replacement string.

The task here is to write the replacement function.

#+begin_src emacs-lisp

  ;; So, with this function written, we can call query-replace-regexp, then give this pattern:

  ;; >\([_A-Za-z0-9]+\)</a>

  ;; And the replacement expression would be:

  ;; \,(ff)

  ;; Here's a example where i need to find all Wikipedia links and change the link text to use space instead of _.

  (defun xah/wikipedia-link-replacement ()
    "Returns a canonical form of Wikipedia link from a regex match.

  The regex to be used for this function is:

   <a href=\"http://\\(..\\)\\.wikipedia.org/wiki/\\([^\"]+\\)\">\\(\\([-.A-Za-z0-9]+_\\)+[-.A-Za-z0-9]+ ?\\)</a>

  To use this function, call `query-replace-regexp', then in the replacement prompt give:
   \\,(wikipedia-link-replacement)
  "
    (let (langCode articlePath linkText linkText2 returnText)
      (setq langCode (match-string 1)) ;; \\(..\\)
      (setq articlePath (match-string 2)) ;; \\([^\"]+\\)
      (setq linkText (match-string 3))
      (setq linkText2 (replace-regexp-in-string "_" " " articlePath))
      (setq returnText
            (concat "<a href=\"http://"
                    langCode ".wikipedia.org/wiki/"
                    articlePath "\">" linkText2 "</a>" ))
      returnText ) )

  ;; The (match-string 1) gives you the first captured string. (“1” is for
  ;; 1st captured pattern, “2” for 2nd captured pattern. “0” is the entire
  ;; match.).

#+end_src

**** match-string-no-properties
Same as [[match-string]] but without Text Properties.

#+begin_src emacs-lisp

  (let ((case-fold-search nil))
    (re-search-forward "\\([0-9]+\\)")
    ;; lots text 123 abc
    (match-string-no-properties 1))
                                          ; "123"

#+end_src

**** highlight-lines-matching-regexp
Highlight all lines that match REGEXP using FACE.

#+begin_src emacs-lisp

  ;; This example shows you how to make lines containing the words “ERROR:”
  ;; or “NOTE:” highlighted, whenever a file ending in “log” is opened.

  (defun highlite-it ()
    "Highlight certain lines…"
    (interactive)
    (if (equal "log" (file-name-extension (buffer-file-name)))
        (progn
          (highlight-lines-matching-regexp "ERROR:" 'hi-red-b)
          (highlight-lines-matching-regexp "NOTE:" 'hi-blue-b))))

  (add-hook 'find-file-hook 'highlite-it)

  ;; The add-hook line will make emacs call “highlite-it” whenever a file
  ;; is opened. It works by adding the function “highlite-it” to the list
  ;; in the variable find-file-hook.

  ;; find-file is the function that open files. find-file-hook is a
  ;; variable containing list of functions that will run when find-file is
  ;; run.

#+end_src

*** point-
**** point
Return the value of the current position of the cursor, as an integer counting the number of characters from the beginning of the buffer.

**** point-min
Return the minimum permissible value of point in the current buffer. This is 1, unless narrowing is in effect.

**** point-max
Return the value of the maximum permissible value of point in the current buffer. This is the end of the buffer, unless narrowing is in effect.

**** goto-char
Set point to the location specified by the value of the argument.

**** line-beginning-position
Return the character position of the first character on the current line.

**** line-end-position
Return the character position of the last character on the current line.

**** forward-char
Move point N characters forward (backward if N is negative).

**** backward-char
Move point N characters backward (forward if N is negative).

**** bounds-of-thing-at-point
Determine the start and end buffer locations for the THING at point.

Often you want a command that works on the current word (or line, paragraph), but if there is a text selection, take the text selection as input. Here's a template for this and other examples.

Sometimes, you need to not just grab current word, but do other things such as delete the word. You need to know the beginning and ending positions of the region you are interested. Use ~bounds-of-thing-at-point~.


#+begin_src emacs-lisp

  (defun xah/downcase-word-or-region ()
    "Downcase current word or region."
    (interactive)
    (let (pos1 pos2 bds)
      (if (use-region-p)
          (setq pos1 (region-beginning) pos2 (region-end))
        (progn
          (setq bds (bounds-of-thing-at-point 'symbol))
          (setq pos1 (car bds) pos2 (cdr bds))))

      ;; now, pos1 and pos2 are the starting and ending positions of the
      ;; current word, or current text selection if exist.
      (downcase-region pos1 pos2)))


  (defun xah/get-boundary-and-thing ()
    "Returns the boundary positions of the text unit under cursor."
    (interactive)
    (let (bounds pos1 pos2 mything)
      (setq bounds (bounds-of-thing-at-point 'symbol))
      (setq pos1 (car bounds))
      (setq pos2 (cdr bounds))
      (setq mything (buffer-substring-no-properties pos1 pos2))

      (message
       "thing begin at [%s], end at [%s], thing is [%s]"
       pos1 pos2 mything)))


  (defun ake/html-table-string (textblock delim)
    "Turn a text string into a HTML table.
  See make-html-table."
    (let ()
      (setq textblock (replace-regexp-in-string delim "</td><td>" textblock))
      (setq textblock (replace-regexp-in-string "\n" "</td></tr>\n<tr><td>" textblock))
      (setq textblock (substring textblock 0 -8)) ;; delet the beginning “<tr><td>” in last line
      (concat "<table border=\"1\" cellpadding=\"5\" cellspacing=\"0\">\n<tr><td>" textblock "</table>")
      ))

  (defun make-html-table (sep)
    "Turn the current paragraph into a HTML table.

  The “current paragraph” is defined as having empty lines before and
  after the block of text the cursor is on.

  For example:

  a*b*c
  1*2*3
  this*and*that

  with “*” as separator, becomes

  <table border=\"1\" cellpadding=\"5\" cellspacing=\"0\">
  <tr><td>a</td><td>b</td><td>c</td></tr>
  <tr><td>1</td><td>2</td><td>3</td></tr>
  <tr><td>this</td><td>and</td><td>that</td></tr>
  </table>"
    (interactive "sEnter string pattern for column separation:")
    (let (bds p1 p2 myStr)
      (setq bds (bounds-of-thing-at-point 'paragraph))
      (setq p1 (+ (car bds) 1))
      (setq p2 (cdr bds))
      (setq myStr (buffer-substring-no-properties p1 p2))
      (delete-region p1 p2)
      (insert (make-html-table-string myStr sep) "\n")))

#+end_src

**** eobp
Return t for true if point is at the end of the accessible part of a buffer. The end of the accessible part is the end of the buffer if the buffer is not narrowed; it is the end of the narrowed part if the buffer is narrowed.

*** mark-
**** push-mark
Sets a mark at the current position of the cursor.

**** set-mark-command
Set the mark where point is, and activate it; or jump to the mark.

When ~set-mark-command~ is called, the region becomes active (highlighted). When a command is called, it typically set the region status to inactive.

This means, when you set mark using the keyboard or the mouse, text selection become highlighted, then after you called some command, the region returns to inactive again (and the highlighting goes away).

**** transient-mark-mode
Toogle transient mark mode. When enabled, the *region is highlighted* with the region face whenever the mark is active.

~transient-mark-mode~ is on by default, and many command's behavior changed. If there is a text selection, the command acts on it, else it acts on the current word, line, paragraph, buffer (or whatever is its default input).

**** mark-active
Variable. Non-nil means the mark and region are currently active in this buffer.

#+begin_src emacs-lisp

  (defun xar/select-line ()
    "Select current line."
    (interactive)
    (let (p1 p2)
      (setq p1 (line-beginning-position))
      (setq p2 (line-end-position))
      (goto-char p1)
      (push-mark p2)
      (setq mark-active t)))

#+end_src

*** region-
**** region-beginning
Return the integer value of point or mark, whichever is smaller.

#+begin_src emacs-lisp

  ;; example of a command that works on current word or text selection
  (defun down-case-word-or-region ()
    "Lower case the current word or text selection."
    (interactive)
    (let (pos1 pos2 meat)
      (if (and transient-mark-mode mark-active)
          (setq pos1 (region-beginning)
                pos2 (region-end))
        (setq pos1 (car (bounds-of-thing-at-point 'symbol))
              pos2 (cdr (bounds-of-thing-at-point 'symbol))))

      ;; now, pos1 and pos2 are the starting and ending positions
      ;; of the current word, or current text selection if exists

      ;; put your code here.
      $0
      ;; Some example of things you might want to do
      (downcase-region pos1 pos2) ; example of a func that takes region as args
      (setq meat (buffer-substring-no-properties pos1 pos2)) ; grab the text.
      (delete-region pos1 pos2) ; get rid of it
      (insert "newText") ; insert your new text

      )
    )

#+end_src

**** region-end
Return the integer value of point or mark, whichever is larger.

**** delete-region
Delete the text between START and END.

**** use-region-p
Return t if the region is active and it is appropriate to act on it.

The function ~use-region-p~ basically checks 3 things:
- ~transient-mark-mode~ is on.
- ~mark-active~ is true.
- region isn't empty by checking ~use-empty-active-region~.


#+begin_src emacs-lisp

  ;; Often you want a command that works on the current word (or line,
  ;; paragraph), but if there is a text selection, take the text selection
  ;; as input.
  (defun xah/downcase-word-or-region ()
    "Downcase current word or region."
    (interactive)
    (let (pos1 pos2 bds)
      (if (use-region-p)
          (setq pos1 (region-beginning) pos2 (region-end))
        (progn
          (setq bds (bounds-of-thing-at-point 'symbol))
          (setq pos1 (car bds) pos2 (cdr bds))))

      ;; now, pos1 and pos2 are the starting and ending positions of the
      ;; current word, or current text selection if exist.
      (downcase-region pos1 pos2)))

#+end_src

**** kill-region
Cuts the text between point and mark from the buffer and stores that text in the kill ring, so you can get it back by yanking.

#+begin_src emacs-lisp

  ;; cut text between buffer positions and push it to kill-ring.
  (kill-region 247 528)

#+end_src

**** kill-ring-save
Save the region as if killed, but don't kill it.

#+begin_src emacs-lisp

  ;; copy text between buffer positions and push it to kill-ring.
  (kill-ring-save 247 528)

#+end_src

**** kill-new
Make STRING the latest kill in the kill ring.

[[kill-ring-save]] copy text between buffer positions and push it to ~kill-ring~ if you already have a string, use ~kill-new~

#+begin_src emacs-lisp

  ;; push a string into kill-ring
  (kill-new "dragon dragon")

  (defun xah/copy-all ()
    "Put the whole buffer content into the `kill-ring'.
  (respects `narrow-to-region')
  URL `http://ergoemacs.org/emacs/elisp_cut_copy_yank_kill-ring.html'
  Version 2015-05-06"
    (interactive)
    (kill-new (buffer-string))
    (message "Buffer content copied."))

#+end_src

**** kill-append
Append STRING to the end of the latest kill in the kill ring.

**** narrow-to-region
Restrict editing in this buffer to the current region.

Whenever you work in a region, remember that the boundaries of the text that you are interested is changed when you add or remove text in that region. Don't just call ~(something-region p1 p2)~ again, because ~p2~ is no longer the correct boundary. Use ~save-restriction~ and ~narrow-to-region~.

#+begin_src emacs-lisp

  ;; idiom for string replacement within a region
  (save-restriction
    (narrow-to-region pos1 pos2)

    (goto-char (point-min))
    (while (search-forward "myStr1" nil t) (replace-match "myReplaceStr1"))

    ;; repeat for other string pairs
    )

#+end_src

**** copy-region-as-kill
Copies the text between point and mark into the kill ring, from which you can get it by yanking. The function does not cut or remove the text from the buffer.

**** delete-and-extract-region
Removes the text between point and mark from the buffer and throws it away. You cannot get it back. (This is not an interactive command.)

**** widen
Remove restrictions (narrowing) from current buffer.

This function is usually not needed—Emacs creates a fresh buffer if none already exists; but if a buffer visiting the file already exists Emacs returns that one. In this case, the buffer may be narrowed and must be widened.

**** my-select-line*
Create a text selection (Xah function).

#+begin_src emacs-lisp

  (defun my-select-line ()
    "Select current line."
    (interactive)
    (let (p1 p2)
      (setq p1 (line-beginning-position))
      (setq p2 (line-end-position))
      (push-mark p1)
      (goto-char p2)
      (setq mark-active t)))

#+end_src

**** downcase-word-or-region*
Downcase current word or region (Xah function).

Often you want a command that automatically act on a text unit such as current word, when there is no text selection, and use text selection if there is one.

#+begin_src emacs-lisp

  (defun downcase-word-or-region ()
    "Downcase current word or region."
  (interactive)
  (let (pos1 pos2 bds)
    (if (use-region-p)
       (setq pos1 (region-beginning) pos2 (region-end))
      (progn
        (setq bds (bounds-of-thing-at-point 'symbol))
        (setq pos1 (car bds) pos2 (cdr bds))))

    ;; now, pos1 and pos2 are the starting and ending positions of the
    ;; current word, or current text selection if exist.
    (downcase-region pos1 pos2)
    ))

#+end_src

*** file-
**** write-region
Write current region into specified file.

Modify Files: If you want to write to file ONLY when you actually changed the file, you can create flag variable and call write-region, like this:

#+begin_src emacs-lisp

  (defun my-process-file (fPath)
    "Process the file at path FPATH …"
    (let ((fileChanged-p nil))
      (with-temp-buffer
        (insert-file-contents fPath)

        ;; process text
        ;; set fileChanged-p to t or nil

        (when fileChanged-p (write-region 1 (point-max) fPath)))))

#+end_src

**** with-temp-file
Create a new buffer, evaluate BODY there, and write the buffer to FILE.

when doing batch text processing of thousands of files, don't use ~find-file~, use ~with-temp-buffer~ or ~with-temp-file~ instead. (use the latter when you need to make changes to the file.

**** insert-file-contents
Insert contents of file FILENAME after point.

#+begin_src emacs-lisp

  (defun get-string-from-file (filePath)
    "Return filePath's file content."
    (with-temp-buffer
      (insert-file-contents filePath)
      (buffer-string)))

#+end_src

**** append-to-file
Append the contents of the region to the end of file FILENAME.

**** file-name-directory
Return the directory component in file name FILENAME.

**** file-name-nondirectory
Return file name FILENAME sans its directory.

**** file-name-extension
Get suffix.

**** file-name-sans-extension
Return FILENAME sans final "extension".

**** file-relative-name
Get relative path.

**** expand-file-name
Convert filename NAME to absolute, and canonicalize it. The function employs the name of the directory in which the function is called.

#+begin_src emacs-lisp

  ;; if expand-file-name is called when Emacs is visiting
  ;; the /usr/local/share/emacs/22.1.1/lisp/emacs-lisp/

  (expand-file-name "debug.el")
  ;; => /usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el

#+end_src

**** dired-get-marked-files
Return the marked files' names as list of strings.

#+begin_src emacs-lisp

  ;; To apply a function to marked files in dired

  ;; idiom for processing a list of files in dired's marked files

  ;; suppose myProcessFile is your function that takes a file path
  ;; and do some processing on the file

  (defun dired-myProcessFile ()
    "apply myProcessFile function to marked files in dired."
    (interactive)
    (require 'dired)
    (mapc 'myProcessFile (dired-get-marked-files)))

#+end_src

**** rename-file
Rename FILE as NEWNAME.  Both args must be strings.

**** copy-file
Copy FILE to NEWNAME.  Both args must be strings.

#+begin_src emacs-lisp

  (defun xah/make-backup ()
    "Make a backup copy of current buffer's file.
  Create a backup of current buffer's file.
  The new file name is the old file name with trailing “~”, in the same dir.
  If such a file already exist, append more “~”.
  If the current buffer is not associated with a file, its a error."
    (interactive)
    (let (fName backupName)
      (setq fName (buffer-file-name))
      (setq backupName (concat fName "~"))

      (while (file-exists-p backupName)
        (setq backupName (concat backupName "~")))

      (copy-file fName backupName t)
      (message (concat "Backup saved as: " (file-name-nondirectory backupName)))))

#+end_src

**** delete-file
Delete file named FILENAME.  If it is a symlink, remove the symlink.

#+begin_src emacs-lisp

  (defun xah/delete-current-file ()
    "Delete the file associated with the current buffer.
  Delete the current buffer too.
  If no file is associated, just close buffer without prompt for save."
    (interactive)
    (let (currentFile)
      (setq currentFile (buffer-file-name))
      (when (yes-or-no-p (concat "Delete file?: " currentFile))
        (kill-buffer (current-buffer))
        (when (not (equal currentFile nil))
          (delete-file currentFile) ) ) ) )

#+end_src

**** file-exists-p
Return t if file FILENAME exists (whether or not you can read it).

#+begin_src emacs-lisp

  (defun xah/make-backup ()
    "Make a backup copy of current buffer's file.
  Create a backup of current buffer's file.
  The new file name is the old file name with trailing “~”, in the same dir.
  If such a file already exist, append more “~”.
  If the current buffer is not associated with a file, its a error."
    (interactive)
    (let (fName backupName)
      (setq fName (buffer-file-name))
      (setq backupName (concat fName "~"))

      (while (file-exists-p backupName)
        (setq backupName (concat backupName "~")))

      (copy-file fName backupName t)
      (message (concat "Backup saved as: "
                       (file-name-nondirectory backupName)))))

#+end_src

**** set-file-modes
Set mode bits of file named FILENAME to MODE (an integer).

*** dir-
**** directory-files
Return a list of names of files in DIRECTORY.

No recurse into sub-directories, for using recursive directories you can try these functions, find-lisp-find-files, find-lisp-find-files-internal from find-lisp package.

**** make-directory
Create the directory DIR and optionally any nonexistent parent dirs.

Non existent paren dirs will be created.

**** delete-directory
Delete the directory named DIRECTORY.  Does not follow symlinks.

Whole dir.

**** copy-directory
Copy DIRECTORY to NEWNAME.  Both args must be strings.

Whole dir.

*** math-
**** random
Elisp's random function can be called in 3 ways:

- ~(random t)~. Set a random seed based on current time and PID (process ID).
- ~(random n)~. Returns a random number between ~0~ and ~n-1~, including possible ~0~ and ~n-1~.
- ~(random)~. Returns a random number between ~0~ and ~2^29-1~, inclusive.

**** expt
Return the exponential ARG1 ** ARG2.

**** truncate
This returns number, converted to an integer by rounding towards zero.

#+begin_src emacs-lisp

  (truncate  1.2)  ;; =>  1
  (truncate  1.7)  ;; =>  1
  (truncate -1.2)  ;; => -1
  (truncate -1.7)  ;; => -1

#+end_src

**** floor
This returns number, converted to an integer by rounding downward (towards negative infinity).

If divisor is specified, this uses the kind of division operation that corresponds to mod, rounding downward.

#+begin_src emacs-lisp

  (floor  1.2) ;; =>  1
  (floor  1.7) ;; =>  1
  (floor -1.2) ;; => -2
  (floor -1.7) ;; => -2

  (floor 5.99 3) ;; => 1
  (floor 6.01 3) ;; => 2

#+end_src

**** ceiling
This returns number, converted to an integer by rounding upward (towards positive infinity).

#+begin_src emacs-lisp

  (ceiling  1.2) ;; =>  2
  (ceiling  1.7) ;; =>  2
  (ceiling -1.2) ;; => -1
  (ceiling -1.7) ;; => -1

#+end_src

**** round
This returns number, converted to an integer by rounding towards the nearest integer. Rounding a value equidistant between two integers returns the even integer.

#+begin_src emacs-lisp

  (round  1.2) ;; =>  1
  (round  1.7) ;; =>  2
  (round -1.2) ;; => -1
  (round -1.7) ;; => -2

#+end_src

**** max
Return largest of all the arguments (which must be numbers or markers).

#+begin_src emacs-lisp

  (max 5 9 6 3 48) ;; => 48

  ;; max into a list
  (apply 'max '(1 2 3 4)) ;; => 4
  (funcall 'max '(1 2 3 4))
  ;; => error because "funcall" would pass that argument to the function "max"
  ;; which precisely cannot recive the list as an argument while "apply" does,
  ;; "apply" passes each value of the list as an individual argument.

#+end_src

**** zerop
Return t if NUMBER is zero.

**** /
The division operation approximates immediately by default, to change this behavior, the dividend must be placed in decimal notation.

#+begin_src emacs-lisp

  (/ 21 4)   ;; => 5
  (/ 21 4.0) ;; => 5.25

#+end_src

*** lines-
**** beginning-of-line
Move cursor to beginning of current line.

Better than ~(goto-char (line-beginning-position))~.

Do not use ~move-beginning-of-line~ or ~move-end-of-line~. Because these are designed for interactive use.

Do not use ~(search-forward "\n")~ for moving cursor to end of line. Because you'll have special cases if the line is at the end of buffer and doesn't have a newline char. It is also slower.

#+begin_src emacs-lisp

  (transient-mark-mode 1)

  (defun xah/select-current-line ()
    "Select the current line"
    (interactive)
    (end-of-line) ; move to end of line
    (set-mark (line-beginning-position)))

#+end_src

**** end-of-line
Move cursor to end of current line.

Better than ~(goto-char (line-end-position))~.

Do not use ~move-beginning-of-line~ or ~move-end-of-line~. Because these are designed for interactive use.

Do not use ~(search-forward "\n")~ for moving cursor to end of line. Because you'll have special cases if the line is at the end of buffer and doesn't have a newline char. It is also slower.

**** line-beginning-position
Return line beginning's position.

#+begin_src emacs-lisp

  ;; grab current line
  (setq myLine
        (buffer-substring-no-properties
         (line-beginning-position)
         (line-end-position)))
  ;; Do not use (thing-at-point 'line). Normally, thing-at-point will
  ;; include the newline char, but if the line is at the end of buffer,
  ;; then it won't.

#+end_src

**** line-end-position
Return line end's position.

**** count-lines
Return number of lines between START and END.
**** forward-line
Move cursor to previous(-1) or next line(1). Cursor will be at beginning of line.

Do not use ~next-line~ , ~previous-line~ or ~goto-line~ because these are for interactive use, ~forward-line~ is better opcion. Their behavior changes depending on the variable ~line-move-visual~.

*** ring-
**** kill-append
Append STRING  argument to the end of the latest kill in the kill ring.

**** kill-new
Make STRING argument the latest kill in the kill ring.

**** current-kill
Rotate the yanking point by N places, and then return that kill.

**** yank
Reinsert ("paste") the last stretch of killed text.

**** yank-pop
Replace just-yanked stretch of killed text with a different stretch.

**** rotate-yank-pointer
Rotate the yanking point in the kill ring.

*** variable-
**** buffer-read-only
Útil para setear momentaneamente un buffer con solo lectura, cuando hay posibilidad de que el buffer cambie al aplicar una función que se esta ejecutando y no sea eso lo que se quiera o mientras se experimenta con funciones que puedan alterar el buffer o en archivos delicados (archivos fuente) que por más seguro que se este que la función no modificará el buffer es mejor estar seguro.

**** line-move-visual
Is variable that controls whether ~next-line~ and ~previous-line~ move by newline char or screen.

Note: there's also a function named ~line-move-visual~. It doesn't have inline doc. It's for moving cursor by visual lines.

**** default-directory
Get the current dir.

**** case-fold-search
Non-nil if searches and matches should ignore case.

#+begin_src emacs-lisp

  (defun search-for-abc ()
    "Search for the string \"abc\", ignoring case differences."
    (let ((case-fold-search t))
      (re-search-forward "abc")))


  ;; -*- coding: utf-8 -*-
  ;; 2011-03-21
  ;; report the line number of a occurrences of string, of a given dir
  ;; script

  (setq inputDir "~/web/ergoemacs_org/emacs/" )

  ;; add a ending slash if not there
  (when (not (string= "/" (substring inputDir -1)))
    (setq inputDir (concat inputDir "/")))

  (defun my-process-file (fPath)
    "process the file at fullpath fPath …"
    (let (myBuffer (ii 0) searchStr)

      (when (not (string-match "/xx" fPath)) ; skip dir starting with xx

        (setq myBuffer (get-buffer-create " myTemp"))
        (set-buffer myBuffer)
        (insert-file-contents fPath nil nil nil t)

        (setq case-fold-search nil) ; remember to set case sensitivity here

        (setq searchStr "<style>" )

        (goto-char 1)
        (while (search-forward searchStr nil t) ;for regex, re-search-forward
          (princ (format "this many: %d %s\n"
                         (line-number-at-pos (point)) fPath)))

        (kill-buffer myBuffer))))

  (require 'find-lisp)

  (let (outputBuffer)
    (setq outputBuffer "*xah occur output*" )
    (with-output-to-temp-buffer outputBuffer
      (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
      (princ "Done deal!")))

#+end_src

**** boundp
Return t if SYMBOL's value is not void.

Check if a variable is defined.

The ~boundp~ checks a symbol's value cell. Similarly, the [[fboundp]] actually check a symbol's function cell.

#+begin_src emacs-lisp

  (boundp 'auto-mode-alist)       ; t
  (boundp 'xyz)                   ; nil

#+end_src

**** Notes

#+begin_src emacs-lisp

  ;; input dir
  (setq inputDir "~/web/" ) ; In elisp, dir path should end with a slash

  ;; set output buffer
  (setq outputBuffer "*my occur output*" )

#+end_src

*** command-
**** this-command
Normally, whenever a function is executed, Emacs sets the value of this-command to the function being executed.

#+begin_src emacs-lisp

  ;; check if the command is being called repeatedly
  (if (not (eq last-command this-command))
      …
      )
  ;; the “this-command” and “last-command” are built-in variables. They
  ;; store the command currently called or last called.

#+end_src

**** last-command
Normally, whenever a function is executed, Emacs sets the value of this-command to the function being executed. At the same time, Emacs sets the value of last-command to the previous value of this-command.

#+begin_src emacs-lisp

  ;; check if the command is being called repeatedly
  (if (not (eq last-command this-command))
      …
      )
  ;; the “this-command” and “last-command” are built-in variables. They
  ;; store the command currently called or last calle.

#+end_src

**** shell-command
Execute string COMMAND in inferior shell; display output, if any.

#+begin_src emacs-lisp

  ;; copy file
  (shell-command "cp /somepath/myfile.txt  /somepath")

  ;; gzip file
  ;; ...
  (when gzip-it-p
    (shell-command (concat "gzip " filePath)))

  ;; copy dir recursively
  ;; ...
  (make-directory toDir t)
  (shell-command (concat "cp -R " fromDir " " toDir))

#+end_src

**** shell-command-to-string
Execute shell command COMMAND and return its output as a string.

Idiom for calling a shell command and get its output.

#+begin_src emacs-lisp

  (shell-command-to-string "ls")

#+end_src

*** p-
**** sequencep
This function returns t if object is a list, vector, string, bool-vector, or char-table, nil otherwise.

**** functionp
Return t if OBJECT is a function.

Note that ~functionp~ returns ~t~ for symbols that are function names and returns ~nil~ for special forms. It is also possible to find out how many arguments an arbitrary function expects.

**** fboundp
Check if a function is defined.

The ~fboundp~ actually check a symbol's *function* cell. Similarly, the [[boundp]] checks a symbol's *value* cell.

#+begin_src emacs-lisp

  (fboundp 'info)     ; t
  (fboundp 'xyz)      ; nil

#+end_src

**** featurep
Check if a “feature” is loaded (if a library is loaded).

#+begin_src emacs-lisp

  ;; check if a “feature” (package) has been loaded
  (featurep 'ibuffer)

#+end_src

*** misc-
**** y-or-n-p
Ask user a "y or n" question.

Return t if answer is "y" and nil if it is "n".

#+begin_src emacs-lisp

  (if (y-or-n-p "Do it?")
      (progn
        ;; code to do something here
        )
    (progn
      ;; code if user answered no.
      ))


  ;; -*- coding: utf-8 -*-
  ;; 2011-07-03
  ;; replace image tags to use HTML5's “figure”  and “figcaption” tags.

  ;; Example. This:
  ;; <div class="img">…</div>
  ;; should become this
  ;; <figure>…</figure>

  ;; do this for all files in a dir.

  ;; rough steps:
  ;; find the <div class="img">
  ;; use sgml-skip-tag-forward to move to the ending tag.
  ;; save their positions.
  ;; ask user whether to replace, if so, delete them and insert new string

  (defun xah/my-process-file (fPath)
    "Process the file at FPATH …"
    (let (myBuff p1 p2 p3 p4 )
      (setq myBuff (find-file fPath))

      (widen)
      (goto-char 1) ;; in case buffer already open

      (while (search-forward "<div class=\"img\">" nil t)
        (progn
          (setq p2 (point) )
          (backward-char 17) ; beginning of “div” tag
          (setq p1 (point) )

          (forward-char 1)
          (sgml-skip-tag-forward 1) ; move to the closing tag
          (setq p4 (point) )
          (backward-char 6) ; beginning of the closing div tag
          (setq p3 (point) )
          (narrow-to-region p1 p4)

          (when (y-or-n-p "replace?")
            (progn
              (delete-region p3 p4 )
              (goto-char p3)
              (insert "</figure>")

              (delete-region p1 p2 )
              (goto-char p1)
              (insert "<figure>")
              (widen) ) ) ) )

      (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff))))

  (require 'find-lisp)


  (let (outputBuffer)
    (setq outputBuffer "*xah img/figure replace output*" )
    (with-output-to-temp-buffer outputBuffer
      (mapc 'my-process-file (find-lisp-find-files
                              "~/web/xahlee_org/emacs/" "\\.html$"))
      (princ "Done deal!")))

#+end_src

**** read-from-minibuffer
Read a string from the minibuffer, prompting with string PROMPT.

~read-from-minibuffer~ is the most general command for get user input, but there are others such as ~read-string~, ~read-file-name~, read ~-directory-name~, ~read-regexp~.

#+begin_src emacs-lisp

  (defun ff ()
    "Prompt user to enter a file name, with completion and history support."
    (interactive)
    (let ((x (read-file-name "Enter file name:")))
      (message "String is %s." x)))

  (defun ff (arg)
    "Prompt user to enter a string, with input history support."
    (interactive
     (list
      (read-string "Enter your name:")))
    (message "String is %s." arg))

#+end_src

**** start-process
Start a program in a subprocess.  Return the process object for it.

Call a shell command, but don't wait for it to finish before continuing, use ~start-process~ or ~start-process-shell-command~.

#+begin_src emacs-lisp

  ;; open files in Linux desktop
  (mapc
   (lambda (fPath)
     (let ((process-connection-type nil))
       (start-process "" nil "xdg-open" fPath)) )
   myFileList)

#+end_src

**** prefix-numeric-value
Convert the raw prefix argument produced by (interactive "P") to a numeric value.

**** default-value
Check whether the minor mode is enabled in the current buffer.

**** require
If feature FEATURE is not loaded, load it from FILENAME.

When writing a elisp script that does batch processing, it's best to print to your own buffer.

For example, suppose you have a elisp batch script that do find and replace on all files in a dir. For each file visited, it prints out the file path. If you use (message …), it prints to the “*Messages*” buffer, which automatically roll off the top if you have more than a hundred lines. Also, it may intermix your script's output with output from other emacs activities.

Here's a example of printing to your own buffer:

#+begin_src emacs-lisp

  (require 'find-lisp)
  (with-output-to-temp-buffer "*my output*"
    (mapc 'my-process-file (find-lisp-find-files "~/" "\\.html$"))
    (princ "Done.\n")
    (switch-to-buffer "*my output*")
    )

  ;; In the above example, any call to print in “my-process-file” is output
  ;; to your temp buffer.

#+end_src

**** catch throw
Use ~catch~ and ~throw~ to exit loop, function or map.

To exit a function, just put ~throw 'tagname value~ where you want to, and, wrap your function body with a ~catch 'tagname~.

~(catch 'tagname body)~ => evaluates ~body~ and return ~body~'s last expression, but if ~body~ contains ~(throw …)~ and it is called, return the value throw passes.

~(throw tagName passValue)~ => jump to a outer ~(catch 'tagName)~ and continue there, passing the value of ~passValue~ to it. Both ~tagName passValue~ are evaluated.

#+begin_src emacs-lisp

  (defun test-exit-f ()
    "example. using catch/throw to exit function"
    (interactive)
    (catch 'aaa
      (if (y-or-n-p "exit?")
          (progn
            (message "existing")
            (throw 'aaa 3) ; if yes, exit right away, return 3 to catch
            )
        (progn ; else, go on
          (message "went on")
          4)))) ; return 4


  ;; Exit a map
  (let ((myList [0 1 2 3 4 5]))
    ;; map lambda onto a list. If value 3 is found, return 3, else nil
    (catch 'bbb
      (mapc
       (lambda (x)
         (message "%s" x)
         (when (equal x 3) (throw 'bbb x)))
       myList)
      nil))


  ;; Here's a sample of setting flag:
  (let ((myList [0 1 2 3 4 5] )
        (foundFlag-p nil )
        (i 0))

    (while (and
            (not foundFlag-p)
            (<= i (length myList)))

      ;; if found, set foundFlag-p
      (when (equal (elt myList i) 3)
        (setq foundFlag-p t ))

      (message "value: %s" i)
      (setq i (1+ i))))

#+end_src

**** error
Use ~error~ or ~user-error~ to signal a error and exit.

You can exit by calling ~error~ or ~user-error~.

#+begin_src emacs-lisp

  (defun test-exit-f ()
    "example"
    (interactive)
    (if (y-or-n-p "invoke user-error to exit?")
        (user-error "Error, because: %s" "you said so!")
      (progn ; else, go on
        (message "went on"))))

#+end_src

**** highlight-phrase
Set face of each match of phrase REGEXP to FACE.

Another similar function is ~highlight-lines-matching-regexp~.

#+begin_src emacs-lisp

  (highlight-phrase "\\bKing\\b" (quote hi-blue))

  (highlight-lines-matching-regexp "^#" (quote hi-blue-b))

  ;; You can set a file to automatically eval elisp code when the file
  ;; opens.  add this to the end of file:

  /* Local Variables: */
  /* eval: (highlight-phrase "\\bJane\\b" (quote hi-pink)) */
  /* eval: (highlight-phrase "\\bKing\\b" (quote hi-blue)) */
  /* eval: (highlight-lines-matching-regexp "^#" (quote hi-blue-b)) */
  /* End: */

#+end_src

**** benchmark-run
Time execution of FORMS.

**** sgml-skip-tag-forward
Skip to end of tag or matching closing tag if present.

**** sit-for
Redisplay, then wait for SECONDS seconds.  Stop when input is available.

This expression makes the graph printing operation more interesting to watch than it would be otherwise. The expression causes Emacs to sit or do nothing for a zero length of time and then redraw the screen. Placed here, it causes Emacs to redraw the screen column by column. Without it, Emacs would not redraw the screen until the function exits.

#+begin_src emacs-lisp

  ;; Example of use (sit-for 0)
  (defun graph-body-print (numbers-list)
    "Print a bar graph of the NUMBERS-LIST.
  The numbers-list consists of the Y-axis values."

    (let ((height (apply 'max numbers-list))
          (symbol-width (length graph-blank))
          from-position)


      (while numbers-list
        (setq from-position (point))
        (insert-rectangle
         (column-of-graph height (car numbers-list)))
        (goto-char from-position)
        (forward-char symbol-width)

        ;; Draw graph column by column.
        (sit-for 0)
        (setq numbers-list (cdr numbers-list)))

      ;; Place point for X axis labels.
      (forward-line height)
      (insert "\n")))


  ;; other functions and variables of this graph if you wish to test the
  ;; above function.
  (defvar graph-symbol "*"
    "String used as symbol in graph, usually an asterisk.")


  (defvar graph-blank " "
    "String used as blank in graph, usually a blank space.
  graph-blank must be the same number of columns wide
  as graph-symbol.")


  ;;; Second version.
  (defun column-of-graph (max-graph-height actual-height)
    "Return MAX-GRAPH-HEIGHT strings; ACTUAL-HEIGHT are graph-symbols.

  The graph-symbols are contiguous entries at the end
  of the list.
  The list will be inserted as one column of a graph.
  The strings are either graph-blank or graph-symbol."


    (let ((insert-list nil)
          (number-of-top-blanks
           (- max-graph-height actual-height)))


      ;; Fill in graph-symbols.
      (while (> actual-height 0)
        (setq insert-list (cons graph-symbol insert-list))
        (setq actual-height (1- actual-height)))


      ;; Fill in graph-blanks.
      (while (> number-of-top-blanks 0)
        (setq insert-list (cons graph-blank insert-list))
        (setq number-of-top-blanks
              (1- number-of-top-blanks)))

      ;; Return whole list.
      insert-list))

#+end_src

**** null
Return t if OBJECT is nil, and return nil otherwise.

#+begin_src emacs-lisp

  (null '()) ; => t

#+end_src

**** set-register
Set contents of Emacs register named REGISTER to VALUE.

#+begin_src emacs-lisp

  ;; Example of how to resets/clears register a.
  (set-register ?a nil)

#+end_src

** List processing
*** Get
**** car
Return the first item in the list.

~car~ does not remove the first item from the list; it only reports what it is. ~car~ is “non-destructive”.

Thus, in Lisp, to get the ~car~ of a list, you get the address of the first element of the list.

#+begin_src emacs-lisp

  (car '(first second third)) ;; => first

#+end_src

**** nth
Takes the ~car~ of the result returned by [[nthcdr]]. It returns the Nth element of the list. The function is “non-destructive”.

Note that the elements are numbered from zero, not one. That is to say, the first element of a list, its ~car~ is the zeroth element.

#+begin_src emacs-lisp

  (nth 0 '(zero first second third)) ;; => zero
  (nth 1 '(zero first second third)) ;; => first

#+end_src

**** elt
This function returns the element of sequence indexed by index. Legitimate values of index are integers ranging from 0 up to one less than the length of sequence. If sequence is a list, out-of-range values behave as for [[nth]].

#+begin_src emacs-lisp

  (elt [1 2 3 4] 2) ;; => 3

  (elt '(1 2 3 4) 2) ;; => 3

  ;; We use string to show clearly which character elt returns.
  (string (elt "1234" 2)) ;; => "3"

  (elt [1 2 3 4] 4) ;; error→ Args out of range: [1 2 3 4], 4

#+end_src

**** last
Return the last link of LIST.  Its car is the last element.

#+begin_src emacs-lisp

  (last '(1 4 7)) ;; => (7)

#+end_src

**** cdr
Returns the second and subsequent elements of a list.

~cdr~ does not remove any elements from the list—it just returns a report of what the second and subsequent elements are.  ~cdr~ is “non-destructive”

Thus, in Lisp, to get the ~cdr~ of a list, you just get the address of the next cons cell in the series.

#+begin_src emacs-lisp

  (cdr '(first second third)) ;; => (second third)

  (cdr (cdr '(zero first second third))) ;; => (second third)
  (nthcdr 2 '(zero first second third)) ;; => (second third)

#+end_src

**** nthcdr
Return the result of taking [[cdr]] ~n~ times on a list. The “rest of the rest”.

Is associated with the ~cdr~ function. What it does is take the ~cdr~ of a list repeatedly. The function is “non-destructive”.

#+begin_src emacs-lisp

  (nthcdr 2 '(zero first second third)) ;; => (second third)

  (cdr (cdr '(zero first second third))) ;; => (second third)

#+end_src

**** seq-take
This function returns the first N (an integer) elements of SEQUENCE. If N is negative or zero, the result is nil.

#+begin_src emacs-lisp

  (seq-take '(1 2 3 4) 3)  ;; => (1 2 3)

  (seq-take [1 2 3 4] 0)   ;; =>  []

#+end_src

**** pop
This macro provides a convenient way to examine the CAR of a list, and take it off the list, all at once. It operates on the list stored in LISTNAME. It removes the first element from the list, saves the CDR into listname, then returns the removed element. *It changed the list*.

#+begin_src emacs-lisp

  (pop listname)
  ; In the simplest case, listname is an unquoted symbol naming a list
  ; in that case, this macro is equivalent to
  (prog1 (car  listname)
    (setq listname (cdr listname)))


  x       ;; => (a b c)
  (pop x) ;; => a
  x       ;; => (b c)

  ; More generally, listname can be a generalized variable.
  ; In that case, this macro saves into listname using setf.

#+end_src

**** seq-drop-while
This function returns the members of SEQUENCE in order, starting from the first one for which PREDICATE returns nil.

#+begin_src emacs-lisp

  (seq-drop-while (lambda (x) (> x 0)) '(1 2 3 -1 -2))
  ;; => (-1 -2)

  (seq-drop-while (lambda (x) (< x 0)) [1 4 6])
  ;; => [1 4 6]

#+end_src

*** Add
**** cons
Return a new list, with new element added to front. (prepend)

Constructs a list by prepending its first argument to its second argument. ~cons~ does not change an existing list, but creates a new one. ~cons~ is “non-destructive”.

- ~cons~ must have a list to attach to. You cannot start from absolutely nothing. If you are building a list, you need to provide at least an empty list at the beginning.
- ~cons~, can put together or construct a list, but not an array.

The function ~cons~ adds a new pair of addresses to the front of a series of addresses. Thus, to ~cons~ a new element on a list, you add a new cons cell to the front of the list.

#+begin_src emacs-lisp

  (cons 'zero '(first second third)) ;; => (zero first second third)

  (cons 'born ()) ;; => (born)

  (cons 'born 'now) ;; => (born . now) ;; build cons cell

#+end_src

**** append
Return a new list, join two lists.

#+begin_src emacs-lisp

  (append '(1 2 3 4) '(5 6 7 8))
  ;; => (1 2 3 4 5 6 7 8)


  ;; The results contrast with cons, which constructs a new list in which
  ;; the first argument to cons becomes the first element of the new list:
  (cons '(1 2 3 4) '(5 6 7 8))
  ;; => ((1 2 3 4) 5 6 7 8)

#+end_src

**** push
Add new element to the list *stored* in the generalized variable. Like [[cons]] but *this does changed the list*.

#+begin_src emacs-lisp

  (push value list)

  ;; it's the same that
  (add-to-list list value)
  ;; and
  (setq list (cons value list))

  ;; example
  (setq list '(1 2 3 4)) ;; =>   (1 2 3 4)
  (push 5 list)          ;; => (5 1 2 3 4)
  list                   ;; => (5 1 2 3 4)

#+end_src

*Caution*: Si a ~push~ se le pasa una lista modificada (por ejemplo, la cola de la lista), solo cambiará esa parte de la lista (o sea, la cola) la primera parte quedará exactamente igual.

#+begin_src emacs-lisp

  (setq list '(1 2 3 4))              ;; => (1 2 3 4)
  (push (car list) (cdr (cdr list)))  ;; => (1 3 4)
  list                                ;; => (1 2 1 3 4)

#+end_src

*** Remove
**** pop
Remove first element from the variable. Returns the removed element. The argument must be a generalized variable whose value is a list.

#+begin_src emacs-lisp

  (setq mylist '(7 4 2 1 0)) ;; => (7 4 2 1 0)
  (pop mylist)               ;; => 7

#+end_src

**** butlast
Return a copy of LIST with the *last N elements removed*. It *doesn't change the list*.

#+begin_src emacs-lisp

  (butlast '(1 3 5 7 9) 2)  ;; => (1 3 5)

  (butlast '("a" "b" "c"))  ;; => ("a" "b")

#+end_src

**** nbutlast
Modify LIST to *remove the last N elements*. It *changed the list*.

#+begin_src emacs-lisp

  (nbutlast '(1 3 5 7 9) 2)  ;; => (1 3 5)

#+end_src

**** seq-drop
Returns all but the first ~n~ (an integer) elements of SEQUENCE. If ~n~ is negative or zero, the result is SEQUENCE.

#+begin_src emacs-lisp

  (seq-drop [1 2 3 4 5 6] 3)  ;; => [4 5 6]

  (seq-drop "hello world" -4) ;; => "hello world"

#+end_src

**** delq
~(delq ELT LIST)~
Delete members of LIST which are [[eq]] to ELT, and return the result.

#+begin_src emacs-lisp

  (delq   "b" '("a" "b" "c" "b")) ;; => ("a" "b" "c" "b")
  (delete "b" '("a" "b" "c" "b")) ;; => ("a" "c")

  (delq   2 '(1 2 3 2 4)) ;; => (1 3 4)
  (delete 2 '(1 2 3 2 4)) ;; => (1 3 4)

  (delq   '(0) '(1 (0) 2 3 (0) 4 5 6)) ;; => (1 (0) 2 3 (0) 4 5 6)
  (delete '(0) '(1 (0) 2 3 (0) 4 5 6)) ;; => (1 2 3 4 5 6)

#+end_src

**** delete
~(delete ELT SEQ)~
Delete members of SEQ which are [[equal]] to ELT, and return the result.

#+begin_src emacs-lisp

  (delete "b" '("a" "b" "c" "b")) ;; => ("a" "c")
  (delq   "b" '("a" "b" "c" "b")) ;; => ("a" "b" "c" "b")

  (delete 2 '(1 2 3 2 4)) ;; => (1 3 4)
  (delq   2 '(1 2 3 2 4)) ;; => (1 3 4)

  (delete '(0) '(1 (0) 2 3 (0) 4 5 6)) ;; => (1 2 3 4 5 6)
  (delq   '(0) '(1 (0) 2 3 (0) 4 5 6)) ;; => (1 (0) 2 3 (0) 4 5 6)

#+end_src

*** Replace
**** setcar
Changes the first element of a list.

Set the [[car]] of a list to a new value.

~setcar~ did not add a new element to the list as ~cons~ would have; it replaced first element of the list with new value; *it changed the list*.

The result we are interested in is the side effect, which we can see by evaluating the variable what will change.

#+begin_src emacs-lisp

  ;; first set value of a variable to the list
  (setq numbers (list 'first 'second 'third 'fourth))
  numbers ;; =>  (first second third fourth)

  ;; apply the function setcar to set a new first value
  (setcar numbers 'new)
  ;; evaluted the variable to check result
  numbers ;; =>  (new second third fourth)

#+end_src

**** setcdr
Changes the second and subsequent elements of a list.

Set the [[cdr]] of a list to a new value.

~setcdr~ did not add elements to the list as ~cons~ would have; it replaced the second and subsequent elements of the list with new values; *it changed the list*.

The result we are interested in is the side effect, which we can see by evaluating the variable what will change.

#+begin_src emacs-lisp

  ;; first set value of a variable to the list
  (setq numbers (list 'first 'second 'third 'fourth))
  numbers ;; =>  (first second third fourth)

  ;; apply the function setcar to set a new first value
  (setcdr numbers '(2 3))
  ;; evaluted the variable to check result
  numbers ;; =>  (first 2 3)

#+end_src

#+begin_src emacs-lisp

  ;; Ejemplo de acortar una lista se debe poneniendo
  ;; el último valor con nil
  (setq numbers (list 'first 'second 'third 'fourth))
  ;; numbers => (first second third fourth)

  (setcdr (nthcdr 2 numbers) nil)
  ;; (nthcdr 2 numbers) no altera la lista, solo trabaja
  ;; temporalmente entregando (third fourt) y luego
  ;; setcdr la altera (third fourt) => (third nil)
  ;; numbers => (first second third)
  ;; SE PUEDE VER MEJOR USANDO LAS DIRECCIONES DE LISTA, I.E.
  ;; CADA CONS CELL TIENE LA DIRECCIÓN PROPIA Y LA DE EL PUNTERO
  ;; AL SIGUIENTE VALOR

#+end_src

*** Misc
**** length
Return the length of vector, list or string.

#+begin_src emacs-lisp

  (length '(first second third)) ;; => 3

  (length "first") ;; => 5

  (length (make-bool-vector 5 nil)) ;; => 5

#+end_src

**** sort
This function sorts SEQUENCE stably. Note that this function doesn’t work for all sequences; it may be used only for lists and vectors. If SEQUENCE is a list, it is modified *destructively*. This functions returns the sorted SEQUENCE and compares elements using PREDICATE. A stable sort is one in which elements with equal sort keys maintain their relative order before and after the sort. Stability is important when successive sorts are used to order elements according to different criteria.

*WARNING*: The destructive aspect of ~sort~ for lists is that it rearranges the cons cells forming SEQUENCE by changing CDRs. A nondestructive sort function would create new cons cells to store the elements in their sorted order. If you wish to make a sorted copy without destroying the original, copy it first with [[copy-sequence]] and then sort.

#+begin_src emacs-lisp

  (setq nums (list 1 3 2 6 5 4 0)) ;; => (1 3 2 6 5 4 0)
  (sort nums #'<)                  ;; => (0 1 2 3 4 5 6)
  nums                             ;; => (1 2 3 4 5 6)

  ;;Most often we store the result back into the variable
  ;;that held the original list:
  (setq nums (sort nums #'<))


  ;; to sort the list in alphabetical order
  (sort
   (files-in-below-directory "/some/path/")
   'string-lessp)

#+end_src

**** copy-sequence
This function returns a copy of its ARGUMENT, which should be either a sequence or a record. The copy is the same type of object as the original, and it has the same elements in the same order. However, if ARGUMENT is empty, like a string or a vector of zero length, the value returned by this function might not be a copy, but an empty object of the same type and identical to ARGUMENT.

*Storing a new element into the copy does not affect the original ARGUMENT, and vice versa. However, the elements of the copy are not copies; they are identical (eq) to the elements of the original. Therefore, changes made within these elements, as found via the copy, are also visible in the original.*

This function does not work for dotted lists. Trying to copy a circular list may cause an infinite loop.

#+begin_src emacs-lisp

  (setq x '(1 2 3))       ;; => (1 2 3)
  (setq y (copy-sequence x))  ;; => (1 2 3)

  (eq x y)     ;; => nil
  (equal x y)  ;; => t

  (eq (nth 1 x) (nth 1 y)) ;; => t

#+end_src

**** mapcar
Apply FUNCTION to each element of SEQUENCE, and make a list of the results. SEQUENCE may be a list, a vector, a bool-vector, or a string.

Contrast this with [[apply]], which applies its first argument to all the remaining.

The ‘map’ part of the name comes from the mathematical phrase, “mapping over a domain”, meaning to apply a function to each of the elements in a domain. The mathematical phrase is based on the metaphor of a surveyor walking, one step at a time, over an area he is mapping. And ‘car’, of course, comes from the Lisp notion of the first of a list.

#+begin_src emacs-lisp

  ; add one to each list member
  (mapcar '1+ (list 1 2 3 4)) ; (2 3 4 5)
  ; same, but using the "lambda" function created inline
  (mapcar
   (lambda (x) (+ x 1))
   (list 1 2 3 4)) ;; => (2 3 4 5)


  ; take the 1st element of each
  (mapcar 'car '((1 2) (3 4) (5 6))) ; (1 3 5)


  ;; take the 2nd element of each
  (mapcar (lambda (x) (nth 1 x))
          '((1 2) (3 4) (5 6))) ;; => (2 4 6)

#+end_src

**** mapc
Apply FUNCTION to each element of SEQUENCE *for side effects only*. Like [[mapcar]], but returns ~nil~.

#+begin_src emacs-lisp

  ;; apply a file processing function to a list of files
  (mapc 'my-update-html-footer
        (list
         "~/web/file1.html"
         "~/web/file2.html"
         "~/web/file3.html"))

#+end_src

**** reverse
Creates a new sequence whose elements are the elements of SEQUENCE, but in reverse order. The original argument sequence *is not altered*. Note that char-tables cannot be reversed.

#+begin_src emacs-lisp

  (setq x '(1 2 3 4)) ;; => (1 2 3 4)
  (reverse x)         ;; => (4 3 2 1)
  x                   ;; => (1 2 3 4)


  (setq x [1 2 3 4]) ;; => [1 2 3 4]
  (reverse x)        ;; => [4 3 2 1]
  x                  ;; => [1 2 3 4]

  (setq x "xyzzy") ;; => "xyzzy"
  (reverse x)      ;; => "yzzyx"
  x                ;; => "xyzzy"

#+end_src

**** nreverse
This function reverses the order of the elements of SEQUENCE. Unlike [[reverse]] the original SEQUENCE may be *modified*.

Note that unlike ~reverse~, this function doesn’t work with strings. Although you can alter string data by using ~aset~, it is strongly encouraged to treat strings as immutable even when they are mutable.

#+begin_src emacs-lisp

  (setq list '(1 3 5 7))   ;; => (1 3 5 7)
  (nreverse list)          ;; => (7 5 3 1)
  list                     ;; => (1)

  ;; To avoid confusion, we usually store the result of nreverse back in
  ;; the same variable which held the original list:
  (setq x (nreverse x))


  ;; For the vector, it is even simpler because you don’t need setq
  (setq x (copy-sequence [1 2 3 4])) ;; => [1 2 3 4]
  (nreverse x)                       ;; => [4 3 2 1]
  x                                  ;; => [4 3 2 1]

#+end_src

**** make-list
Return a newly created list of length LENGTH, with each element being INIT.

#+begin_src emacs-lisp

  (make-list 8 0) ;; => (0 0 0 0 0 0 0 0)

  (make-list 3 'pigs) ;; => (pigs pigs pigs)

#+end_src

**** number-sequence
Return a sequence of numbers from FROM to TO (both inclusive) as a list.

#+begin_src emacs-lisp

  (number-sequence 5 20 5) ;; (5 10 15 20)

#+end_src

**** seq-random-elt
This function returns an ELEMENT of sequence taken at random.

#+begin_src emacs-lisp

  (seq-random-elt [1 2 3 4]) ;; => 2

  (seq-random-elt [1 2 3 4]) ;; => 3

#+end_src

**** seqp
This function returns non-nil if object is a sequence (a list or array), or any additional type of sequence defined via seq.el generic functions. This is an extensible variant of ~sequencep~.

#+begin_src emacs-lisp

  (seqp [1 2])  ;; => t

  (seqp 2)      ;; => nil

#+end_src

* Glossary
** point
*** point
Is the current position of the cursor. The expression ~(point)~ returns a number that tells you where the cursor is located as a count of the number of characters from the beginning of the buffer up to point.

*** point-min
Is somewhat similar to ~point~, but it returns the value of the minimum permissible value of point in the current buffer. This is the number ~1~ unless narrowing is in effect.

*** point-max
Returns the value of the maximum permissible value of point in the current buffer.

** mark
Like [[point]] the ~mark~ is another position in the buffer; its value can be set, for the purpose of making a text selection with a command such as ~(set-mark-command)~ linked to ~C-SPC~, this value is kept as a marker. The mark can be considered a number—the number of characters the location is from the beginning of the buffer.

In lisp code, you should call ~push-mark~ or ~set-mark~.

If a mark has been set, you can use the command ~(exchange-point-and-mark)~ linked to ~C-x C-x~ to cause the cursor to jump to the mark and set the mark to be the previous position of point.

In addition, if you set another mark, the position of the previous mark is saved in the mark ring. Many mark positions can be saved this way. You can jump the cursor to a saved mark by typing ~C-u C-SPC~ one or more times.

** region
Is the part of the buffer between point and mark. Numerous commands work on the region, including ~center-region~, ~count-words-region~, ~kill-region~, and ~print-region~.

Once a user sets a mark in a buffer, a region exists. So, almost always, there exists a region in a buffer.

Emacs has a minor mode called [[transient-mark-mode]]. When on, it will highlight the region when it's active.

*Caution*:
*region* => The last marked position to the current cursor position.
*Active Region* => Because a region exists once a user sets a mark, and always having a section of text highlighted to the cursor position is annoying, so there's a new concept of Active Region. A Region is Active when the variable ~mark-active~ is true.

Note:
Emacs's concept of “active region” is practically the same as the modern term “Text Selection”.

Text Selection = when region is active, and is not empty.

** prefix argument
A prefix argument is passed to an [[interactive]] function by typing the ~META~ key followed by a number, for example, ~M-3 M-x command~ , or through ~universal-command~ this way ~C-u 3 M-x command~ .

- ~C-u~ is bound to ~universal-argument~.
- if you type ~C-u~ without a number, it defaults to ~4~.

To make your command aware of universal argument, there are 3 simple ways:

- The global variable ~current-prefix-arg~ holds the value of universal argument.
- Add ~(interactive "P")~ to your function.
- Add ~(interactive "p")~ to your function.

Can be raw prefix argument or can be numerical prefix argument, to see the difference [[Raw vs Numerical Prefix Arg]].

The following table shows the possible values of current-prefix-arg.

| /KEY INPUT/ | /current-prefix-arg/ | /VALUE/ |
|-----------+--------------------+-------|
| /No called/ | nil                |     1 |
| /C-u -/     | Symbol -           |    -1 |
| /C-u - 2/   | Number -2          |    -2 |
| /C-u 1/     | Number 1           |     1 |
| /C-u 4/     | Number 4           |     4 |
| /C-u/       | List '(4)          |     4 |
| /C-u C-u/   | List '(16)         |    16 |

Raw vs Numerical Prefix Arg

#+begin_src emacs-lisp

  (defun print-raw-prefix-arg (arg)
    "Print the current raw prefix argument value."
    (interactive "P")
    (insert (message "%S" arg)))
  ;; "M-x         print-raw-prefix-arg => nil
  ;; "C-u M-x     print-raw-prefix-arg => (4)
  ;; "C-u C-u M-x print-raw-prefix-arg => (16)
  ;; "C-u 3 M-x   print-raw-prefix-arg => 3
  ;; "M-- M-x     print-raw-prefix-arg => -

  (defun print-numeric-prefix-arg (arg)
    "Print the current numeric prefix argument value."
    (interactive "p")
    (insert (message "%S" arg)))
  ;; "M-x         print-numeric-prefix-arg =>  1
  ;; "C-u M-x     print-numeric-prefix-arg =>  4
  ;; "C-u C-u M-x print-numeric-prefix-arg => 16
  ;; "C-u 3 M-x   print-numeric-prefix-arg =>  3
  ;; "M-- M-x     print-numeric-prefix-arg => -1

#+end_src

** \\[...]
Tells the Lisp interpreter to substitute whatever key is currently bound to the ~[...]~.

#+begin_src emacs-lisp

  \\[universal-argument]
  In the case of "universal-argument", that is usually "C-u", but it might be different.

#+end_src

** narrowing
Is a feature of Emacs that makes it possible for you to focus on a specific part of a buffer, and work without accidentally changing other parts. Narrowing is normally disabled since it can confuse novices.

** kill ring
The kill ring is called a “ring” rather than just a “list”. However, the actual data structure that holds the text is a list.

** kill-ring-yank-pointer
Is a variable, just as kill-ring is a variable. It points to something by being bound to the value of what it points to.

The variable ~kill-ring~ and the variable ~kill-ring-yank-pointer~ are pointers.

#+begin_src emacs-lisp

  ;; If the value of the kill ring is:

  ("some text" "a different piece of text" "yet more text")

  ;; and the kill-ring-yank-pointer points to the second clause
  ;; the value of kill-ring-yank-pointer is:

  ("a different piece of text" "yet more text")

  kill-ring     kill-ring-yank-pointer
      |               |
      |      ___ ___  |     ___ ___      ___ ___
       ---> |   |   |  --> |   |   |    |   |   |
            |___|___|----> |___|___|--> |___|___|--> nil
              |              |            |
              |              |            |
              |              |             --> "yet more text"
              |              |
              |               --> "a different piece of text"
              |
              --> "some text"

#+end_src

** predicate
Is a function that determines whether some property is true or false.

It's used for example in the ~(sort SEQ PREDICATE)~ function. The ~sort~ function takes two arguments, the list to be sorted, and a predicate that determines whether the first of two list elements is less than the second  ~(sort '(4 8 21 17 33 7 21 7) '<)~.

PREDICATE is called with two elements of SEQ, and should return non-nil if the first element should sort before the second.

* Regexp
** Regexp
Regular expressions have a syntax in which a few characters are *special constructs* and the rest are *ordinary*. An ordinary character matches that same character and nothing else. The special characters are ~$^.*+?[\~ .

*Nota*: La expresión regular de emacs es básicamente BRE, pero se ha ampliado para tratar ~+~ y ~?~ como metacaracteres así como en ERE. Por lo tanto, no hay necesidad de escaparlos con ~\~ en la expresión regular de emacs.

Regular expression syntax varies significantly among computer programs. When writing Elisp code that generates regular expressions for use by other programs, it is helpful to know how syntax variants differ. Emacs regular expressions differ from two syntax variants standarded by POSIX: basic regular expressions (BREs) and extended regular expressions (EREs). Plain ~grep~ uses BREs, and ~grep -E~ uses EREs.

#+begin_src sh

  # Plain grep uses BREs, and ‘grep -E’ uses EREs.

  # With -E (Extended Regular Expressions)
  ls | grep -E 'ja*'    # Same as BRE in this case
  ls | grep -E 'ja+'    # + is a metacharacter in ERE (needs no escape)

  # With BRE (Basic Regular Expressions):
  ls | grep -G 'ja\*'   # Same as ERE in this case
  ls | grep -G 'ja\+'   # + needs escape in BRE

#+end_src

** Table

| /Character/   | /Description/                                       |
|-------------+---------------------------------------------------|
| /./           | any char (but newline)                            |
| /*/           | previous char or group, repeated 0 or more time   |
| /+/           | previous char or group, repeated 1 or more time   |
| /?/           | previous char or group, repeated 0 or 1 time      |
| /^/           | start of line                                     |
| /$/           | end of line                                       |
| /[...]/       | any char between brackets                         |
| /[^..]/       | any char not in the brackets                      |
| /[a-z]/       | any char between a and z                          |
| /\/           | prevents interpretation of following special char |
| /\¦/          | or                                                |
| /\w/          | word constituent                                  |
| /\b/          | word boundary                                     |
| /\sc/         | char with c syntax (e.g. \s- for whitespace char) |
| /\( \)/       | start/end of group                                |
| /\&lt; \&gt;/ | start/end of word (faulty rendering*)             |
| /\_< \_>/     | start/end of symbol                               |
| /\` \'/       | start/end of buffer/string                        |
| /\1/          | string matched by the first group                 |
| /\n/          | string matched by the nth group                   |
| /\{3\}/       | previous char or group, repeated 3 times          |
| /\{3,\}/      | previous char or group, repeated 3 or more times  |
| /\{3,6\}/     | previous char or group, repeated 3 to 6 times     |
| /\=/          | match succeeds if it is located at point          |

/*/  faulty rendering: backslash + less-than and backslash + greater-than

| When you *type* in a |                                            |
| replacement string | Emacs replaces it *with*                     |
|--------------------+--------------------------------------------|
| /\&/                 | the original found text                    |
| /\1, \2, etc./       | 1st,2nd parenthesis subgroup in found text |
| /\#/                 | the number of replacements done so far     |
| /\?/                 | string obtained by prompting on each match |
| /\,(lisp-expres …)/  | result of eval an arbitrary function       |

Here's an example. Suppose we have a buffer containing names like this:

 George Washington
 John Adams
 Thomas Jefferson
 James Madison
 James Monroe

If we run ~M-x replace-regexp~ and replace the regexp ~\(\w+\) \(\w+\)~ with ~\,(upcase \2), \1,~ our buffer now looks like this:

 WASHINGTON, George
 ADAMS, John
 JEFFERSON, Thomas
 MADISON, James
 MONROE, James

** Special characters
*** . , * , + , ?
**** .
Is a special character that matches *any single* character *except a newline*.

~a.b~ matches any three-character string that begins with ~a~ and ends with ~b~.

**** *
Is not a construct by itself; it is a postfix operator that means to match the *preceding regular expression* repetitively *any number of times*, as many times as possible. Thus, ~o*~ matches any number of ~o~ s, *including no* ~o~ s.

~*~ always applies to the smallest possible preceding expression. Thus, ~fo~ has a repeating ~o~, not a repeating ~fo~. It matches ~f~, ~fo~, ~foo~, and so on.

*Nota*: cuando se está realizando una busqueda con alguna función regex y el programa destaca (highlight) las expresiones que coinciden, se debe tener cuidado en no confundir cuando el programa resalta todas las coincidencias señalando varias coincidencias independientes como si fuera una sola coincidencia, por ejemplo: ~fo*~ destacará (highlight) ~fofofofofo~ pero no es que realmente coincida con todo este string junto, si no que destaca ~fo~ repetidas veces, es decir, la coincidencia es ~fo~ otro ~fo~ otro ~fo~ pero no el string completo ~fofofofofo~ .

The matcher processes a ~*~ construct by matching, immediately, as many repetitions as can be found. Then it continues with the rest of the pattern. If that fails, backtracking occurs, discarding some of the matches of the ~*~-modified construct in case that makes it possible to match the rest of the pattern. For example, in matching ~ca*ar~ against the string ~caaar~, the ~a*~ first tries to match all three ~a~ s; but the rest of the pattern is ~ar~ and there is only ~r~ left to match, so this try fails. The next alternative is for ~a*~ to match only two ~a~ s. With this choice, the rest of the regexp matches successfully.

- Using [[\{n,m\}]] notation, ~\{0,\}~ is equivalent to ~*~.

**** +
Is a postfix operator, similar to ~*~ except that it must match the preceding expression *at least once*.

Thus, ~ca+r~ matches the strings ~car~ and ~caaaar~ but not the string ~cr~, whereas ~ca*r~ matches all three strings.

- Using [[\{n,m\}]] notation, ~\{1,\}~ is equivalent to ~+~.

**** ?
Is a postfix operator, similar to ~*~ except that it can match the preceding expression *either once or not at all*.

Thus, ~ca?r~ matches ~car~ or ~cr~, and nothing else.

- Using [[\{n,m\}]] notation, ~\{0,1\}~ is equivalent to ~?~.

*** *? , +? , ??
Are non-greedy variants.

The normal operators ~*~, ~+~, ~?~ match as much as they can, as long as the overall regexp can still match. With a following ~?~, they will *match as little as possible* .

For example, ~ab*~ can match the string ~a~ and the string ~abbbb~; but  ~ab*?~ match only with ~a~ (the shortest valid match).

Non-greedy operators match the shortest possible string starting at a given starting point; in a forward search, though, the earliest possible starting point for match is always the one chosen. Thus, if you search for ~a.*?$~ against the text ~abbab~ followed by a newline, it matches the whole string. Since it can match starting at the first ~a~, it does.

In the following example you can see the difference when using the normal operators against the non-greedy search (?).

We want to replace the "=" markup with "~" (each match is marked with numbers).

#+begin_example

REGEXP: =\\(.+\\)=

- =/dev/clip= and =/dev/kill=(1) you can redirect shell commands to the emacs clipboard and killring
- REPL alias =alias ffo "find-file-other-window $1"=(2) y proporciona una manera sencilla.
- Puede correr comandos en la shell como =find-file=, =dired=, ...,  también correr funciones =(+ 20 5)=(3) completas.
- Puede usar comandos con pipe para enviar salida a un buffer =echo "Hello" > #<buffer test-buffer>=(4).
- La sintaxis de la subshell es un poco diferente se utiliza =${ }= en vez de =$( )=(5).

MATCHES: 5


REGEXP: =\\(.+?\\)=

- =/dev/clip=(1) and =/dev/kill=(2) you can redirect shell commands to the emacs clipboard and killring
- REPL alias =alias ffo "find-file-other-window $1"=(3) y proporciona una manera sencilla.
- Puede correr comandos en la shell como =find-file=(4), =dired=(5), ...,  también correr funciones =(+ 20 5)=(6) completas.
- Puede usar comandos con pipe para enviar salida a un buffer =echo "Hello" > #<buffer test-buffer>=(7).
- La sintaxis de la subshell es un poco diferente se utiliza =${ }=(8) en vez de =$( )=(9).

MATCHES: 9

#+end_example

*** \{n\}
**** \\{n\\}
Is a postfix operator specifying ~n~ repetitions—that is, the preceding regular expression must match *exactly ~n~ times in a row*.

For example, ~x\\{4\\}~ matches the string ~xxxx~ and nothing else.

Caution: maybe it's just one ~\~ , e.g.  ~x\{4\}~.

**** \\{n,m\\}
Is a postfix operator specifying between ~n~ and ~m~ repetitions—that is, the preceding regular expression must match *at least ~n~ times, but no more than ~m~ times*. If ~m~ is omitted, then there is no upper limit, but the preceding regular expression must match at least ~n~ times.

-  ~\\{0,1\\}~ is equivalent to ~?~.
-  ~\\{0,\\}~ is equivalent to ~*~.
-  ~\\{1,\\}~ is equivalent to ~+~.

Caution: maybe it's just one ~\~ , e.g.  ~\{0,1\}~.

*** [ ... ]
**** [ … ]
The characters between the two brackets are what this set can match.

- ~[ad]~ matches either one ~a~ or one ~d~.
- ~[ad]*~ matches any string composed of just ~a~ s and ~d~ s (including the empty string).
- ~c[ad]*r~ matches ~cr~, ~car~, ~cdr~, ~caddaar~, etc.

You can also include character ranges in a character set, by writing the starting and ending characters with a ~-~ between them. Thus, ~[a-z]~ matches any lower-case ASCII letter.

To include a ~]~ in a character set, you must make it the first character. For example, ~[]a]~ matches ~]~ or ~a~. To include a ~-~, write ~-~ as the last character of the set, tho you can also put it first or after a range. Thus, ~[]-]~ matches both ~]~ and ~-~.

**** [^ … ]
~[^~ begins a *complemented* (caracter complementario como en matemática, el complemento de todos esos caracteres, cualquier caracter menos los que estan en los corchetes, es como un "No estos caracteres") character set, which *matches any character except the ones specified*, even new line (put a newline in the list if you want it not to be matched).

Thus, ~[^a-z0-9A-Z]~ matches all characters except ASCII letters and digits.

~^~ is not special in a character set unless it is the first character. The character following the ~^~ is treated as if it were first (in other words, ~-~ and ~]~ are not special there).

Note: A complemented character set can match a newline, unless newline is mentioned as one of the characters not to match. This is in contrast to the handling of regexps in programs such as grep.

*** ^ , $
**** ^
Is a special character that matches the empty string, but *only at the beginning of a line* in the text being matched. Otherwise it fails to match anything.

Thus, ~^foo~ matches a ~foo~ that occurs at the beginning of a line.

**** $
Is similar to ~^~ but matches *only at the end of a line*.

Thus, ~x+$~ matches a string of one ~x~ or more at the end of a line.

*** \
**** \
Has two functions: it *quotes the special characters* (including ~\~), and it introduces additional special constructs.

Because ~\~ quotes special characters, ~\$~ is a regular expression that matches only ~$~, and ~\[~ is a regular expression that matches only ~[~, and so on.

Backslashes must be entered as ~\\~.

Literal backslash with doubling backslash ~\\\\~.

*Caution*: when it's an interactive command search one ~\~ by executing Lisp code two ~\\~.

**** \|
*Specifies an alternative*. Two regular expressions ~a~ and ~b~ with ~\|~ in between form an expression that matches some text if either ~a~ matches it or ~b~ matches it. It works by trying to match ~a~, and if that fails, by trying to match ~b~.

Thus, ~foo\|bar~ matches either ~foo~ or ~bar~ but no other string.

**** \b
Matches the *empty string*, but only at the *beginning or end of a word*.

- ~\bfoo\b~ matches any occurrence of ~foo~ as a separate word.
- ~\bballs?\b~ matches ~ball~ or ~balls~ as a separate word.

~\b~ matches at the beginning or end of the buffer regardless of what text appears next to it.

~\b~ word boundary marker. If you want to match with word boundary, use it, like this ~\bcat\b~. This will find ~cat~ but not ~cats~.

**** \B
Matches the *empty string*, but *NOT at the beginning or end of a word*.

~\Blab\B~ matches of any occurrence of "e~lab~oration" but not for "The ~lab~ is".

**** \( … \)
Is a grouping construct that serves three purposes:

1. To enclose a set of ~\|~ *alternatives* for other operations. Thus, ~\(foo\|bar\)x~ matches either ~foox~ or ~barx~.
2. To enclose a *complicated expression* for the postfix operators ~*~, ~+~ and ~?~ to operate on. Thus, ~ba\(na\)*~ matches ~bananana~, etc., with any (zero or more) number of ~na~ strings.
3. To *record* a <<matched substring>> for future reference.

Capture pattern. ~\\(pattern\\)~

**** \d
Matches the same text that matched the ~dth~ occurrence of a ~\( … \)~ construct. This is called a *back reference*.

After the end of a ~\( … \)~ construct, the matcher remembers the beginning and end of the text matched by that construct. Then, later on in the regular expression, you can use ~\~ followed by the digit ~d~ to mean “match the same text matched the ~dth~ time by the ~\( … \)~ construct”.

For example, ~\(.*\)\1~ matches any newline-free string that is composed of two identical halves. The ~\(.*\)~ matches the first half, which may be anything, but the ~\1~ that follows must match the same exact text.

If a particular ~\( … \)~ construct matches more than once (which can easily happen if it is followed by ~*~), only the last match is recorded.

Note: The construct ~\d~ for any digit is not supported, use ~[0-9]~ or ~[[:digit:]]~ instead.

**** \w
Matches any word-constituent *character*. The syntax table determines which characters these are.

Note: The construct ~\w~ for any word is not always supported, use ~[[:word:]]~ instead.

**** \W
Matches any *character* that is not a word-constituent.

*** misc
**** \`
Matches the empty string, but only at the *beginning of the string or buffer* (or its accessible portion) being matched against.

~\`…~ Beginning of {string, buffer}

**** \'
Matches the empty string, but only at the *end of the string or buffer* (or its accessible portion) being matched against.

~…\'~ End of {string, buffer}

**** \(?: … \)
Specifies a shy group that does not record the [[matched substring]]; you can~t refer back to it with ~\d~. This is useful in mechanically combining regular expressions, so that you can add groups for syntactic purposes without interfering with the numbering of the groups that are meant to be referred to.

**** \=
Matches the empty string, but only at point.

**** \<
Matches the *empty string*, but only at the *beginning of a word*.

~\<~ matches at the beginning of the buffer only if a word-constituent character follows.

**** \>
Matches the *empty string*, but only at the *end of a word*.

~\>~ matches at the end of the buffer only if the contents end with a word-constituent character.

**** \sc
Matches any character whose syntax is ~c~. Here ~c~ is a character which represents a syntax code: thus, ~w~ for word constituent, ~-~ for whitespace, ~(~ for open parenthesis, etc.

**** \Sc
Matches any character whose syntax is not ~c~.

** Classes

| /Character/    | /Class Description/                         |
|--------------+-------------------------------------------|
| /[:digit:]/    | a digit, same as [0-9]                    |
| /[:alpha:]/    | a letter (an alphabetic character)        |
| /[:alnum:]/    | a letter or a digit(an alphanumeric char) |
| /[:upper:]/    | a letter in uppercase                     |
| /[:lower:]/    | a letter in lowercase                     |
| /[:graph:]/    | a visible character                       |
| /[:print:]/    | a visible character plus the space char   |
| /[:space:]/    | a whitespace char,typically [\t\r\n\v\f]  |
| /[:blank:]/    | a space or tab character                  |
| /[:xdigit:]/   | an hexadecimal digit                      |
| /[:cntrl:]/    | a control character                       |
| /[:ascii:]/    | an ascii character                        |
| /[:nonascii:]/ | any non ascii character                   |

*Syntax Class Usage*:
One must remember that *syntax classes must be used within square brackets*, as one would in specifying any other sequence to match or reject: e.g. ~[[:upper:]\|[:digit:]\.]~. This is easy to overlook when using square-bracket-delimited syntax classes, since they include their own square brackets! E.g., if searching for a single whitespace character in a regexp, this

#+begin_src emacs-lisp

  [:space:]

#+end_src

will *fail*. Just remember to add a 2nd/outer pair of square brackets: e.g., this

#+begin_src emacs-lisp

  [[:space:]]

#+end_src

will succeed in finding a single whitespace character, this

#+begin_src emacs-lisp

  [[:space:]]*

#+end_src

will succeed in finding zero-or-more single whitespace characters, etc.

** Examples
*** End of sentence
End of a sentence together with any whitespace that follows. It is the value of the variable ~sentence-end~.

#+begin_src emacs-lisp

  "[.?!][]\"')}]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"

  ;; or in contrast, if you evaluate the variable sentence-end
  "[.?!][]\"')}]*\\($\\| $\\|  \\|  \\)[
  ]*"
  ;; In this output, tab and newline appear as themselves.


  ;; With rx expressions
  (rx (any ".?!")                    ; Punctuation ending sentence.
      (zero-or-more (any "\"')]}"))  ; Closing quotes or brackets.
      (or line-end
          (seq " " line-end)
          "\t"
          "  ")                      ; Two spaces.
      (zero-or-more (any "\t\n ")))  ; Optional extra whitespace.

  ;; =>

  "[!.?][]\"')}]*\\(?:$\\| $\\|	\\|  \\)[
   ]*"

#+end_src

~[.?!]~ match with one of three characters, a period, a question mark and an exclamation mark.

~[]\"')}]*~ matches any closing braces and quotation marks, zero or more of them, that may follow the period, question mark or exclamation mark.

~\\($\\| \\|\t\\| \\)~ matches the whitespace that follows the end of a sentence: the end of a line, or a tab, or two spaces. The parentheses mark the group and the vertical bars separate alternatives. The dollar sign is used to match the end of a line.

~[ \t\n]*~ matches any additional whitespace beyond the minimum needed to end a sentence.

*** At least one character that is a word or symbol

#+begin_src emacs-lisp

  "\\(\\w\\|\\s_\\)+"

#+end_src

The ~\\(~ is the first part of the grouping construct that includes the ~\\w~ and the ~\\s_~ as alternatives, separated by the ~\\|~. The ~\\w~ matches any word-constituent character and the ~\\s_~ matches any character that is part of a symbol name but not a word-constituent character. The ~+~ following the group indicates that the word or symbol constituent characters must be matched at least once.

*** Word or symbol followed optionally by
Word or symbol constituents are followed optionally by characters that are not white space and then followed optionally by white space.

#+begin_src emacs-lisp

  "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"

#+end_src

*** Replace the decimal point by a comma
Here are two ways to replace the decimal point by a comma (~1.5 -> 1,5~), first by an interactive command, second by executing Lisp code (type ~C-x C-e~ after the expression to get it executed).

Note: The construct ~\d~ for any digit is not supported, use ~[0-9]~ or ~[:digit:]~ instead.

#+begin_src emacs-lisp

  M-x replace-regexp RET \([0-9]+\)\. RET \1, RET

  (while (re-search-forward "\\([0-9]+\\)\\." nil t)
    (replace-match "\\1,"))

#+end_src

*** Detect consecutive duplicate words

#+begin_src emacs-lisp

  ;; \\(\\w+[ \t\n]+\\)\\1
  ;; This regexp matches one or more word-constituent characters followed
  ;; by one or more spaces, tabs, or newlines. However, it does not detect
  ;; duplicated words on different lines, since the ending of the first
  ;; word, the end of the line, is different from the ending of the second
  ;; word, a space

  ;; \\(\\(\\w+\\)\\W*\\)\\1
  ;; Another possible regexp searches for word-constituent characters
  ;; followed by non-word-constituent characters, reduplicated. Here,
  ;; ‘\\w+’ matches one or more word-constituent characters and ‘\\W*’
  ;; matches zero or more non-word-constituent characters. Again, not
  ;; useful.

  ;; Here is the pattern that I use. It is not perfect, but good enough.
  \\b\\([^@ \n\t]+\\)[ \n\t]+\\1\\b
  ;; ‘\\b’ matches the empty string, provided it is at the beginning or end
  ;; of a word; ‘[^@ \n\t]+’ matches one or more occurrences of any
  ;; characters that are not an @-sign, space, newline, or tab.

#+end_src

*** Mix

#+begin_src emacs-lisp

  ;; Delete new lines
  ;; replacing "\n" by "^$"

  ;; Empty line
  "^$"

  ;; Word with 20 letters or more
  "\\w\\{20,\\}"

  ;; Year 1900-2099
  "\\(19\\|20\\)[0-9]\\{2\\}"

  ;;At least 6 symbols
  "^.\\{6,\\}"

  ;; Capture text between double quotes.
  ;; "\([^"]+\)" ;; or ;; "\([^"]+?\)"
  ;; \"\\([^\"]+\\)\" ;; or ;; \"\\([^\"]+?\\)\"

  ;; To truncate decimals to 3 places, e.g. 0.123456 -> 0.123
  "\([0-9]\)\.\([0-9][0-9][0-9]\)[0-9]+"
  ;;and replace it with
  "\1.\2."

  ;; Digit or + or - sign.
  [-+[:digit:]]

  ;; Decimal number (-2 or 1.5 but not .2 or 1.).
  \(\+\|-\)?[0-9]+\(\.[0-9]+\)?

  ;; Two consecutive, identical words.
  \&lt;\(\w+\) +\1\&gt;

  ;; Word starting with an uppercase letter.
  \&lt;[[:upper:]]\w*

  ;; Trailing whitespaces (note the starting SPC).
  +$

  ;; Regexp that matches the string 'sometext1:sometext2' with
  ;; 'sometext1' and not 'sometext1:sometext2'
  ^[^:]+:

#+end_src

** Commands descriptions

| /Command/              | /Description/                             |
|------------------------+-------------------------------------------|
| /C-M-s/                | incremental forward search regexp         |
| /C-M-r/                | incremental backward search regexp        |
| /query-replace-regexp/ | same, but query before each replacement   |
| /replace-regexp/       | replace string matching regexp            |
| /dired-do-query-re/    | replace maked files in dired              |
| /replace-string/       | find & replace in 1 shot without asking   |
| /replace-regexp/       | same replace-string but with regexp       |
| /highlight-regexp/     | highlight strings matching regexp         |
| /unhighlight-regexp/   | remove highlighting                       |
| /occur/list-match lin/ | show lines containing a match             |
| /multi-occur/          | show lines in all buffers contain a match |
| /how-many/             | count the number of strings match regexp  |
| /keep-lines/           | delete all lines except contain match     |
| /flush-lines/          | delete lines containing matches           |
| /align-regexp/         | alig using strings match regex delimiters |

Note that ~list-matching-lines~ is an alias for ~occur~ and ~delete-matching-lines~ is an alias for ~flush-lines~.

** Rx
A nifty macro that generates regular expressions for you, from reasonably-comprehensible s-expressions. This notation is usually easier to read, write and maintain than regexp strings, and can be indented and commented freely. It requires a conversion into string form since that is what regexp functions expect, but that conversion typically takes place during byte-compilation rather than when the Lisp code using the regexp is run.

The ~rx~ notation is mainly useful in Lisp code; it cannot be used in most interactive situations where a regexp is requested, such as when running ~query-replace-regexp~ or in variable customization.

When given just a single string argument, it acts just like ~regexp-to-string~.

Here is an ~rx~ regexp that matches a block comment in the C programming language:

#+begin_src emacs-lisp

  (rx "/*"                          ; Initial /*
      (zero-or-more
       (or (not (any "*"))          ;  Either non-*,
           (seq "*"                 ;  or * followed by
                (not (any "/")))))  ;  non-/
      (one-or-more "*")             ; At least one star,
      "/")                          ; and the final /

  ;; =>
  "/\\*\\(?:[^*]\\|\\*[^/]\\)*\\*+/"

  ;; or, using shorter synonyms and written more compactly,
  (rx "/*"
      (* (| (not "*")
            (: "*" (not "/"))))
      (+ "*") "/")

  ;; other example
  (rx bol
      (zero-or-more blank)
      (one-or-more digit)
      ":")
  ;; =>
  "^[[:blank:]]*[[:digit:]]+:"

#+end_src

** Search
*** Consult asynchronous search
Consult has support for asynchronous generation of candidate lists. This feature is used for search commands like consult-grep, where the list of matches is generated dynamically while the user is typing a regular expression. The grep process is executed in the background. When modifying the regular expression, the background process is terminated and a new process is started with the modified regular expression.

The matches, which have been found, can then be narrowed using the installed Emacs completion-style. This can be powerful if you are using for example the ~orderless~ completion style.

This two-level filtering is possible by splitting the input string. Part of the input string is treated as input to grep and part of the input is used for filtering. There are multiple splitting styles available, configured in ~consult-async-split-styles-alist~: ~nil~, ~comma~, ~semicolon~ and ~perl~. The default splitting style is configured with the variable consult-async-split-style.

With the ~comma~ and ~semicolon~ splitting styles, the first word before the comma or semicolon is passed to grep, the remaining string is used for filtering. The ~nil~ splitting style does not perform any splitting, the whole input is passed to grep.

The ~perl~ splitting style splits the input string at a punctuation character, using a similar syntax as Perl regular expressions.

Examples:

#+begin_src emacs-lisp

  ;; Search for “defun” using grep.
  #defun

  ;; Search for both “consult” and “embark” using grep in any order.
  #consult embark

  ;; Search for “first” followed by “second” using grep.
  #first.*second

  ;; Search for “consult” or “embark” using grep. Note the usage
  ;; of Emacs-style regular expressions.
  #\(consult\|embark\)

  ;; Search for “defun” using grep, filter with the word “consult”.
  #defun#consult

  ;; It is also possible to use other punctuation characters.
  /defun/consult

  ;; Force searching for “to” using grep, since the grep pattern
  ;; must be longer than consult-async-min-input characters by default.
  #to#

  ;; Pass argument --invert-match to grep.
  #defun -- --invert-match#

#+end_src

*** Orderless package
**** Consecutive and not consecutive words

1. there are
2. there         are
3. are there
4. there some words here are
5. thereare
6. thereZare
7. there}are

#+begin_src emacs-lisp

  M-x consult-line: there\ are
  ;;1. there are

  M-x consult-line: there.are
  ;;1. there are
  ;;6. thereZare
  ;;7. there}are

  M-x consult-line: there.*are
  ;;1. there are
  ;;2. there         are
  ;;4. there some words here are
  ;;5. thereare
  ;;6. thereZare
  ;;7. there}are

#+end_src

**** Two different searches in one

#+begin_src emacs-lisp

  M-x consult-line: js
  ;; Search for "js"

  M-x consult-line: console
  ;; Search for "console"

  M-x consult-line: js\|console
  ;; Search for "js" and also search for "console"

#+end_src

**** Literal word

1. casa
2. lacasa
3. la casa
4. otra la casa
5. la la casa
6. lal casa

#+begin_src emacs-lisp

  M-x consult-line: \<casa\>
  ;; 1. casa
  ;; 3. la casa
  ;; 4. otra la casa
  ;; 5. la la casa
  ;; 6. lal casa

  M-x consult-line: \bcasa\b
  ;; 1. casa
  ;; 3. la casa
  ;; 4. otra la casa
  ;; 5. la la casa
  ;; 6. lal casa

#+end_src

**** Whitespace
Backward slash ( ~\~ ) + whitespace (    )

1. lacasablanca
2. la casa blanca
3. lacasa blanca
4. la casablanca

#+begin_src emacs-lisp

  M-x consult-line: \ casa
  ;; 2. la casa blanca
  ;; 4. la casablanca

  M-x consult-line: \ casa\
  ;; 2. la casa blanca

#+end_src

**** Literal symbol (& .)

#+begin_src emacs-lisp

  M-x consult-line: =&
  ;; command &

  M-x consult-line: =.
  ;; Detach a process /command/ from the shell and put it in the "background".

#+end_src

** Notes
*** BREs vs EREs
Emacs regular expressions have a syntax closer to EREs than to BREs, with some extensions.

With BRE, the following metacharacters are recognized, all other characters are considered literals:
~^ $ . [ ] *~

With ERE, the following metacharacters (and their associated functions) are added:
~( ) { } ? + |~

However, the ~(~ , ~)~ , ~{~ , and ~}~ characters are treated as metacharacters in BRE if they are escaped with a backslash, whereas with ERE, preceding any metacharacter with a backslash causes it to be treated as a literal.

Here is a summary of how POSIX BREs and EREs differ from Emacs regular expressions:

- In POSIX BREs ~+~ and ~?~ are not special. The only backslash escape sequences are ~\(…\)~, ~\{…\}~, ~\1~ through ~\9~, along with the escaped special characters ~\$~, ~\*~, ~\.~, ~\[~, ~\\~, and ~\^~. Therefore ~\(?:~ acts like ~\([?]:~. POSIX does not define how other BRE escapes behave; for example, GNU grep treats ~\|~ like Emacs does, but does not support all the Emacs escapes.

- In POSIX BREs, it is an implementation option whether ~^~ is special after ~\(~; GNU grep treats it like Emacs does. In POSIX EREs, ~^~ is always special outside of bracket expressions, which means the ERE ~x^~ never matches. In Emacs regular expressions, ~^~ is special only at the beginning of the regular expression, or after ~\(~, ~\(?:~ or ~\|~.

- In POSIX BREs, it is an implementation option whether ~$~ is special before ~\)~; GNU grep treats it like Emacs does. In POSIX EREs, ~$~ is always special outside of bracket expressions (see bracket expressions), which means the ERE ~$x~ never matches. In Emacs regular expressions, ~$~ is special only at the end of the regular expression, or before ~\)~ or ~\|~.

- In POSIX EREs ~{~, ~(~ and ~|~ are special, and ~)~ is special when matched with a preceding ~(~. These special characters do not use preceding backslashes; ~(?~ produces undefined results. The only backslash escape sequences are the escaped special characters ~\$~, ~\(~, ~\)~, ~\*~, ~\+~, ~\.~, ~\?~, ~\[~, ~\\~, ~\^~, ~\{~ and ~\|~. POSIX does not define how other ERE escapes behave; for example, GNU ~grep -E~ treats ~\1~ like Emacs does, but does not support all the Emacs escapes.

- In POSIX BREs and EREs, undefined results are produced by repetition operators at the start of a regular expression or subexpression (possibly preceded by ~^~), except that the repetition operator ~*~ has the same behavior in BREs as in Emacs. In Emacs, these operators are treated as ordinary.

- In BREs and EREs, undefined results are produced by two repetition operators in sequence. In Emacs, these have well-defined behavior, e.g., ~a**~ is equivalent to ~a*~.

- In BREs and EREs, undefined results are produced by empty regular expressions or subexpressions. In Emacs these have well-defined behavior, e.g., ~\(\)*~ matches the empty string,

- In BREs and EREs, undefined results are produced for the named character classes ~[:ascii:]~, ~[:multibyte:]~, ~[:nonascii:]~, ~[:unibyte:]~, and ~[:word:]~.

- BREs and EREs can contain collating symbols and equivalence class expressions within bracket expressions, e.g., ~[[.ch.]d[=a=]]~. Emacs regular expressions do not support this.

- BREs, EREs, and the strings they match cannot contain encoding errors or NUL bytes. In Emacs these constructs simply match themselves.

- BRE and ERE searching always finds the longest match. Emacs searching by default does not necessarily do so. See Longest-match searching for regular expression matches.

*** Wikibooks notes
Notes on regular expressions used in text editor Emacs:

- For backslash escaping (magic vs literal), Emacs uses a mixture of BRE and ERE. Like in ERE, Emacs supports unescaped ~+~ , ~?~ . Like in BRE, Emacs supports escaped ~\(~ , ~\)~ , ~\|~ , ~\{~ , ~\}~ .
- GNU extensions to regular expressions supported by Emacs include ~\w~ , ~\W~ , ~\b~ , ~\B~ , ~\<~ , ~\>~ , ~\`~  , ~\'~ (start and end of buffer)
- No ~\s~ like in PCRE; whitespace is matched by ~\s-~ .
- No ~\d~ like in PCRE; use ~[0-9]~ or ~[[:digit:]]~
- No lookahead and no lookbehind like in PCRE
- Emacs regexp can match characters by syntax using mode-specific syntax tables ( ~\sc~ , ~\s-~ , ~\s ~ ) or by categories ( ~\cc~ , ~\cg~ ).

- Regexp commands use regex to search. So, if you simply want to search plain words or phrases, and if your phrase contains any of regex characters, you need to escape them. Here's some commonly used regex characters that you'll need to place a backslash before it: ~[ ] \ + * ?~ .

*** Using lisp expressions ( ~\,~ )
*Xah*
If you are doing a regex search, and you want to force the replacement to upper case or lower case, in the replace prompt, give ~\,(upcase \1)~ or ~\,(downcase \1)~.

For example, suppose you have this text:

#+begin_example

  once upon a time.
  There is a dragon who lived in the river.
  princess Tana is still waiting for her prince.

#+end_example

Suppose you want all paragraphs to start with a capital letter. So, you use a pattern that catches the first letter of each line, like this ~^\([a-z]\)~.

To make your captured pattern upper case, give your replacement string this expression: ~^\,(upcase \1)~. The ~\,~ tells emacs that what follows should be a lisp expression. The ~(upcase \1)~ is a lisp expression. The ~upcase~ is a lisp function and the ~\1~ means the 1st captured string in your regex pattern.

*** Case replace
- By default, the case of the replaced text is smartly dependent on the matched text. For example, if you want to replace ~dragon~ for ~here~ in this ~{here, Here, HERE}~ the result will be ~{dragon, Dragon, DRAGON}~. If you want the letter case of your replacement string be exactly as you have it, you need to set the variable ~case-replace~ to ~nil~.

- When using ~[a-z]~, it is not case sensitive by default. Case sensitivity is controlled by the variable ~case-fold-search~. Call ~toggle-case-fold-search~ to toggle it.

*** Insert literals
- To insert a literal *tab*, ~C-q C-i~.

- To insert a *newline*, press ~C-q C-j~.

*** Miscellaneous
- Do not use ~[A-z]~, because that'll match some punctuation chars too. Use ~[A-Za-z]~.

- Unicode character can be used literally. But for non-printable ones such as “RIGHT-TO-LEFT MARK”, you can represent them by a code.

- whitespace ~[[:space:]]~

*Warning*: the meaning of a character class in emacs is dependent on the current major mode's syntax table. For example, what chars are considered “word” in ~[[:word:]]~ depends on how its defined in syntax table of current major mode.

*** Grouping subexpressions
*Note*: in the grouping expressions with parentheses followed by a sing, something like ~(hoo+)+~ the outer loop matcher (the second ~+~) takes the *regular expression* inside the parentheses to do the search, *not the match*; e.g. in the string ~Boohoooohoohooo~ what it uses is ~hoo+~ (regexp), not ~hoooo~ (match). The last match is taken as a future reference (~$1~).

#+begin_src javascript

  let cartoonCrying  = /boo+(hoo+)+/i;
  console.log(cartoonCrying.test("Boohoooohoohooo"));  // → true
  // The first and second + characters apply only to the second 'o' in boo
  // and hoo, respectively. The third + applies to the whole group (hoo+),
  // matching one or more sequences like that.

  console.log(cartoonCrying.exec("Boohoooohoohooo"))
  console.log(cartoonCrying.exec("Boohoooohohooo"))
  console.log(cartoonCrying.exec("Boohoooohoohooooooooooo"))
  console.log(cartoonCrying.exec("Boo7hoooohoohooo"))

  // [ 'Boohoooohoohooo'        , 'hooo'         ]
  // [ 'Boohoooo'               , 'hoooo'        ]
  // [ 'Boohoooohoohooooooooooo', 'hooooooooooo' ]
  // null

  console.log(/boo+(hoo)+/i.exec("Boohoooohoohooo"));
  // [ 'Boohoo'                 , 'hoo'          ]

#+end_src

* Emacs
** Loading
*** Brief
Loading a file of Lisp code means bringing its contents into the Lisp environment in the form of Lisp objects. *Emacs finds and opens the file, reads the text, evaluates each form, and then closes the file*. Such a file is also called a /Lisp library/.

The load functions evaluate all the expressions in a file just as the ~eval-buffer~ function evaluates all the expressions in a buffer. The difference is that the load functions read and evaluate the text in the file as found on disk, not the text in an Emacs buffer.

The loaded file must contain Lisp expressions, either as source code or as byte-compiled code. Each form in the file is called a /top-level/ form. There is no special format for the forms in a loadable file; any form in a file may equally well be typed directly into a buffer and evaluated there. (Indeed, most code is tested this way.) Most often, the forms are function definitions and variable definitions.

Emacs can also load compiled dynamic modules: shared libraries that provide additional functionality for use in Emacs Lisp programs, just like a package written in Emacs Lisp would. When a dynamic module is loaded, Emacs calls a specially-named initialization function which the module needs to implement, and which exposes the additional functions and variables to Emacs Lisp programs.

*** Load
**** Brief
You can use a ~load~ command to evaluate a complete file and thereby install all the functions and variables in the file into Emacs. For example:

#+begin_src emacs-lisp

  (load "~/emacs/slowsplit")

#+end_src

This *evaluates*, i.e., *loads*, the ~slowsplit.el~ file or if it exists, the faster, byte compiled ~slowsplit.elc~ file from the ~emacs~ sub-directory of your home directory.

#+begin_src emacs-lisp

  ;; Load the installed Lisp library named foo
  (load "foo")
  ;; When the argument to load is a relative file name, not starting
  ;; with ‘/’ or ‘~’, load searches the directories in load-path.

#+end_src

If you load many extensions, then instead of specifying the exact location of the extension file, you can specify that directory as part of Emacs’s [[Load path][load-path]]. Then, when Emacs loads a file, it will search that directory as well as its default list of directories.

#+begin_src emacs-lisp

  ;; Adds your ~/emacs directory to the existing load path:
  (setq load-path (cons "~/emacs" load-path))

#+end_src

**** Load file
To *load* an Emacs Lisp file, type ~M-x load-file~. This command *reads a file name using the minibuffer*, and executes the contents of that file as Emacs Lisp code. It is not necessary to visit the file first; this command reads the file directly from disk, not from an existing Emacs buffer.

**** Load library
If an Emacs Lisp *file is installed in the Emacs Lisp* [[Load path][load path]], you can load it by typing ~M-x load-library~, instead of using ~M-x load-file~. The ~M-x load-library~ command prompts for a /library name/ rather than a file name; it searches through each directory in the Emacs Lisp load path, trying to find a file matching that library name.

Emacs Lisp programs usually load Emacs Lisp files using the ~load~ function. This is similar to ~load-library~, but is lower-level and accepts additional arguments.

**** Unloading
You can discard the functions and variables loaded by a library to reclaim memory for other Lisp objects. To do this, use the function ~unload-feature~.

**** Hooks for loading
You can ask for code to be executed each time Emacs loads a library, by using the variable ~after-load-functions~:

This abnormal hook is run after loading a file. Each function in the hook is called with a single argument, the absolute filename of the file that was just loaded.

If you want code to be executed when a *particular* library is loaded, use the macro ~with-eval-after-load~:

This macro arranges to evaluate /body/ at the end of loading the file /library/, each time /library/ is loaded. If /library/ is already loaded, it evaluates body right away.

#+begin_src emacs-lisp

  (with-eval-after-load "js" (keymap-set js-mode-map "C-c C-c" 'js-eval))

#+end_src

/library/ can also be a feature (i.e., a symbol), in which case /body/ is evaluated at the end of any file where ~(provide library)~ is called.

Normally, well-designed Lisp programs should not use ~with-eval-after-load~. If you need to examine and set the variables defined in another library (those meant for outside use), you can do it immediately—there is no need to wait until the library is loaded. If you need to call functions defined by that library, you should load the library, preferably with [[require feature][require]].

**** Which file defined a certain symbol
The ~symbol-file~ function returns the name of the file that defined /symbol/.

The value is normally an absolute file name. It can also be ~nil~, if the definition is not associated with any file. If /symbol/ specifies an autoloaded function, the value can be a relative file name without extension.

The basis for ~symbol-file~ is the data in the variable ~load-history~.

The value of this variable is an *alist that associates the names of loaded library files with the names of the functions and variables they defined*, as well as the features they provided or required.

Each element in this alist describes one loaded library (including libraries that are preloaded at startup).

The value of ~load-history~ may have one element whose CAR is ~nil~. This element describes definitions made with ~eval-buffer~ on a buffer that is not visiting a file.

The command ~eval-region~ updates ~load-history~, but does so by adding the symbols defined to the element for the file being visited, rather than replacing that element.

**** site-wide
In addition to your personal initialization file, Emacs automatically loads various site-wide initialization files, if they exist. These have the same form as your ~.emacs~ file, but are loaded by everyone.

Two site-wide initialization files, ~site-load.el~ and ~site-init.el~, are loaded into Emacs and then dumped if a dumped version of Emacs is created, as is most common.

Three other site-wide initialization files are loaded automatically each time you start Emacs, if they exist. These are ~site-start.el~ (it pretty much means a init file for all users of this emacs installation), which is loaded /before/ your ~.emacs~ file, and ~default.el~, and the terminal type file, which are both loaded /after/ your ~.emacs~ file.

Settings and definitions in your ~.emacs~ file will overwrite conflicting settings and definitions in a ~site-start.el~ file, if it exists; but the settings and definitions in a ~default.el~ or terminal type file will overwrite those in your ~.emacs~ file. (You can prevent interference from a terminal type file by setting ~term-file-prefix~ to ~nil~.)

The ~INSTALL~ file that comes in the distribution contains descriptions of the ~site-init.el~ and ~site-load.el~ files.

The ~loadup.el~, ~startup.el~, and ~loaddefs.el~ files control loading. These files are in the lisp directory of the Emacs distribution and are worth perusing.

*** Load path
The Emacs Lisp load path is specified by the variable ~load-path~. Its value should be a list of directories (strings). These directories are searched, in the specified order, by the [[Load library][M-x load-library]] command, the lower-level [[Load][load]] function, and other Emacs functions that find Emacs Lisp libraries.

The default value of ~load-path~ is a list of directories where the Lisp code for Emacs itself is stored. If you have libraries of your own in another directory, you can add that directory to the load path.

#+begin_src emacs-lisp

  ;; Add a directory (not need to end with a slash) to load-path:
  (add-to-list 'load-path "/path/to/my/lisp/library")
  ;; Adding a directory to variable load-path does not also add any of
  ;; its descendants (its subdirectories, their subdirectories, and
  ;; so on, recursively)

#+end_src

It is customary to put locally installed libraries in the ~site-lisp~ directory that is already in the default value of ~load-path~, or in some subdirectory of ~site-lisp~. This way, you don’t need to modify the default value of ~load-path~.

On GNU/Linux, the default value of ~load-path~ includes two special directories and their descendants: ~/usr/local/share/emacs/VERSION/site-lisp~ and ~/usr/local/share/emacs/site-lisp~ . The first directory contains packages for a particular Emacs version; the second contains packages for all installed versions of Emacs. These directories contain files for the current site, for use by the system administrator when installing software locally.

~~/.emacs.d/~, on the other hand, contains files for the current user, and is independent of system-wide changes. This makes it the best choice for storing your personal changes. Installing all packages in a sub-directory of ~~/.emacs.d/~ also makes it very easy to move them along with your configuration to a different machine.

*** Autoload
**** Brief
The /autoload/ facility lets you *register the existence of a function or macro, but put off loading the file that defines it*. The first call to the function automatically loads the proper library, in order to install the real definition and other associated code, then runs the real definition as if it had been loaded all along.

Autoloading can also be triggered by looking up the documentation of the function or macro, and completion of variable and function names.

There are two ways to set up an autoloaded function: by calling ~autoload~, and by writing a “magic” comment in the source before the real definition. ~autoload~ is the low-level primitive for autoloading; any Lisp program can call ~autoload~ at any time.

Magic comments are the most convenient way to make a function autoload, for packages installed along with Emacs. These comments do nothing on their own, but they serve as a guide for the command ~loaddefs-generate~, which constructs calls to ~autoload~ and arranges to execute them when Emacs is built.

The ~M-x compile~ command is autoloaded; if you call it, Emacs automatically loads the "compile" library first. In contrast, the command ~M-x recompile~ is not autoloaded, so it is unavailable until you load the compile library.

To tell Emacs to find the definition for the function ~myfunction~ by loading a Lisp library named ~mypackage~ (i.e., a file ~mypackage.elc~ or ~mypackage.el~):

#+begin_src emacs-lisp

  ;; The autoload object has this form:
  (autoload filename docstring interactive type)

  ;; Will load mypackage.elc or mypackage.el when myfunction is invoked.
  (autoload 'myfunction "mypackage" "Do what I say." t)
  ;; The string "Do what I say." is the function’s documentation string.
  ;; You specify it in the autoload definition so it will be available
  ;; for help commands even when the package is not loaded.
  ;; The last argument, t, indicates that this function is interactive.

  ;; Loads my-shining-package.elc unconditionally.
  (require 'my-shining-package)

#+end_src

Once you put your library in a directory where Emacs can find and load it, you may wish to make it available at startup. This is useful when the library defines features that should be available automatically on demand, and manually loading the library is thus inconvenient. In these cases, make sure the library will be loaded by adding suitable forms to your init file: either ~load~ or [[require feature][require]] (if you always need to load the library at startup), or ~autoload~ if you need Emacs to load the library when some command or function is invoked.

Do not add an autoload comment unless it is really necessary. Autoloading code means it is always globally visible. Once an item is autoloaded, there is no compatible way to transition back to it not being autoloaded (after people become accustomed to being able to use it without an explicit load).

The most common items to autoload are the interactive entry points to a library. For example, if ~python.el~ is a library defining a major-mode for editing Python code, autoload the definition of the ~python-mode~ function, so that people can simply use ~M-x python-mode~ to load the library.

**** Magic comment
A magic autoload comment (often called an /autoload cookie/) consists of ~;;;###autoload~, on a line by itself, just before the real definition of the function in its autoloadable source file. The function ~loaddefs-generate~ writes a corresponding autoload call into ~loaddefs.el~. Building Emacs loads ~loaddefs.el~ and thus calls autoload.

You can also use a magic comment to execute a form at build time /without/ executing it when the file itself is loaded. To do this, write the form on the /same/ line as the magic comment. Since it is in a comment, it does nothing when you load the source file; but ~loaddefs-generate~ copies it to ~loaddefs.el~, where it is executed while building Emacs.

The following example shows how ~doctor~ is prepared for autoloading with a magic comment:

#+begin_src emacs-lisp

  ;;;###autoload
  (defun doctor ()
    "Switch to *doctor* buffer and start giving psychotherapy."
    (interactive)
    (switch-to-buffer "*doctor*")
    (doctor-mode))

#+end_src

Here’s what that produces in ~loaddefs.el~:

#+begin_src emacs-lisp

  (autoload 'doctor "doctor" "\
  Switch to *doctor* buffer and start giving psychotherapy.

  \(fn)" t nil)

#+end_src

**** Notes
- *Reply stack overflow* (“activates” a package, package-initialize)
The Emacs package manager *automatically loads the autoloads file of a package, when it “activates” a package*. Emacs also automatically initializes the package manager and activates all installed packages, but only after your ~init.el~ was processed.

Hence, packages (and this their autoloads as well) are not available while your ~init.el~ is loaded, so you can't use packages in your ~init.el~.

To address this, you can either postpone all your setup to ~after-init-hook~, or force Emacs to initialize the package manager by adding ~(package-initialize)~ at the top of your init file.

BTW, in Emacs-27 we have changed this so that ~package-initialize~ is called before loading ~~/.emacs~.

- *Reply stack overflow* (start Emacs, install Elpa package, [package]-autoloads.el)
When you install an Elpa package, Emacs scans through all the ~.el~ files in the package for autoload tokens and adds stubs for those functions/variables to a ~[package]-autoloads.el~ file. The stubs just attach information to the function/variable symbols that tell Emacs where to find the actual definitions, and what the docstring says. Then it compiles all the ~.el~ files to ~.elc~ files, including the autoloads file.

Then (and every time you start Emacs) it loads and evaluates the ~[package]-autoloads.elc~ file, rather than the ~main .elc~ files. That way it's much faster to load packages, as the main ~.elc~ files will only be loaded when one of the autoloaded symbols is invoked. The other functions/variables in the main ~.el~ files are not known to Emacs until then.

- *Reddit reply* (autoload, start Emacs, example)
Installing, for example, the ~evil~ package with the package manager *will have generated an autoload for* the ~evil-mode~ function, and when ~package-initialize~ is called when you start Emacs *any such autoloads are read and defined*; so when you subsequently call ~(evil-mode 1)~ which is only defined as an autoload, Emacs firstly loads the associated package and then evaluates the function you called, all in one smooth move.

The ~PACKAGENAME-autoloads.el~ file is loaded into Emacs (when ~package-initialize~ runs, which happens automatically). Which is the reason why, you can call ~evil-mode~ without having loaded the rest of the package.

*** Features (provide, require)
**** Features
~provide~ and ~require~ are an alternative to ~autoload~ for *loading files automatically*. They work in terms of named /features/. Autoloading is triggered by calling a specific function, but a feature is *loaded the first time another program asks for it* by name.

A /feature/ name is a *symbol* that stands for a *collection of functions, variables, etc*. The file that defines them should /provide/ the feature. Another program that uses them may ensure they are defined by /requiring/ the feature. This loads the file of definitions if it hasn’t been loaded already.

*Xah*: ~features~ is a elisp symbol that represent a lisp package. It is a global variable, holding a list of elisp symbols that are features. Its purpose is for emacs to know if a package is already loaded.

To require the presence of a feature, call ~require~ with the feature name as argument. ~require~ looks in the global variable ~features~ to see whether the desired feature has been provided already. If not, it loads the feature from the appropriate file. This file should call ~provide~ at the top-level to add the feature to ~features~; if it fails to do so, ~require~ signals an error.

For example, in ~idlwave.el~, the definition for ~idlwave-complete-filename~ includes the following code:

#+begin_src emacs-lisp

  (defun idlwave-complete-filename ()
    "Use the comint stuff to complete a file name."
    (require 'comint)
    (let* ((comint-file-name-chars "~/A-Za-z0-9+@:_.$#%={}\\-")
           (comint-completion-addsuffix nil)
           ...)
      (comint-dynamic-complete-filename)))

#+end_src

The expression ~(require 'comint)~ loads the file ~comint.el~ if it has not yet been loaded, ensuring that ~comint-dynamic-complete-filename~ is defined. Features are normally named after the files that provide them, so that ~require~ need not be given the file name.

The ~comint.el~ file contains the following top-level expression:

#+begin_src emacs-lisp

  (provide 'comint)

#+end_src

This adds ~comint~ to the global ~features~ list, so that ~(require 'comint)~ will henceforth know that nothing needs to be done.

When ~require~ is used at top level in a file, it takes effect when you byte-compile that file as well as when you load it. This is in case the required package contains macros that the byte compiler must know about. It also avoids byte compiler warnings for functions and variables defined in the file loaded with ~require~.

Although top-level calls to ~require~ are evaluated during byte compilation, ~provide~ calls are not. Therefore, you can ensure that a file of definitions is loaded before it is byte-compiled by including a ~provide~ followed by a ~require~ for the same feature, as in the following example.

#+begin_src emacs-lisp

  (provide 'my-feature)  ; Ignored by byte compiler,
                         ;   evaluated by load.
  (require 'my-feature)  ; Evaluated by byte compiler.

#+end_src

The compiler ignores the ~provide~, then processes the ~require~ by loading the file in question. Loading the file does execute the ~provide~ call, so the subsequent ~require~ call does nothing when the file is loaded.

**** provide feature
This function announces that /feature/ is now loaded, or being loaded, into the current Emacs session. This means that the facilities associated with /feature/ are or will be available for other Lisp programs.

The direct effect of calling ~provide~ is to *add feature* to the front of ~features~ if it is not already in that list and call any ~eval-after-load~ code waiting for it. The argument feature must be a symbol. ~provide~ returns /feature/.

#+begin_src emacs-lisp

  features
  ;; (bar bish)

  (provide 'foo)
  ;; ⇒ foo
  features
  ;; ⇒ (foo bar bish)

#+end_src

When a file is loaded to satisfy an autoload, and it stops due to an error in the evaluation of its contents, any function definitions or ~provide~ calls that occurred during the load are undone.

**** require feature
This function *checks* whether /feature/ is present in the current Emacs session (using ~(featurep feature)~). The argument /feature/ must be a symbol.

If the feature is not present, then ~require~ *loads* filename with [[Load][load]]. If filename is not supplied, then the name of the symbol /feature/ is used as the base file name to load. However, in this case, ~require~ insists on finding /feature/ with an added ~.el~ or ~.elc~ suffix (possibly extended with a compression suffix); a file whose name is just /feature/ won’t be used.

Best used in elisp libraries or scripts, similar to other lang's “require” or “import”.

Using ~require~ adds a dependency: Not only must a file with the same name exist, but in that file, Emacs wants to see a statement such as this:

#+begin_src emacs-lisp

  (provide 'foo)

#+end_src

Thus, in your package, you can ~require~ several so-called [[Features][features]]. This will load the files with the same name, and these files must ~provide~ the feature. These features are recorded in the ~features~ variable.

If loading the file succeeds but does not provide /feature/, ~require~ signals an error about the missing feature.

*Note*: reply stack overflow
There is not difference between ~require~ and ~load~ with regards to ~autoload~. ~require~ is just a frontend to ~load~, which more or less comes down to:

#+begin_src emacs-lisp

  (defun require (feature &optional filename noerror)
    (unless (featurep feature)
      (let ((filename (or filename (symbol-name feature))))
        (load filename noerror))))

#+end_src

As you can see, the symbol name given to ~require~ is equal to the filename given to ~load~. As a matter of fact, the first ~(require 'foo)~ evaluated in an Emacs session is equivalent to ~(load "foo")~.

*** Configuring packages
The autoloads for installed packages will automatically be loaded after your /InitFile/ has finished processing, so common commands will be available without any additional configuration. You can also use Customize to change the settings for your installed files.

If you need to configure other settings in your /InitFile/ and you’re running into undefined functions or variables, you can use ~(package-initialize)~ to *set up the load-paths and autoloads for installed packages*. Then you can use ~(require 'package-name)~ to fully load the package, [[Hooks for loading][(with-eval-after-load "package-name" ...)]] or ~(eval-after-load 'package-name ...)~ to run code after a package is loaded, or something like the [[Use package]] macro to organize your package-related configuration.

*** The early init file
Most customizations for Emacs should be put in the normal init file. However, it is sometimes necessary to have customizations take effect during Emacs startup earlier than the normal init file is processed. Such customizations can be put in the early init file, ~~/.config/emacs/early-init.el~ or ~~/.emacs.d/early-init.el~. This file is loaded before the package system and GUI is initialized, so in it you can customize variables that affect the package initialization process, such as ~package-enable-at-startup~, ~package-load-list~, and ~package-user-dir~. Note that variables like ~package-archives~ which only affect the installation of new packages, and not the process of making already-installed packages available, may be customized in the regular init file.

We do not recommend that you move into ~early-init.el~ customizations that can be left in the normal init files. That is because the early init file is read before the GUI is initialized, so customizations related to GUI features will not work reliably in ~early-init.el~. By contrast, the normal init files are read after the GUI is initialized. If you must have customizations in the early init file that rely on GUI features, make them run off hooks provided by the Emacs startup, such as ~window-setup-hook~ or ~tty-setup-hook~.

** Set variable
*** Setq
You can set any Lisp variable with [[setq]], but with certain variables ~setq~ won’t do what you probably want in the init file. Some variables automatically become buffer-local when set with ~setq~; what you want in the init file is to set the default value, using [[Setting default values (setq-default)][setq-default]].

The second argument to ~setq~ is an expression for the new value of the variable. This can be a constant, a variable, or a function call expression. In the init file, constants are used most of the time. They can be:

- Numbers :: numbers are written in decimal, with an optional initial minus sign.

- Strings :: lisp string syntax is the same as C string syntax with a few extra features. Use a double-quote character to begin and end a string constant.

  In a string, you can include newlines and special characters literally. But often it is cleaner to use backslash sequences for them: ~\n~ for newline, ~\b~ for backspace, ~\r~ for carriage return, ~\t~ for tab, ~\f~ for formfeed (control-L), ~\e~ for escape, ~\\~ for a backslash, ~\"~ for a double-quote, or ~\ooo~ for the character whose octal code is ooo. Backslash and double-quote are the only characters for which backslash sequences are mandatory.

  ~\C-~ can be used as a prefix for a control character, as in ~\C-s~ for ASCII control-S, and ~\M-~ can be used as a prefix for a Meta character, as in ~\M-a~ for Meta-A or ~\M-\C-a~ for Ctrl-Meta-A.

- Characters :: lisp character constant syntax consists of a ~?~ followed by either a character or an escape sequence starting with ~\~. Examples: ~?x~ , ~?\n~ , ~?\"~ , ~?\~ ). Note that strings and characters are not interchangeable in Lisp; some contexts require one and some contexts require the other.

- True :: ~t~ stands for “true”.

- False :: ~nil~ stands for “false”.

- Other Lisp objects :: write a single-quote ( ~'~ ) followed by the Lisp object you want.

*** Setting default values (setq-default)
You can set any Lisp variable with [[setq]], but with certain variables ~setq~ won’t do what you probably want in the init file. Some variables automatically become buffer-local when set with ~setq~; what you want in the init file is to set the default value, using ~setq-default~.

Keep in mind that ~setq-default~ does not set the value in the current buffer, only future buffers!

Make searches case sensitive by default (in all buffers that do not override this).

#+begin_src emacs-lisp

  (setq-default case-fold-search nil)

#+end_src

This sets the default value, which is effective in all buffers that do not have local values for the variable. Setting ~case-fold-search~ with ~setq~ affects only the current buffer’s local value, which is probably not what you want to do in an init file.

#+begin_src emacs-lisp

  ;; Text mode the default mode for new buffers
  (setq-default major-mode 'text-mode)

  (setq-default tab-width 2
                evil-shift-width 2)

  ;; BEWARE!  Unexpected results using buffer-local variables:
  (setq-default evil-shift-width tab-width)

  ;; This will create a variable that doesn't exist
  (setq-default will-i-be-created t)

#+end_src

*** Buffer local variables (setq-local)
You can set the value of a variable for the current buffer only using ~setq-local~. Any code that runs in that buffer will receive the buffer-local value instead of the global value!

Why do this? There are many settings that should only be set per buffer, like editor settings for different programming languages and customization variables for major modes.

If the variable isn’t already buffer-local, ~setq-local~ will make it so, but only for the current buffer!

#+begin_src emacs-lisp

  ;; some-value doesn't exist yet!
  (setq some-value 2)
  ;; Make it buffer-local
  (setq-local some-value 4)

#+end_src

You can make any variable local for all future buffers with the ~make-variable-buffer-local~ function:

#+begin_src emacs-lisp

  (setq not-local-yet t)
  (make-variable-buffer-local 'not-local-yet)

#+end_src

If you are writing an Emacs Lisp package and want to provide a buffer-local variable, this is the way to do it!

#+begin_src emacs-lisp

  ;; Defining a variable with defvar and then making it buffer local
  (defvar new-buffer-local-var 311)
  (make-variable-buffer-local 'new-buffer-local-var)

#+end_src

*** Defining customization variables (defcustom)
Customizable variables are used to define user-facing settings for customizing the behavior of Emacs and packages.

You can specify variables using ~defcustom~ so that you and others can then use Emacs’s ~customize~ feature to set their values.

The ~customize~ feature depends on the ~defcustom~ macro. Although you can use [[defvar]] or [[setq]] for variables that users set, the ~defcustom~ macro is designed for the job.

- The first argument to ~defcustom~ is the name of the variable.
- The second argument is the variable’s initial value, if any; and this value is set only if the value has not already been set.
- The third argument is the documentation.
- The fourth and subsequent arguments to defcustom specify types and options; these are not featured in defvar.

#+begin_src emacs-lisp

  ;; the customizable user option variable text-mode-hook looks like this:
  (defcustom text-mode-hook nil
    "Normal hook run when entering Text mode and many related modes."
    :type 'hook ;; tells Emacs the kind of data to which text-mode-hook
    ;; should be set and how to display the value in a
    ;; Customization buffer.
    :options '(turn-on-auto-fill flyspell-mode) ;; specifies a suggested list
    ;; of values for the variable.
    ;; Usually, applies to a hook.
    :group 'wp) ;; tells command in which group the variable is located.

#+end_src

~defcustom~ takes some additional parameters after the documentation string:

-  ~:type~ - The expected value type
-  ~:group~ - The symbol that identifies the “group” this variable belongs to (defined with ~defgroup~)
-  ~:options~ - The list of possible values this variable can hold
-  ~:set~ - A function that will be invoked when this variable is customized
-  ~:get~ - A function that will be invoked when this variable is resolved
-  ~:initialize~ - A function to be used to initialize the variable when it gets defined
-  ~:local~ - When ~t~, automatically marks the variable as buffer-local

Incidentally, to be more complete concerning defines:
~defsubst~ defines an inline function. The syntax is just like that of defun.
~defconst~ defines a symbol as a constant.

*customize-set-variable*
Some customizable minor mode variables do special things to enable the mode when you set them with Customize, but ordinary ~setq~ won’t do that; to enable the mode in your init file, call the minor mode command. Finally, a few customizable user options are initialized in complex ways, and these have to be set either via the customize interface or by using ~customize-set-variable~.

*** set-variable
You could use the ~set-variable~ command to change the value of ~shell-command-default-error-buffer~ temporarily. However, options set using ~set-variable~ are set only for the duration of your editing session. The new values are not saved between sessions.

For me, the major use of the ~set-variable~ command is to suggest variables that I might want to set in my ~.emacs~ file. You can press ~TAB~ after calling the ~M-x set-variable~ command to see the list of variables.

*** File local variables
**** Specifying file variables
There are two ways to specify file local variable values: in the first line, or with a local variables list.

Here’s how to specify them in the first line:

#+begin_src elisp

  ;; -*- mode: modename; var: value; … -*-


  ;; -*- mode: Lisp; fill-column: 75; comment-column: 50; -*-

#+end_src

A local variables list starts with a line containing the string ‘Local Variables:’, and ends with a line containing the string ‘End:’. In between come the variable names and values, one set per line:

#+begin_src c

  /* Local Variables:  */
  /* mode: c           */
  /* comment-column: 0 */
  /* End:              */

#+end_src

If a file has both a local variables list and a ~-*-~ line, Emacs processes everything in the ~- -~ line first, and everything in the local variables list afterward. The exception to this is a major mode specification. Emacs applies this first, wherever it appears, since most major modes kill all local variables as part of their initialization.

*Note*: In shell scripts, the first line is used to identify the script interpreter, so you cannot put any local variables there. To accommodate this, Emacs looks for local variable specifications in the *second* line if the first line specifies an interpreter. The same is true for man pages which start with the magic string ~'\"~ to specify a list of troff preprocessors (not all do, however).

**** Per-directory local variables
Sometimes, you may wish to define the same set of local variables to all the files in a certain directory and its subdirectories, such as the directory tree of a large software project. This can be accomplished with ~directory-local~ variables. File local variables override directory local variables.

The usual way to define directory-local variables is to put a file named ~.dir-locals.el~ in a directory.

You can also use ~.dir-locals-2.el~; if found, Emacs loads it in addition to ~.dir-locals.el~. This is useful when ~.dir-locals.el~ is under version control in a shared repository and can’t be used for personal customizations.

#+begin_src emacs-lisp

  ;; Here’s an example of a .dir-locals.el file:
  ((nil . ((indent-tabs-mode . t)
           (fill-column . 80)
           (mode . auto-fill)))
   (c-mode . ((c-file-style . "BSD")
              (subdirs . nil)))
   ("src/imported"
    . ((nil . ((change-log-default-name
                . "ChangeLog.local"))))))
  ;; This sets the variables ‘indent-tabs-mode’ and fill-column for any
  ;; file in the directory tree, and the indentation style for any C source
  ;; file. The special mode element specifies the minor mode to be
  ;; enabled. So (mode . auto-fill) specifies that the minor mode
  ;; auto-fill-mode needs to be enabled. The special subdirs element is not
  ;; a variable, but a special keyword which indicates that the C mode
  ;; settings are only to be applied in the current directory, not in any
  ;; subdirectories. Finally, it specifies a different ChangeLog file name
  ;; for any file in the src/imported subdirectory.

#+end_src

*** Per-Directory Local Variables
Sometimes, you may wish to define the same set of local variables to all the files in a certain directory and its subdirectories, such as the directory tree of a large software project. This can be accomplished with /directory-local variables/. File local variables override directory local variables, so if some of the files in a directory need specialized settings, you can specify the settings for the majority of the directory’s files in directory variables, and then define file local variables in a few files which need the general settings overridden.

The usual way to define directory-local variables is to put a file named ~.dir-locals.el~ in a directory. Whenever Emacs visits any file in that directory or any of its subdirectories, it will apply the directory-local variables specified in ~.dir-locals.el~, as though they had been defined as file-local variables for that file. Emacs searches for ~.dir-locals.el~ starting in the directory of the visited file, and moving up the directory tree. To avoid slowdown, this search is skipped for remote files. If needed, the search can be extended for remote files by setting the variable ~enable-remote-dir-locals~ to ~t~.

You can also use ~.dir-locals-2~.el; if found in the same directory as ~.dir-locals.el~, Emacs loads it in addition to ~.dir-locals.el~. This is useful when ~.dir-locals.el~ is under version control in a shared repository and can’t be used for personal customizations.

The ~.dir-locals.el~ file should hold a specially-constructed list, which maps major mode names (symbols) to alists. Each alist entry consists of a variable name and the directory-local value to assign to that variable, when the specified major mode is enabled. Instead of a mode name, you can specify  ~nil~, which means that the alist applies to any mode; or you can specify a subdirectory (a string), in which case the alist applies to all files in that subdirectory.

Here’s an example of a ~.dir-locals.el~ file:

#+begin_src emacs-lisp

  ((nil . ((indent-tabs-mode . t)
           (fill-column . 80)
           (mode . auto-fill)))
   (c-mode . ((c-file-style . "BSD")
              (subdirs . nil)))
   ("src/imported"
    . ((nil . ((change-log-default-name
                . "ChangeLog.local"))))))

#+end_src

This sets the variables ~indent-tabs-mode~ and ~fill-column~ for any file in the directory tree, and the indentation style for any C source file. The special mode element specifies the minor mode to be enabled. So ~(mode . auto-fill)~ specifies that the minor mode ~auto-fill-mode~ needs to be enabled. The special subdirs element is not a variable, but a special keyword which indicates that the C mode settings are only to be applied in the current directory, not in any subdirectories. Finally, it specifies a different ChangeLog file name for any file in the ~src/imported~ subdirectory.

** Mode
*** Brief
A /mode/ is a set of definitions that customize the behavior of Emacs in useful ways. It is basically a collection of features that can be applied to a single buffer or to the entire editor.

There are two varieties of modes:
-  major modes :: provide specialized facilities for working on a particular file type, such as a C source file, or a particular type of non-file buffer, such as a shell buffer. Major modes are mutually exclusive; each buffer has one and only one major mode at any time.
- minor modes :: are optional features which you can turn on or off while editing, not necessarily specific to a type of file or buffer. For example, Auto Fill mode is a minor mode in which ~SPC~ breaks lines between words as you type. Minor modes are independent of one another, and of the selected major mode.

*** Major mode
Major modes specialize Emacs for editing or interacting with particular kinds of text. Each buffer has exactly one major mode at a time. Every major mode is associated with a /major mode command/, whose name should end in ~-mode~. This command takes care of switching to that mode in the current buffer, by setting various buffer-local variables such as a local keymap. Note that unlike minor modes there is no way to “turn off” a major mode, instead the buffer must be switched to a different one. However, you can temporarily /suspend/ a major mode and later /restore/ the suspended mode.

The least specialized major mode is called /Fundamental mode/, which has no mode-specific definitions or variable settings, and it does not run any mode hooks, since you are not supposed to customize this mode.

Most modes are divided into three main groups, the first group contains modes for plain text, either plain or markup (/Text mode/. HTML mode, SGML mode, TeX mode and Outline mode). The second contains modes for specific programming languages (/Prog mode/. Lisp (which has several variants), C mode, ...). The third consists of main modes that are not directly associated with files; they are used in buffers created for specific purposes by Emacs (/Special mode/. Dired mode, Message to Mail mode, Shell mode).

Every major mode, apart from Fundamental mode, defines a [[Hooks][mode hook]].

Mode hooks are commonly used to enable [[Minor mode][minor modes]].

#+begin_src emacs-lisp

  ;; Enable Flyspell minor mode in all text-based major modes:
  (add-hook 'text-mode-hook 'flyspell-mode)
  ;; Enable ElDoc minor mode in Emacs Lisp mode:
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)


  ;; Turn on Auto Fill mode automatically in Text mode and related modes.
  (add-hook 'text-mode-hook 'auto-fill-mode)
  ;; You don’t want Auto Fill mode turned on in LaTeX mode,
  ;; which is one of the modes based on Text mode:
  (add-hook 'latex-mode-hook (lambda () (auto-fill-mode -1)))


  ;; Remove a hook:
  (remove-hook 'html-mode-hook 'linum-mode)


  ;; To show paren mode only in programming modes
  (add-hook 'prog-mode-hook #'show-paren-local-mode)

#+end_src

*** Minor mode
A /minor mode/ provides optional features that users may enable or disable independently of the choice of major mode. Minor modes can be enabled individually or in combination.

Most minor modes implement features that are independent of the major mode, and can thus be used with most major modes. For example, Auto Fill mode works with any major mode that permits text insertion. A few minor modes, however, are specific to a particular major mode. For example, Diff Auto Refine mode is a minor mode that is intended to be used only with Diff mode.

Ideally, a minor mode should have its desired effect regardless of the other minor modes in effect. It should be possible to activate and deactivate minor modes in any order.

Some minor modes are /buffer-local/, and can be turned on (enabled) in certain buffers and off (disabled) in others. Other minor modes are /global/: while enabled, they affect everything you do in the Emacs session, in all buffers.

Each minor mode can have its own keymap, which is active when the mode is enabled. To set up a keymap for a minor mode, add an element to the alist ~minor-mode-map-alist~.

Like major modes, each minor mode is associated with a /mode command/, whose name consists of the mode name followed by ~-mode~. But unlike a major mode command, which simply enables the mode, the mode command for a minor mode can either enable or disable it:

- If you invoke the mode command directly with no prefix argument (either via M-x, or by binding it to a key and typing that key), that /toggles/ the minor mode.
- If you invoke the mode command with a prefix argument, the minor mode is unconditionally turned off if that argument is zero or negative; otherwise, it is unconditionally turned on.
- If the mode command is called via Lisp, the minor mode is unconditionally turned on if the argument is omitted or nil. This makes it easy to turn on a minor mode from a major mode’s mode hook A non-~nil~ argument is handled like an interactive prefix argument.

Most minor modes also have a /mode variable/, with the same name as the mode command. Its value is non-~nil~ if the mode is enabled, and ~nil~ if it is disabled.

#+begin_src emacs-lisp

  ;; Enable Flyspell minor mode in all text-based major modes:
  (add-hook 'text-mode-hook 'flyspell-mode)
  ;; Enable ElDoc minor mode in Emacs Lisp mode:
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)

#+end_src

** Hooks
*** Brief
Hooks are an important mechanism for customizing Emacs. A hook is a *Lisp variable which holds a list of functions, to be called on some well-defined occasion*. (This is called /running the hook/.) The individual functions in the list are called the /hook functions/ of the hook. For example, the hook ~kill-emacs-hook~ runs just before exiting Emacs.

A hook is *similar to the concept of events in other systems*. Adding function to a hook is similar to adding event handlers. (note: emacs lisp manual also uses the term “event”, but that is lower level events to emacs, not events by emacs.)

Most major modes run one or more /mode hooks/ as the last step of initialization. This makes it easy for a user to customize the behavior of the mode, by overriding the buffer-local variable assignments already made by the mode. Most minor mode functions also run a mode hook at the end. But hooks are used in other contexts too. For example, the hook ~suspend-hook~ runs just before Emacs suspends itself.

Each mode hook is named after its major mode, e.g., Fortran mode has ~fortran-mode-hook~. Furthermore, all text-based major modes run ~text-mode-hook~, and many programming language modes run ~prog-mode-hook~, prior to running their own mode hooks. Hook functions can look at the value of the variable ~major-mode~ to see which mode is actually being entered.

Major mode hooks also apply to other major modes /derived/ from the original mode. For instance, HTML mode is derived from Text mode; when HTML mode is enabled, it runs ~text-mode-hook~ before running ~html-mode-hook~. In particular, if you want to apply a hook function to any programming language mode, add it to ~prog-mode-hook~; Prog mode is a major mode that does little else than to let other major modes inherit from it, exactly for this purpose.

*** Types of hooks
Most hooks are /normal hooks/. This means that when Emacs runs the hook, it calls each hook function in turn, with no arguments. We have made an effort to keep most hooks normal, so that you can use them in a uniform way. Every variable whose name ends in ~-hook~ is a normal hook. For example, when ~html-mode~ is loaded, ~html-mode-hook~'s functions are run.

A few hooks are /abnormal hooks/. Their names end in ~-functions~, instead of ~-hook~ (some old code may also use the deprecated suffix ~-hooks~). What makes these hooks abnormal is the way its functions are called—perhaps they are given arguments, or perhaps the values they return are used in some way. For example, ~find-file-not-found-functions~ is abnormal because as soon as one hook function returns a non-~nil~ value, the rest are not called at all.

If the name of the variable ends in ~-predicate~ or ~-function~ (singular) then its value must be a function, not a list of functions.

*** Setting a hook
You can set a hook variable with [[setq]] like any other Lisp variable or temporarily with [[let]], but the recommended way to add a function to a hook (either normal or abnormal) is to use ~add-hook~ or remove with ~remove-hook~.

If you play with adding various different versions of a hook function by calling ~add-hook~ over and over, remember that all the versions you added will remain in the hook variable together. You can clear out individual functions by calling ~remove-hook~, or do ~(setq hook-variable nil)~ to remove everything.

If the hook variable is buffer-local, the buffer-local variable will be used instead of the global variable. However, if the buffer-local variable contains the element ~t~, the global hook variable will be run as well.

#+begin_src emacs-lisp

  ;; Set up a hook to turn on Auto Fill mode in Text mode
  ;; and other modes based on Text mode
  (add-hook 'text-mode-hook 'auto-fill-mode)

  ;; Next, suppose you don’t want Auto Fill mode turned on in LaTeX mode,
  ;; which is one of the modes based on Text mode.
  (add-hook 'latex-mode-hook (lambda () (auto-fill-mode -1)))
  ;; The -1 argument disables the minor mode. Because LaTeX mode runs
  ;; latex-mode-hook after running text-mode-hook, the result leaves
  ;; Auto Fill mode disabled.

#+end_src

** Keys
*** Brief
The command bindings (map keys to commands) of input events are recorded in data structures called /keymaps/ (record key bindings). Each entry in a keymap associates (or /binds/) an individual event type, either to another keymap or to a command. When an event type is bound to a keymap, that keymap is used to look up the next input event; this continues until a command is found. The whole process is called key /lookup/.

A key /sequence/, or key for short, is a sequence of one or more input events that form a unit. Input events include characters, function keys, mouse actions, or system events external to Emacs, —all the inputs that you can send to the computer. The Emacs Lisp representation for a key sequence is a string ( =a= -> ~"a"~ , =control= -> ~"\C-"~ , =TAB= -> ~"\t"~ ...) or vector for function keys, mouse button events, system events, or non-ASCII characters ( ~[?\C-x ?l]~ -> ~C-x l~ ).

*Function*: ~kbd keyseq-text~
This function converts the text /keyseq-text/ (a string constant) into a key sequence (a string or vector constant).

#+begin_src emacs-lisp

  (kbd "C-x") ⇒ "\C-x"
  (kbd "C-x C-f") ⇒ "\C-x\C-f"
  (kbd "C-x 4 C-f") ⇒ "\C-x4\C-f"
  (kbd "X") ⇒ "X"
  (kbd "RET") ⇒ "^M"
  (kbd "C-c SPC") ⇒ "\C-c "
  (kbd "<f1> SPC") ⇒ [f1 32]
  (kbd "C-M-<down>") ⇒ [C-M-down]

#+end_src

*Note*: Key sequences that consist of ~C-c~ followed by a letter (upper or lower case; ASCII or non-ASCII) are reserved for users. Emacs itself will never bind those key sequences, and Emacs extensions should avoid binding them. In other words, users can bind key sequences like ~C-c a~ or ~C-c ç~ and rely on these never being shadowed by other Emacs bindings.

*** Keymap basics
A keymap is a Lisp data structure that specifies /key bindings/ for various key sequences (bindings between key sequences and command functions).

Here as an example is the local keymap for Lisp mode, a sparse keymap. It defines bindings for ~DEL~, ~C-c C-z~, ~C-M-q~, and ~C-M-x~ (the actual value also contains a menu binding, which is omitted here for the sake of brevity).

#+begin_src emacs-lisp

  lisp-mode-map
  ⇒
   (keymap
     (3  keymap  (26 . run-lisp))        ;; C-c C-z
     (27 keymap  (24 . lisp-send-defun)) ;; C-M-x, treated as ESC C-x
      ;; This part is inherited from lisp-mode-shared-map.
         keymap  (127 . backward-delete-char-untabify) ;; DEL
     (27 keymap  (17 . indent-sexp)))    ;; C-M-q, treated as ESC C-q

#+end_src

You can use ~define-keymap~, to create a keymap and binds a number of keys. This function creates a new sparse keymap, defines the keystrokes in pairs, and returns the new keymap. Here’s a very basic example:

#+begin_src emacs-lisp

  (define-keymap
    "n" #'forward-line
    "f" #'previous-line
    "C-c C-c" #'quit-window)
  ⇒
  (keymap
   (3 keymap (3 . quit-window))
   (102 . previous-line)
   (110 . forward-line))

#+end_src

*Note*: the difference between use ~#'~ or just ~'~ is that ~#~ tells the person reading the code or the compiler that what follow is specifically a function, not a symbol of any kind.

A /prefix key/ (usually the keymap to use for looking up the following event) is a key sequence whose binding is a keymap. The keymap defines what to do with key sequences that extend the prefix key. For example, ~C-x~ is a prefix key, and it uses a keymap that is also stored in the variable ~ctl-x-map~. This keymap defines bindings for key sequences starting with ~C-x~.

If the binding of a key sequence is a keymap, we call the key sequence a /prefix key/. Otherwise, we call it a /complete key/ (because no more events can be added to it). If the binding is ~nil~, we call the key /undefined/. Examples of prefix keys are ~C-c~ , ~C-x~ , and ~C-x 4~. Examples of defined complete keys are ~X~ , ~RET~ , and ~C-x 4 C-f~. Examples of undefined complete keys are ~C-x C-g~ , and ~C-c 3~.

At any time, several primary keymaps are /active/ —that is, in use for finding key bindings. These are the /global map/ (the most important keymap because it is always in effect), which is shared by *all buffers*; the /local keymap/, which is usually associated with a specific *major mode*; and zero or more /minor mode keymaps/, which belong to currently enabled *minor modes*. (Not all minor modes have keymaps.) The local keymap bindings shadow (i.e., take precedence over) the corresponding global bindings. The minor mode keymaps shadow both local and global keymaps.

For example, a self-inserting character such as ~g~ is self-inserting because the global keymap binds it to the command ~self-insert-command~.

Each keymap is a list whose CAR is the symbol ~keymap~. The remaining elements of the list define the key bindings of the keymap. A symbol whose function definition is a keymap is also a keymap.

*Note*: when the binding is ~nil~, it doesn’t constitute a definition but it does take precedence over a default binding or a binding in the parent keymap. On the other hand, a binding of ~nil~ does *not* override lower-precedence keymaps; thus, if the local map gives a binding of ~nil~, Emacs uses the binding from the global map.

Some prefix keymaps are stored in variables with names:

- ~ctl-x-map~ is the variable name for the map used for characters that follow ~C-x~.
- ~help-map~ is for characters that follow ~C-h~.
- ~esc-map~ is for characters that follow ~ESC~. Thus, all Meta characters are actually defined by this map.
- ~ctl-x-4-map~ is for characters that follow ~C-x 4~.
- ~mode-specific-map~ is for characters that follow ~C-c~.
- ~project-prefix-map~ is for characters that follow ~C-x p~, used for project-related commands.

*** Changing key bindings
**** Brief
The way to rebind a key is to change its entry in a keymap. If you change a binding in the global keymap, the change is effective in all buffers. If you change the current buffer’s local map, that usually affects all buffers using the same major mode. The [[Global keymap][keymap-global-set]] and [[Local keymap][keymap-local-set]] functions are convenient interfaces for these operations. You can also use ~keymap-set~, a more general function; then you must explicitly specify the map to change.

/key/ is a string representing a single key or a series of key strokes, and must satisfy ~key-valid-p~. Key strokes are separated by a single space character.

Each key stroke is either a single character, or the name of an event, surrounded by angle brackets. In addition, any key stroke may be preceded by one or more modifier keys. Finally, a limited number of characters have a special shorthand syntax.  Here’s some example key sequences:

- f :: the key ~f~.
- S o m :: three key sequence of the keys ~S~, ~o~ and ~m~.
- C-c o :: two key sequence of the keys ~c~ with the control modifier and then the key ~o~
- H-<left> :: the key named ~left~ with the hyper modifier.
- M-RET :: the ~return~ key with a meta modifier.
- C-M-<space> :: the ~space~ key with both the control and meta modifiers.

The only keys that have a special shorthand syntax are ~NUL~, ~RET~, ~TAB~, ~LFD~, ~ESC~, ~SPC~ and ~DEL~.

The modifiers have to be specified in alphabetical order: ~A-C-H-M-S-s~, which is ~Alt-Control-Hyper-Meta-Shift-super~.

| /emacs 29/             | /emacs 28/                   |
|----------------------+----------------------------|
| keymap-set           | define-key                 |
| keymap-global-set    | global-set-key             |
| keymap-local-set     | local-set-key              |
| keymap-global-unset  | global-unset-key           |
| keymap-local-unset   | local-unset-key            |
| keymap-substitute    | substitute-key-definition  |
| keymap-set-after     | define-key-after           |
| keymap-lookup        | lookup-key and key-binding |
| keymap-local-lookup  | local-key-binding          |
| keymap-global-lookup | global-key-binding         |

**** Global keymap
The first argument to ~keymap-global-set~ describes the key sequence. It is a string made of a series of characters separated by spaces, with each character corresponding to a key.

Alternatively, to write a key binding you can use the low level functions ~define-key~ and ~global-set-key~.

#+begin_src emacs-lisp

  ;; This function sets the binding of key in the current global map to binding
  (keymap-global-set key binding)
  ;; or an older equivalent
  (global-set-key (kbd key) binding)
  ;; or another way
  (keymap-set (current-global-map) key binding)
  ;; or an older equivalent
  (define-key global-map (kbd key) binding)

  ;; Redefines C-x C-\ to move down a line:
  (keymap-global-set "C-x C-\\" 'next-line)
  ;; Redefines the first (leftmost) mouse button, entered
  ;; with the Meta key, to set point where you click:
  (keymap-global-set "M-<mouse-1>" 'mouse-set-point)
  ;; or an older equivalent
  (global-set-key (kbd "M-<mouse-1>") 'mouse-set-point)

#+end_src

This function *removes the binding of key* from the current global map.  One use of this function is in preparation for defining a longer key that uses key as a prefix—which would not be allowed if key has a non-prefix binding.

#+begin_src emacs-lisp

  (keymap-global-unset "C-l") ;; ⇒ nil
  ;; or an older equivalent
  (global-unset-key "C-l")

  (keymap-global-set "C-l C-l" 'redraw-display) ;; ⇒ nil
  ;; or an older equivalent
  (global-set-key (kbd "C-l") nil)

#+end_src

**** Local keymap
Major modes and minor modes can define local keymaps. These keymaps are constructed when the mode is loaded for the first time in a session. The functions ~keymap-local-set~ and ~keymap-set~ can be used to make changes in a specific keymap. To remove a key binding, use ~keymap-unset~.

#+begin_src emacs-lisp

  ;; Sets the binding of key in the current-local-map keymap.
  (keymap-set (current-local-map) key binding)

  ;; Sets the binding of key in the current local keymap to binding.
  (keymap-local-set key binding)


  ;; This function removes the binding of key from the current local map.
  (keymap-local-unset key)

  ;; Example of unbind key:
  (keymap-set dired-mode-map "I" nil)

#+end_src

Since a mode’s keymaps are not constructed until it has been loaded, you must delay running code which modifies them, e.g., by putting it on a [[Hook][mode hook]]. For example, Texinfo mode runs the hook ~texinfo-mode-hook~. Here’s how you can use the hook to add local bindings for ~C-c n~ and ~C-c p~, and remove the one for ~C-c C-x x~ in Texinfo mode:

#+begin_src emacs-lisp

  (add-hook 'texinfo-mode-hook
            (lambda ()
              (keymap-set texinfo-mode-map "C-c p"
                          'backward-paragraph)
              (keymap-set texinfo-mode-map "C-c n"
                          'forward-paragraph)
              (keymap-set texinfo-mode-map "C-c C-x x" nil)))


  ;; To change minor mode keys, you need to change of the mode's keymap:
  (progn
    ;; change isearch's keys to arrows
    (define-key isearch-mode-map (kbd "<left>") 'isearch-repeat-backward)
    (define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward))

  ;; For some minor modes, you need to load it first:
  (progn
    (require 'dired )
    (define-key dired-mode-map (kbd "o") 'other-window)
    (define-key dired-mode-map (kbd "C-o") 'find-file))


  ;; Here's a example of how to redefine keybinding in minibuffer
  (define-key minibuffer-local-map (kbd "M-r") 'kill-word)
  (define-key minibuffer-local-map (kbd "M-s") 'other-window)

#+end_src

*** Remapping commands
A special kind of key binding can be used to /remap/ one command to another, without having to refer to the key sequence(s) bound to the original command. To use this feature, make a key binding for a key sequence that starts with the dummy event ~remap~, followed by the command name you want to remap; for the binding, specify the new definition (usually a command name, but possibly any other valid definition for a key binding).

For example, suppose My mode provides a special command ~my-kill-line~, which should be invoked instead of ~kill-line~. To establish this, its mode keymap should contain the following remapping:

#+begin_src emacs-lisp

  (keymap-set my-mode-map "<remap> <kill-line>" 'my-kill-line)


  ;; Redefine all keys which now run next-line in Fundamental mode
  ;; so that they run forward-line instead (another old way).
  (keymap-substitute global-map 'next-line 'forward-line)
  ;; or an older equivalent
  (substitute-key-definition 'next-line 'forward-line global-map)


  ;; Remapping a command by Mickey Petersen
  (define-key global-map [remap exchange-point-and-mark]
              'exchange-point-and-mark-no-activate)

#+end_src

Then, whenever ~my-mode-map~ is active, if the user types ~C-k~ (the default global key sequence for ~kill-line~) Emacs will instead run ~my-kill-line~.

Note that remapping only takes place through active keymaps; for example, putting a remapping in a prefix keymap like ~ctl-x-map~ typically has no effect, as such keymaps are not themselves active. In addition, remapping only works through a single level; in the following example,

#+begin_src emacs-lisp

  (keymap-set my-mode-map "<remap> <kill-line>" 'my-kill-line)
  (keymap-set my-mode-map "<remap> <my-kill-line>" 'my-other-kill-line)

#+end_src

~kill-line~ is *not* remapped to ~my-other-kill-line~. Instead, if an ordinary key binding specifies ~kill-line~, it is remapped to ~my-kill-line~; if an ordinary binding specifies ~my-kill-line~, it is remapped to ~my-other-kill-line~.

To undo the remapping of a command, remap it to ~nil~; e.g.,

#+begin_src emacs-lisp

  (keymap-set my-mode-map "<remap> <kill-line>" nil)

#+end_src

[[https://www.masteringemacs.org/article/mastering-key-bindings-emacs][Mickey Petersen]]

Note: to replace a global key, you must use global-map or call current-global-map.

#+begin_src emacs-lisp

  (define-key keymap [remap original-function] 'my-own-function)

#+end_src

*** Define keybinding
**** Unbind/remove a binding
***** Remove a keybinding global and local

#+begin_src emacs-lisp

  ;; for emacs 29 or after
  (keymap-global-set "C-t" nil)
  ;; or use
  (keymap-global-unset "C-t")


  ;; Removes KEY from the global keymap
  (global-unset-key KEY)

  ;; Removes KEY from the active, local keymap.
  (local-unset-key KEY)

#+end_src

***** Unbind key in local keymap
[[https://emacsredux.com/blog/2023/03/14/removing-unbinding-vs-unsetting-keybindings/][Emacs Redux]]

In the example below ~clojure-mode-map~ is a child map of ~prog-mode-map~, as ~clojure-mode~ is derived from ~prog-mode~ (the standard parent for major modes related to programming languages). If ~prog-mode-map~ had some binding for =C-c C-z= it would not become available if you had only unset the binding in ~clojure-mode-map~. Only removal/unbinding of the keybinding from the child map (~clojure-mode-map~) would allow you to use the binding in the parent map (~prog-mode-map~).

#+begin_src emacs-lisp

  ;; unset a binding
  (keymap-unset clojure-mode-map "C-c C-z")

  ;; remove a binding
  (keymap-unset clojure-mode-map "C-c C-z" 'remove)

#+end_src

**** Define key sequences
***** Using global-set-key
[[https://www.masteringemacs.org/article/mastering-key-bindings-emacs][Mickey Petersen]]

Creating a prefix is easy nowadays as you don’t have to explicitly create your own prefix keymaps, provided you use local-set-key or global-set-key. Use custom prefixes to group or categorize your commands.

#+begin_src emacs-lisp

  (global-set-key (kbd "subkey_1 ... endkey_1") 'my-command-1)
  (global-set-key (kbd "subkey_1 ... endkey_2") 'my-command-2)


  ;; Example:
  (defun mp-insert-date ()
    (interactive)
    (insert (format-time-string "%x")))

  (defun mp-insert-time ()
    (interactive)
    (insert (format-time-string "%X")))

  (global-set-key (kbd "C-c i d") 'mp-insert-date)
  (global-set-key (kbd "C-c i t") 'mp-insert-time)

#+end_src

***** Using make-sparse-keymap
This example creates a sparse keymap and makes a number of bindings in it ([[https://www.gnu.org/software/emacs/manual/html_node/elisp/Changing-Key-Bindings.html][Emacs Lisp reference manual]]):

#+begin_src emacs-lisp

  (setq map (make-sparse-keymap)) ;; ⇒ (keymap)

  (keymap-set map "C-f" 'forward-char)

  map ;; ⇒ (keymap (6 . forward-char))

  ;; Build sparse submap for C-x and bind f in that.
  (keymap-set map "C-x f" 'forward-word) ;; ⇒ forward-word

  map
  ;; ⇒ (keymap
  ;;     (24 keymap                ; C-x
  ;;         (102 . forward-word)) ;      f
  ;;     (6 . forward-char))       ; C-f

  (keymap-global-set "M-o" 'map)

  ;; Bind C-p to the ctl-x-map.
  (keymap-set map "C-p" ctl-x-map)
  ;; ctl-x-map
  ;; ⇒ [nil … find-file … backward-kill-sentence]


  ;; Bind C-f to foo in the ctl-x-map.
  (keymap-set map "C-p C-f" 'foo) ;; ⇒ 'foo

  map
  ;; ⇒ (keymap     ; Note foo in ctl-x-map.
  ;;     (16 keymap [nil … foo … backward-kill-sentence])
  ;;     (24 keymap
  ;;         (102 . forward-word))
  ;;     (6 . forward-char))

#+end_src

***** Using define-prefix-command
Xah

#+begin_src emacs-lisp

  (progn
    ;; define key sequence
    (define-prefix-command 'my-key-map)
    (define-key my-key-map (kbd "<f6>") 'visual-line-mode)
    (define-key my-key-map (kbd "<f7>") 'whitespace-mode)
    (define-key my-key-map (kbd "<f8>") 'toggle-frame-fullscreen)
    (global-set-key (kbd "<f9>") my-key-map))
  ;; Then:
  ;; F9 F6 for visual-line-mode
  ;; F9 f7 for whitespace-mode
  ;; F9 F8 for toggle-frame-fullscreen

  ;; Example of single key sequence
  (global-set-key (kbd "<f7>") nil) ;  good idea to put nil to the starting key
  (global-set-key (kbd "<f7> <f8>") #'calendar)
  (global-set-key (kbd "<f7> <f9>") #'calc)
  ;; Example of sequence of single or chord keys
  (global-set-key (kbd "C-e") nil) ; good idea to put nil to the starting key
  (global-set-key (kbd "C-e a") #'calendar)
  (global-set-key (kbd "C-e SPC") #'calendar)
  (global-set-key (kbd "C-e C-a") #'calendar)

#+end_src

**** Swap and translate keys
***** Swap, translate keys
[[http://xahlee.info/emacs/emacs/emacs_key-translation-map.html][Xah]]
Here's how to swap keys.

#+begin_src emacs-lisp

  ;; swap keys
  (define-key key-translation-map (kbd "<f11>") (kbd "<f12>"))
  (define-key key-translation-map (kbd "<f12>") (kbd "<f11>"))

#+end_src

*Note*: there's the function ~keyboard-translate~. However, it is designed to translate character only.

***** Set, translate prefix keys like C-x, C-c
****** C-x (Xah)
[[http://xahlee.info/emacs/emacs/emacs_key-translation-map.html][Xah]]
This is useful to be able to swat the prefix ~C-x~ to another prefix, for example, ~C-t~.

So, key combination isn't a character and you can't use it for =Hyper= key combination. (Due to historical reasons, ~keyboard-translate~ does work for some =Ctrl= combination key.

There are 32 =Ctrl+letter= combinations which are characters, and the above two are among them. These are exceptional special cases due to history. My general recommendation is to not use ~keyboard-translate~ but ~key-translation-map~ or ~function-key-map~, which work on arbitrary key sequences rather only on single-char events.

If you use Dvorak Keyboard Layout with emacs, you may want to change the =Ctrl+x= key to something else.

#+begin_src emacs-lisp

  (global-set-key (kbd "C-t") ctl-x-map)
  (global-set-key (kbd "C-x") nil)

  ;; Bind M-h to the help map
  (global-set-key (kbd "M-h") help-map)
  (global-set-key (kbd "C-h") nil)

#+end_src

by Johan Bockgård ~keyboard-translate~ only works for characters. You can use

#+begin_src emacs-lisp

  (define-key key-translation-map [?\M-x] [?\M-t])
  (define-key key-translation-map [?\M-t] [?\M-x])

#+end_src

****** C-c
Cons:
- It would change all ~C-d~ keys to ~C-c~. So the ~C-c C-c~ Keybind would become ~C-d C-d~ And any ~C-c C-d~ keybind would be inaccessible.

- ~C-c~ is still available as prefix.

#+begin_src emacs-lisp

  ;; Translate C-z to C-d
  (define-key key-translation-map (kbd "C-d") (kbd "C-c"))

#+end_src

****** C-x (emacs manual)
In the following example, we make ~C-p~ a prefix key in the local keymap, in such a way that ~C-p~ is identical to ~C-x~. Then the binding for ~C-p C-f~ is the function find-file, just like ~C-x C-f~. By contrast, the key sequence ~C-p 9~ is not found in any active keymap.

#+begin_src emacs-lisp

  (use-local-map (make-sparse-keymap))
      ⇒ nil

  (keymap-local-set "C-p" ctl-x-map)
      ⇒ (keymap #^[nil nil keymap …

  (keymap-lookup nil "C-p C-f")
      ⇒ find-file

  (keymap-lookup nil "C-p 9")
      ⇒ nil

#+end_src

***** Swap the emacs ctrl, alt, meta, hyper, super keys
You can specify which keysyms Emacs should use for the Control, Meta, Alt, Hyper, and Super modifiers by setting these variables: ~x-ctrl-keysym~, ~x-alt-keysym~, ~x-meta-keysym~, ~x-hyper-keysym~, ~x-super-keysym~.

The name of the keysym that should stand for the Control modifier (respectively, for =Alt=, =Meta=, =Hyper=, and =Super=). For example, here is how to swap the =Meta= and =Alt= modifiers within Emacs:

#+begin_src emacs-lisp

  (setq x-alt-keysym 'meta)
  (setq x-meta-keysym 'alt)

#+end_src

Here is how to swap the =Ctrl= and /Meta/, sometimes the same as =Alt=:

#+begin_src emacs-lisp

  (setq x-meta-keysym 'ctrl)
  (setq x-ctrl-keysym 'meta)

#+end_src

***** Change special prefix keys
Prefix o special keys like ~C-c~, ~C-x~, ~C-h~, ~C-i~, ~C-m~, ~C-[~, ~C-g~, ~C-u~, ~C-q~.

#+begin_src emacs-lisp

  ;; good option but doesn't swap info binding
  (define-key key-translation-map (kbd "<f11>") (kbd "<f12>"))
  (define-key key-translation-map (kbd "<f12>") (kbd "<f11>"))

  ;; Doesn't work well (C-x C-x) (no change info key)
  (global-set-key (kbd "C-t") ctl-x-map)
  (global-set-key (kbd "C-x") nil)

  ;; Doesn't work well (C-x C-h)
  (global-set-key (kbd "M-h") help-map)
  (global-set-key (kbd "C-h") nil)

  ;; It works well
  (keymap-global-set "C-l" 'universal-argument)
  (keymap-set universal-argument-map "C-l" 'universal-argument-more)
  (keymap-set universal-argument-map "C-u" nil)
  ;; or
  (global-set-key "\C-l" 'universal-argument)
  (define-key universal-argument-map "\C-l" 'universal-argument-more)
  (define-key universal-argument-map "\C-u" nil)

  ;; Doesn't work well (other functions bind C-g)
  (keymap-global-set "C-r" 'keyboard-quit)
  (keymap-global-set "C-g" nil)

  ;; It seems work well
  (keymap-global-set "C-r" 'quoted-insert)
  (keymap-global-set "C-q" nil)

#+end_src

**** Binding keys with a mode hook
[[https://www.masteringemacs.org/article/mastering-key-bindings-emacs][Mickey Petersen]]

Here I change the python indentation offset to 4 and make it local to that buffer with setq-local. Next, I disable eldoc-mode and I locally bind a key with local-set-key.

#+begin_src emacs-lisp

  (defun mp-my-hook-settings ()
    (setq-local python-indent-offset 4)
    (eldoc-mode -1)
    (local-set-key (kbd "C-c p" 'python-shell-switch-to-shell)))

  (add-hook 'python-mode-hook #'mp-my-hook-settings)

#+end_src

**** Setup all major mode custom keys
[[http://xahlee.info/emacs/misc/xah-fly-keys_setup_major_mode_key.html][Xah]]
Normally, Major Mode keys start with =Ctrl+c=.

You can make it so that all commands in the major mode uses a leader key sequence.

For example:

- =TAB SPC= → completion-at-point
- =TAB a= → python-shell-send-buffer
- =TAB b= → python-describe-at-point

Here's the best way to do it:

1. Get a list of the commands you want. You do this by first activate the major mode, then, =Alt+x= ~describe-mode~, to list all commands of the mode.
2. Then, decide on a leader key to call them. i recommend =Tab=.
3. Find the keymap name of the major mode. (look at its source code), then do as example.

[[http://xahlee.info/emacs/misc/xah-fly-keys_org_mode.html][Xah]]
Originally, the keys are mostly same as ~org-mode~'s default, by simply replacing =C-c= with =TAB=, as much as possible. e.g. 【 =C-c C-‹key›= 】 is now 【 =leader ‹key›= 】, but is gradually improved by changing them, so they no longer corresponding to ~ord-mode~'s original keys

• make most frequently used command have easy keys. e.g. shorter, and or easier key.

• just simply list the top 20 most used commands from your head and give them easy key.

• a simple key is shorter key count, and or most used letter in english. here's the top most used letter

#+begin_src emacs-lisp

  ["e", 12.7],
  ["t", 9.06],
  ["a", 8.17],
  ["o", 7.51],
  ["i", 6.97],
  ["n", 6.75],
  ["s", 6.33],
  ["h", 6.09],
  ["r", 5.99],
  ["d", 4.25],
  ["l", 4.03],

#+end_src

we use letter frequency not qwerty layout because we need to consider there are people using dvork colemak, and also spanish french german

so for example, a top most command ~xxx~ should have a key 【 =TAB e= 】

once you bind a new key, you need to move the existing command with that key to some other key

after the first 20 most used command is done, then that's enough. (because it covers ~95% of command calls)
the rest org commands's key choice does not matter that much, but if you want, they can have keys by association of command name and key letter, or grouping commands together nearby keys.

• go thru all commands, those that make sense to hold to repeat, need a chord key, or setup emacs repeat last key feature (if you don't know how to do this, just mark them, i'll try it)

• rebind all those that uses a shift key. e.g. =!= =@= =#= =$=

Example of adding a leader key map to python mode:

#+begin_src emacs-lisp

  (defun my-config-python-mode ()
    "Config python-mode.
  Version 2024-07-06"
    (interactive)

    (progn
      ;; create a keymap
      (define-prefix-command 'my-python-leader-map)

      ;; add keys to it
      (define-key my-python-leader-map (kbd "SPC" 'completion-at-point))
      (define-key my-python-leader-map (kbd "a" 'python-describe-at-point))
      (define-key my-python-leader-map (kbd "b" 'python-shell-send-statement))
      (define-key my-python-leader-map (kbd "c" 'python-eldoc-at-point))
      (define-key my-python-leader-map (kbd "d" 'imenu))
      (define-key my-python-leader-map (kbd "e" 'python-shell-send-file))
      (define-key my-python-leader-map (kbd "f" 'run-python))
      (define-key my-python-leader-map (kbd "g" 'python-shell-send-region))
      (define-key my-python-leader-map (kbd "h" 'python-shell-send-string))
      (define-key my-python-leader-map (kbd "i" 'python-check))
      (define-key my-python-leader-map (kbd "j" 'python-shell-switch-to-shell))
      (define-key my-python-leader-map (kbd "," 'python-indent-shift-left))
      (define-key my-python-leader-map (kbd "." 'python-indent-shift-right))

      ;; more here
      )

    ;; modify the major mode key map, so that a key becomes your leader key
    (define-key python-mode-map (kbd "TAB") my-python-leader-map)
    ;;
    )

  (when (fboundp 'python-mode)
    (add-hook 'python-mode-hook 'my-config-python-mode))

#+end_src

**** Miscellaneous
***** Modifying minibuffer keys

#+begin_src emacs-lisp

  (define-key minibuffer-local-map (kbd "M-p") nil)
  (define-key minibuffer-local-map (kbd "M-n") nil)
  (define-key minibuffer-local-map (kbd "<f11>") 'previous-history-element)
  (define-key minibuffer-local-map (kbd "<f12>") 'next-history-element)

#+end_src

***** Bind number pad keys

#+begin_src emacs-lisp

  (global-set-key (kbd "<kp-1>") 'bookmark-bmenu-list)
  (global-set-key (kbd "<kp-2>") 'ibuffer)

  (global-set-key (kbd "<kp-decimal>") 'other-window)
  (global-set-key (kbd "<kp-subtract>") 'xah-close-current-buffer)
  (global-set-key (kbd "<kp-divide>") 'xah-previous-user-buffer)

  (global-set-key (kbd "<C-kp-divide>") 'xah-previous-emacs-buffer)
  (global-set-key (kbd "<C-kp-multiply>") 'xah-next-emacs-buffer)

#+end_src

***** Insert symbols, string

#+begin_src emacs-lisp

  (define-key key-translation-map (kbd "<f5> p") "φ")

  ;; make the f6 key insert a string. space between chars are required
  (keymap-global-set "<f6>" "s o m e t h i n g")

#+end_src

***** Key for key macro

#+begin_src emacs-lisp

  ;; make the f6 key send control-g
  (keymap-global-set "<f6>" "C-g")
  ;; make the f6 key insert a string. space between chars are required
  (keymap-global-set "<f6>" "s o m e t h i n g")

#+end_src

***** Bind mouse

#+begin_src emacs-lisp

  (global-set-key (kbd "<mouse-up>") 'cmdName)
  (global-set-key (kbd "<mouse-down>") 'cmdName)

#+end_src

***** Super, Hyper syntax

#+begin_src emacs-lisp

  ;; s (lowercase s) is syntax for Super.
  (global-set-key (kbd "s-b") #'left-char)
  (global-set-key (kbd "M-s-b") #'left-char) ; Meta+Super+b

  ;; Insert ↑ (up arrow) when press 'Super' and ';' keys (Abbrev System).
  (global-set-key (kbd "s-;") (lambda () (interactive) (insert "↑")))

#+end_src

***** AltGr or Compose keybinding syntax
=AltGr= or =Compose= key is treated as a modifier (like =Ctrl= or =Shift=) rather than a standalone key, i.e. =AltGr + [Key]= works (because it sends a modified key event). =AltGr= alone does nothing

#+begin_src emacs-lisp

  (global-set-key (kbd "á") 'move-end-of-line) ; kbd "AltGr-a"

#+end_src

*** Define prefix (leader key) and repeat commands
**** Using defvar-keymap
***** Brief
To avoid repetitive invocations of put, ~defvar-keymap~ also has a ~:repeat~ keyword, which can be used to specify which commands in the keymap are usable by ~repeat-mode~. The following values are available:

- t :: this means all the commands in the keymap are repeatable, and is the most common usage.

- (:enter (commands ...) :exit (commands ...) :hints ((command . "hint") ...)) :: this specifies that the commands in the ~:enter~ list enter ~repeat-mode~, and the commands in the ~:exit~ list exit repeat mode.

    If the ~:enter~ list is empty, then all commands in the map enter ~repeat-mode~. *Specifying one or more commands in this list is useful* if there is a command which doesn’t exist in the map being defined, but which should have the ~repeat-map~ property.

    If the ~:exit~ list is empty then no commands in the map exit ~repeat-mode~. Specifying one or more commands in this list is useful if the keymap being defined contains a command that should not have the repeat-map property.

    The ~:hints~ list can contain cons pairs where the CAR is a command and the CDR is a string that is displayed alongside of the repeatable key in the echo area.

In order to make e.g. u repeat the ~undo~ command, the following two stanzas are equivalent:

*Note*: the difference between set binding with ~#'~ or ~'~ is that ~#~ tell a person who reads the code or compiler, this is specially a function not a symbol.

*Note*: the difference between use ~#'~ or just ~'~ is that ~#~ tells the person reading the code or the compiler that what follow is specifically a function, not a symbol of any kind.

#+begin_src emacs-lisp

  (defvar-keymap undo-repeat-map
    "u" #'undo)
  (put 'undo 'repeat-map 'undo-repeat-map)

  ;; and

  ;; This one is preferred when there are many commands in the
  ;; map, all of which should be repeatable.
  (defvar-keymap undo-repeat-map
    :repeat t
    "u" #'undo)

#+end_src

***** Set globally

#+begin_src emacs-lisp

    (keymap-global-set "M-e" 'backward-kill-word)
    (keymap-global-set "M-r" 'kill-word)
    (keymap-global-set "M-d" 'backward-delete-char)
    (keymap-global-set "M-f" 'delete-forward-char)

    (defvar-keymap rf-kill-repeat-map
      :repeat t
      :doc "Keymap for kill."
      "e" #'backward-kill-word
      "r" #'kill-word
      "d" #'backward-delete-char
      "f" #'delete-forward-char)


  ;; PROTESILAOS example
  ;; Define key maps that will then be added to the prefix map
  (defvar-keymap test-prefix-buffer-map
    :doc "My prefix key map for buffers."
    "s" #'save-buffer
    "w" #'write-file
    "p" #'previous-buffer
    "n" #'next-buffer)

  (defvar-keymap test-prefix-mode-map
    :doc "My prefix key map for minor modes."
    "l" #'display-line-numbers-mode
    "h" #'hl-line-mode)

  ;; Define a key map with commands and nested key maps
  (defvar-keymap test-prefix-map
    :doc "My prefix key map."
    "b" test-prefix-buffer-map
    "m" test-prefix-mode-map
    "f" #'find-file
    "d" #'dired)

  ;; Define how the nested keymaps are labelled in `which-key-mode'.
  (which-key-add-keymap-based-replacements test-prefix-map
    "b" `("Buffer" . ,test-prefix-buffer-map)
    "m" `("Testing" . ,test-prefix-mode-map))

  ;; Bind the prefix key map to a key.  Notice the absence of a quote for
  ;; the map's symbol.
  (keymap-set global-map "C-z" test-prefix-map)

#+end_src

***** Set using :enter :exit options
[[https://karthinks.com/software/it-bears-repeating/][karthinks]]

Emacs 29 introduces defvar-keymap, making it easier to define keymaps with the repeat-map property attached:

#+begin_src emacs-lisp

  (defvar-keymap hl-todo-repeat-map
      :repeat t
      "n" #'hl-todo-next
      "p" #'hl-todo-previous
      "o" #'hl-todo-occur)

#+end_src

Or, for finer control over when the repeat-map is (de)activated,

#+begin_src emacs-lisp

  (defvar-keymap hl-todo-repeat-map
      :repeat (:enter (hl-todo-insert) :exit (hl-todo-occur))
      "n" #'hl-todo-next
      "p" #'hl-todo-previous
      "o" #'hl-todo-occur)

#+end_src

which specifies that using ~hl-=todo-insert~ should activate the repeat-map and ~hl-todo-occur~ should deactivate it.

Note that turning an existing keymap into a repeat-map or adding this behavior to individual commands still requires one of the above helpers, like ~repeatize~.

With any of these packages you could develop the above idea into a complete modal editing environment – like God Mode, but with custom modes for specialized editing tasks. Even at a more basic level, you can go wild here, placing all commands into repeat maps: Why delete words with =M-d= or =M-DEL= five times when you can just do =M-d= =d= =d= =d= =d=? Why cycle through the kill-ring with =M-y= when you can just yank and cycle with =C-y= =y= =y= =y=...?

I’m not sure about taking it that far. For one, it’s simpler to use digit arguments: =M-5 M-d= is shorter and possibly faster to type. Second, many commands that involve more than three levels of “cycling” are better served by a menu with choices, i.e. a completing-read interface or an Avy selection. I’ve found that the returns diminish and the common issues with modality start to surface as the repeat maps become more expansive.

Repeat maps appear to be best suited for families of related commands that are usually invoked in succession and are cumbersome to invoke. Pretty much exactly what folks use Hydras or (more lately) Transients for, which brings us to…

***** Set the repeat command to 2 different keymap groups (inherit)
****** Keymap inherits the keymap of another

#+begin_src emacs-lisp

  (keymap-global-set "M-d" 'backward-delete-char)
  (keymap-global-set "M-f" 'delete-forward-char)

  (defvar-keymap kill-repeat-map
    :repeat (:exit (other-window))
    :doc "Keymap for kill."
    "d" #'backward-delete-char
    "f" #'delete-forward-char)

  ;; kill inherit from other-window (child:kill   parent:other-window)
  (set-keymap-parent kill-repeat-map other-window-repeat-map)

  ;; Defined by default.
  ;; (defvar-keymap other-window-repeat-map
  ;;   :doc "Keymap to repeat `other-window'.  Used in `repeat-mode'."
  ;;   :repeat t
  ;;   "o" #'other-window
  ;;   "O" (lambda ()
  ;;         (interactive)
  ;;         (setq repeat-map 'other-window-repeat-map)
  ;;         (other-window -1)))

#+end_src

****** Kemaps activate each other
Both kemaps are activated when you enter one of them.

#+begin_src emacs-lisp

  (keymap-global-set "M-d" 'backward-delete-char)
  (keymap-global-set "M-f" 'delete-forward-char)

  (defvar-keymap kill-repeat-map
    :repeat t
    :doc "Keymap for kill."
    "d" #'backward-delete-char
    "f" #'delete-forward-char
    "o" #'other-window)

  ;; Defined by default.
  ;; (defvar-keymap other-window-repeat-map
  ;;   :doc "Keymap to repeat `other-window'.  Used in `repeat-mode'."
  ;;   :repeat t
  ;;   "o" #'other-window
  ;;   "O" (lambda ()
  ;;         (interactive)
  ;;         (setq repeat-map 'other-window-repeat-map)
  ;;         (other-window -1)))

#+end_src

****** Exit the keymap and enter to another
In the next example, when you activate ~kill-repeat-map~ (e.g. by pressing =M-f=) and pressing =o= deactivates it, and activate ~other-window-repeat-map~.

When you activate ~other-window-repeat-map~ (e.g. pressing =C-x o=) it work as usual.

#+begin_src emacs-lisp

  (keymap-global-set "M-d" 'backward-delete-char)
  (keymap-global-set "M-f" 'delete-forward-char)

  (defvar-keymap kill-repeat-map
    :repeat (:exit (other-window))
    :doc "Keymap for kill."
    "d" #'backward-delete-char
    "f" #'delete-forward-char
    "o" #'other-window)

  ;; Defined by default.
  ;; (defvar-keymap other-window-repeat-map
  ;;   :doc "Keymap to repeat `other-window'.  Used in `repeat-mode'."
  ;;   :repeat t
  ;;   "o" #'other-window
  ;;   "O" (lambda ()
  ;;         (interactive)
  ;;         (setq repeat-map 'other-window-repeat-map)
  ;;         (other-window -1)))

#+end_src

****** Exit the keymap
It exits one keymap but does not activate the other, it completely exits the repeat mode.

When you activate ~other-window-repeat-map~ (e.g. pressing =C-x o=) it work as usual.

#+begin_src emacs-lisp

  (keymap-global-set "M-d" 'backward-delete-char)
  (keymap-global-set "M-f" 'delete-forward-char)

  (defvar-keymap kill-repeat-map
    :repeat t
    :doc "Keymap for kill."
    "d" #'backward-delete-char
    "f" #'delete-forward-char
    "o" (lambda ()
          (interactive)
          (other-window 1)))

  ;; Defined by default.
  ;; (defvar-keymap other-window-repeat-map
  ;;   :doc "Keymap to repeat `other-window'.  Used in `repeat-mode'."
  ;;   :repeat t
  ;;   "o" #'other-window
  ;;   "O" (lambda ()
  ;;         (interactive)
  ;;         (setq repeat-map 'other-window-repeat-map)
  ;;         (other-window -1)))

#+end_src

***** Define keymap with standar keys and additional key

#+begin_src emacs-lisp

  (defvar-keymap resize-window-repeat-map
    :doc "Keymap to repeat window resizing commands.
  Repeatable commands are `enlarge-window' and `shrink-window',
  and also `enlarge-window-horizontally' and `shrink-window-horizontally'.
  Used in `repeat-mode'."
    :repeat t
    ;; Standard keys:
    "^" #'enlarge-window
    "}" #'enlarge-window-horizontally
    "{" #'shrink-window-horizontally
    ;; Additional keys:
    "v" #'shrink-window)

#+end_src

***** Add a command to the repeat keymap (without defvar-keymap)

#+begin_src emacs-lisp

  (defun other-window-reverse ()
    "Select another window in reverse cyclic ordering of windows."
    (interactive)
    (other-window -1))

  ;; Set C-x 7 as its keybinding (this is optional)
  (define-key ctl-x-map "7" 'other-window-reverse)

  ;; Add it to the repeat commands.
  (define-key other-window-repeat-map "7" 'other-window-reverse)
  (put #'other-window-reverse 'repeat-map 'other-window-repeat-map)

  ;; Defined by default.
  ;; (defvar-keymap other-window-repeat-map
  ;;   :doc "Keymap to repeat `other-window'.  Used in `repeat-mode'."
  ;;   :repeat t
  ;;   "o" #'other-window
  ;;   "O" (lambda ()
  ;;         (interactive)
  ;;         (setq repeat-map 'other-window-repeat-map)
  ;;         (other-window -1)))

#+end_src

***** Define bindings in mode map and set repeat comands (shell-mode-map)

#+begin_src emacs-lisp

  ;; c-c c-f shell-forward-command	Forward a shell command
  ;; c-c c-b shell-backward-command	Backward a shell command

  (defvar shell-mode-map
    (let ((map (make-sparse-keymap)))
      (define-key map "\C-c\C-f" 'shell-forward-command)
      (define-key map "\C-c\C-b" 'shell-backward-command)
      (define-key map "\t" 'completion-at-point)
      (define-key map (kbd "M-RET") 'shell-resync-dirs)
      (define-key map "\M-?" 'comint-dynamic-list-filename-completions)
      (define-key map (kbd "C-x n d") 'shell-narrow-to-prompt)
      (define-key map [menu-bar completion]
        (cons "Complete"
            (copy-keymap (lookup-key comint-mode-map [menu-bar completion]))))
      (define-key-after (lookup-key map [menu-bar completion])
        [complete-env-variable] '("Complete Env. Variable Name" .
                                shell-dynamic-complete-environment-variable)
        'complete-file)
      (define-key-after (lookup-key map [menu-bar completion])
        [expand-directory] '("Expand Directory Reference" .
                           shell-replace-by-expanded-directory)
        'complete-expand)
      map))

  (defvar-keymap shell-repeat-map
    :doc "Keymap to repeat shell key sequences.  Used in `repeat-mode'."
    :repeat t
    "C-f" #'shell-forward-command
    "C-b" #'shell-backward-command)


  ;; Some suggestions for your init file.
  ;;
  ;; ;; Define M-# to run some strange command:
  ;; (eval-after-load "shell"
  ;;  '(define-key shell-mode-map "\M-#" 'shells-dynamic-spell))

#+end_src

***** Define keymap with prefix

#+begin_src emacs-lisp

  (defvar-keymap window-prefix-map
    :doc "Keymap for subcommands of \\`C-x w'."
    "2" #'split-root-window-below
    "3" #'split-root-window-right
    "s" #'window-toggle-side-windows
    "d" #'toggle-window-dedicated
    "^ f" #'tear-off-window
    "^ t" #'tab-window-detach
    "-" #'fit-window-to-buffer
    "0" #'delete-windows-on
    "q" #'quit-window)
  (define-key ctl-x-map "w" window-prefix-map)


  (defvar-keymap search-map
    :doc "Keymap for search related commands."
    "o"   #'occur
    "M-w" #'eww-search-words
    "h r" #'highlight-regexp
    "h p" #'highlight-phrase
    "h l" #'highlight-lines-matching-regexp
    "h ." #'highlight-symbol-at-point
    "h u" #'unhighlight-regexp
    "h f" #'hi-lock-find-patterns
    "h w" #'hi-lock-write-interactive-patterns)
  (define-key esc-map "s" search-map) ; esc-map is also M-

#+end_src

***** repeat-exit-key variable
Typing any key other than those defined to repeat the previous command exits the transient repeating mode, and then the key you typed is executed normally. You can also define a key which will exit the transient repeating mode without executing the key which caused the exit. To this end, customize the user option ~repeat-exit-key~ to name a key; one natural value is =RET=.

***** Using repeat mode (Emac 28)
****** Brief
[[https://zck.org/emacs-repeat-mode-emacs-repeat-mode][zck]]

In 2022, Emacs 28.1 was released. This release added repeat mode, a piece of functionality that's similar to transient maps. Like transient maps, repeat mode allows for different actions to be triggered by keypresses after a function is called. Unlike transient maps, repeat mode works without modifying the source of the function being acted on.

****** Enable repeat mode
Enable it with ~(repeat-mode 1)~.

Now, every time a command is called, Emacs will look at the ~'repeat-map~ property on that specific command. If it finds a keymap there, Emacs will bind it as a transient map after running the command.

To use it, add a keymap to the function with

#+begin_src emacs-lisp

  (put #'original-function-name 'repeat-map 'keymap-for-the-function)

#+end_src

If you look carefully, you'll notice that I lied before.

There isn't a keymap as the property; there's a symbol. That is, the keymap name is quoted. It can't directly be a function, like a make-keymap call. Instead, make a variable and set its value to the desired keymap, like

#+begin_src emacs-lisp

  (defvar my-example-repeat-map (define-keymap "h" #'function-to-repeat)).

#+end_src

Once we do all that, after calling ~#'original-function-name~, the user can call ~#'function-to-repeat~ by pressing ~h~.

****** Not just for repeating
Remember how I said repeat mode was confusing? Well, it sure is. Unintuitively, repeat mode is not just for repeating. It can be used to call a whole menu of commands after the original function.

If you're writing your own functions, I'm not sure whether to use repeat maps vs transient maps. As far as I can tell, the result is basically the same, except for two things:

1. Repeat-maps can be listed by ~#'describe-repeat-maps~. I don't think this is especially useful.
2. Repeat-maps automatically message the user the keys that are bound in that map, although they do not tell the user what the keys do. Transient maps don't provide any guidance to the user.

On the other hand, repeat mode means you can change any given function, not just ones you're coding yourself.

****** An example!
Let's say you want to capitalize, lowercase, and upcase words easily. We want to choose between pressing =c= to call ~#'capitalize-dwim~, =d= to call ~#'downcase-dwim~, and =u= for ~#'upcase-dwim~. First, let's create a keymap that binds those three keys.

#+begin_src emacs-lisp

  (defvar change-of-case-keymap
    (define-keymap
      "c" #'capitalize-dwim
      "d" #'downcase-dwim
      "u" #'upcase-dwim))

#+end_src

Now, we set that map as the 'repeat-map' property on the three functions.

#+begin_src emacs-lisp

  (put #'capitalize-dwim 'repeat-map 'change-of-case-keymap)
  (put #'downcase-dwim 'repeat-map 'change-of-case-keymap)
  (put #'upcase-dwim 'repeat-map 'change-of-case-keymap)

#+end_src

Now, after running any of those three functions, the keymap is activated, and it's possible to run any of the three functions again with a keypress.

****** Mickey Petersen example
For changes relating to a specific package, use this format:

#+begin_src emacs-lisp

  (defvar my-repeat-map
   (let ((map (make-sparse-keymap)))
     (define-key map "a" 'some-command)
     ;; ...
     (define-key map "z" 'another-command)
     map)
   "Repeating map example.")

  (put 'some-command 'repeat-map 'my-repeat-map)
  (put 'another-command 'repeat-map 'my-repeat-map)

#+end_src

**** Using M-x interface (interactive)
[[https://www.emacswiki.org/emacs/Repeatable][EmacsWiki]]

A repeatable command can be called again by repeatedly hitting (or just holding down) the last key stroke/chord.

For example: You can call the repeatable command ‘kmacro-end-and-call-macro’ (bound to ‘C-x e’) repeatedly – the first time with ‘C-x e’ and with only ‘e’ subsequently. After you press another key, things are back to normal.

But you cannot call the non-repeatable command ‘transpose-lines’ (bound to ‘C-x C-t’ repeatedly. That is, you cannot use ‘C-x C-t C-t C-t’…, holding ‘C-t’ pressed, to repeat the action of transposing lines.

*RF*: this command works by calling an interactive command and pressing Enter again to repeat it again and again. I guess its purpose is to be iterative.

#+begin_src emacs-lisp

  (defun repeat-command (command)
    "Repeat COMMAND."
    (require 'repeat)
    (let ((repeat-previous-repeated-command  command)
          (repeat-message-function           #'ignore)
          (last-repeatable-command           'repeat))
      (repeat nil)))

#+end_src

Given an ordinary, non-repeatable command ‘foo’, just do this to get a repeatable one:

#+begin_src emacs-lisp

  (defun repeatable-foo (arg) ; or whatever other arguments
    "whatever..."
    (interactive "P") ; or whatever else
    (repeat-command 'foo))

#+end_src

I use this in several of my libraries: Bookmark+, Zones, Isearch+, Icicles, misc-cmds.el, thing-cmds.el. – DrewAdams

*Simple code to make EVERY command repeatable*
This makes all key-bindings repeatable even “single”-key shortcuts like ‘C-f’ or ‘M-C-f’ (both repeated by subsequent ‘f’). Stuff like ‘C-x o’ is repeated with ‘o’ and `C-x C-@’ repeats with `@’. There is no need to explicitly configure functions or shortcuts to make them repeatable, because this works on all commands. On the other hand, there is no option to (easily) configure exceptions. So far this wasn’t a Problem for me.

#+begin_src emacs-lisp

  (defun easy-repeat ()
    "Repeat last command by typing it's last key again."
    (unless (eq this-command 'self-insert-command)
      (let* ((keys (recent-keys))
           (len (length keys))
           (key (unless (zerop len) (aref keys (1- len))))
           (key-str (when (or (integerp key) (symbolp key) (listp key))
                      (single-key-description (event-basic-type key))))
           (map (make-sparse-keymap)))
        (define-key map (kbd key-str) this-command)
        (set-transient-map map))))
  ;; (remove-hook 'post-command-hook 'easy-repeat)

#+end_src

**** Using transient map
[[http://xahlee.info/emacs/emacs/elisp_repeat_command_key.html][Xah]]

Some command lets you press a key to call it again, without relying on your current global keymap nor any keymap.

For example, ~text-scale-adjust~. You can call it by =Alt+x= ~text-scale-adjust~. Once you call it, press =+= to increase font size, === to decrease, =0= to resize to default.

Another command that have such key feature is ~repeat~. Once called, press whatever key that invoked it will repeat the command.

*Add a Repeat Key to Any Command*
You can add a repeat key for any emacs command. Just write a wrapper function and add ~set-transient-map~ at end.

Suppose you want add a repeat key =r= to call ~forward-word~ (moving cursor to right by word) and =l= for ~backward-word~

#+begin_src emacs-lisp

  (defun my-forward-word ()
    "move cursor right 1 position.
  Press r will do it again, press l will move to left. Press other key to exit.
  Version 2021-08-08 2023-03-30"
    (interactive)
    (forward-word)
    (set-transient-map
     (let ((xkmap (make-sparse-keymap)))
       (define-key xkmap (kbd "r") 'my-forward-word)
       (define-key xkmap (kbd "l") 'my-backward-word)
       xkmap)))

  (defun my-backward-word ()
    "move cursor left 1 position.
  Press r will do it again, press l will move to left. Press other key to exit.
  Version 2021-08-08 2023-03-30"
    (interactive)
    (backward-word)
    (set-transient-map
     (let ((xkmap (make-sparse-keymap)))
       (define-key xkmap (kbd "r") 'my-forward-word)
       (define-key xkmap (kbd "l") 'my-backward-word)
       xkmap)))

#+end_src

*** Key syntax examples
**** One Modifier

| "M-a"    | Alt+a     |
| "C-a"    | Ctrl+a    |
| "A"      | Shift+a   |
| "S-<f3>" | Shift+ F3 |

**** 1 Modifier + Special Key

| "M-<f3>" | Alt+F3   |
| "C-<f3>" | Ctrl+F3  |
| "S-<f3>" | Shift+F3 |
|          |          |
| "M-<up>" | Alt+↑    |
| "C-<up>" | Ctrl+↑   |
| "S-<up>" | Shift+↑  |

**** 2 Modifier Keys

| "M-A"        | Alt+Shift+a               |
| "C-A"        | Ctrl+Shift+a              |
| "C-M-a"      | Ctrl+Alt+a                |
|              |                           |
| "M-#"        | Alt+Shift+3 or Alt+#      |
| "C-#"        | Ctrl+Shift+3 or Ctrl+#    |
| "C-M-3"      | Ctrl+Alt+3                |
| "C-S-<kp-3>" | Ctrl+Shift+“number pad 3” |

**** 3 Modifier Keys

| "C-M-S-a"    | Ctrl+Alt+Shift+a               |
| "C-M-!"      | Ctrl+Alt+Shift+1 or Ctrl+Alt+! |
| "C-M-S-<up>" | Ctrl+Alt+Shift+↑               |

**** Arrow and Home End Cluster Keys

| "<left>"   | left arrow                  |
| "<right>"  | right arrow                 |
| "<up>"     | up arrow                    |
| "<down>"   | down arrow                  |
|            |                             |
| "<next>"   | page down key               |
| "<prior>"  | page up key                 |
|            |                             |
| "<insert>" | Ins key                     |
| "<delete>" | Del key ⌦ (forward delete) |
|            |                             |
| "<home>"   |                             |
| "<end>"    |                             |

**** Enter, Return, Space, Backspace Keys

| <backspace> | backspace key ⌫                    |
| "SPC"       | Space key                           |
| "<return>"  | Enter/Return key while in GUI emacs |

**** Function, Numberpad  keys

| "<f3>"   | F3 key                  |
| "<kp-3>" | the key 3 on number pad |

**** No Modifiers
A shortcut can be created without any modifier keys.

    "3"
    "a"
    "é"
    "α"
    "你"

**** Misc

| <M-backspace> | M-DEL    |
| <M-clear>     | C-M-l    |
| <M-delete>    | M-DEL    |
| <M-escape>    | M-ESC    |
| <M-kp-next>   | <M-next> |
| <M-linefeed>  | C-M-j    |
| <M-return>    | M-RET    |
| <M-tab>       | M-TAB    |

*** Key binding conventions
**** Brief
The Emacs guide, indicates that the only key space reserved for users to define, are the function keys =F5= to =F9=, and key stroke sequence starting with =Ctrl+c= followed by a single letter key.

This is a severe restraint to the utility of customized shortcuts. =F5= to =F9= are only 6 keys. The key sequence starting with =Ctrl+c= followed by a letter, is multiple keystrokes and rather a painful choice, and there are only 26 spaces there.

The function keys, =F1= to =F12=, are very good key space for user to define their own shortcuts. The digit key shortcuts, =0= to =9=, are also good user space. These keys can be used with any combination of =Ctrl=, =Alt=, =Shift=. For example, a user might define them to insert various templates, headers/footers, a system of customized HTML/XML tags. Or, she might assign them to various special emacs modes such as dired, shell, ftp, email, calendar, calc, *scratch*, make-frame-command (Open a new window), insert signature.

- Don’t define =C-c letter= as a key in Lisp programs. Sequences consisting of =C-c= and a letter (either upper or lower case; ASCII or non-ASCII) are reserved for users; they are the only sequences reserved for users, so do not block them.
- Function keys =F5= through =F9= without modifier keys are also reserved for users to define.
- Sequences consisting of =C-c= followed by a control character or a digit are reserved for major modes.
- Sequences consisting of =C-c= followed by ={=, =}=, =<=, =>=, =:= or =;= are also reserved for major modes.
- Sequences consisting of =C-c= followed by any other ASCII punctuation or symbol character are allocated for minor modes. Using them in a major mode is not absolutely prohibited, but if you do that, the major mode binding may be shadowed from time to time by minor modes.

**** Bad Key choices
[[http://xahlee.info/emacs/emacs/emacs_good_keybinding.html][Xah]]

 Best not to bind the following keys.

- Ctrl+? :: for historical reasons, Emacs treats the DEL character as the control equivalent of ?

- Ctrl+h ::  =C-h= have a special status in emacs's key system for help-map. For example, type =Ctrl+x=, then type =Ctrl+h=, it'll list what valid keys can follow and the associated command.

- Esc or Ctrl+[ :: the =Esc= key is tied to =Ctrl+[= and Meta Key . Esc by itself has complicated meanings depending when it is pressed and how many times it is pressed.

- Ctrl+Shift+letter :: in text terminals, it cannot distinguish shifted and unshifted versions of such combination. Works fine if you always use emacs in a GUI environment.

- Ctrl+m or Enter :: these are the same by default. Normally they are bind to a command that sends ASCII 10 LINE FEED character.

- Ctrl+i or Tab :: these are the same by default. Normally they are bind to a command that sends ASCII 9 horizontal tab character.

**** Good Key choices
***** Brief
Emacs has some 7 thousand commands. By default, 800 of them have key shortcuts. All the common key spots are used. If you define your own keys without care, you may find that many major mode or minor mode override your keys, because they have priority.

By official emacs documentation Key Binding Conventions (ELISP Manual) , the key space reserved for users are the function keys =F5= to =F9=, and =Ctrl+c= letter. This is very restrictive.

The following keys are good spots for your own definitions, and does not cause any problems in practice.

***** F5, F6, F7, F8, F9, F11, F12
Not defined by emacs. Combination with =Alt= or =Ctrl= or =Shift= is also good. Make sure they are not used by the OS. Best is to create key sequence with them.

***** F1, F2, F3, F4, F10, F11
Their default commands are not frequently used, or, better with other keys.

***** Ctrl+0 to Ctrl+9, Alt+0 to Alt+9
By default they are ~digit-argument~. Such is not very frequently used. If you need them, use the more general ~universal-argument~ 【 =Ctrl+u= 】 instead.

***** Number Pad Keys
Very useful, but depending on which emacs distro/OS you are using, or if you use emacs in terminal or GUI, binding these keys may not work.

*** Keybinding system documentation
*System design conventions (RF)*

- The most frequently used commands should *bind to the most easy-to-press keys*
- Modifier keys must be changed to be used as leader keys (enable Sticky keys)
- The primary modifier key is the =Meta= key (~M-~ ) (the physical =Meta= key should be in the thumb position)
- The =Meta= modifier key will contain the most useful global commands (e.g. move characters and lines, delete characters and word, switch and removes windows, replace strings, selections commands, ...)
- Commands are usually grouped (e.g. inverted T on the right home row: move characters; left hand: kill commands, right set of number (6,7,8,9); selection commands, ...)
- The right hand has groups of movements (e.g. move characters, lines, scroll, ...) while the left hand has kill and delete commands (delete characters, kill words or text, ...)
- The combination =Meta= + =Shift= (~M-S-~ ) or =Control= + =Shift= (~C-S-~ ) contains the other commands that don't fit on =Meta= (~M-~) or =Control= (~C-~) key
- The most important default emacs standars remain the same (e.g. global prefix ~C-x~, mode prefix ~C-c~, help map ~C-h~, cancel ~C-g~, ...)
- The =Control= modifier key contains main default Emacs commands (e.g. prefix like ~ctl-x~, ~ctl-c~, help ~C-h~, cancel ~C-g~, universal argument ~C-u~, newline ~C-m~, ...), universal standar commands (e.g. cut ~C-x~, copy ~C-c~, paste ~C-v~, open ~C-o~, ...), and other common Emacs commands related to standar commands (e.g. switch buffers, search, ...), and the most common/useful ones that don't fit into the =Meta= modifier
- The =Modifier= + =Shift= keys (~M-S-~ or ~C-S-~ ) usually include reverse commands (e.g. switch window right/left) less common commands (e.g. open file other window) ,  and commands that are related to another (e.g. switch/resize window)
- Major modes are built with key sequences that begin with a leader key (=<f6>=, =<f7>=, =<f8>=, =<tab>=, =<insert>=, ...) usually the 20 most used command are configured
- In general, in some minor modes and maps, commands that use the =Meta= modifier to move lines or other essential comamnds (e.g. ~M-n~ , ~M-p~ to move up/down in history) are exchanged for the =Control= + =Shift= modifier (e.g. ~C-S-n~, ~C-S-p~) since the =Meta= modifier is already used for basic movements
- The ~ctl-c~ prefix can be used to set additional commands that don't fit in other maps, e.g. (~C-c g~ magit-dispatch, ~C-c f~ magit-file-dispatch)
- The ~ctl-x~ map has some free keybindings, which can be remapped to any useful key (~C-x c~, ~C-x g~, ~C-x j~, and ~C-x w~), e.g. (~C-x g~ magit-status).
- The =Meta= + =Control= + =Shift= key combinations are generally intended for use with keyboard macros so they don't interfere with other manual bindings.

*Steps to set up bindings in minor modes*

- use the inverted T (=ijkl=) for the main movement (up/down/left/right), and adjacent keys like (=uo=) for other movements
- use the inverted T on the left hand (=esdf=) for main editing commands such as deleting chars to the left or right, words, sentences, ...
- use prefixes for commands with multiple subcommands. Use the same key to enter the prefix for the most frequently used command, e.g., =f6 m= -> prefix to ~flycheck~, =f6 m m= -> ~flycheck-list~ (most frequently used), =f6 m i= -> ~flycheck-previous-error~, and =f6 m k= -> ~flycheck-next-error~ (=ik= inverted T movements up/down) or use the most frequently used keys (=htns=) for the other commands

** Packages
*** Brief
Emacs is extended by implementing additional features in /packages/, which are Emacs Lisp libraries. These could be written by you or provided by someone else. If you want to install such a package so it is available in your future Emacs session, you need to compile it and put it in a directory where Emacs looks for Lisp libraries.

Packages can also be provided by package /archives/, which are large collections of Emacs Lisp packages. Each package is a separate Emacs Lisp program, sometimes including other components such as an Info manual.

To list the packages available for installation from package archives, type [[Package installation][M-x list-packages RET]].

By default, Emacs downloads packages from a package archive maintained by the Emacs developers and hosted by the GNU project. Optionally, you can also download packages from archives maintained by third parties.

*Package vs library*
Note that a “package” is (sometimes) different from an Emacs Lisp “library”. The ~(use-package foo)~ declaration tells use-package to load the /library/ ~foo.el~, which in the overwhelming majority of cases also resides in a /package/ named ~foo~. But the package ~foo~ might also contain a library named ~foo-extra.el~. If that library is not loaded automatically, you will need a separate ~use-package~ declaration to make sure that it is loaded when needed.

*** package.el
**** Brief
The idea behind ~package.el~ is to be able to download packages and install them.  Packages are versioned and have versioned dependencies. Furthermore, this supports built-in packages which may or may not be newer than user-specified packages. This makes it possible to upgrade Emacs and automatically disable packages which have moved from external to core.

A package is described by its name and version. The distribution format is either a tar file or a single ~.el~ file.

A tar file should be named ~NAME-VERSION.tar~. The tar file must unpack into a directory named after the package and version: ~NAME-VERSION~. It must contain a file named ~PACKAGE-pkg.el~ which consists of a call to define-package. It may also contain a "dir" file and the info files it references.

A ~.el~ file is named ~NAME-VERSION.el~ in the remote archive, but is installed as simply ~NAME.el~ in a directory named ~NAME-VERSION~.

The downloader downloads all dependent packages. By default, packages come from the official GNU sources, but others may be added by customizing the ~package-archives~ alist. Packages get byte-compiled at install time.

At activation time we will set up the [[Load path][load-path]] and the info path, and we will load the package's [[Autoload][autoloads]]. If a package's dependencies are not available, we will not activate that package.

/ELPA/ (or Emacs Lisp Package Archive) is the official GNU Emacs ~package.el~ repository (None is required. ELPA is preconfigured in Emacs 24).

**** Package states
Conceptually a package has multiple state transitions:
- download :: fetching the package from ELPA.
- install :: untar the package, or write the ~.el~ file, into ~~/.emacs.d/elpa/~ directory.
- autoload generation ::
- byte compile :: currently this phase is done during install, but we may change this.
- activate :: evaluate the autoloads for the package to make it available to the user.
- load :: actually [[Load][load]] the package and run some code from it.

**** Install packages automatically on startup
Using the ~package.el~ UI is ok if you’re a casual Emacs user, but what if you have a custom Emacs configuration, stored under version control, that you’d like to instantly deploy on any OS/machine. Here in play comes ~package.el~ ’s programmer interface.

The following code check if all of the packages in the list are installed and if any of them are not installed if refreshes the local package database (in the case a required package for recently added to the remote repo) and installs them.

But the [[Use package]] also helps in doing that, and more. It allows to declare packages, install and load them asynchronously and declare their configuration.

#+begin_src emacs-lisp

  (require 'cl-lib)

  (defvar my-packages
    '(ack-and-a-half auctex clojure-mode coffee-mode deft expand-region
                     gist groovy-mode haml-mode haskell-mode inf-ruby
                     magit magithub markdown-mode paredit projectile python
                     sass-mode rainbow-mode scss-mode solarized-theme
                     volatile-highlights yaml-mode yari zenburn-theme)
    "A list of packages to ensure are installed at launch.")

  (defun my-packages-installed-p ()
    (cl-loop for p in my-packages
             when (not (package-installed-p p)) do (cl-return nil)
             finally (cl-return t)))

  (unless (my-packages-installed-p)
    ;; check for new packages (package versions)
    (package-refresh-contents)
    ;; install the missing packages
    (dolist (p my-packages)
      (when (not (package-installed-p p))
        (package-install p))))

#+end_src

**** Straight.el, other alternative
~straight.el~ is a "Next-generation, purely functional package manager for the Emacs hacker".

The primary differences are that:
- ~straight.el~ clones Git repos and builds packages from source, instead of downloading tarballs from a central server
- ~straight.el~ uses the init-file as a sole source of truth, whereas ~package.el~ stores mutable state outside the init-file
- ~straight.el~ focuses on reproducibility and local modification, neither of which are supported in any way by ~package.el~

*** Package installation
Packages are most conveniently installed using the package menu ~M-x list-packages~, but you can also use the command ~M-x package-install~. This prompts for the name of a package with the ~available~ status, then downloads and installs it. Similarly, if you want to upgrade a package, you can use the ~M-x package-upgrade~ command, and if you want to upgrade all the packages, you can use the ~M-x package-upgrade-all~ command.

Once a package is downloaded, byte-compiled and installed, it is made available to the current Emacs session. *Making a package available adds its directory to [[Load path][load-path]] and loads its autoloads*. The effect of a package’s autoloads varies from package to package. Most packages just make some new commands available, while others have more wide-ranging effects on the Emacs session.

*Note* that installing a package using ~package-install~ takes care of placing the package’s Lisp files in a directory where Emacs will find it, and also writes the necessary initialization code into your init files, making the manual customizations unnecessary.

#+begin_src emacs-lisp

  ;; Enable installation of packages from MELPA:
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  ;; Note that you'll need to run M-x package-refresh-contents or M-x
  ;; package-list-packages to ensure Emacs has fetched the MELPA package
  ;; list before you can install packages with M-x package-install or similar

#+end_src

*** Package files and directory layout
Each package is downloaded from the package archive in the form of a single /package file/ —either an Emacs Lisp source file, or a tar file containing multiple Emacs Lisp source and other files. Package files are automatically retrieved, processed, and disposed of by the Emacs commands that [[Package installation][install packages]]. Should you ever need to install a package directly from a package file, use the command ~M-x package-install-file~.

Once installed, the contents of a package are placed in a subdirectory of ~~/.emacs.d/elpa/~ (you can change the name of that directory by changing the variable[[ package-user-dir]]). The package subdirectory is named ~name-version~, where name is the package /name/ and /version/ is its version string.

In addition to ~package-user-dir~, Emacs looks for installed packages in the directories listed in [[package-directory-list]]. These directories are meant for system administrators to make Emacs packages available system-wide; Emacs itself never installs packages there.

*Deleting* a package involves deleting the corresponding package subdirectory. This only works for packages installed in ~package-user-dir~; if told to act on a package in a system-wide package directory, the deletion command signals an error.

** Use package
*** Brief
To install a desired package without using use-package, one may have to manually install it from GitHub and put it under a load path where Emacs can find it, for instance with [[path][(add-to-list 'load-path "/path/to/installed-package-repo")]]. Alternatively, you could open up the package list in Emacs with [[Package installation][M-x list-packages]]. Either way, you’d have to explicitly call [[require feature][(require 'package-name)]] in your ~init.el~ before you could do any configuration. Lastly, any configuration of the package may need to be wrapped in a [[Hooks for loading][(with-eval-after-load 'package-name ...)]] block, to avoid running into undefined variables and functions before your package is fully loaded. Well, the good news is that use-package abstracts all of this away from you.

The [[use-package]] macro allows you to *isolate and set up package customization in your init file in a declarative way*. It can help with common customization, such as binding keys, setting up [[Hooks][hooks]], [[Defining customization variables (defcustom)][customizing]] user options and faces, [[Autoload][autoloading]], and more. It also helps you keep Emacs startup fast.

Note that use-package is not a package manager. Although use-package does have the useful capability to interface with the Emacs package manager, *its primary purpose is help with the configuration and loading of packages*, not with managing their download, upgrades, and installation.

*Note* that each call to the ~use-package~ macro in your init file is a *declaration*.

The ~use-package~ macro provides the [[:ensure]] and ~:pin~ (pin a package to a specific archive, for example, from GNU ELPA or NonGNU ELPA) keywords that interface with standard Emacs [[Package installation][package manager]] to automatically install packages.

By default, ~use-package~ assumes that you are using the Emacs built-in [[package.el]] package manager.

*** Loanding Packages
Before use-package can load an Emacs Lisp package, it must be available in a directory on your [[Load path][load-path]]. When you install packages using the built-in ~install-package~ command, it will do this automatically for you. Packages shipped with Emacs (built-in packages) are always available.

use-package can interface with ~package.el~ to install packages on Emacs start.

*Forcing package to load immediately*
The presence of autoloading [[Deferring package loading][trigger keywords]] can be overridden using [[:demand t]], which forces the package to load immediately. Thus, even if you use an autoloading keyword such as [[:bind]], adding ~:demand~ will force loading to occur immediately. It will also avoid creating an autoload for the bound key, as it would be redundant.

If you specify both ~:demand t~ and ~:defer t~, the [[:defer]] keyword will take precedence.

*Note*: when enabled the 'package-install-upgrade-built-in' (nil by default) variable, 'package-install' will include in the list of upgradeable packages those built-in packages (like Eglot and use-package) for which a newer version is available in package archives, and will allow installing those newer versions.

*** Deferring package loading
use-package allows setting things up in such a way that packages are only loaded when some of the package’s commands is first used (either with ~M-x~ or via some key binding). This is based on [[Autoload][autoloading]].

Some ~use-package~ keywords provide autoload /triggers/ that cause a package to be loaded when certain events occur. For example, the [[:hook]] keyword sets up a trigger that fires when the specified hook is run, and then loads the package automatically. The other *trigger keywords* are [[:commands]] , [[:bind]] , [[:bind*]] , [[:bind-keymap]] , [[:bind-keymap*]] , [[:mode , :interpreter][:mode]] , and [[:mode , :interpreter][:interpreter]].

If you did not specify any autoloading keyword, use-package will fall back to loading the package immediately.

[[:defer]] works to postpone loading the package.

Using ~:defer t~ by itself like this is rarely useful. Typically, you would only use it together with a keyword like [[:config]], or [[:ensure]].

*Making ~:defer t~ the default*
If you customize the user option ~use-package-always-defer~ to non-~nil~, the ~use-package~ macro will behave as if ~:defer t~ is always specified. This can be overridden for individual declarations using either ~:defer nil~ or [[:demand][:demand t]].

*Defer loading until idle for N seconds*
You can also give a numeric argument /n/ to ~:defer~ to specify that a package should be loaded (if it hasn’t already) after Emacs has been idle for /n/ seconds.

#+begin_src emacs-lisp

  (use-package foo
    :defer 30)
  ;; make use-package load foo after 30 seconds of idle time

#+end_src

*** use-package
The call to the ~use-package~ macro will *load a package either immediately, or when the package is first used* (via [[Autoload][autoloading]]). In the simplest case, a ~use-package~ declaration loads a package when it is evaluated. If the declaration is in your init file, this happens automatically each time Emacs is started.

If you did not specify any [[Deferring package loading][autoloading keyword]], use-package will fall back to loading the package immediately.

The declaration below immediately loads the library ~foo~, this declaration is equivalent to using [[require feature][require]], with some use-package specific error handling added in. Just like ~require~, it needs the package ~foo~ to be installed and available via your [[Load path][load-path]].

#+begin_src emacs-lisp

  (use-package foo)

#+end_src

If the library ~foo~ is not available in your ~load-path~, the declaration logs a warning to the ~*Messages*~ buffer. The [[:ensure]] keyword takes care of *installing the package if it's not already on the system*, you can use ~:ensure t~ or set the ~use-package-always-ensure~ variable to non-~nil~ to set this behavior globally for all packages.

*Note*: If the above declaration loads the /library/ ~foo.el~, but the package ~foo~ might also contain a library named ~foo-extra.el~, which is not loaded automatically, you will need a separate ~use-package~ declaration to make sure that it is loaded when needed.

*** Order to evaluate keywords
**** :preface
The ~:preface~ section *is evaluated before anything else* (evaluated first), except [[:disabled]] and [[:ensure]]. It can be used to establish function and variable definitions that will:

1. Make the byte-compiler happy: it will not complain about functions whose definitions are unknown.
2. Define functions and variables that will be used in an [[:if , :when , :unless][:if]] test.

Note that whatever is specified within ~:preface~ *is evaluated both at load time and at byte-compilation time*, in order to ensure that definitions are seen by both the Lisp evaluator and the byte-compiler. Therefore, you should avoid having any side-effects in your ~:preface~ forms, and restrict them to symbol declarations and definitions.

Where possible, it is better to avoid ~:preface~, [[:config]] and [[:init]]. Instead, prefer autoloading keywords such as [[:bind]], [[:hook]], and [[:mode , :interpreter][:mode]], as they will take care of setting up autoloads for you without any need for boilerplate code.

**** :init
The ~:init~ section is *evaluated just before the package is loaded* (always executed (Not lazy)). Note that the ~:init~ form is run unconditionally – even if the package happens to not exist on your system. You must therefore remember to restrict ~:init~ code to what would succeed either way; put the rest in the [[:config]] section. ~:init~ also always happens before package load, whether ~:config~ has been deferred or not.

In general, you should keep ~:init~ forms as simple and quick as possible, and put as much as you can get away with into the ~:config~ section. That way, deferred loading can help your Emacs start as quickly as possible.

Where possible, it is better to avoid [[:preface]], ~:config~ and ~:init~. Instead, prefer autoloading keywords such as [[:bind]], [[:hook]], and [[:mode , :interpreter][:mode]], as they will take care of setting up autoloads for you without any need for boilerplate code.

#+begin_src emacs-lisp

  ;; Evaluate some Lisp before the foo package is loaded:
  (use-package foo
    :init
    (setq foo-variable t))


  ;; As you might expect, you can use :init and :config together:
  (use-package foo
    :init
    (setq foo-variable t)
    :config
    (foo-mode 1))


  ;; What :bind does behind the scenes (useful to understand the keywords):
  (use-package ace-jump-mode
    :bind ("C-." . ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :commands ace-jump-mode
    :init
    (bind-key "C-." 'ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :defer t
    :init
    (autoload 'ace-jump-mode "ace-jump-mode" nil t)
    (bind-key "C-." 'ace-jump-mode))

#+end_src

**** :config
The ~:config~ section *is evaluated after the package has been loaded* (after lazily loading the package). If the package is loaded immediately, this happens immediately after that, but if loading is done lazily, this is deferred until after the package has been loaded.

In general, you should keep [[:init]] forms as simple and quick as possible, and put as much as you can get away with into the ~:config~ section. That way, deferred loading can help your Emacs start as quickly as possible.

Where possible, it is better to avoid [[:preface]], ~:config~ and ~:init~. Instead, prefer autoloading keywords such as [[:bind]], [[:hook]], and [[:mode , :interpreter][:mode]], as they will take care of setting up autoloads for you without any need for boilerplate code.

As you might expect, you can use ~:init~ and ~:config~ together:

#+begin_src emacs-lisp

  (use-package foo
    :init
    (setq foo-variable t)
    :config
    (foo-mode 1))


  (use-package hi-lock
    :defer t
    :init (add-hook 'some-hook 'hi-lock-mode)
    :config (use-package my-hi-lock)
    :bind (("M-o l" . highlight-lines-matching-regexp)
           ("M-o r" . highlight-regexp)
           ("M-o w" . highlight-phrase)))
  ;; This will load hi-lock when some of its commands or variables are
  ;; first used, bind 3 keys to its commands, and additionally load the
  ;; my-hi-lock package (presumably further customizing hi-lock) after
  ;; loading hi-lock.

#+end_src

*** Loading keywords
**** :ensure
The ~:ensure~ keyword makes ~use-package~ *ask* the Emacs package manager to *install a package if it is not already present on your system*.

This is particularly useful if you use your init file on more than one system.

To avoid using ~:ensure t~ on all packages that have not been previously installed, you can set the ~use-package-always-ensure~ variable to no-~nil~ to get this behavior globally for all packages.

*Note*: ~:ensure nil~ avoid ~use-package~ from asking the Emacs package manager for the package (avoid fetching it in online archives like melpa). ~:ensure~ does not automatically keep packages up to date. It just ensures that the package is installed.

#+begin_src emacs-lisp

  (use-package magit
    :ensure t)

  ;; You can customize the user option use-package-always-ensure to a
  ;; non-nil value if you want this behavior to be global for all packages:
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
  ;; Override the above setting for a single package:
  (use-package foo
    :ensure nil)


  ;; Install a different package from the one named by use-package:
  (use-package tex
    :ensure auctex)

#+end_src

**** :defer
If you did not specify any [[Deferring package loading][autoloading keyword]], use-package will fall back to loading the package immediately (typically when Emacs is starting up). This can be overridden using the ~:defer~ keyword. It takes one boolean argument: a non-~nil~ value means to stop this package from being immediately loaded (*deferring package loading*). Using ~:defer~ postpones loading the package.

#+begin_src emacs-lisp

  ;; If you have installed a package from GNU ELPA that provides it’s own
  ;; autoloads, it is often enough to say:
  (use-package foo
    :defer t)
  ;; Now, when run any autoloaded command, the package is loaded automatically


  ;; What :bind does behind the scenes (useful to understand the keywords):
  (use-package ace-jump-mode
    :bind ("C-." . ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :commands ace-jump-mode
    :init
    (bind-key "C-." 'ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :defer t
    :init
    (autoload 'ace-jump-mode "ace-jump-mode" nil t)
    (bind-key "C-." 'ace-jump-mode))

#+end_src

Using ~:defer t~ by itself like this is rarely useful. Typically, you would only use it together with a keyword like [[:config]], or [[:ensure]].

*Defer loading until idle for N seconds*
You can also give a numeric argument /n/ to ~:defer~ to specify that a package should be loaded (if it hasn’t already) after Emacs has been idle for /n/ seconds.

#+begin_src emacs-lisp

  (use-package foo
    :defer 30)
  ;; make use-package load foo after 30 seconds of idle time

#+end_src

**** :demand
The presence of autoloading [[Deferring package loading][trigger keywords]] can be overridden using ~:demand~ *forces the package to load immediately*. Thus, even if you use an autoloading keyword such as [[:bind]], adding ~:demand~ will force loading to occur immediately. It will also avoid creating an autoload for the bound key, as it would be redundant.

If you specify both ~:demand t~ and ~:defer t~, the [[:defer]] keyword will take precedence.

**** :after
Allows a fairly rich description of the exact *conditions when loading should occur* (*loading packages in sequence*). The ~:after~ keyword takes as argument either a symbol indicating the package name, a list of such symbols, or a list of selectors.

Here is an example of using the GNU ELPA packages ~hydra~, ~ivy~, and ~ivy-hydra~. Note that ~ivy-hydra~ will always be loaded last:

#+begin_src emacs-lisp

  (use-package hydra)

  (use-package ivy)

  (use-package ivy-hydra
    :after (ivy hydra))
  ;; Because the declarations are evaluated in the order they occur, the
  ;; use of :after is not strictly necessary. However, if hydra and ivy
  ;; were to be autoloaded, using :after guarantees that ivy-hydra is not
  ;; loaded until it is actually needed. By using :after, the above code
  ;; will also work even if the order of the declaration changes.

#+end_src

*Note*: when setting ~use-package-always-defer~ to a non-~nil~ value, and also using the ~:after~ keyword. In that case, you will need to specify how the declared package is to be loaded: for example, by some [[:bind]]. If you are not using one of the keywords that registers autoloads, such as ~:bind~ or [[:hook]], and your package manager does not provide autoloads, it is possible that your package will never be loaded if you do not add [[:demand t]] to those declarations.

*Using ~:after~ selectors*
The ~:after~ keyword also accepts a list of selectors. By default, ~:after (foo bar)~ is the same as ~:after (:all foo bar)~, meaning that loading of the given package will not happen until both ~foo~ and ~bar~ have been loaded.

#+begin_src emacs-lisp

  :after (foo bar)
  :after (:all foo bar)
  :after (:any foo bar)
  :after (:all (:any foo bar) (:any baz quux))
  :after (:any (:all foo bar) (:all baz quux))

#+end_src

When you nest selectors, such as in ~(:any (:all foo bar) (:all baz quux))~, it means that the package will be loaded when either both ~foo~ and ~bar~ have been loaded, or when both ~baz~ and ~quux~ have been loaded.

**** :requires
While the [[:after]] keyword delays loading until the dependencies are loaded, the somewhat simpler ~:requires~ keyword *never loads the package if the dependencies are not available when* the [[use-package]] declaration is evaluated. In this context, “available” means that ~foo~ is available if [[Features][(featurep 'foo)]] evaluates to a non-~nil~ value.

#+begin_src emacs-lisp

  (use-package abbrev
    :requires foo)
  ;; This is the same as:
  (use-package abbrev
    :if (featurep 'foo))

  ;; As a convenience, a list of such packages may be specified:
  (use-package abbrev
    :requires (foo bar baz))

#+end_src

**** :if , :when , :unless
The ~:if~ , ~:when~ , and ~:unless~ keywords predicates the loading and initialization of packages (*loading packages conditionally*). They all accept one argument, an Emacs Lisp form that is evaluated at run-time.

If the argument of the ~:if~ keyword evaluates to non-~nil~, the package will be loaded and initialized. The ~:when~ keyword is provided as an alias for ~:if~. Finally, the ~:unless~ keyword is the inverse of ~:if~, such that ~:unless~ foo means the same thing as ~:if (not foo)~.

#+begin_src emacs-lisp

  ;; If you only want to load foo in graphical Emacs sessions, you could use:
  (use-package foo
    :if (display-graphic-p))

  ;; Some common use cases:
  ;; Loads a package only on GNU/Linux.
  :if (eq system-type 'gnu/linux)

  ;; Loads a package only when the foo package is installed.
  :if (package-installed-p 'foo)

  ;; Loads a package only when foo.el is available in your load-path
  ;; (for example, if you installed that file manually):
  :if (locate-library "foo.el")

#+end_src

If you need to make a use-package form conditional so that the condition occurs before even [[:ensure]] or [[:preface]], use ~when~ around the ~use-package~ form itself. For example:

#+begin_src emacs-lisp

  (when (memq window-system '(mac ns))
    (use-package foo
      :ensure t))

#+end_src

**** :commands
In some cases, you might need or want to *provide your own autoloads*. The ~:commands~ keyword autoload an interactive command, takes either a symbol or a list of symbols as its argument. It creates autoloads for those commands (which defers loading of the module until those commands are used).

*Note*: To autoload non-interactive functions use [[:autoload]].

The example below autoloads the commands ~isearch-moccur~ and ~isearch-all~ from the package ~color-moccur.el~. When one of these two commands are used, the package will be loaded. At that point, ~moccur-edit~ is also loaded, to allow editing of the ~moccur~ buffer.

#+begin_src emacs-lisp

  (use-package color-moccur
    :commands (isearch-moccur isearch-all)
    :bind (("M-s O" . moccur)
           :map isearch-mode-map
           ("M-o" . isearch-moccur)
           ("M-O" . isearch-moccur-all))
    :init
    (setq isearch-lazy-highlight t)
    :config
    (use-package moccur-edit))


  ;; What :bind does behind the scenes (useful to understand the keywords):
  (use-package ace-jump-mode
    :bind ("C-." . ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :commands ace-jump-mode
    :init
    (bind-key "C-." 'ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :defer t
    :init
    (autoload 'ace-jump-mode "ace-jump-mode" nil t)
    (bind-key "C-." 'ace-jump-mode))

#+end_src

**** :autoload
Takes the same arguments as [[:commands]], but is used to *autoload non-interactive functions*.

#+begin_src emacs-lisp

  (use-package org-crypt
    :autoload org-crypt-use-before-save-magic)

#+end_src

*** Configurations keywords
**** :hook
*Allows adding functions to hooks*. It takes one argument of the form /hooks/, specifying one or more functions to add to one or more hooks.

For the purposes of ~:hook~, the name of hook variables should always exclude the ~-hook~ suffix. It is appended automatically.

The use of ~:hook~, as with [[:bind]], [[:mode , :interpreter][:mode]], [[:mode , :interpreter][:interpreter]], etc., causes the functions being hooked to implicitly be read as [[:commands]]. This means that they will establish interactive ~autoload~ definitions for that module, if not already defined as functions, and so [[:defer][:defer t]] is also implied by ~:hook~.

#+begin_src emacs-lisp

  ;; Sets up autoloads for company-mode from the company package,
  ;; and adds company-mode to prog-mode-hook
  (use-package company
    :commands company-mode
    :init
    (add-hook 'prog-mode-hook #'company-mode))
  ;; Using :hook keyword:
  (use-package company
    :hook (prog-mode . company-mode))
  ;; :hook will automatically set up autoloads for the company-mode
  ;; command, so there is no need to use :commands.
  ;; You can simplify the above to the equivalent:
  (use-package company
    :hook prog-mode)


  ;; You can also provide a list of hooks:
  (use-package company
    :hook ((prog-mode text-mode) . company-mode))
  ;; or
  (use-package company
    :hook ((prog-mode . company-mode)
           (text-mode . company-mode)))
  ;; or
  (use-package company
    :hook (prog-mode text-mode))


  ;; DOES NOT WORK
  (use-package ace-jump-mode
    :hook (prog-mode-hook . ace-jump-mode))
  ;; It attempts to add a function to non-existent prog-mode-hook-hook.

#+end_src

**** :bind
***** Brief
*To bind keys globally*, the ~:bind~ autoloading keyword takes as its argument either a single cons or a list of conses. Each cons has the form ~(key . command)~, where /key/ is a string indicating the key to bind, and /command/ is the name of a command (a symbol).

~:bind~ creates an autoload for the command and defers loading of the package until you actually use it, and bind the key to that command.

The ~:bind~ keyword uses the ~bind-keys~ macro from the ~bind-key.el~ library to set up keybindings. It keeps track of all keybindings you make, so that you can display them separately from the default keybindings.

Use ~M-x describe-personal-keybindings~ to see all keybindings you’ve set using either the ~:bind~ keyword or the ~bind-keys~ macro.

#+begin_src emacs-lisp

  ;; Here is an example of using a single cons:
  (use-package ace-jump-mode
    :bind ("C-." . ace-jump-mode))


  ;; Here is an example of using :bind with a list of conses:
  (use-package hi-lock
    :bind (("M-o l" . highlight-lines-matching-regexp)
           ("M-o r" . highlight-regexp)
           ("M-o w" . highlight-phrase)))


  ;; What :bind does behind the scenes (useful to understand the keywords):
  (use-package ace-jump-mode
    :bind ("C-." . ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :commands ace-jump-mode
    :init
    (bind-key "C-." 'ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :defer t
    :init
    (autoload 'ace-jump-mode "ace-jump-mode" nil t)
    (bind-key "C-." 'ace-jump-mode))

#+end_src

***** Key bindings in local keymaps
Slightly different from binding a key to a keymap, is *binding a key within a local keymap* that only exists after the package is loaded. ~use-package~ supports this with a ~:map~ modifier, taking the local keymap to bind to:

#+begin_src emacs-lisp

  (use-package helm
    :bind (:map helm-command-map
                ("C-c h" . helm-execute-persistent-action)))
  ;; The effect of this is to wait until helm has loaded, and then
  ;; to bind the key sequence C-c h to helm-execute-persistent-action
  ;; within Helm’s local keymap, helm-command-map.


  ;; Multiple uses of :map may be specified. Any binding occurring
  ;; before the first use of :map are applied to the global keymap:
  (use-package term
    :bind (("C-c t" . term)
           :map term-mode-map
           ("M-p" . term-send-up)
           ("M-n" . term-send-down)
           :map term-raw-map
           ("M-o" . other-window)
           ("M-p" . term-send-up)
           ("M-n" . term-send-down)))

#+end_src

***** Binding to keymaps
Normally ~:bind~ expects that commands are functions that will be autoloaded from the given package. However, this does not work if one of those commands is actually a [[Keymap basics][keymap]], since keymaps are not functions, and cannot be autoloaded using the built-in ~autoload~ function.

To handle this case, ~use-package~ offers a special, limited variant of ~:bind~ called ~:bind-keymap~. The only difference is that the “commands” bound to by ~:bind-keymap~ must be *keymaps defined in the package, rather than interactive functions*.

#+begin_src emacs-lisp

  (use-package foo
    :bind-keymap ("C-c p" . foo-command-map))

#+end_src

***** Remapping
[[Remapping commands][Remapping of commands]] with ~:bind~ and ~bind-key~ works as expected, because when the binding is a vector, it is passed straight to define-key.

#+begin_src emacs-lisp

  ;; Will rebind fill-paragraph (bound to M-q by default) to unfill-toggle:
  (use-package unfill
    :bind ([remap fill-paragraph] . unfill-toggle))

#+end_src

***** Using special keys
Inside key strings, special keys like ~TAB~ or ~F1–F12~ have to be written inside angle brackets, e.g., ~"C-<up>"~ . Standalone special keys (and some combinations) can be written in square brackets, e.g. ~[tab]~ instead of ~"<tab>"~.

#+begin_src emacs-lisp

  (use-package helm
    :bind (("M-x" . helm-M-x)
           ("M-<f5>" . helm-find-files)
           ([f10] . helm-buffers-list)
           ([S-f10] . helm-recentf)))

#+end_src

***** Binding to repeat-maps
A special case of binding within a local keymap is when that keymap is used by ~repeat-mode~. These keymaps are usually defined specifically for this. Using the ~:repeat-map~ keyword, and passing it a name for the map it defines, will bind all the following keys inside that map, and (by default) set the ~repeat-map~ property of each bound command to that map.

The following example creates a keymap called ~git-gutter+-repeat-map~, makes four bindings in it, then sets the ~repeat-map~ property of each bound command (~git-gutter+-next-hunk~, ~git-gutter+-previous-hunk~, ~git-gutter+-stage-hunks~, and ~git-gutter+-revert-hunk~) to that keymap.

#+begin_src emacs-lisp

  (use-package git-gutter+
    :bind
    (:repeat-map git-gutter+-repeat-map
     ("n" . git-gutter+-next-hunk)
     ("p" . git-gutter+-previous-hunk)
     ("s" . git-gutter+-stage-hunks)
     ("r" . git-gutter+-revert-hunk)))

#+end_src

Specifying ~:exit~ inside the scope of ~:repeat-map~ will prevent the ~repeat-map~ property from being set, so that the command can be used from within the repeat map, but after using it the repeat map will no longer be available. This is useful for commands often used at the end of a series of repeated commands. Example:

#+begin_src emacs-lisp

  (use-package git-gutter+
    :bind
    (:repeat-map my/git-gutter+-repeat-map
     ("n" . git-gutter+-next-hunk)
     ("p" . git-gutter+-previous-hunk)
     ("s" . git-gutter+-stage-hunks)
     ("r" . git-gutter+-revert-hunk)
     :exit
     ("c" . magit-commit-create)
     ("C" . magit-commit)
     ("b" . magit-blame)))

#+end_src

Specifying ~:continue~ /forces/ setting the ~repeat-map~ property (just like /not/ specifying ~:exit~), so the above snippet is equivalent to:

#+begin_src emacs-lisp

  (use-package git-gutter+
    :bind
    (:repeat-map my/git-gutter+-repeat-map
     :exit
     ("c" . magit-commit-create)
     ("C" . magit-commit)
     ("b" . magit-blame)
     :continue
     ("n" . git-gutter+-next-hunk)
     ("p" . git-gutter+-previous-hunk)
     ("s" . git-gutter+-stage-hunks)
     ("r" . git-gutter+-revert-hunk)))

#+end_src

**** :mode , :interpreter
You can use ~:mode~ and ~:interpreter~ to establish a *deferred binding within the* [[auto-mode-alist]] and [[interpreter-mode-alist]] variables. The specifier to either keyword can be a cons cell, a list of cons cells, or a string or regexp.

#+begin_src emacs-lisp

  ;; The package is "python", and the mode is "python-mode":
  (use-package python
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("python" . python-mode))


  ;; Both the :mode and :interpreter keywords also accept a list of regexps:
  (use-package foo
    ;; Equivalent to "\\(ba[rz]\\)\\'":
    :mode ("\\.bar\\'" "\\.baz\\'")
    ;; Equivalent to "\\(foo[ab]\\)":
    :interpreter ("fooa" "foob"))


  ;; That mode is enabled automatically when a file whose name matches the
  ;; regexp "\\.rb\\'", or when the first line of the file (known as the
  ;; “shebang”) matches the string "ruby":
  (use-package ruby-mode
    :mode "\\.rb\\'"
    :interpreter "ruby")
  ;; It can be simplified since the package is "ruby-mode", and the
  ;; mode is the same "ruby-mode":


  ;; All :mode does is that internally expands to the normal Emacs syntax:
  (add-to-list 'auto-mode-alist '("\\.tsx?\\'" . typescript-mode)) ; or
  (add-to-list 'auto-mode-alist '("\\.tsx?\\" . typescript-mode))

#+end_src

**** :magic
Similar to [[:mode , :interpreter][:mode]] and ~:interpreter~, you can also use ~:magic~ and ~:magic-fallback~ to cause *certain function to be run if the beginning of a file matches a given regular expression*, as if these regular expressions were added to ~magic-mode-alist~ and ~magic-fallback-mode-alist~. The difference between ~:magic~ and ~:magic-fallback~, is that the latter has a lower priority than ~:mode~.

#+begin_src emacs-lisp

  ;; This registers an autoloaded command for pdf-view-mode, defers loading
  ;; of pdf-tools, and runs pdf-view-mode if the beginning of a buffer
  ;; matches the string "%PDF".
  (use-package pdf-tools
    :magic ("%PDF" . pdf-view-mode)
    :config
    (pdf-tools-install :no-query))

#+end_src

**** :custom
You normally *set customizable variables* using the ~M-x customize~ interface. However, it is also possible to set them in your ~use-package~ declarations by using the ~:custom~ keyword.

This is better than using setq in a [[:config]] block, as customizable variables might have some code associated with it that Emacs will execute when you assign values to them. (In Emacs 29 and later, there is also the new [[setopt]] macro that does this for you.)

Note that the values customized using ~:custom~ are not saved in the standard Emacs ~custom-file~. You should therefore set each user option using either the ~:custom~ keyword or ~M-x customize-option~ command; the latter will save customized values in the Emacs ~custom-file~. Do not use both for the same variable, as this risks having conflicting values.

#+begin_src emacs-lisp

  (use-package comint
    :defer t
    :custom
    (comint-buffer-maximum-size 20000 "Increase comint buffer size.")
    (comint-prompt-read-only t "Make the prompt read only."))

#+end_src

**** :custom-face
Allows *customization* of package’s *faces*.

#+begin_src emacs-lisp

  (use-package eruby-mode
    :custom-face
    (eruby-standard-face ((t (:slant italic)))))


  (use-package example
    :custom-face
    (example-1-face ((t (:foreground "LightPink"))))
    (example-2-face ((t (:foreground "LightGreen"))) face-defspec-spec))


  (use-package zenburn-theme
    :preface
    (setq my/zenburn-colors-alist
          '((fg . "#DCDCCC") (bg . "#1C1C1C") (cyan . "#93E0E3")))
    :custom-face
    (region ((t (:background ,(alist-get my/zenburn-colors-alist 'cyan)))))
    :config
    (load-theme 'zenburn t))


  (use-package markdown-mode
    :hook (markdown-mode . auto-fill-mode)
    :custom-face (markdown-code-face ((t (:inherit org-block)))))
  ;; same as
  (use-package markdown-mode
    :config
    (add-hook 'markdown-mode-hook #'auto-fill-mode)
    (set-face-attribute 'markdown-code-face nil :inherit 'org-block))

#+end_src

**** :load-path
Provides a convenient way to *add directories to your [[Load path][load path]]*. It takes as argument a symbol, a function, a string or a list of strings. If a directory is specified as a relative file name, it is expanded relative to ~user-emacs-directory~.

#+begin_src emacs-lisp

  (use-package org
    :load-path "site-lisp/org/lisp/"
    :commands org-mode)

#+end_src

When using a symbol or a function to provide a dynamically generated list of directories, you must inform the byte-compiler of this definition, so that the value is available at byte-compilation time. This is done by using the special form ~eval-and-compile~ (as opposed to ~eval-when-compile~). Furthermore, this value is fixed to the value it had during compilation. If the operation is costly, you do not have to repeat it again on each startup.

#+begin_src emacs-lisp

  (eval-and-compile
    (defun ess-site-load-path ()
      (shell-command-to-string "find ~ -path ess/lisp")))


  (use-package ess-site
    :load-path (lambda () (list (ess-site-load-path)))
    :commands R)

#+end_src

**** :diminish , :delight
~use-package~ supports the ~diminish~ and ~delight~ packages, both of which make it possible to *remove or change minor mode strings in your mode-line*. Which one to use is up to you, but you should normally only use one or the other – never both. To use either of them, you must first install the corresponding package from GNU ELPA.

The ~:diminish~ keyword takes as its argument either a minor mode symbol, a cons of the symbol and its replacement string, or just a replacement string, in which case the minor mode symbol is guessed to be the package name with ~-mode~ appended at the end.

#+begin_src emacs-lisp

  ;; First, add the following declaration to the beginning of your init file.
  (use-package diminish :ensure t)

  (use-package abbrev
    :diminish abbrev-mode
    :config
    (if (file-exists-p abbrev-file-name)
        (quietly-read-abbrev-file)))

#+end_src

The ~:delight~ keyword takes as its argument a minor mode symbol, a replacement string, or quoted mode line data (in which case the minor mode symbol is assumed to be the package name with ~-mode~ appended at the end), both of these, or several lists of both. If no arguments are provided, the default mode name is hidden completely.

#+begin_src emacs-lisp

  ;; Hides everything for the foo-mode minor mode in the foo package:
  (use-package foo
    :delight)

  ;; Don't show auto-revert-mode, which doesn't match its package name.
  (use-package autorevert
    :delight auto-revert-mode)


  ;; Here is an example of hiding several built-in minor modes.
  ;; Completely hide visual-line-mode and change auto-fill-mode to " AF".
  (use-package emacs
    :delight
    (auto-fill-function " AF")
    (visual-line-mode))


  ;; You can also use arbitrary Lisp code as argument of :delight. For
  ;; example, to replace foo-mode with the value of the current buffer:
  (use-package foo
    :delight '(:eval buffer-file-name))

#+end_src

**** :pin
use-package can /pin/ a package to a specific archive using the ~:pin~ keyword. This allows you to mix and match packages from different archives. The primary use-case for this is preferring to install packages from GNU ELPA or NonGNU ELPA (indicated by ~gnu~ and ~nongnu~), while installing specific packages from third-party archives.

#+begin_src emacs-lisp

  (use-package company
    :ensure t
    :pin gnu)   ; GNU ELPA

#+end_src

Unfortunately, the third-party archive MELPA uses a versioning scheme based on dates, which means that packages from that archive are always preferred. If you are using that archive, we strongly encourage you to customize ~use-package-always-pin~ to ~nongnu~. This guarantees that you are using a version of that package that has been specifically marked for release by its developer, and not a development snapshot.

If you want to manually keep a package updated and ignore upstream updates, you can pin it to ~manual~. This will work as long as you have not customized a repository to use that name in the ~package-archives~ variable.

#+begin_src emacs-lisp

  (use-package org
    :ensure t
    ;; ignore org-mode from upstream and use a manually installed version
    :pin manual)

#+end_src

~use-package~ signals an error if you try to pin a package to an archive that is not configured using ~package-archives~ (except from the special ~manual~ archive).

** Commands-
*** Lines-
**** list-matching-lines (occur)
Show all lines in the current buffer containing a match for REGEXP.

**** delete-matching-lines (flush-lines)
Delete lines containing matches for REGEXP.

~delete-matching-lines~ starts at the line your cursor is on.

*Note*: the ~kill-matching-lines~ command add the matching lines to the kill ring as a single string, including the newlines that separate the lines.

**** delete-non-matching-lines (keep-lines)
Delete all lines except those containing matches for REGEXP.

~delete-non-matching-lines~ starts at the line your cursor is on.

*Note*: the ~copy-matching-lines~ command add the matching lines to the kill ring as a single string, including the newlines that separate the lines.

**** delete-duplicate-lines
Delete all but one copy of any identical lines in the region.

**** count-matches (how-many)
Print and return number of matches for REGEXP following point.

**** sort-lines
Sort lines in region alphabetically; REVERSE non-nil means descending order

**** reverse-region
Reverse the order of lines in a region.

**** highlight-lines-matching-regexp
Highlight all lines that match REGEXP using FACE.

**** unhighlight-regexp
Remove highlighting of each match to REGEXP set by hi-lock.

**** occur
Show all lines in the current buffer containing a match for REGEXP.

**** xah-fill-or-unfill
This command automatically toggle “fill” or “unfill” on the current paragraph. If there is a text selection, then the command automatically works on the region.

#+begin_src emacs-lisp

  ;; Automatically toggle “fill” or “unfill” on the current paragraph.
  (defun xah-fill-or-unfill ()
    "Reformat current paragraph or region to `fill-column'.
  When there is a text selection, act on the selection, else, act on a
  text block separated by blank lines. URL
  `http://xahlee.info/emacs/emacs/modernization_fill-paragraph.html'
  Version 2017-01-08"
    (interactive)
    ;; This command symbol has a property “'compact-p”, the possible values
    ;; are t and nil. This property is used to easily determine whether to
    ;; compact or uncompact, when this command is called again
    (let ( ($compact-p
            (if (eq last-command this-command)
                (get this-command 'compact-p)
              (> (- (line-end-position) (line-beginning-position))
                 fill-column)))
           (deactivate-mark nil)
           ($blanks-regex "\n[ \t]*\n")
           $p1 $p2
           )
      (if (use-region-p)
          (progn (setq $p1 (region-beginning))
                 (setq $p2 (region-end)))
        (save-excursion
          (if (re-search-backward $blanks-regex nil "NOERROR")
              (progn (re-search-forward $blanks-regex)
                     (setq $p1 (point)))
            (setq $p1 (point)))
          (if (re-search-forward $blanks-regex nil "NOERROR")
              (progn (re-search-backward $blanks-regex)
                     (setq $p2 (point)))
            (setq $p2 (point)))))
      (if $compact-p
          (fill-region $p1 $p2)
        (let ((fill-column most-positive-fixnum ))
          (fill-region $p1 $p2)))
      (put this-command 'compact-p (not $compact-p)))
    (deactivate-mark))

#+end_src

**** duplicate-dwim
Duplicates the region if it is active.  If not, it works like 'duplicate-line'.  An active rectangular region is duplicate on its right-hand side.  The new user option 'duplicate-line-final-position' specifies where to move point after duplicating a line.

*** Regex-
**** isearch-forward
Do incremental search forward.

**** isearch-backward
Do incremental search backward.

**** highlight-regexp
Set face of each match of REGEXP to FACE.

**** find-dired
Run find and go into Dired mode on a buffer of the output.

**** dired-do-search
Search through all marked files for a match for REGEXP.

While in dired, you can *step thru all files that matches a text pattern*. In dired, call ~dired-do-search A~. It will prompt you for a search string, then open the first file of the match, with your cursor placed at the matching location.

To go to next occurrence, press ~M-,~ (~tags-loop-continue~).

**** dired-do-query-replace-regexp
Do query-replace-regexp of FROM with TO, on all marked files.

**** dired-do-rename-regexp
Rename selected files whose names match REGEXP to NEWNAME.

**** grep
Call ~grep~ to list all matching text of all files in the current directory.

For example, if you give this input ~grep -nH -e "Cheshire" *html~, which will list all files ending in “html” that contains the word “Cheshire”.

If you want case insensitive search, add a ~-i~ in the grep option.

**** rgrep
Search all files in current directory and sub-directory.

**** lgrep
Search only some files of current dir by using a text pattern (regex) on file names first.

**** grep-find
Use a combination of unix's ~grep~ and ~find~ commands..

**** replace-regexp-function

*** String-
**** string-rectangle
Replace rectangle contents with STRING on each line.

*Note*: The command string-rectangle can be used to insert a vertical column of string across mulitple lines at any column position, not just at the beginning of lines.

**** kill-rectangle
Delete the region-rectangle and save it as the last killed one.

~kill-rectangle~ can be used to delete any rectangular block of text, not just at the beginning of lines.

There are others useful command like ~replace-rectangle~, ~yank-rectangle~,...

#+begin_example

  try to delete the middle column
  3c21 646f 6374
  6874 6d6c 3e3c
  2063 6861 7273
  202f 3e0a 3c6d
  6965 7770 6f72
  2277 6964 7468

  1. Put your cursor before “646f”.
  2. Call set-mark-command =C-SPC=.
  3. Move cursor to end of “6964”.
  4. Call =kill-rectangle=.

#+end_example

**** align-regexp
Align the current region using an ad-hoc rule read from the minibuffer.Align the current region using an ad-hoc rule read from the minibuffer.

There are others useful command like ~align-regexp~, ~sort-regexp-fields~, ~sort-columns~.

Example pressing ~align-regexp~ with "=" align the text.

#+begin_example

  align them by the equal sign
  tom = 5
  jenny = 8
  mary = 7

  align
  California 423,970 km²
  Taiwan 36,008 km²
  Japan 377,944 km²
  Germany 357,021 km²
  Iraq 438,317 km²
  Iran 1,648,195 km²
  Korea (North+South) 219,140 km²
  Mexico 1,964,375 km²

  Select the text first, then press C-u then call align-regexp, with the
  regexp .* \([0-9,]+\).* then choose -1 for group, 1 for spacing, and n for
  repeat.

#+end_example

*** Comparing-
**** ediff
Alternative to [[diff]] much more sophisticated.

Provides a convenient way of simultaneous browsing through the differences between a pair (or a triple) of files or buffers. The files being compared, file-A, file-B, and file-C (if applicable) are shown in separate windows (side by side, one above the other or in separate frames) and the differences are highlighted as you step through them. You can also copy difference regions from one buffer to another (and recover old differences if you change your mind).

Ediff also supports merging operations on files and buffers, including merging using ancestor versions. Both comparison and merging operations can be performed on directories, i.e. by pairwise comparison of files in those directories.

You can ignore whitespace or case sensitivity interactively, on the fly:
- Whitespace sensitivity :: toggle with ` ~##~ ’ (~‘ediff-toggle-skip-similar’~).
- Case sensitivity :: toggle with ` ~#c~ ’ (~‘ediff-toggle-ignore-case’~). This assumes that you’ve loaded library Lisp:ediff+.el and that you are using ` ~diff(1)~ ’ as ~‘ediff-diff-program’~. (Toggling case-sensitivity is available in vanilla GNU Emacs 22, so Lisp:ediff+.el is mainly useful for older Emacs versions.)

**** ediff3
Run Ediff on three files, FILE-A, FILE-B, and FILE-C.

**** ediff-buffers
Run Ediff on a pair of buffers, BUFFER-A and BUFFER-B.

**** compare-windows
Compare text in *current window with text in another window*.

Comparison starts at point in each window, after pushing each initial point value on the mark ring in its respective buffer. Then it moves point forward in each window, one character at a time, until it reaches characters that don't match. Then the command exits.

If point in the two windows is followed by non-matching text when the command starts, it tries heuristically to advance up to matching text in the two windows, and then exits. So if you use ~M-x compare-windows~ repeatedly, each time it either skips one matching range or finds the start of another.

With a numeric argument, ~compare-windows~ ignores changes in whitespace. If the variable ~compare-ignore-case~ is non-~nil~, the comparison ignores differences in case as well. If the variable ~compare-ignore-whitespace~ is non-~nil~, ~compare-windows~ normally ignores changes in whitespace, and a prefix argument turns that off.

**** smerge-makeup-conflict
See the differences between two *blocks of text in the same buffer*.

Uses point and mark for two of the relevant positions and previous marks
for the other ones. By default, makes up a 2-way conflict, with a ~C-u~ prefix, makes up a 3-way conflict.

- go to the beginning of the first bloc, ~C-SPC~
- go the beginning of the second bloc, ~C-SPC~
- go to the end of the second bloc, ~M-x smerge-makeup-conflict RET~
- then you can use ~C-c ^ R~ or ~C-c ^ =~ to view the differences.

Note that this works better if the two blocs are pretty much consecutive.

**** diff
Prompts for two file names, using the minibuffer, and displays the differences between the two files in a buffer named ‘*diff*’. This works by running the ~diff~ program, using options taken from the variable ~diff-switches~.

After running ~M-x diff~, you can use ~C-x `~ to visit successive changed locations in the two source files, as in Compilation mode. (see Compilation Mode.) In the ‘*diff*’ buffer, you can move to a particular hunk of changes and type C-c C-c (diff-goto-source) to visit the corresponding source location.

**** diff-backup
Compares a specified file with its most recent backup.

*** Info-
**** describe-personal-keybindings
Display all keybindings you’ve set using either the [[:bind]] keyword or the ~bind-keys~ macro.
**** apropos
This command is like the ~C-h a~ (command-apropos) command, except that the latter finds only those functions that are commands. The ~M-x apropos~ command lists all symbols that match a regular expression, including functions that are not interactive.

#+begin_src emacs-lisp

  ;; Example: we want to look for is some command that prints or inserts
  ;; columns. Very likely, the name of the function will contain either the
  ;; word “print” or the word “insert” or the word “column”. Therefore, we
  ;; can simply type:

  M-x apropos RET print\|insert\|column RET

#+end_src

**** pwd
Show the current default directory.

**** command-history
Examine commands from command-history in a buffer.

**** help-quick
Displays an overview of common commands. The command pops up a buffer at the bottom of the screen with a few helpful commands for various tasks.  You can toggle the display using 'C-h C-q'.

*** Files-
**** load-file
Load the Lisp file named FILE.

**** load-library
Load the Emacs Lisp library named LIBRARY.

**** locate-library
Show the precise file name of Emacs library LIBRARY.

**** unload-feature
Unloads the library that provided [[Features][feature]]. It undefines all functions, macros, and variables defined in that library with ~defun~ , ~defalias~ , ~defsubst~ , ~defmacro~ , ~defconst~ , ~defvar~ , and ~defcustom~. It then restores any autoloads formerly associated with those symbols.

Before restoring the previous definitions, ~unload-feature~ runs ~remove-hook~ to remove functions defined by the library from certain hooks. This is to prevent Emacs from ceasing to function because important hooks refer to functions that are no longer defined.

This function discard the functions and variables loaded by a library. It can be used to free up some memory, or occasionally to undo some add-on behaviour.

Ordinarily, ~unload-feature~ refuses to unload a library on which other loaded libraries depend (a library ~a~ depends on library ~b~ if ~a~ contains a ~require~ for ~b~). If the optional argument force is non-~nil~, dependencies are ignored and you can unload any library.

**** do-auto-save
Auto-save all buffers that need it. This is all buffers that have auto-saving enabled and are changed since last auto-saved.

**** recover-file
Visit file FILE, but get contents from its last auto-save file.

**** recover-session
Recover auto save files from a previous Emacs session.

*** Cursor-
**** mc/mark-all-dwim
Tries even harder to guess what you want to mark all of.

**** mc/mark-all-in-region
Find and mark all the parts in the region matching the given search

**** mc/mark-all-in-region-regexp
Find and mark all the parts in the region matching the given regexp.

**** mc/mark-next-word-like-this
Find and mark the next word of the buffer matching the currently active region

**** mc/mark-previous-word-like-this
Find and mark the previous part of the buffer matching the currently active region.

**** mc/mark-sgml-tag-pair
Mark the tag we're in and its pair for renaming.

*** Buffer-
**** revert-buffer
Replace current buffer text with the text of the visited file on disk.

**** revert-buffer-with-fine-grain

**** scratch-buffer
This command switches to the "*scratch*" buffer.  If "*scratch*" doesn't exist, the command creates it first.  You can use this command if you inadvertently delete the "*scratch*" buffer.

*** Mark-
**** transient-mark-mode
Toggle Transient Mark mode.

**** counsel-mark-ring
Browse mark-ring interactively.

*** Packages-
**** package-refresh-contents
Download descriptions of all configured ELPA packages.

For each archive configured in the variable package-archives, inform Emacs about the latest versions of all packages it offers, and make them available for download.

*Note*: when you try to install something appear an error like says "a package is not found using use package" just run the ~package-refresh-contents~ command and that will get everything fixed up for you.

**** package-initialize
This function initializes Emacs’ *internal record* (elpa packages) of which packages are installed, and then calls [[package-activate-all]].

The optional argument no-activate, if non-nil, causes Emacs to update its record of installed packages without actually making them available.

**** package-activate-all
This function makes the packages available to the current session. The user option ~package-load-list~ specifies which packages to make available; by default, *all installed packages are made available*.

In most cases, you should not need to call ~package-activate-all~, as this *is done automatically during startup*. Simply make sure to put any code that should run before ~package-activate-all~ in the [[The early init file][early init file]], and any code that should run after it in the primary init file.

**** package-delete
Delete package PKG-DESC.

**** package-autoremove
Remove packages that are no longer needed.

Packages that are no more needed by other packages in package-selected-packages and their *dependencies* will be deleted.

**** list-packages
Display a list of packages.

This first fetches the updated list of packages before displaying, unless a prefix argument NO-FETCH is specified.

**** package-upgrade
This command allows you to upgrade packages without using 'list-packages'. A package that comes with the Emacs distribution can only be upgraded after you install, once, a newer version from ELPA via the package-menu displayed by 'list-packages'.

*Note*: when enabled the 'package-install-upgrade-built-in' (nil by default) variable, 'package-install' will include in the list of upgradeable packages those built-in packages (like Eglot and use-package) for which a newer version is available in package archives, and will allow installing those newer versions.

**** package-upgrade-all
This command allows upgrading all packages without any queries.

**** package-recompile
This command and 'package-recompile-all' can be useful if the ".elc" files are out of date (invalid byte code and macros).

*** Desktop-
**** desktop-change-dir
Change to desktop saved in DIRNAME.

**** desktop-revert
Revert to the last loaded desktop.

**** desktop-save
Save the state of Emacs in a desktop file in directory DIRNAME.

**** desktop-read
Read and process the desktop file in directory DIRNAME.

*** Orderless-
**** orderless-regexp
The component is treated as a regexp that must match somewhere in the candidate.

If the component is not a valid regexp, it is ignored.

**** orderless-literal
The component is treated as a literal string that must occur in the candidate.

**** orderless-literal-prefix
The component is treated as a literal string that must occur as a prefix of a candidate.

**** orderless-prefixes
The component is split at word endings and each piece must match at a word boundary in the candidate, occurring in that order.

This is similar to the built-in ~partial-completion~ completion-style. For example, ~re-re~ matches ~query-replace-regexp~, ~recode-region~ and ~magit-remote-list-refs~; ~f-d.t~ matches ~final-draft.txt~.

**** orderless-initialism
Each character of the component should appear as the beginning of a word in the candidate, in order.

This maps ~abc~ to ~\<a.*\<b.*\c~.

**** orderless-flex
The characters of the component should appear in that order in the candidate, but not necessarily consecutively.

This maps ~abc~ to ~a.*b.*c~.

**** orderless-without-literal
The component is a treated as a literal string that must not occur in the candidate.

Nothing is highlighted by this style. This style should not be used directly in ~orderless-matching-styles~ but with a style dispatcher instead. See also the more general style modifier ~orderless-not~.

**** orderless-annotation
This style modifier matches the pattern against the annotation string of the candidate, instead of against the candidate string.

**** orderless-not
This style modifier inverts the pattern, such that candidates pass which do not match the pattern.

*** Misc-
**** custom-reevaluate-setting
Reset the value of SYMBOL by re-evaluating its saved or standard value.

*Note*: "saved or standard value". In that order of precedence. If the user has customized and saved a value for the variable, this function resets it to its saved-value, not its standard-value.

#+begin_src emacs-lisp

  (custom-reevaluate-setting 'emms-player-next-function)

#+end_src

**** delete-trailing-whitespace
Delete trailing whitespace between START and END.

**** describe-keymap
Describe key bindings in KEYMAP. When called interactively, prompt for a variable that has a keymap value.

If the symbol at point is a keymap, 'describe-keymap' suggests it as the default candidate.

**** set-fringe-style
Set the default appearance of fringes (arrows) on the selected frame.
When called interactively, query the user for MODE; valid values
are ‘no-fringes’, ‘default’, ‘left-only’, ‘right-only’, ‘minimal’
and ‘half-width’.

When used in a Lisp program, MODE should be one of these:
- nil, which means the default width (8 pixels).
- a cons cell (LEFT . RIGHT), where LEFT and RIGHT are
  respectively the left and right fringe widths in pixels, or
  nil (meaning the default width).
- a single integer, which specifies the pixel widths of both
  fringes.

**** whitespace-cleanup
Cleanup some blank problems in all buffer or at region.

**** set-register
Set contents of Emacs register named REGISTER to VALUE.  Returns VALUE.

**** toggle-case-fold-search
Toggle whether to ignore letter-case in search commands.

**** global-set-key
Give KEY a global binding as COMMAND.

Global/local set key commands have the added advantage of being able to temporarily bind commands to keys.

**** proced
Generate a listing of UNIX system processes.

This command is like ~top~ or ~ps~.

**** zone
Zone out, completely.

Emacs’s screensaver.

** Variables-
*** Library-
**** load-path
[[Load path][load-path]] is a list of directories to *search* for files to load.

#+begin_src emacs-lisp

  (
   "/home/richard/.emacs.d/elpa/aggressive-indent-20230112.1300"
   "/home/richard/.emacs.d/elpa/all-the-icons-dired-20231207.1324"
   "/home/richard/.emacs.d/elpa/company-box-20240320.921"
   ...
   "/etc/emacs"
   "/usr/local/share/emacs/27.1/site-lisp"
   "/usr/share/emacs/site-lisp/git"
   ...
   "/usr/share/emacs/site-lisp/autoconf"
   "/usr/share/emacs/site-lisp/elpa"
   "/usr/share/emacs/site-lisp/git"
   ...
   "/usr/share/emacs/27.1/lisp/eshell"
   "/usr/share/emacs/27.1/lisp/calendar"
   "/usr/share/emacs/27.1/lisp/calc"
   ...)

#+end_src

**** load-history
Alist mapping *loaded* file names to symbols and features.

Variable ~load-history~ records lots of information about what *libraries have been loaded in your session so far*, what *functions and variables they each *define* (features provided), and what other libraries they *require* (features required).

Standard library [[loadhist.el]] uses the information in ~load-history~ to let you [[unload-feature][unload feature]] things that were added in a library.

In other words, *it’s a gold mine of information about the files, features, functions, and variables that have been loaded* – in particular, about their interrelations.

#+begin_src emacs-lisp

  ;; Example:
  (("/usr/share/emacs/27.1/lisp/thingatpt.elc"
    (provide . thingatpt)
    (t . forward-thing)
    (defun . forward-thing)
    ...)
   ("/usr/share/emacs/27.1/lisp/help-fns.elc"
    (require . cl-lib)
    (require . radix-tree)
    help-fns-describe-function-functions help-fns-describe-variable-functions help-fns-describe-face-functions help-definition-prefixes
    (defun . help--load-prefixes)
    ...)
   ...
   ("/etc/emacs/site-start.d/50cmake-data.el"
    (autoload . cmake-mode))
   ("/etc/emacs/site-start.d/50autoconf.el"
    (autoload . autotest-mode))
   ("/etc/emacs/site-start.d/00debian.el")
   ("/usr/share/emacs/site-lisp/debian-startup.elc"
    (defun . debian-pkg-add-load-path-item)
    (defun . debian-unique-strings)
    ("/usr/share/emacs/27.1/lisp/subdirs.el")
    ...)

#+end_src

**** loadhist.el
Standard library that uses the information in ~load-history~ to let you [[unload-feature][unload feature]] things that were added in a library.

It also provides functions that let you know which library loaded a given function ~feature-symbols~, the features required by a given library ~file-requires~, the (loaded) libraries that require a given library ~file-dependents~, and the features provided by a given library ~file-provides~.

#+begin_src emacs-lisp

  ;; Which library load dired function:
  (feature-symbols 'dired)
  ;; ("/usr/share/emacs/27.1/lisp/dired.elc"
  ;; (require . dired-loaddefs) dired-listing-switches dired-chown-program ...)

  ;; The (loaded) libraries that require a given library:
  ;; (archivos dependientes de dired (INS))
  (file-dependents "dired")
  ;; ("/home/richard/.emacs.d/elpa/counsel-20240520.1323/counsel.elc"
  ;; "/usr/share/emacs/27.1/lisp/doc-view.elc"
  ;; "/usr/share/emacs/27.1/lisp/gnus/message.elc")

  ;; Features required by a given library:
  ;; (archivos requeridos por dired (INS)) (dependencias)
  (file-requires "dired")
  ;; (dired-loaddefs)

  ;;Features provided by a given library:
  (file-provides "dired")
  ;; (dired)


  ;; Which library load counsel function:
  (feature-symbols 'counsel)
  ;; ("/home/richard/.emacs.d/elpa/counsel-20240520.1323/counsel.elc"
  ;; (require . ivy)(require . swiper)(require . compile)(require . dired) ...)

  ;; The (loaded) libraries that require a given library:
  (file-dependents "counsel")
  ;; ("/home/richard/.emacs.d/init.el")

  ;; Features required by a given library:
  (file-requires "counsel")
  ;; (xdg xref dired compile swiper ivy)

  ;;Features provided by a given library:
  (file-provides "counsel")
  ;; (counsel)

#+end_src

**** features
A list of symbols which are the [[Features (provide, require)][features]] of the *executing* Emacs.

*Note* if you run the [[Autoload][autoload]] command ~doctor~ (which was not previously loaded) the new list would look something like this ~(doctor abbrev ace window ... ivy ivy-faces ...)~.

**** package-activated-list
List of the names of *currently* activated packages (packages in [[package-user-dir]]).

**** package-selected-packages
Store here packages installed *explicitly* (via [[Use package][use-package]] or [[Package installation][M-x list-package]]) by user (not dependencies).

*Note*: Useful if you move to a different system and you would like to quickly install all of your previously installed packages.

**** package-user-dir
Directory containing the user's Emacs Lisp packages.

**** package-directory-list
List of additional directories containing Emacs Lisp packages.

**** user-emacs-directory
Directory beneath which additional per-user Emacs-specific files are placed.

*** Files-
**** auto-save-list-file-prefix
Emacs records information about interrupted sessions in files named ~.saves-pid-hostname~~ in the directory ~~/.emacs.d/auto-save-list/~. This directory is determined by the variable ~auto-save-list-file-prefix~. If you set ~auto-save-list-file-prefix~ to ~nil~, sessions are not recorded for recovery.

**** buffer-auto-save-file-name
This buffer-local variable is the name of the file used for auto-saving the current buffer. It is ~nil~ if the buffer should not be auto-saved.

**** backup-directory-alist
Alist of filename patterns and backup directory names.

**** desktop-path
If you turn on ~desktop-save-mode~ in your init file, then when Emacs starts, it looks for a saved desktop in ~desktop-path~ (which defaults to ~user-emacs-directory~ and then your home directory) and uses the first desktop it finds. While Emacs runs with ~desktop-save-mode~ turned on, it by default auto-saves the desktop whenever any of the desktop configuration changes. The variable ~desktop-auto-save-timeout~ determines how frequently Emacs checks for modifications to your desktop. The desktop is also saved when you exit Emacs.

Specify the option ~--no-desktop~ on the Emacs command line when you don't want it to reload any saved desktop configurations. This turns off ~desktop-save-mode~ for the current session. Starting Emacs with the ~--no-init-file~ option also disables desktop reloading, since it bypasses the init file, where ~desktop-save-mode~ is usually turned on.

You can have separate saved desktop configurations in different directories; starting Emacs from a directory where you have a saved desktop configuration will restore that configuration, provided that you customize ~desktop-path~ to prepend ( ~.~ ) (the current directory) to the other directories there. You can save the current desktop and reload the one saved in another directory by typing ~M-x desktop-change-dir~. Typing ~M-x desktop-revert~ reverts to the previously reloaded desktop.

**** desktop-globals-to-save
List of global variables saved by desktop-save.

**** create-lockfiles
When you make the first modification in an Emacs buffer that is visiting a file, Emacs records that the file is /locked/ by you. (It does this by creating a specially-named symbolic link (~.#*~) with special contents in the same directory). Emacs removes the lock when you save the changes. The idea is that the file is locked whenever an Emacs buffer visiting it has unsaved changes.

You can prevent the creation of lock files by setting the variable ~create-lockfiles~ to ~nil~.

*Caution*: by doing so you will lose the benefits that this feature provides. You can also control where lock files are written by using the ~lock-file-name-transforms~ variable.

**** interpreter-mode-alist
Alist mapping interpreter names to major modes.

#+begin_src emacs-lisp

  ("emacs" . emacs-lisp-mode)

#+end_src

**** auto-mode-alist
Alist of filename patterns vs corresponding major mode functions.

When Emacs visits a file, it automatically selects a major mode for the buffer based on information in the file name or in the file itself. It also processes local variables specified in the file text.

#+begin_src emacs-lisp

  ("\\.el\\'" . emacs-lisp-mode)
  ("\\.js[mx]?\\'" . javascript-mode)

#+end_src

*** Lsp-
**** lsp-ui-sideline-enable
Whether or not to enable ‘lsp-ui-sideline’.

The info line at the end.

**** lsp mode toggle
Whenever you have a buffer width that's kind of narrow things get jammed up together with the code and it starts to get a little bit distracting so i tend to allow only minimal information there if at all. You can toggle this on and off using =C-c l T= and then some toggle code action.

*** Org-
**** org-structure-template-alist
An alist of keys and block types.

~org-insert-structure-template~ will display a menu with this list of templates to choose from.  The block type is inserted, with ~#+BEGIN_~ and ~#+END_~ added automatically.

**** org-hide-emphasis-markers
Non-nil mean font-lock should hide the emphasis marker characters.

*** Text-
**** repeat-exit-timeout
To break the repetition chain in repeat-mode automatically after some amount of idle time: customize the user option ~repeat-exit-timeout~ to specify the idle time in seconds after which this transient repetition mode will be turned off automatically.

**** describe-repeat-maps
It's not a variable is a function that show the commands that support repetition in ~repeat-mode~.

**** repeat-exit-key
Typing any key other than those defined to repeat the previous command exits the transient repeating mode, and then the key you typed is executed normally. You can also define a key which will exit the transient repeating mode /without/ executing the key which caused the exit. To this end, customize the user option ~repeat-exit-key~ to name a key; one natural value is ~RET~.

*** Misc
**** global-minor-modes
This variable holds a list of currently enabled global minor modes (as a list of symbols). A list of the currently enabled global minor modes.

**** local-minor-modes
This permanently buffer-local variable holds a list of currently enabled non-global minor modes in the current buffer (as a list of symbols).

**** major-mode-remap-alist
Specifies the favorite major modes

This user option lets you remap the default modes (e.g. 'perl-mode' or 'latex-mode') to your favorite ones (e.g. 'cperl-mode' or 'LaTeX-mode') instead of having to use 'defalias', which can have undesirable side effects. This applies to all modes specified via 'auto-mode-alist', file-local variables, etc.

** Modes-
*** multiple-cursors-
**** mc/mark-next-like-this
Find and mark the next part of the buffer matching the currently active region
If no region is active add a cursor on the next line.

**** mc/mark-previous-like-this
Find and mark the previous part of the buffer matching the currently active region. If no region is active ,add a cursor on the previous line.

**** mc/mark-all-like-this
Find and mark all parts of the buffer matching the currently active region, while also keeping the current region.

**** mc/edit-lines
When you have an active region that spans multiple lines, the following will add a cursor to each line.

**** mc/mark-next-like-this-word
Adds a cursor and region at the next part of the buffer forwards that matches the current region, if no region is selected it selects the word at the point. (words in the same or following lines)

**** mc/mark-next-word-like-this
Like mc/mark-next-like-this but only for whole words. (just the words in the following lines)

**** mc/mark-all-in-region
Prompts for a string to match in the region, adding cursors to all of them.

**** mc/mark-all-dwim
Tries to be smart about marking everything you want. Can be pressed multiple times.

**** mc/add-cursor-on-click
Add a cursor where you click, or remove a fake cursor that is already there (~C-S-<mouse-1>~).

**** mc/mark-more-like-this-extended
Use arrow keys to quickly mark/skip next/previous occurrences.

**** mc/insert-numbers
Insert increasing numbers for each cursor, top to bottom.

**** mc/insert-letters
Insert increasing letters for each cursor, top to bottom.

**** set-rectangular-region-anchor
Think of this one as `set-mark` except you're marking a rectangular region. It is an exceedingly quick way of adding multiple cursors to multiple lines.

**** Notes
- To get out of ~multiple-cursors-mode~, press ~<return>~ or ~C-g~. The latter will first *disable multiple regions before disabling multiple cursors*. If you want to insert a newline in ~multiple-cursors-mode~, use ~C-j~.

- Sometimes you end up with cursors outside of your view. You can scroll the screen to center on each cursor with ~C-v~ and ~M-v~ or you can press ~C-'~ to hide all lines without a cursor, press ~C-'~ again to unhide.

- If you get out of ~multiple-cursors-mode~ and yank - it will yank only from the ~kill-ring~ of main cursor. To yank from the ~kill-rings~ of every cursor use ~yank-rectangle~, normally found at ~C-x r y~.

- It is possible to set multiple-cursors to "run-for-all" for every command except for those that are listed in ~mc/cmds-to-run-once~. To enable this set ~mc/always-run-for-all~ to non-nil. Add commands to be run once to ~mc/cmds-to-run-once~ in ".mc-lists.el".

  Multiple-cursors uses two lists of commands to know what to do: the run-once list and the run-for-all list. It comes with a set of defaults, but it would be beyond silly to try and include all the known Emacs commands.

  So that's why multiple-cursors occasionally asks what to do about a command. It will then remember your choice by saving it in ~~/.emacs.d/.mc-lists.el~. You can change the location with:

  ~(setq mc/list-file "/my/preferred/file")~

  NB! Make sure to do so before requiring multiple-cursors.

- Redo might screw with your cursors. Undo works very well.

- Multiple cursors sometimes don't work well, for example when these two modes  ~org-indent-mode~ and ~variable-pitch-mode~ are activated in org-mode, the cursors don't move down/up linearly.

*** yas-global-
**** M-x yas-expand
Try to expand snippets before point.  In `yas-minor-mode', this is normally bound to TAB, but you can customize it in `yas-minor-mode-map'.

**** M-x yas-insert-snippet
Prompts you for possible snippet expansion if that is possible according to buffer-local and snippet-local expansion conditions.  With prefix argument, ignore these conditions.

**** M-x yas-visit-snippet-file
Prompts you for possible snippet expansions like `yas-insert-snippet', but instead of expanding it, takes you directly to the snippet definition's file, if it exists.

**** M-x yas-load-directory
Prompts you for a directory hierarchy of snippets to load.

**** M-x yas-load-snippet-buffer
When editing a snippet, this loads the snippet.  This is bound to "C-c C-c" while in the `snippet-mode' editing mode.

**** M-x yas-tryout-snippet
When editing a snippet, this opens a new empty buffer, sets it to the appropriate major mode and inserts the snippet there, so you can see what it looks like.  This is bound to "C-c C-t" while in `snippet-mode'.

**** M-x yas-describe-tables
Lists known snippets in a separate buffer.  User is prompted as to whether only the currently active tables are to be displayed, or all the tables for all major modes.

**** M-x yas-activate-extra-mode
Prompts you for an extra mode to add snippets for in the current buffer.

**** M-x yas-new-snippet
Lets you create a new snippet file in the correct subdirectory of `yas-snippet-dirs', according to the active major mode.

*** misc-
**** xref-etags-mode
Minor mode to make xref use etags again.

Some major modes install ~xref~ support facilities that might sometimes fail to find certain identifiers. For example, in Emacs Lisp mode =M-.= will by default find only functions and variables from Lisp packages which are loaded into the current Emacs session or are [[Autoload][auto-loaded]]. If =M-.= fails to find some identifiers, you can try forcing ~xref~ to use the ~etags~ backend. To this end, turn on the Xref Etags minor mode with ~M-x xref-etags-mode~, then invoke =M-.= again. (For this to work, be sure to run etags to create the tags table in the directory tree of the source files.)

The ~etags~ program is used to create a tags table file. It knows the syntax of several languages. Here is how to run etags:

#+begin_src sh

  etags inputfiles…

#+end_src

The ~etags~ program reads the specified files, and writes a tags table named ~TAGS~ in the current working directory.
**** hl-line-mode
Toggle highlighting of the current line (Hl-Line mode).

* Subjects
** LSP
*** Background
To implement support for language features in a code editor, for example VS Code, we found three common problems:

First, Language Servers are usually implemented in their native programming languages, and that presents a challenge in integrating them with VS Code, which has a Node.js runtime.

Additionally, language features can be resource intensive. For example, to correctly validate a file, Language Server needs to parse a large amount of files, build up Abstract Syntax Trees for them and perform static program analysis. Those operations could incur significant CPU and memory usage and we need to ensure that VS Code's performance remains unaffected.

Finally, integrating multiple language toolings with multiple code editors could involve significant effort. From language toolings' perspective, they need to adapt to code editors with different APIs. From code editors' perspective, they cannot expect any uniform API from language toolings. This makes implementing language support for M languages in N code editors the work of M * N.

To solve those problems, Microsoft specified Language Server Protocol, which standardizes the communication between language tooling and code editor. This way, Language Servers can be implemented in any language and run in their own process to avoid performance cost, as they communicate with the code editor through the Language Server Protocol. Furthermore, any LSP-compliant language toolings can integrate with multiple LSP-compliant code editors, and any LSP-compliant code editors can easily pick up multiple LSP-compliant language toolings. LSP is a win for both language tooling providers and code editor vendors!

*** Technical overview
Programmatic Language Features is a set of smart-editing features powered by the ~vscode.languages.*~ API.

Let's take Hover as an example:

#+begin_src javascript

  vscode.languages.registerHoverProvider('javascript', {
      provideHover(document, position, token) {
          return {
              contents: ['Hover Content']
          };
      }
  });

#+end_src

The ~vscode.languages.registerHoverProvider~ API provides an easy way to provide hover contents to JavaScript files. After this extension gets activated, whenever you hover over some JavaScript code, VS Code queries all ~HoverProvider~ for JavaScript and shows the result in a Hover widget.

An alternative approach is to implement a Language Server that speaks Language Server Protocol. The way it works is:

1. An extension provides a Language Client and a Language Server for JavaScript.
2. The Language Client is like any other VS Code extension, running in the Node.js Extension Host context. When it gets activated, it spawns the Language Server in another process and communicates with it through Language Server Protocol.
3. You hover over JavaScript code in VS Code
4. VS Code informs the Language Client of the hover
5. The Language Client queries the Language Server for a hover result and sends it back to VS Code
6. VS Code displays the hover result in a Hover widget

The process seems more complicated, but it provides two major benefits:

- The Language Server can be written in any language
- The Language Server can be reused to provide smart editing features for multiple editors

*Libraries for the client and server*
The actual integration of a language server into a particular tool is not defined by the language server protocol and is left to the tool implementors. Some tools integrate language servers generically by having an extension that can start and talk to any kind of language server. Others, like VS Code, create a custom extension per language server, so that an extension is still able to provide some custom language features.

*To simplify the implementation of language servers and clients, there are libraries or SDKs for the client and server parts*. These libraries are provided for different languages. For example, there is a *language client npm module* (npm i vscode-languageclient) to ease the integration of a language server into a VS Code extension and another *language server npm module* (npm i vscode-languageserver) to write a language server using Node.js.

*Note*: *Eglot* relays the diagnostics information received from the LSP server to Emacs's *Flymake*, which annotates/underlines the problematic parts of the buffer. The information is shared with the *ElDoc* system, meaning that the commands ~eldoc~ and ~eldoc-doc-buffer~ show diagnostics along with other documentation under point.

*** Emacs role as a client
As of 2020, Emacs is at least 35 years old; it had coding features way before LSP was a thing, through elisp packages. Keeping only currently popular implementations:

- *completion* is brought by ~company~ or ~corfu~
- *syntax/error* checking is brought by ~flycheck~ or ~flymake~
- *jumping to definitions* is brought by ~xref~
- displaying symbol *documentation* on point (under the cursor) is brought by ~eldoc~
- *syntax highlighting* is brought by ~Font Lock~.

All those packages use data sources that are defined on a case by case basis; for example, ~elpy-company-backend~ is a source that uses Jedi to bring python completions to company

As emacs is a “development tool”, theoretically emacs’ developers are responsible to handle the client part of the protocol. This means integrating LSP in all the existing packages so that they ask a language server over JSON-RPC for the relevant information as a data source.

Instead of implementing a ~company-lsp~ source, and a ~flycheck-lsp~ source, and a ~xref-lsp~ source etc. that could be out of sync and create a lot of compatibilty issues, complete “LSP client” packages exist to act as an abstraction layer between the LSProtocol and the inner emacs packages that need a source.

There are 2 coexisting LSP clients in emacs, *eglot* and *lsp-mode* that provide exactly this :

- convert user intent (“I want completions” or “What is this symbol ?”) from ~company~, ~xref~ … requests into JSON-RPC messages
- send and receive LSProtocol messages**
- dispatch the received messages to the relevant “source” so that other packages seamlessly use language servers as a source

*** Eglot behavior and how to get started
1. Select and *install a language server*.
2. *Visit the file* you want to work on (e.g. ~~/projects/fooey/lib/x.foo~).
3. *Turn on Eglot* for your project (~M-x eglot~).
4. Eglot uses Emacs’s project management infrastructure to figure out which files and buffers belong to what project. When Eglot starts a server program, it does so in the project’s root directory, which is usually the top-level directory of the project’s directory hierarchy. For example, if you visit the file ~~/projects/fooey/lib/x.foo~ and ~x.foo~ belongs to a project rooted at ~~/projects/fooey~ (perhaps because a .git directory exists there), then ~M-x eglot~ causes the language server configured for the programming language of that buffer to start with that root as the current working directory. The server then will analyze not only the file ~lib/x.foo~ you visited, but likely also all the other ~*.foo~ files under the ~~/projects/fooey~ directory.
5. For each buffer in which Eglot is active, it notifies the language server that Eglot is managing the file visited by that buffer. This tells the language server that the file’s contents on disk may no longer be up-to-date due to unsaved edits. Eglot reports to the server any changes in the text of each managed buffer, to make the server aware of unsaved changes. Killing a buffer relinquishes its management by Eglot and notifies the server that the file on disk is up-to-date.
6. Eglot turns on a special minor mode in each buffer it manages. This minor mode ensures the server is notified about files Eglot manages, and also arranges for other Emacs features supported by Eglot (this activation of the minor mode is what ensures Eglot that it has to follow the buffer changes and not the disk file).
7. *Use Eglot*. Most Eglot facilities are integrated into Emacs features, such as ElDoc, Flymake, Xref, and Imenu. However, Eglot also provides commands of its own, mainly to perform tasks by the language server, such as ~M-x eglot-rename~ (to rename an identifier across the entire project), ~M-x eglot-format~ (to reformat and reindent code), and some others.

*** Example of lsp-mode server configurations
**** Setting up C++
By default, ~lsp-mode~ will look for the ~clangd~ executable on the path. ~Clangd~ can be downloaded with ~pacman -S clang~ on Arch.

**** Setting up Python
LSP-mode supports 5 different Python language servers. You can install, for example, ~pyright~ globally with ~pip~, ~npm~, or your system’s package manager. Also you need a thin layer of extra client, ~lsp-pyright~, to sit atop ~lsp-mode~ and leverage ~pyright~ ’s features.

#+begin_src emacs-lisp

  ;; Example python configuration:
  (use-package lsp-pyright
    :hook (python-mode . (lambda () (require 'lsp-pyright)))
    :init (when (executable-find "python3")
            (setq lsp-pyright-python-executable-cmd "python3")))

#+end_src

**** Setting up JavaScript
The recommended language server for JavaScript (and TypeScript) is the conveniently-named ~typescript-language-server~ (or ~ts-ls~ for short), which is a wrapper around Visual Studio Code’s tsserver.

Since ~lsp-mode~ has ~ts-ls~ support integrated by default, *there’s no need to install an additional thin layer of client on top of ~lsp-mode~. However, we do need to install the language server on our system. We can install it globally with ~npm~:

#+begin_src sh

  npm install -g typescript-language-server

#+end_src

*Note*: the vscode-langservers-extracted is a thin client layer that help to connect/work to language servers, like vscode-css-language-server, vscode-eslint-language-server, vscode-html-language-server,... (IDK)

**** Setting up Java
The go-to language server for Java is Eclipse’s JDT Language Server. We need yet another thin layer of a client called ~lsp-java~ to help leverage ~lsp-mode~ and the ~JDT~ server. The good news is once you have ~lsp-java~ installed in Emacs through ~use-package~, the client will “automatically detect whether the server is missing and download Eclipse JDT Language Server before the first startup”!

#+begin_src emacs-lisp

  (use-package lsp-java
    :after lsp)

#+end_src

*** lsp-mode notes
- The highest number is highest priority (20 highest -20 lowest (INS)). Note this is the opposite of Unix priority (niceness). Servers defined in ~lsp-mode~ tend to have lower priority than the external packages (priority 0 if unspecified). If a server is registered with :add-on? flag set to t it will be started in parallel to the other servers that are registered for the current mode. If the server that you want to use is not with the highest priority you may use ~lsp-disabled-clients~ to disable the server with higher priority or use ~lsp-enabled-clients~ to enable only the servers you want to use. In order to find the server ids you may check ~*lsp-log*~ buffer.

- Refer to ~lsp--formatting-indent-alist~ to find out what is the variable that is used for the current major mode.

- Some language servers, e.g. for C++, Java, etc, can format code as you type and the formatting is triggered when the corresponding character is pressed(typically, ~}~ , ~RET~). This behaviour is controlled via ~lsp-enable-on-type-formatting~ and it is enabled by default.

- Look for ~lsp-mode~ variable to customize *server path*. Usually, you may find the variable by doing: ~M-x customize-group~ =RET= ~lsp-LANGUAGE-SERVER-ID~.

- ~lsp-deferred~ will wait until the buffer is visible before invoking lsp.
This avoids overloading the server with many files when starting Emacs. Useful when setting a ~:hook (js-mode . lsp-deferred)~ hook this way when cycling through buffers, and there are ~js~ files, then ~lsp-mode~ will not triggered on every ~js~ file, it will only turn on when the buffer is open.

*** Miscellaneous
**** ts-lit-plugin
https://www.reddit.com/r/neovim/comments/y62tr4/javascript_lit_html_syntax_highlighting_ts/

Javascript Lit HTML syntax highlighting. (TS Injection)

I have been trying to develop web components under neovim.

So far thanks to [[https://github.com/runem/lit-analyzer/tree/master/packages/ts-lit-plugin][ts-lit-plugin]] LSP started working.

I still have one big major problem. Treesitter can not figure out${(x) => x.disabled && disabled}. It should be highlighted with JS.

This correctly works on Vscode via [[https://github.com/runem/lit-analyzer/tree/master/packages/vscode-lit-plugin][vscode-lit-plugin]].

**** Packages about js, eslint, npm, lit, ...
***** Eslint-RC
eslint-rc is a function that searches for local rc rules and eslintignore rules per project and use it to format the current buffer using eslint. The package also exports a minor mode that applies ~(eslint-rc)~ on save.

***** code-tag
https://github.com/fregante/code-tag
noop functions to help formatters and syntax highlighters recognize embedded code

When embedding other languages in JavaScript, you can mark those strings with a tag function to help JavaScript tools recognize the string as code:

#+begin_src javascript

  document.body.innerHTML = html`
          <p>This is inline HTML</p>
          <!-- Including comments -->
          <style>.and {css: 'too'}</style>
  `;

#+end_src

**** IDE (Daniel)
I don't used an IDE, but I have Emacs, which does most of the things I want. I can navigate through code (even code outside the project). It warns me of syntax errors. I can navigate to files in the project, and look for text inside (helm-git-grep).
I do the debugging outside Emacs: in Python, through ipdb.

Option 1, the „cheap“ but good enough option:
- helm-git-grep (with helm, of course), and just typing a few letters of where I want to go. For instance, if I want to go to where a function is defined, I type „name def“ (or „def name“ or „name d“ or „f.name“ or „f na“, … Helm does fuzzy matching and finds it)
- for syntax errors: flymake

Option 2, elegant one:
-  and eglot (already integrated into the latest Emacs).  I have a call like (add-hook 'python-mode-hook 'eglot-ensure)  in .emacs, and it enables many features, like going to definition with M-. (and back, with M-,). You need a lsp server, e.g. pyls for Python, ccls for C, etc.

Projectile:
Is a project interaction library for Emacs. Its goal is to provide a nice set of features operating on a project level without introducing external dependencies (when feasible). This library provides easy project management and navigation.

debugging "console.log" ...
Python has a REPL (look this up) where you can run interactive commands. There are JavaScript REPL tools too, e.g. I used the node.js one.
The interesting trick is that in the middle of a program you can invoke the REPL shell. So it stops there (at any point you want) and you can type commands to inspect the variables or even to change them.
And you get extra commands, like „next“ to execute the next line, „cont“ to stop debugging, „where“ to see the stack, „list“ to see the code, etc.
And autocompletion etc.
To do that, you just insert this line in a Python program: from ipdb import set_trace; set_trace()

** IDE
Tools for using in programming modes

- Combobulate/major-mode :: for main *movements*, *editing*, and *marking*
- Corfu/cape/completion-preview/company :: for *completion*
- Abbrev/yasnippet/tempel :: for *templates*
- Flymake/flycheck :: for *syntax/error checking*
- Xref/imenu :: for jumping to *definitions*
- Consult :: for features like *navigating*, *searching*, grep, references, ...
- Eldoc :: for *documentation*
- Font Lock :: for *syntax highlighting*
- Project/projectile :: for *project management* and *navigation*
- Eglot/lsp-mode :: *LSP* server clients
- Dape/REPL/dap-mode :: for *debugger*

These tools work with the default major-mode (preferably using treesitter) or need to use the LSP server.

Useful minor-modes:

- electric-pair-mode

** Debugging
*** User interface
The following diagram shows the main components of the debugging user interface:

- Run and Debug view :: displays all information related to running, debugging, and managing debug configuration settings.
- Debug toolbar :: has buttons for the most common debugging actions.
- Debug console :: enables viewing and interacting with the output of your code running in the debugger.
- Debug sidebar :: during a debug session, lets you interact with the call stack, breakpoints, variables, and watch variables.

*** Start debugging
https://code.visualstudio.com/docs/editor/debugging

*** Launch configurations
Creating a launch configuration file is beneficial because it allows you to configure and save debugging setup details. VS Code keeps debugging configuration information in a ~launch.json~ file located in a ~.vscode~ folder in your workspace (project root folder) or in your user settings or workspace settings.

*** Debug actions

- Continue / Pause :: resume normal program/script execution (up to the next breakpoint) / inspect code executing at the current line and debug line-by-line.

- Step Over :: execute the next method as a single command without inspecting or following its component steps.

- Step Into :: enter the next method to follow its execution line-by-line.

- Step Out :: when inside a method or subroutine, return to the earlier execution context by completing remaining lines of the current method as though it were a single command.

- Restart :: terminate the current program execution and start debugging again using the current run configuration.

- Stop :: terminate the current program execution.

*** Breakpoints
**** Conditional breakpoints
A powerful VS Code debugging feature is the ability to set conditions based on expressions, hit counts, or a combination of both.

- Expression condition :: the breakpoint will be hit whenever the expression evaluates to true
- Hit count :: the hit count controls how many times a breakpoint needs to be hit before it interrupts execution. Whether a hit count is respected, and the exact syntax of the expression, can vary among debugger extensions.

**** Triggered breakpoints
Is a breakpoint that is automatically enabled once another breakpoint is hit. They can be very useful when diagnosing failure cases in code that happen only after a certain precondition.

**** Inline breakpoints
Are only hit when the execution reaches the column associated with the inline breakpoint. This is particularly useful when debugging minified code which contains multiple statements in a single line.

**** Function breakpoints
Instead of placing breakpoints directly in source code, a debugger can support creating breakpoints by specifying a function name. This is useful in situations where source is not available but a function name is known.

**** Data breakpoints
If a debugger supports data breakpoints, they can be set from the context menu in the *VARIABLES* view. The Break on Value Change/Read/Access commands add a data breakpoint that is hit when the value of the underlying variable changes/is read/is accessed.

*** Logpoints
A Logpoint is a variant of a breakpoint that does not "break" into the debugger but instead logs a message to the debug console. Logpoints enable you to inject logging while debugging without modifying the source code. They are especially useful when you're debugging production servers that cannot be paused or stopped. Logpoints can also help you save time by not having to add or remove logging statements in your code.

*** Data inspection
Variables can be inspected in the *VARIABLES* section or by hovering over their source in the editor. Variable values and expression evaluation are relative to the selected stack frame in the *CALL STACK* section.

*** Variable substitution
VS Code makes commonly used paths and other values available as variables and supports variable substitution inside strings in ~launch.json~. For example, ~${workspaceFolder}~ gives the root path of a workspace folder, ~${file}~ the file open in the active editor, and ~${env:Name}~ the environment variable 'Name'.

*** Debug Console REPL
Expressions can be evaluated with the Debug Console REPL (Read-Eval-Print Loop) feature.

Expressions are evaluated after you press =Enter= and the Debug Console REPL shows suggestions as you type. If you need to enter multiple lines, use =Shift+Enter= between the lines and then send all lines for evaluation with =Enter=.

*** dape package
**** Installation
First install ~dape~ package.

Then install the supported debug adapters.

*Javascript - vscode-js-**:
1. Install ~node~
2. Visit https://github.com/microsoft/vscode-js-debug/releases/ and download the asset ~js-debug-dap-<version>.tar.gz~
3. Unpack

#+begin_src sh

  mkdir -p ~/.emacs.d/debug-adapters && tar -xvzf js-debug-dap-<version>.tar.gz -C ~/.emacs.d/debug-adapters
  # or depending on the route
  mkdir -p ~/.emacs.d/var/dape/adapters && tar -xvzf js-debug-dap-<version>.tar.gz -C ~/.emacs.d/var/dape/adapters

#+end_src

**** Usage
To begin a debugging session, invoke the ~dape~ command. In the minibuffer prompt, enter a debug adapter configuration name from ~dape-configs~. For example, on ~.js~ files, =Run adapter=: ~js-debug-node~, whrere the path is: ~/home/rich/.emacs.d/var/dap-adapters/js-debug/src/depDeguggerServer.js~.

**** Notes
- If the debugger is not running, verify that the path of the file you want to debug matches the one you are entering on the prompt:

#+begin_src emacs-lisp

  :cwd "/home/rich/trials/trial-test/project-name/src" :program "index.js"
  ;; buffer -> /home/rich/trials/trial-test/project-name/src/index.js

#+end_src

- Example ~dape-config~ template for ~debugpy~:

#+begin_src emacs-lisp

  (add-to-list 'dape-configs
               `(debugpy
                 modes (python-ts-mode python-mode)
                 command "python3"
                 command-args ("-m" "debugpy.adapter")
                 :type "executable"
                 :request "launch"
                 :cwd dape-cwd-fn
                 :program dape-find-file-buffer-default))

#+end_src

*** dap-mode package
**** Installation
First install ~dap-mode~ package.

After enabling DAP mode on emacs side follow the language specific settings.

*Installation node debugger*
For easier of setting up vscode extension, you only need call ~dap-node-setup~ (download the vscode extension) after requiring ~dap-node~.

~dap-node~ library is a thin layer between dap-mode (DAP emacs client debugger) and vscode extension (DAP node debugger) (INS).

#+begin_src emacs-lisp

  (require 'dap-node)

#+end_src

~dap-node-setup~
Downloading ms-vscode.node-debug2 to path specified.

~dap-node-debug-program~
The path to the node debugger.

#+begin_src emacs-lisp

  ("node"
   "/home/rich/.emacs.d/var/dap/extensions/vscode
  /ms-vscode.node-debug2/extension/out/src/nodeDebug.js")

#+end_src

**** Configuration
For an auto-configuration enable the ~dap-auto-configure-mode~. You can configure which features from dap-mode do you want with ~dap-auto-configure-features~:

~dap-auto-configure-mode~
Non-nil if Dap-Auto-Configure mode is enabled.

~dap-auto-configure-features~
Windows to auto show on debugging when in dap-ui-auto-configure-mode.

#+begin_src emacs-lisp

  (sessions locals breakpoints expressions controls tooltip)

#+end_src

**** Usage
The main entry points are ~dap-debug~ and ~dap-debug-edit-template~. The first one asks for a registered debug template and starts the configuration using the default values for that particular configuration. The latter creates a debug template which could be customized before running. ~dap-debug-edit-template~ will prepare a template declaration inside a temporary buffer. You should execute this code using =C-M-x= for the changes to apply. You should also copy this code into your Emacs configuration if you wish to make it persistent.

To usage on node, run ~dap-debug~ or ~dap-debug-edit-template~ and select the node template. For additional documentation on the supported template parameters or about different configuration templates refer to Nodejs Debugging.

~dap-debug~
Run debug configuration DEBUG-ARGS.

~dap-debug-edit-template~
Edit registered template DEBUG-ARGS.

~dap-mode~
Global minor mode for DAP mode.

~dap-ui-mode~ ...

**** Notes/errors
- The ~dap-debug~ command throws the following error:

#+begin_src emacs-lisp

  ⛔ Warning (emacs): Initialize request failed: Attribute 'program' is not absolute ('{path}'); consider adding '${workspaceFolder}/' as a prefix to make it absolute.

#+end_src

So to fix it, use this command ~dap-debug-edit-template~ and set configure this template, changing only the value of the ~program~ attribute:

#+begin_src emacs-lisp

  ;; Eval Buffer with `M-x eval-buffer' to register the newly created template.
  (dap-register-debug-template
   "Node::Run"
   (list :type "node"
         :cwd nil
         :request "launch"
         :program "${workspaceFolder}/index.js"
         :name "Node::Run"))

#+end_src

-The  ~dap-debug-template-configurations~ variable is a plist Template configurations for DEBUG/RUN.

#+begin_src emacs-lisp

  (("Firefox Run Configuration" :type "firefox" :cwd nil
    :request "launch" :file nil :reAttach t :program nil
    :name "Firefox::Run"))

#+end_src

** Tasks runners
*** Brief
Lots of tools exist to automate tasks like linting, building, packaging, testing, or deploying software systems. Examples include the TypeScript Compiler, linters like ESLint and TSLint as well as build systems like Make, Ant, Gulp, Jake, Rake, and MSBuild.

These tools are mostly run from the command line and automate jobs inside and outside the inner software development loop (edit, compile, test, and debug). Given their importance in the development life cycle, it is helpful to be able to run tools and analyze their results from within VS Code. Tasks in VS Code can be configured to run scripts and start processes so that many of these existing tools can be used from within VS Code without having to enter a command line or write new code. Workspace or folder specific tasks are configured from the ~tasks.json~ file in the ~.vscode~ folder for a workspace.

*** Prodigy
**** Brief
Is a manage external services from within Emacs.

Start prodigy with ~M-x prodigy~. You should see a list of all defined services.

**** Add services
Services can be defined in a few different ways. See ~doc-string~ for information about available properties to specify: ~M-x describe-variable RET prodigy-services~.

Services can be defined using the function ~prodigy-define-service~ or can be defined by setting the variable ~prodigy-services~:

#+begin_src emacs-lisp

  ;; Funciton prodigy-define-service (&rest args):
  (prodigy-define-service :prop value ...)

  ;; Variable prodigy-services:
  (setq prodigy-services
        '((:prop value ...)
          (:prop value ...)))

#+end_src

*Note*: unlike the ~prodigy-define-service~ function, when setting properties to ~prodigy-services~ some values ​​must omit the single quote ( ~'~ ). For example:

#+begin_src emacs-lisp

  ;; In the function it works.:
  (prodigy-define-service :tags '(work) ...)

  ;; In the variable it doesn't work, it should be omitted:
  (setq prodigy-services '((:tags (work) ...)))     ; it work
  ;; (setq prodigy-services '((:tags '(work) ...))) ; it doesn't work

#+end_src

**** Remove services
To remove a service, just delete it from the ~prodigy-services~ variable.

To remove all services, just do ~(setq prodigy-services nil)~.

**** Notes
- In the prodigy window, you can see a process' output with the ~$~ key.

- Pressing ~c~ in the log buffer of a service (thus using ~prodigy-view-mode~) now gives access to all commands accessible in ~prodigy-mode~. This is, for example, useful to restart the service (with =c r=) or to open ~dired~ (with =c j d=) or ~magit~ (with =c j m=) in the directory of the service

- By default the ~rc-create-prodigy-service~ function will use ~npm~. For using ~pnpm~ specify it as follows:

#+begin_src emacs-lisp

  (rc-create-prodigy-service "pnpm")

#+end_src

**** Examples
Nodemon Server

#+begin_src emacs-lisp

  ;; This service starts a Nodemon server on port 6002. The project is
  ;; using NVM, so before the process starts, NVM is set up.
  (prodigy-define-service
    :name "Node app"
    :command "nodemon"
    :cwd "/path/to/my/project"
    :args '("app.coffee")
    :port 6002
    :tags '(work node)
    :init-async (lambda (done)
                  (nvm-use-for "/path/to/my/project" done)))

#+end_src

Python Simple HTTP Server

#+begin_src emacs-lisp

  ;; This service start a Python Simple HTTP Server on port 6001. When
  ;; stopping the service, the sigkill signal is used.
  (prodigy-define-service
    :name "Python app"
    :command "python"
    :args '("-m" "SimpleHTTPServer" "6001")
    :cwd "/path/to/my/project"
    :tags '(work)
    :stop-signal 'sigkill
    :kill-process-buffer-on-stop t)

#+end_src

**** Creating dynamic task runners
Creating dynamic task runners for ~npm~ scripts (Rajasegar Chandran):

#+begin_src emacs-lisp

  (defun rc-create-prodigy-service (&optional package-manager)
    "Create new prodigy services based on current package.json

  To use it, open the package.json file situated in the project
  root folder, and invoke the function."
    (interactive)
    (let ((pkg (json-parse-string (buffer-substring-no-properties
                                   (point-min) (point-max)))))
      (maphash  (lambda (key value)
                  (let ((args '())
                        (name (gethash "name" pkg)))
                    (add-to-list 'args key)
                    (add-to-list 'args "run")
                    (prodigy-define-service
                      :name (concat name "-" key)
                      :command (or package-manager "npm")
                      :cwd (file-name-directory (buffer-file-name))
                      :path (file-name-directory (buffer-file-name))
                      :args args
                      :tags '(temp)
                      :stop-signal 'sigkill
                      :kill-process-buffer-on-stop t
                      ))) (gethash "scripts" pkg))
      (prodigy)
      (prodigy-refresh)))

#+end_src

** Eshell
*** It's a shell
While eshell may look like a shell, like Bash you should view it as a REPL with parenthesis-less s-expressions.

Like a shell, everything is a string except for the first command. Actually don't have to put strings or quotes around this to make it a string.

As a shell:
- Concept of a current directory
- ~popd~, ~pushd~, and ~dirs~
- Globbing Expressions
- Quotes often optional

#+begin_src sh

  # Doesn't this:
  ls -d /tmp
  # look like this =:
  (ls "-d" "/tmp")

#+end_src

*** It's a REPL
Lisp expressions work within parens.

- Unlike shell, EShell:
  - Commands can be executables or Emacs functions
  - Distinguishes strings, numbers, and lists

- EShell is marriage of two syntax parsers:
  - Lisp Expressions (as soon as type in parentheses it's going into lisp parser)
  - Shell Expressions (if remove parentheses it now types it into shell parser)
  - A single line can mix the two!

Without parens, Eshell is in "shell mode", wich means that words are strings, and variables need to be prefixed with dollar signs.

#+begin_src sh

  (+ 8 8)
  # 16
  # or
  + 8 8
  # 16

  # mix two
  - 3 (+ 1 2)
  # 0


  # Parentheses with $
  echo $answer1:$answer2
  # 41:42
  echo $answer1:(+ $answer2 10)
  # Unknown predicate character ‘+’
  echo $answer1:$(+ answer2 10)
  # 41:52
  echo $answer1:${+ answer2 10} # with {} going to shell mode
  # 41:52

#+end_src

*** Eshell’s parsers
*Lisp* parser:
- ~( ... )~
- ~$( ... )~ … useful for string evaluation

*Shell* parser:
- no parens … in other words, the default
- ~{ ... }~
- ~${ ... }~ … useful for string evaluation
- reference variables with ~$~

#+begin_src sh

  setq ANSWER 42   # ← Normal Emacs variable
  # 42

  numberp ANSWER  # ← Use  to get value.
  # t

  setq UNANSWER "41"
  # 41

  stringp UNANSWER
  # t

  mod ANSWER 5    # ← Forgot the  with shell parser
  # Wrong type argument: number-or-marker-p, "ANSWER"

  mod ANSWER 5   # ← Math without expr
  # 2

  (mod ANSWER 5)  # ← Lisp doesn't need  for vars
  # 2

  (mod ANSWER 5)
  # Symbol's value as variable is void: ANSWER

  echo UNANSWER:ANSWER
  # 41:42

  echo UNANSWER:(mod ANSWER 5)
  # Malformed modification time modifier `m'

  echo UNANSWER:(mod ANSWER 5)
  # 41:2

  echo ANSWER:{mod ANSWER 5}
  # 42:2

#+end_src

*** Subshell rules
- with ~(...)~ , eshell treats it as Lisp-expressions.
- with ~{...}~ , eshell follows these shell-like rules:
  - looks like a number, it's a number
  - otherwise, converted to string (quotes, like in shells, grops words)
  - what about functions and executables?
    - first, fuctions start with ~eshell/~
    - next are executables orn your ~$PATH~
    - then matching Lidp functions
    - you can switch this order (see ~eshell-prefer-lisp-funcitons~ variable)

Shells can call subshells which return their outputlike a function call.

#+begin_src sh

  # This bash command, you can have a subshell:
  $(cat files.txt)
  # is the same as:
  { cat files.txt }

#+end_src

*** Wildcard and globbin’ filters
The wildcard actually crates a list.

#+begin_src sh

  touch 'English.org Shell.org init.org'

  ls *.org
  # English.org  Shell.org  init.org

  echo *.org
  # ("English.org" "Shell.org" "init.org")

  length *.org
  # 3

#+end_src

*Globbin’ Filters*:
- The ~*~ glob-thing has filters
- Great if you can remember the syntax:
  - ~.~ for files
  - ~/~ for directories
  - ~r~ if readable
  - ~w~ if writable
  - ~L~ filtering based on file size
  - ~m~ filtering on modification time
- The filters can be stacked, e.g. . ~L~

  ~C-c M-q~ ( ~eshell-display-predicate-help~ )

#+begin_src sh

  ls *(.)
  # README  and go.py  pi.py  pi.rb

  ls *(^/)   # ← Inverse of directories are often files
  # README  and go.py  pi.py  pi.rb


#+end_src

Demonstrate combining modifiers by listing all files with more than 50 bytes to them:

#+begin_src sh

  ls *(.L+50)
  # README  pi.py

#+end_src

After creating three files (using the ~touch~ executable), we can list all empty files (that is, those that have less than 1 byte):

#+begin_src sh

  ls *(L-1)
  # and go.py  goo.py  grip.py  swam.py

#+end_src

Or those modified less than 40 seconds ago:

#+begin_src sh

  ls *(.ms-40)
  # README  and go.py  goo.py  grip.py  pi.py  pi.rb  src  swam.py  tests


#+end_src

Modified after we modified ~goo.py~:

#+begin_src sh

  ls *(.m-'goo.py')
  # grip.py  swam.py

#+end_src

And before we modified ~goo.py~:

#+begin_src sh

  ls *(.m+'goo.py')
  # README  and go.py  pi.py  pi.rb

#+end_src

I can get a list of my journal entries larger than 5000 bytes, and open ~dired~ showing only those files:

#+begin_src sh

  dired ~/journal/2017*(L+5000)

#+end_src

*** Set variable eshell
~Setq~ to create variable, those are global Emacs variables available everywhere.
This variable asssignment doesn't work as you might expect, as ~setq~ in Eshell is still ~setq~, and it assigns variables in pairs.

*Note*: dollar sign ~$~ of variable does not work within a list.

#+begin_src sh

  setq file text.org
  # text.org
  echo $file
  # text.org


  # The wildcard actually crates a list.
  setq all-org *.org
  # ("English.org" "Shell.org" "init.org")
  echo $all-org
  # ("English.org" "Shell.org" "init.org")


  # To make a list, use listify
  setq some { listify fileA.org fileB.org }
  # ("fileA.org" "fileB.org")


  # Other examples
  setq ANSWER 50
  + ANSWER 49
  # Wrong type argument: number-or-marker-p, "ANSWER"
  + $ANSWER 49
  # 99


  # Parentheses with $
  echo $answer1:$answer2
  # 41:42
  echo $answer1:(+ $answer2 10)
  # Unknown predicate character ‘+’
  echo $answer1:$(+ answer2 10)
  # 41:52
  echo $answer1:${+ answer2 10} # with {} going to shell mode
  # 41:52

#+end_src

*** Shell-like Loops
- Syntactic sugar around ~loop~.
- Code following ~in~ is a generate list
- Use trailing ~{ ... }~ for side-effects

#+begin_src sh

  for i in A B C; do echo $i; done
  # do: command not found
  # done: command not found


  for i in A B C { echo "Hello $i" }
  # Hello A
  # Hello B
  # Hello C


  for i in A B C { echo Hello $i }
  # ("Hello" "A")
  # ("Hello" "B")
  # ("Hello" "C")


  # A list can be generated in any way, like with Lisp:
  for N in (number-sequence 1 5) { + 10 $N }
  # 11
  # 12
  # 13
  # 14
  # 15

  # You cannot replace the action with a lisp
  for N in (number-sequence 1 5) ( + 10 $N )
  #
  # but if you put it inside a shell mode then you
  # can run Lisp as the action
  for N in (number-sequence 1 5) {( + 10 $N )}
  # 11
  # 12
  # 13
  # 14
  # 15

#+end_src

*** Write your own functions
Eshell is Emacs: you can write Emacs functions instead shell scripts and other pretty features.

- Functions for Eshell: ~eshell/~
- They do not need to be ~interactive~
- Functions should assume ~&rest~ for arguments:

#+begin_src emacs-lisp

  (defun eshell/do-work (&rest args)
    "Do some work in an optional directory."
    (let ((some-dir (if args
                        (pop args)
                      default-directory)))
      (message "Work in %s" some-dir)))

#+end_src

Using &rest allows your functions to behave more like shell functions:

#+begin_src sh

  do-work
  # Work in /tmp/testing/

  do-work /home/howard/bin
  # Work in /home/howard/bin

#+end_src

*** Function or executable?
What about the executable ~find~ vs. Emacs’ ~find~ function?

*Precedence Order*:
- Eshell aliases
- Emacs functions that being with ~eshell/~ prefix
- Normal Emacs functions (don’t need to be ~interactive~)
- Shell executables
- Of course, this is customizable:

~eshell-prefer-lisp-functions~ prefer Lisp functions to external commands
~eshell-prefer-lisp-variables~ prefer Lisp variables to environmentals

To demonstrate the precedence order for eshell commands, I created a script called foobar that simply contains:

#+begin_src sh

  #!/bin/sh
  echo "Called: executable"

#+end_src

Without anything else, this will be called:

#+begin_src sh

  which foobar
  # /home/howard/bin/foobar

  foobar
  # Called: executable

#+end_src

We now create a regular Emacs function in Lisp (notice that it isn’t interactive):

#+begin_src emacs-lisp

  (defun foobar ()
    "Called: function")

#+end_src

It now takes precedence over the executable:

#+begin_src sh

  which foobar
  # foobar is a Lisp function

  foobar
  # Called: function

#+end_src

Create another Lisp function, this has the ~eshell/~ prefix. Again, no need to make interactive:

#+begin_src emacs-lisp

  (defun eshell/foobar ()
    "Called: eshell function")

#+end_src

And this new function over-shadows the others:

#+begin_src sh

  which foobar
  # eshell/foobar is a Lisp function

  foobar
  # Called: eshell function

#+end_src

Finally, we define an alias, and demonstrate that it over-shadows all the others:

#+begin_src sh

  alias foobar 'echo "Called: alias"'

  which foobar
  # foobar is an alias, defined as "echo "Called: alias""

  foobar
  # Called: alias

#+end_src

*** Aliases
A common alias for ~ls -l~, and would be defined with the command invocation ~alias ll 'ls -l $*'~ ; with this defined, running ~ll foo~ in Eshell will actually run ~ls -l foo~.

Aliases defined (or deleted) by the alias command are automatically written to the file named by ~eshell-aliases-file~ (this defaults to something like ~~/.emacs.d/eshell/aliases~), which you can also edit directly (although you will have to manually reload it).

Note that unlike aliases in Bash, arguments must be handled explicitly. Typically the alias definition would end in ~$*~ to pass all arguments along. More selective use of arguments via ~$1~, ~$2~, etc., is also possible. For example, alias ~mcd 'mkdir $1 && cd $1'~ would cause ~mcd foo~ to create and switch to a directory called ~foo~.

*Warning*: if this doesn't work and get the error ~command not found~ , remove the quote, e.g. type the command ~alias ll ls -l $*~  instead of ~alias ll 'ls -l $*'~.

*Note*: Example alias from Howard Abrams (Emacs hacker who has a YouTube channel)
~alias ee 'find-file-other-window $1'~

*** Notes
- ~cd =~ list all recent directories, and ~cd -2~ to get to that directory
- ~clear 1~  command that clean eshell
- REPL de Emacs Lisp, permite llamar a las funciones o evaluar comandos de Emacs Lisp directamente desde el shell, incluso puede configurar alias ~alias ffo "find-file-other-window $1"~ y proporciona una manera sencilla de hacer nuestros scripts en elisp en lugar de bash u otros.
- Puede correr comandos en la shell como ~find-file~, ~dired~, ...,  también correr funciones ~(+ 20 5)~  (presionando =TAB= se puede completar las funciones).
- Puede usar comandos con pipe para enviar salida a un buffer ~echo "Hello" > #<buffer test-buffer>~ o para adjuntar ~ls >> #<buffer *scratch*>~.
- La sintaxis de la subshell es un poco diferente se utiliza ~${ }~ en vez de ~$( )~.
- Soporta TRAMP (controlar remotamente otra maquina).
- Programas que leen input (como lenguajes REPLs, como por ejemplo "node") y herramientas que dependen de la configuración de los ambientes de shell (nvm, virtualenv) pueden funcionar incorrectamente.
- ~*ls~ (se coloca delante para poderlo usar).
- ~/dev/clip~ and ~/dev/kill~ - you can redirect shell commands to the emacs clipboard and killring
- Eshell pipelines only pipe stdout by default. To pipe both stdout and stderr, use the ~|&~ operator instead of ~|~.

*Warning*:
- Los enlaces duros y simbólicos funcionan diferente a lo esperado. Cuando se modifica el archivo original que tiene un hard link creado con eshell, cambia su valor de ~inode~ .
- Comandos que impliquen opciones que manipulan enlaces simbólicos como ~cp -a dir dirNew~  dan problema.
- No permite crear redirecciones tales como ~cat << Whatever~.

** Tempel
*** Template file format
The templates are defined in a Lisp data file configured by ~tempel-path~. Lisp data files are files containing Lisp s-expressions. By default the file templates in the ~user-emacs-directory~ is used, e.g., ~~/.config/emacs/templates~. The templates are grouped by major mode with an optional ~:when~ condition.

In addition, /after/ the template elements, each template may specify several key/value pairs. Specifically, templates may specify ~:pre~ and/or ~:post~ keys with a FORM that is evaluated before the template is expanded or after it is finished, respectively. The ~:post~ form is evaluated in the lexical scope of the template, which means that it can access the template’s named fields. Beyond that, templates may include an ~:ann~ and ~:doc~ key with strings that are used as annotation and documentation respectively.

*** Template syntax

| "str" | The str is inserted in the buffer.                     |
| nil   | It is ignored.                                         |
| p     | An empty and unnamed *placeholder* field is inserted.    |
| r     | The template is finished when jump to the field like q |
| r>    | Like r, but it also indents the region.                |
| n     | Inserts a newline.                                     |
| n>    | Inserts a newline and indents line.                    |
| >     | The line is indented using indent-according-to-mode.   |
| &     | If there's whitespace in start, nothing. Otherw newlin |
| %     | If there's whitespace in end, nothing. Otherw newline  |
| o     | Like % but leaves the point before the newline.        |

| (s NAME)                      | Inserts a named field.        |
|                               | Then you can use NAME as var  |
| (p PROMPT <NAME> <NOINSERT>)  | Insert an optionally named    |
|                               | field with a prompt           |
| (r PROMPT <NAME> <NOINSERT>)  | Like (p ..), but if there is  |
|                               | a current region, placed here |
| (r> PROMPT <NAME> <NOINSERT>) | Like (r ..), but it also      |
|                               | indents the region            |
| (l ELEMENTS..)                | Insert multiple elements.     |

- ~r~ Inserts the currently active region. If no region is active, a placeholder field is inserted. If ~tempel-done-on-region~ is non-nil, the template is finished when you jump to the field like ~q~.
- ~>~ The line is indented using ~indent-according-to-mode~. Note that you often should place this item after the text you want on the line.
- ~&~ If there is only whitespace between the line start and point, nothing happens. Otherwise a newline is inserted.
- ~%~ If there is only whitespace between point and end of line, nothing happens. Otherwise a newline is inserted.

- ~(p PROMPT <NAME> <NOINSERT>)~ Insert an optionally named field with a prompt. The ~PROMPT~ is displayed directly in the buffer as default value. The field value is bound to ~NAME~ and updated dynamically. If ~NOINSERT~ is non-nil, no field is inserted and the minibuffer is used for prompting. For clarity, the symbol noinsert should be used as argument.
- ~(r PROMPT <NAME> <NOINSERT>)~: Like ~(p ..)~, but if there is a current region, it is placed here.
- ~(r> PROMPT <NAME> <NOINSERT>)~ Like ~(r ..)~, but it also indents the region.
- ~(l ELEMENTS..)~ Insert multiple elements.
- Anything else is passed to each function in ~tempel-user-elements~ until one of the functions returns non-nil, and the result is inserted. If all of them return nil, the form is evaluated. The result can either be a string or any other element. If the return value is a string it is dynamically updated on modification of other fields. Other return values are treated as elements and inserted according to the rules. The element ~(l ..)~ is useful to return multiple elements.

Tempel extends the Tempo syntax with the following elements:

- ~(p FORM <NAME> <NOINSERT>)~ Like ~(p ..)~ described above, but ~FORM~ is evaluated. You can for example select from various values via ~completing-read~.
- ~(FORM ..)~ If a Lisp form evaluates to a string, it is inserted as overlay and the overlay is updated on modifications of other fields.
- ~q~ Like ~p~, but the template is finished if the user jumps to the field. Similarly r finishes the template if ~tempel-done-on-region~ is non-nil.

Use caution with templates which execute arbitrary code!

*** Syntax examples
**** & %
- & :: if there is only whitespace between the line start and point, nothing happens. Otherwise a newline is inserted.

- % :: if there is only whitespace between point and end of line, nothing happens. Otherwise a newline is inserted.

#+begin_src emacs-lisp

  (at  "###autoload")

  START   at   END
  ;; After `tempel-complete':
  START   ###autoload   END


  (ats & "###autoload")

  START   ats   END
  ;; After `tempel-complete':
  START
  ###autoload   END


  (ate "###autoload" %)

  START   ate   END
  ;; After `tempel-complete':
  START   ###autoload
  END

#+end_src

**** (s NAME)
~(s NAME)~ Inserts a named field.

#+begin_src emacs-lisp

  (st "(setq " (s var) " " var ")")
  ;; Typing "st (space) TYPING" the output is:
  (setq TYPING TYPING)

#+end_src

**** (p PROMPT <NAME> <NOINSERT>) (p FORM <NAME> <NOINSERT>)
- (p PROMPT <NAME> <NOINSERT>) :: Insert an optionally named field with a prompt. The ~PROMPT~ is displayed directly in the buffer as default value. The field value is bound to ~NAME~ and updated dynamically. If ~NOINSERT~ is non-nil, no field is inserted and the minibuffer is used for prompting. For clarity, the symbol noinsert should be used as argument.

- (p FORM <NAME> <NOINSERT>) :: Like ~(p ..)~ described above, but FORM is evaluated. You can for example select from various values via ~completing-read~.

#+begin_src emacs-lisp

  ;; (p PROMPT <NAME> <NOINSERT>)
  (ts "Default-string(overwritable):: " (p "Venezuela") n
      ;; (p FORM <NAME> <NOINSERT>)
      "Default-object:: " (p (user-full-name)) n)

  ;; Whithout typing anything and just pressisg the TAB key:
  Default-string(overwritable):: Venezuela
  Default-object:: richard rene frangie vera

  ;; Typing "TYPING (adds)" and "TYPING (overwrites)" the output is:
  Default-string(overwritable):: TYPING (overwrites)
  Default-object:: richard rene frangie vera TYPING (adds)

#+end_src

**** (p PROMPT <NAME> <NOINSERT>) and (l ELEMENTS..) and use vars

#+begin_src emacs-lisp

  (tsv "Default-string(overwritable):: " (p "Venezuela" var2) n
       "Default-object:: " (p (user-full-name) var1) n
       "List:: " (l (buffer-name) " --- " (user-login-name) " --- " (pwd)) n
       "Use-vars:: " var1  " ****** " var2 n)
  ;; Whithout typing anything and just pressisg the TAB key:
  Default-string(overwritable):: Venezuela
  Default-object:: richard rene frangie vera
  List:: *scratch* --- rich --- Directory ~/
  Use-vars:: richard rene frangie vera ****** Venezuela

  ;; Typing "TYPING (adds)" and "TYPING (overwrites)" the output is:
  Default-string(overwritable):: TYPING (overwrites)
  Default-object:: richard rene frangie vera TYPING (adds)
  List:: *scratch* --- rich --- Directory ~/
  Use-vars:: richard rene frangie vera TYPING (adds)  ****** TYPING (overwrites)

#+end_src

**** (p FORM <NAME> <NOINSERT>) using completing-read

#+begin_src emacs-lisp

  (ts "Choices:: " (p (completing-read
                     "Tell me:" '(("First"  . 'first-choice)
                                  ("Second" . 'second-choice)
                                  ("Third"  . 'third-choice)))) n)

  ;; tempel-complete and then choose the second option:
  Choices:: Second


#+end_src

**** Mix

#+begin_src emacs-lisp

  (ts "String::                           richard rene frangie vera" n
      "String-literal::                  " "\"richard rene frangie vera\"" n
      "Object::                           " (user-full-name) n
      "String-placeholder(overwritable):: " (p "richard rene frangie vera") n
      "Object-placeholder::               " (p (user-full-name)) n)
  ;; Whithout typing anything and just pressisg the TAB key:
  String::                           richard rene frangie vera
  String-literal::                  "richard rene frangie vera"
  Object::                           richard rene frangie vera
  String-placeholder(overwritable):: richard rene frangie vera
  Object-placeholder::               richard rene frangie vera

  ;; Typing SOMETHING1 and then SOMETHING2
  String::                           richard rene frangie vera
  String-literal::                  "richard rene frangie vera"
  Object::                           richard rene frangie vera
  String-placeholder(overwritable):: SOMETHING2
  Object-placeholder::               richard rene frangie vera SOMETHING1

#+end_src

*** Rules for creating abbreviations
To create programming or markup templates, follow these rules:

1. use the first two initials letters, e.g. ~const~ -> ~co~. Note that in certain languages, it's better to use alternating initial (or consonants) than the initial letters ~const~ -> ~cn~ (depending on the case you choose, try to follow the same pattern for all of them)
2. use the initials of words,  e.g. ~org-babel~, ~orgBabel~ -> ~ob~
3. use the initials of compound words,  e.g. ~background~ -> ~bg~
4. use prefixes/namespace when there are many templates in a category. One letter for the prefix and two letters for the abbreviation (or one if there are few abbreviations with that namespace), e.g. ~block js~, ~block html~, ~block css~ (*prefix* ~b~) -> ~bj~, ~bh~, ~bc~ and suffixes when they have or add additional features, e.g. ~block js export~, ~block js run~ first: (*suffix* ~e~ / ~r~) -> ~bje~, ~bjr~
5. the number of letters in the abbrev should be proportional to the frequency. Don't worry if it breaks some rule, fewer keys are better: *high*: ~function~ -> ~f~, *medium*: ~for~ -> ~fo~, *low*: ~dowhile~ -> ~dwh~
6. if we have the following abbreviation (~class~ ~inline~ -> ~ci~), but the abbreviation has already been taken (~cipher~ -> ~ci~), and the ~class~ form already has a template abbreviation assigned to it (~class~ -> ~cl~), keep the template abbreviation, and add the new abbrev at the end (with one letter when possible) (~class~ ~inline~ -> ~cli~)

#+begin_src emacs-lisp

    ;; class
  (cl "class " p " {" n> q n> "}" >)
  ;; class inline
  (cli "class " p " {" q "}")
  ;; class extends
  (cle "class " p " extends " p " {" n> q n> "}" >)
  ;; class extend inline
  (clei "class " p " extends " p " {" q "}")
  ;; class constructor
  (clc "class " p " {" n> "constructor(" p ") {" n> p n> "}" n> q n> "}" >)
  ;; class constructor super
  (clcs "class " p " {" n> "constructor(" p ") {" n>
        "super(" p ")" n> p n>"}" n> q n> "}" >)

#+end_src

When the above is not possible, for example, the first two letters already match another template, or it's an real word (~be~), follow these:

  1. when there are *many* templates:
     - add more letters (pros: more options, and easier to remember) e.g. ~console~ -> ~con~
  2. when there are *few* templates:
     - use the next letter (pros: fewer keys, easier to type) e.g.  ~console~ -> ~cn~
  3. reverses the letters, e.g.  ~if~ -> ~fi~
  4. in words with prefix, extend the second one, e.g. ~text-decoration~, ~text-direction~ -> ~td~ (most used) ~tdi~ (less used) (pro: keep the same prefix (~t~) for all other options, and the most used template fulfill the main rule (intitial ~td~) which is easy to remember and type, while the other template (~tdi~) may not be used or are used less)

Tips:

- most frequently used words take priority in the chosen rule, e.g. ~const~ -> ~co~  /  ~console~ -> ~con~ (~const~ is used more often, so it takes fewer letters)
- sometimes is useful to preserve the templates that are already set, e.g. if we already have the following abbreviation (~class~ -> ~cl~), keep the template abbreviation, and add the new abbrev at the end (with one letter when possible) (~class constructor~ -> ~clc~)  (~class super~ -> ~cls~)  (~class constructor super~ -> ~clcs~) (pros: less likely to cause conflicts with other letters, and easier to remember) (cons: more keys to type)
- it should not resemble a real word,  e.g. ~text-high-ext~  -> (~the~ not) (~teh~ yes)
- use consonants (less likely to resemble a word) e.g. ~function~ -> (~fun~ not) ( ~fn~ or ~fnc~ yes)
- try to keep the same patterns, e.g. ~link~, ~link variable~, ~link property~ -> (~lk~, ~lv~, ~lp~ not) (~lk~, ~lkv~, ~lkp~ yes)
- use a combination of templates, e.g.:

#+begin_src emacs-lisp

  ;; USING A SINGLE TEMPLATE:
  ;; Typing 'fie' triggers the template.
  ;; if else
  (fie "if (" p ") {" n> p n> "} else { " > n> q n> "}" >)

  ;; USING A COMBINATION OF TEMPLATES:
  ;; Typing 'fi' triggers the first template,fill
  ;; out, and then 'els' to trigger the second.
  ;; if
  (fi "if (" p ") {" n> q n> "}" >)
  ;; else
  (els "else {" n> q n> "}" >)

#+end_src

*** Letter frequency table
**** Possible combinations

#+begin_src

  Number of letters (alphabet) x Quantity of the prefix

  f    -> 26 x 1 = 26 - 9 = 17
  fu   -> 26 x 2 = 676 - 27 = 649
  fun  -> 26 x 3 = 15776
  func -> 26 x 4 = 456976

#+end_src

**** Beware of these letters
Exclude these letters as they have a different meaning:

  - one letter (9)

#+begin_src

  - never use (9):
    a, i    — english words
    i, j, k — indices, loop counters, imaginary unit
    n       — integer, count, size, length
    x, y, z — variables: unknowns, coordinates
    t       — true

  - try not to use (5):
    f, g, h — functions, graph
    c       — constant, character
    e       — error

  - maybe use (6):
    a, b, c — generic variable, loop counters, array indices
    m       — units: meter, slope
    s       — string, second, displacement
    p       — pointer
    q       — queue, query
    o       — spanish word

  - safe to use (6):
    u, r, w, v, l, d

#+end_src

  - two letters (27 options)

#+begin_src

  ad	       *Advertisement.
  ai	       *Three-toed sloth. Artificially intelligence.
  am	       1st person singular present of be.
  an	       Indefinite article (used before vowel sound).
  as	       To the same extent; like.
  at	       Expressing location or time.

  be	       To exist or live.
  by	       Indicating proximity or agency.

  do	       To perform an action.

  go	       To move or travel.

  hi	       *Greeting.

  id	       Part of the psyche; identification.
  if	       Introducing a conditional clause.
  in	       Expressing location within something.
  is	       3rd person singular present of be.
  it	       Neuter pronoun.

  ko	       *Knockout.

  me	       Objective case of I.
  my	       Belonging to me.

  no	       Negative response; not any.

  of	       Expressing relationship or origin.

  on	       Above and touching; functioning.
  or	       Connecting alternatives.

  so	       To such an extent; therefore.

  to	       Expressing direction or purpose.

  us	       Objective case of we.

  we	       1st person plural pronoun.

#+end_src

**** Frequency of initials
Table that presents the frequency of initials in the English (deepSeek).

#+begin_src sh

  Letter	Frequency as Word-Initial
  *t             ~16%
  *a             ~12%
  *i             ~11%
  s             ~10%
  o             ~8%
  c             ~7%
  m             ~6%
  f             ~5%
  p             ~5%
  b             ~4%
  h             ~4%
  w             ~4%
  d             ~3%
  e             ~2%
  r             ~2%
  l             ~1.5%
  g             ~1%
  *n             ~1%
  u             ~0.5%
  v             ~0.5%
  *j             ~0.3%
  *k             ~0.3%
  *y             ~0.2%
  q             ~0.1%
  *x             ~0.05%
  *z             ~0.05%

#+end_src

**** Bigram frequency in the English language
The frequency of the most common letter bigrams in a large English corpus is:[4]

#+begin_src

  th   3.56%         of   1.17%          io   0.83%
  he   3.07%         ed   1.17%          le   0.83%
  in   2.43%         is   1.13%          ve   0.83%
  er   2.05%         it   1.12%          co   0.79%
  an   1.99%         al   1.09%          me   0.79%
  re   1.85%         ar   1.07%          de   0.76%
  on   1.76%         st   1.05%          hi   0.76%
  at   1.49%         to   1.05%          ri   0.73%
  en   1.45%         nt   1.04%          ro   0.73%
  nd   1.35%         ng   0.95%          ic   0.70%
  ti   1.34%         se   0.93%          ne   0.69%
  es   1.34%         ha   0.93%          ea   0.69%
  or   1.28%         as   0.87%          ra   0.69%
  te   1.20%         ou   0.87%          ce   0.65%

#+end_src


** Mode line
*** Brief
A mode line construct can be either a single string, a single Lisp symbol, or a list. For lists, the first element in the list determines how the list is interpreted. Nesting mode line constructs for recursive processing is very common.

|     | /Input Method and Coding System/                              |
|-----+-------------------------------------------------------------|
| /-/   | No code conversion, except possibly end-of-line translation |
| /'=/  | No code conversion or end-of-line translation               |
| /1/   | ISO Latin 1 code conversion                                 |
| /U/   | Unicode (typically UTF-8)                                   |
|     |                                                             |
|     | /End Of Line/                                                 |
|-----+-------------------------------------------------------------|
| /:/   | (Unix) Line feed - Unix, Linux, MacOS X                     |
| /'//  | (MAC) Carriage return - classic Macintosh (not MacOS X)     |
| /\/   | (DOS) Both - Microsoft, DEC, RFCs                           |
|     |                                                             |
|     | /Buffer Modification/                                         |
|-----+-------------------------------------------------------------|
| /**/  | modified since last save                                    |
| /--/  | not modified since last save                                |
| /%*/  | read-only, but modified                                     |
| /%%/  | read-only, not modified                                     |
|     | /Cursor Position/                                             |
|-----+-------------------------------------------------------------|
| /Top/ | the beginning of the buffer is shown in the window          |
| /Bot/ | the end of the buffer is shown in the window                |
| /All/ | all of the buffer is shown in the window                    |
| /xx%/ | % of the buffer above the top of the window ( visible text) |

*** Single string
A mode line construct can be a single string. When rendered by ‘ ~format-mode-line~ ’, this yields the same string, with any ~%-constructs~ replaced with their values. Note that ~%-construct~ replacement in simple strings only happens at the top-level.

#+begin_src emacs-lisp

  (setq example-construct "buffer: %b")
  ;; buffer: *scratch*

#+end_src

*** Single lisp symbol
A mode line construct can be a single Lisp symbol. When rendered, symbols are evaluated for their value. The symbols ‘ ~t~ ’ and ‘ ~nil~ ’ are ignored, as are any symbols whose value is void. A symbol whose value is a string is not subject to ~%-construct~ replacement.

#+begin_src emacs-lisp

  (setq example-construct emacs-version)

  (setq mode-line-format nil)
  ;; disable mode line

#+end_src

*** List of constructs
A mode line construct can be a list of mode constructs. Such a list must start with either a string, or another list. When rendered, the list elements(s) are processed recursively as mode line constructs, and the results concatenated into one string. Strings in such a list are subject to ~%-construct~ processing.

#+begin_src emacs-lisp

  (setq example-construct (list "Emacs version: " emacs-version))

#+end_src

*** Field width
A list starting with an integer specifies a field width. The remainder of the list is processed recursively, as above. If the width is positive, the resulting string is space padded on the right to that width as needed. If the width is negative, it is truncated as needed.

#+begin_src emacs-lisp

  ;; FIXME example for positive padded

  ;; limit path display to 70 characters
  (setq example-construct (list -70 "File: %f"))

#+end_src

*** Eval form
A list starting with ~:eval~ causes the rest of the list to be evaluated as a Lisp form, and uses the result as the string to display. If the Lisp evaluation loads any files, it may cause infinite recursion and crash Emacs, so don’t do that.

#+begin_src emacs-lisp

  (setq mode-line-format '("%e" "Hello world!"
                           (:eval (format " Buffer: %s" (buffer-name)))))
  ;; Hello world! Buffer: *scratch*

#+end_src

*** Propertize
A list starting with ~:propertize~ will process the second list element as a mode line construct, taking the remaining elements as *text properties to add to the resulting string*.

#+begin_src emacs-lisp

  (setq mode-line-format '("%e" "Hello world!"
                           (:eval (format " Buffer: %s"
                                          (propertize (buffer-name)
                                                      'face 'error)))))
  ;; Hello world! Buffer: *scratch*
  ;; but "*scratch*" in red color

  (setq mode-line-format '("%e" "Hello world!"
                           (:eval (propertize (capitalize
                                               (symbol-name major-mode))
                                              'face 'bold))))
  ;; MODE: Lisp-Interaction-Mode

#+end_src

*** defvar-local
Declares local variables, it is useful to use it in “mode-line” to make its construction more comfortable and easier to read.

#+begin_src emacs-lisp

  (defvar-local rf-modeline-buffer '(:eval
                                     (format " Buffer: %s"
                                             (propertize (buffer-name)
                                                         'face 'error)))
    "Mode line construct to display the buffer.")
  (defvar-local rf-modeline-major-mode '(:eval
                                         (propertize
                                          (capitalize
                                           (symbol-name major-mode))
                                          'face 'bold))
    "Mode line construct to display the major mode.")

  (setq-default mode-line-format '("%e" "Hello world!"
                                   (:eval
                                    (format " Buffer: %s"
                                            (propertize (buffer-name)
                                                        'face 'error)))
                                   (:eval
                                    (propertize
                                     (capitalize (symbol-name
                                                  major-mode))
                                     'face 'bold))))
  ;; is equivalent to
  (setq-default mode-line-format '("%e" "Hello world!" rf-modeline-buffer
                                   rf-modeline-major-mode)

#+end_src

*Note* the variable must have a risky local variable property:

#+begin_src emacs-lisp

  (put 'rf-modeline-buffer 'risky-local-variable t)
  ;; or many variable at once in dolist
  (dolist (construct '(rf-modeline-buffer
                       rf-modeline-major-mode))
    (put construct 'risky-local-variable t))

#+end_src

** Draw ASCII
*** artist-mode
Lets you draw ASCII pictures with mouse. Permite dibujar líneas, cuadrados, rectángulos y polilíneas, elipses y círculos con el mouse y/o el teclado en formato AsCii.

- Left mouse button to draw.
- Right mouse button to erase.
- Middle click (mouse-2) to switch to rectangle, ellipse, and other tools.

When *line* is used to create lines, the ~>~ and ~<~ characters can be used to placed arrows.

#+begin_src ditaa :file some_filename.png :cmdline -r -s 0.8

    +-----------+        +---------+
    |    PLC    |        |         |
    |  Network  +<------>+   PLC   +<---=---------+
    |    cRED   |        |  c707   |              |
    +-----------+        +----+----+              |
                              ^                   |
                              |                   |
                              |  +----------------|-----------------+
                              |  |                |                 |
                              v  v                v                 v
      +----------+       +----+--+--+      +-------+---+      +-----+-----+       Windows clients
      |          |       |          |      |           |      |           |      +----+      +----+
      | Database +<----->+  Shared  +<---->+ Executive +<-=-->+ Operator  +<---->|cYEL| . . .|cYEL|
      |   c707   |       |  Memory  |      |   c707    |      | Server    |      |    |      |    |
      +--+----+--+       |{d} cGRE  |      +------+----+      |   c707    |      +----+      +----+
         ^    ^          +----------+             ^           +-------+---+
         |    |                                   |
         |    +--------=--------------------------+
         v
+--------+--------+
|                 |
| Millwide System |            -------- Data ---------
| cBLU            |            --=----- Signals ---=--
+-----------------+

#java -jar ditaaXXX.jar
#java -jar ditaa0_9.jar demo.txt

#+end_src

*** Box drawing unicode

|        | /0/ | /1/ | /2/ | /3/ | /4/ | /5/ | /6/ | /7/ |
|--------+---+---+---+---+---+---+---+---|
| /U+250x/ | ─ | ━ | │ | ┃ | ┄ | ┅ | ┆ | ┇ |
|--------+---+---+---+---+---+---+---+---|
| /U+251x/ | ┐ | ┑ | ┒ | ┓ | └ | ┕ | ┖ | ┗ |
|--------+---+---+---+---+---+---+---+---|
| /U+252x/ | ┠ | ┡ | ┢ | ┣ | ┤ | ┥ | ┦ | ┧ |
|--------+---+---+---+---+---+---+---+---|
| /U+253x/ | ┰ | ┱ | ┲ | ┳ | ┴ | ┵ | ┶ | ┷ |
|--------+---+---+---+---+---+---+---+---|
| /U+254x/ | ╀ | ╁ | ╂ | ╃ | ╄ | ╅ | ╆ | ╇ |
|--------+---+---+---+---+---+---+---+---|
| /U+255x/ | ═ | ║ | ╒ | ╓ | ╔ | ╕ | ╖ | ╗ |
|--------+---+---+---+---+---+---+---+---|
| /U+256x/ | ╠ | ╡ | ╢ | ╣ | ╤ | ╥ | ╦ | ╧ |
|--------+---+---+---+---+---+---+---+---|
| /U+257x/ | ╰ | ╱ | ╲ | ╳ | ╴ | ╵ | ╶ | ╷ |

|        | /8/ | /9/ | /A/ | /B/ | /C/ | /D/ | /E/ | /F/ |
|--------+---+---+---+---+---+---+---+---|
| /U+250x/ | ┈ | ┉ | ┊ | ┋ | ┌ | ┍ | ┎ | ┏ |
|--------+---+---+---+---+---+---+---+---|
| /U+251x/ | ┘ | ┙ | ┚ | ┛ | ├ | ┝ | ┞ | ┟ |
|--------+---+---+---+---+---+---+---+---|
| /U+252x/ | ┨ | ┩ | ┪ | ┫ | ┬ | ┭ | ┮ | ┯ |
|--------+---+---+---+---+---+---+---+---|
| /U+253x/ | ┸ | ┹ | ┺ | ┻ | ┼ | ┽ | ┾ | ┿ |
|--------+---+---+---+---+---+---+---+---|
| /U+254x/ | ╈ | ╉ | ╊ | ╋ | ╌ | ╍ | ╎ | ╏ |
|--------+---+---+---+---+---+---+---+---|
| /U+255x/ | ╘ | ╙ | ╚ | ╛ | ╜ | ╝ | ╞ | ╟ |
|--------+---+---+---+---+---+---+---+---|
| /U+256x/ | ╨ | ╩ | ╪ | ╫ | ╬ | ╭ | ╮ | ╯ |
|--------+---+---+---+---+---+---+---+---|
| /U+257x/ | ╸ | ╹ | ╺ | ╻ | ╼ | ╽ | ╾ | ╿ |

*** Geometric shapes

#+begin_src

          0   1   2   3   4   5   6   7
  U+25Ax  ■   □   ▢   ▣   ▤   ▥   ▦   ▧
  U+25Bx  ▰   ▱   ▲   △   ▴   ▵   ▶   ▷
  U+25Cx  ◀   ◁   ◂   ◃   ◄   ◅   ◆   ◇
  U+25Dx  ◐   ◑   ◒   ◓   ◔   ◕   ◖   ◗
  U+25Ex  ◠   ◡   ◢   ◣   ◤   ◥   ◦   ◧
  U+25Fx  ◰   ◱   ◲   ◳   ◴   ◵   ◶   ◷

          8   9   A   B   C   D   E   F
  U+25Ax  ▨   ▩   ▪   ▫   ▬   ▭   ▮   ▯
  U+25Bx  ▸   ▹   ►   ▻   ▼   ▽   ▾   ▿
  U+25Cx  ◈   ◉   ◊   ○   ◌   ◍   ◎   ●
  U+25Dx  ◘   ◙   ◚   ◛   ◜   ◝   ◞   ◟
  U+25Ex  ◨   ◩   ◪   ◫   ◬   ◭   ◮   ◯
  U+25Fx  ◸   ◹   ◺   ◻   ◼   ◽  ◾  ◿

#+end_src

*** Dingbats

#+begin_src

            0   1   2   3   4   5   6   7
   U+270x   ✀   ✁   ✂   ✃   ✄   ✅  ✆   ✇
   U+271x   ✐   ✑   ✒   ✓   ✔   ✕   ✖   ✗
   U+272x   ✠   ✡   ✢   ✣   ✤   ✥   ✦   ✧
   U+273x   ✰   ✱   ✲   ✳   ✴   ✵   ✶   ✷
   U+274x   ❀   ❁   ❂   ❃   ❄   ❅   ❆   ❇
   U+275x   ❐   ❑   ❒   ❓  ❔  ❕  ❖   ❗
   U+276x   ❠   ❡   ❢   ❣   ❤   ❥   ❦   ❧
   U+277x   ❰   ❱   ❲   ❳   ❴   ❵   ❶   ❷
   U+278x   ➀   ➁   ➂   ➃   ➄   ➅   ➆   ➇
   U+279x   ➐   ➑   ➒   ➓   ➔   ➕  ➖  ➗
   U+27Ax   ➠   ➡   ➢   ➣   ➤   ➥   ➦   ➧
   U+27Bx   ➰  ➱   ➲   ➳   ➴   ➵   ➶   ➷

            8   9   A   B   C   D   E   F
   U+270x   ✈   ✉   ✊  ✋  ✌   ✍   ✎   ✏
   U+271x   ✘   ✙   ✚   ✛   ✜   ✝   ✞   ✟
   U+272x   ✨  ✩   ✪   ✫   ✬   ✭   ✮   ✯
   U+273x   ✸   ✹   ✺   ✻   ✼   ✽   ✾   ✿
   U+274x   ❈   ❉   ❊   ❋   ❌  ❍   ❎  ❏
   U+275x   ❘   ❙   ❚   ❛   ❜   ❝   ❞   ❟
   U+276x   ❨   ❩   ❪   ❫   ❬   ❭   ❮   ❯
   U+277x   ❸   ❹   ❺   ❻   ❼   ❽   ❾   ❿
   U+278x   ➈   ➉   ➊   ➋   ➌   ➍   ➎   ➏
   U+279x   ➘   ➙   ➚   ➛   ➜   ➝   ➞   ➟
   U+27Ax   ➨   ➩   ➪   ➫   ➬   ➭   ➮   ➯
   U+27Bx   ➸   ➹   ➺   ➻   ➼   ➽   ➾   ➿

#+end_src

*** The most common ones

┌ ┐ └ ┘
─ │ ├ ┤
┴ ┬ ┼

** Miscellaneous
*** Master Tips
Here are 7 general emacs tips that's the most important in emacs productivity to me (Xah).

- Everything is a Command :: In emacs, every keystroke is bound to a command. For example: =e= runs ~self-insert-command~, =↓= runs ~next-line~, =Alt+x= runs ~execute-extended-command~. Any key or key combination or key sequence you press is ultimately a command call.
- Master Window Splitting :: Use window splitting commands extensively, and give them easy keys.
- Master Dired :: In coding, almost every hour you need to look at different files or directories, especially if you are sys admin. You'll need to do copying, deleting, renaming files or directories.
- Master Buffer Switching :: In emacs, every file is represented in a “buffer”. Practically, it means a single window is used to represent several different files or work area, but only one is shown. (similar to tabbed window in web browser, but without showing the tabs.)
- Remap Most Frequently Used Keys :: The cursor moving commands are statistically the most frequently used keys. You use them every few seconds.
- Master Find Replace and Emacs Regex :: Searching text and find replace is the heart of text processing. I use it many times every hour.
- Get A Good Keyboard :: You switch to different applications all day. Web browsers, emacs, terminal, Desktop, music player, image editor, etc. Their usage and interface changes, but there is one thing that does not change: Your keyboard.

*** Completing Read interface
Outside of editing a buffer, one of the most common user interface in Emacs is completing-read, which allows you to select an item from a list of choices.

#+begin_src emacs-lisp

  (let ((choices '("First" "Second" "Third")))
    (completing-read "Choose: " choices))

#+end_src

 The completing-read can also take more interesting types of lists, like associative lists.

#+begin_src emacs-lisp

  (let ((choices '(("First"  . 'first-choice)
                   ("Second" . 'second-choice)
                   ("Third"  . 'third-choice))))
    (completing-read "Choose: " choices))

#+end_src

 I sometimes have a list of identifiers the program needs, but I want to display more user-friendly choices. In other words, in the example above, I would like to display Second, but have the call return 'second-choice instead. We have always just called assoc after the fact, as in:

#+begin_src emacs-lisp

  (let ((choices '(("First"  . 'first-choice)
                   ("Second" . 'second-choice)
                   ("Third"  . 'third-choice))))
    (alist-get
     (completing-read "Choose: " choices)
     choices nil nil 'equal))

#+end_src

* How to
** Configure the init file
*** Initialization
**** Package
Manager for Emacs Lisp packages.

#+begin_src emacs-lisp

  ;; When enabled, 'package-install' will include in the list of
  ;; upgradeable packages those built-in packages (like Eglot and
  ;; use-package) for which a newer version is available in package
  ;; archives, and will allow installing those newer versions:
  (setq package-install-upgrade-built-in t)

#+end_src

**** Startup settings
Emacs start-up settings.

*** Faces
**** Basic faces
The standard faces  for specifying text appearance.
- default :: is used for ordinary text that doesn’t specify any face. Its background color is used as the frame’s background color.
- variable-pitch :: forces use of a variable-width (i.e., proportional) font. The font size picked for this face matches the font picked for the default (usually fixed-width) font.
- fixed-pitch :: forces use of a fixed-width font. It’s reasonable to customize this face to use a different fixed-width font, if you like, but you should not make it a variable-width font.
- shadow :: is used for making the text less noticeable than the surrounding ordinary text. Usually this can be achieved by using shades of gray in contrast with either black or white default foreground color.

#+begin_src emacs-lisp

  ;; Set the default face:
  (set-face-attribute 'default nil :font "Fira Code Retina":height 100)

  ;; Set the variable pitch face:
  (set-face-attribute 'variable-pitch nil :font "Cantarell":height 125)

  ;; Set the fixed pitch face:
  (set-face-attribute 'fixed-pitch nil :font "JetBrains Mono":height 100)

#+end_src

**** All the icons faces
Manage how all the icons icons are coloured and themed.

**** Nerd icons faces
Manage how Nerd Font icons are coloured and themed.

#+begin_src emacs-lisp

  ;; Library for easily using Nerd Font icons inside Emacs:
  (use-package nerd-icons)
  ;; :custom
  ;; "Symbols Nerd Font Mono" is the default and is recommended
  ;; (nerd-icons-font-family "JetBrainsMono Nerd Font"))
  ;; This need a Nerd Font installed on your system.
  ;; You can use M-x nerd-icons-install-fonts or install it manually
  ;; to get Symbols Nerd Fonts Mono or another variant of your choice.


  ;; Icons for Corfu via nerd-icons
  (use-package nerd-icons-corfu
    :config
    (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
  ;; Optionally:
  (setq nerd-icons-corfu-mapping
        '((array :style "cod" :icon "symbol_array" :face font-lock-type-face)
          (boolean :style "cod" :icon "symbol_boolean" :face
                   font-lock-builtin-face)
          ;; You can alternatively specify a function to perform the mapping,
          ;; use this when knowing the exact completion candidate is important.
          ;; Don't pass `:face' if the function already returns string with the
          ;; face property, though.
          (file :fn nerd-icons-icon-for-file :face font-lock-string-face)
          ;; ...
          (t :style "cod" :icon "code" :face font-lock-warning-face)))
  ;; If you add an entry for t, the library uses that as fallback.
  ;; The default fallback (when it's not specified) is the ? symbol.
  ;; The Custom interface is also supported for tuning the variable above.

#+end_src

**** Kind-icon
Colorful icons for completion in Emacs.

#+begin_src emacs-lisp

  ;; Adds configurable icon or text-based completion prefixes based on
  ;; the `:company-kind' property that many completion backends provide.
  (use-package kind-icon
    :after corfu
    :custom
    ;; (kind-icon-blend-background t)
    ;; only needed with blend-background
    ;; (kind-icon-default-face 'corfu-default)
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
  ;;Note that icon support requires the small library svg-lib.

#+end_src

**** Svg Lib
SVG tags, bars & icons.

#+begin_src emacs-lisp

  ;; svg-lib is an Emacs library that allows to create and display various SVG
  ;; objects, tags, icons, buttons, progress bars, progress pies and dates.
  (use-package svg-lib
    :config
    ;; Using SVG icons from a nerd-fonts icon collection
    (add-to-list 'svg-lib-icon-collections
                 '("nerd-fonts-codicons" . "https://github.com/microsoft/vscode-codicons/raw/HEAD/src/icons/%s.svg")))

#+end_src

*** Environment
**** Mode line
Contents of the mode line.

#+begin_src emacs-lisp

  ;; Hidden minor modes from the default mode line:
  (defvar hidden-minor-modes
    '(abbrev-mode drag-stuff-mode ivy-mode counsel-mode
                  yas-minor-mode eldoc-mode buffer-face-mode visual-line-mode
                  org-indent-mode which-key-mode help-mode company-mode
                  company-box-mode paredit-mode lsp-lens-mode skewer-css-mode
                  skewer-html-mode skewer-mode projectile-mode))

  (defun se/purge-minor-modes ()
    (interactive)
    (dolist (minor-mode hidden-minor-modes)
      (let ((show-string (cdr (assoc minor-mode minor-mode-alist))))
        (when show-string
          (setcar show-string "")))))

  (add-hook 'after-change-major-mode-hook 'se/purge-minor-modes)


  ;; This is another way to hide the modes in modeline by Mickey
  ;; Petersen, but first need to define the loop function.
  ;; Hiding and replacing modeline strings (Mickey Petersen)
  (defvar mode-line-cleaner-alist
    `((abbrev-mode . " α")
      (drag-stuff-mode . " δσ")
      (ivy-mode . " ι")
      (counsel-mode . " ψ")
      (yas-minor-mode . " υμ")
      (eldoc-mode . " ε")
      (buffer-face-mode . " βφ")
      (visual-line-mode . " ωλ")
      (org-indent-mode . " οι")
      (which-key-mode . " ςκ")
      (help-mode . " η")
      (company-mode . " ψα")
      (company-box-mode . " ψαβ")
      (paredit-mode . " π")
      (lsp-lens-mode . " λλ")
      (skewer-css-mode . " σψ")
      (skewer-html-mode . " ση")
      (skewer-mode . " σ")
      (projectile-mode . " πρ"))
    "Alist for `clean-mode-line'.

  When you add a new element to the alist, keep in mind that you
  must pass the correct minor/major mode symbol and a string you
  want to use in the modeline *in lieu of* the original.")

  (defun mp/clean-mode-line ()
    (interactive)
    (loop for cleaner in mode-line-cleaner-alist
          do (let* ((mode (car cleaner))
                    (mode-str (cdr cleaner))
                    (old-mode-str (cdr (assq mode minor-mode-alist))))
               (when old-mode-str
                 (setcar old-mode-str mode-str))
               ;; major mode
               (when (eq mode major-mode)
                 (setq mode-name mode-str)))))

  (add-hook 'after-change-major-mode-hook 'mp/clean-mode-line)


  ;; Only display modes on the visible screen by Protesilaos:
  (defvar-local prot-mode-line-modes-hide
      '(:eval
        (when (mode-line-window-selected-p)
          mode-line-modes))
    "Only display modes on the visible screen.")
  (put 'prot-mode-line-modes-hide 'risky-local-variable t)

  (setq-default mode-line-format
                '("%e"
                  mode-line-front-space
                  mode-line-mule-info
                  mode-line-client
                  mode-line-modified
                  mode-line-remote
                  mode-line-frame-identification
                  mode-line-buffer-identification
                  "   "
                  mode-line-position
                  (vc-mode vc-mode)
                  "  "
                  prot-mode-line-modes-hide
                  mode-line-misc-info
                  mode-line-end-spaces))

#+end_src

**** Theme
Options for doom-themes.

#+begin_src emacs-lisp

  ;; A theme megapack for GNU Emacs:
  (use-package doom-themes
    :config
    (load-theme 'doom-one t)
    ;; Another fancy option:
    ;; (load-theme 'doom-palenight t)
    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config))

#+end_src

**** Frames
Support for Emacs frames and window systems.

#+begin_src emacs-lisp

  ;; Set maximize frame into the current frame:
  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  ;; Set maximize frame by default:
  (add-to-list 'default-frame-alist '(fullscreen . maximized))

  ;; Set specify frame size, and set it by default:
  ;; These functions previously help us know the size of the frame:
  ;; (frame-parameters) -> all parameters
  ;; (frame-width) -> 170
  ;; (frame-height) -> 43
  (set-frame-size (selected-frame) 170 43)
  (add-to-list 'default-frame-alist '(width . 170))
  (add-to-list 'default-frame-alist '(height . 43))

  ;; Set position of the frame:
  ;; Fits on the monitor screen.
  (add-to-list 'default-frame-alist '(left . 1356))
  (add-to-list 'default-frame-alist '(top . 30))
  ;; Fits on the laptop screen.
  (add-to-list 'default-frame-alist '(left + -10))
  (add-to-list 'default-frame-alist '(top . 475))


  ;; Set the default appearance of fringes on the Package Menu frame.
  (add-hook 'package-menu-mode-hook (lambda () (set-fringe-style nil)))
  ;; Note: changes all the windows


  ;; Switch the contents of two open frames.
  ;; https://www.emacswiki.org/emacs/SwitchingBuffers
  (defun switch-buffers-between-frames ()
    "switch-buffers-between-frames switches the buffers between the two last frames"
    (interactive)
    (let ((this-frame-buffer nil)
          (other-frame-buffer nil))
      (setq this-frame-buffer (car (frame-parameter nil 'buffer-list)))
      (other-frame 1)
      (setq other-frame-buffer (car (frame-parameter nil 'buffer-list)))
      (switch-to-buffer this-frame-buffer)
      (other-frame 1)
      (switch-to-buffer other-frame-buffer)))


  ;; Updated version that opens the new frame at the same size. This is
  ;; because GNOME or another app intentionally offsets it slightly from
  ;; the previous window's position and size.
  (defun rf-make-frame-command-mod ()
    "Make a new frame, on the same terminal as the selected frame.
  If the terminal is a text-only terminal, this also selects the
  new frame.

  Updated version that opens the new frame at the same size. This is
  because GNOME or another app intentionally offsets it slightly from
  the previous window's position and size.

  NOTE: if the new frame opens in an odd size, it's because of the size
  of the last window, for example, if the width is 169, it will open in
  a tiny size, it's fixed by putting another size.

  When called from Lisp, returns the new frame."
    (interactive)
    (if (display-graphic-p)
        (let ((width (frame-width))
              (height (frame-height))
              (frame (make-frame)))
          (set-frame-size frame width height))))
  ;; Optional: set position too
  ;; (set-frame-position frame 100 100))

#+end_src

**** Windows
***** Window
Window configuration.

#+begin_src emacs-lisp

  ;; When you invoke switchy-window in quick succession, it will switch to
  ;; one window after the other in most-recently-used order.
  (use-package switchy-window
    :ensure t
    :custom (switchy-window-delay 1.5) ;; That's the default value.
    :bind     :bind (:map switchy-window-minor-mode-map
                          ;; Bind to separate key...
                          ("C-<" . switchy-window)
                          ;; ...or as `other-key' substitute (C-x o).
                          ("<remap> <other-window>" . switchy-window))
    :init
    (switchy-window-minor-mode))


  ;; Defining window reverse, set binding and repeat map
  (defun other-window-reverse ()
    "Select another window in reverse cyclic ordering of windows."
    (interactive)
    (other-window -1))
  ;; Set C-x 7 as its keybinding
  (keymap-set ctl-x-map "7" 'other-window-reverse)

  ;; Add it to the repeat commands.
  (keymap-set other-window-repeat-map "7" 'other-window-reverse)
  (put #'other-window-reverse 'repeat-map 'other-window-repeat-map)


  ;; Creating a display-buffer-alist entry:
  ;; It will force Emacs to place them at the bottom, with a window
  ;; height of no more than 30% of the size of the frame.
  (add-to-list 'display-buffer-alist
               '("\\*e?shell\\*" display-buffer-in-direction
                 (direction . bottom)
                 (window . root)
                 (window-height . 0.3)))

  (add-to-list 'display-buffer-alist
               '("^\\*eldoc for" display-buffer-at-bottom
                 (window-height . 4)))

  ;; We match against one buffer name, *Compilation*; with one ACTION,
  ;; display-buffer-reuse-window; and no ALIST settings, so it’s not listed.
  (add-to-list 'display-buffer-alist
               '("\\*Compilation\\*"
                 display-buffer-reuse-window))

  ;; I want *info* windows in a side bar window; it must be on the
  ;; right-hand side and in slot 0; the window-width must be 80; and Emacs
  ;; must set the window no-delete-other-windows window parameter to t.
  (add-to-list 'display-buffer-alist
               '("\\*info\\*"
                 (display-buffer-in-side-window)
                 (side . right)
                 (slot . 0)
                 (window-width . 80)
                 (window-parameters
                  (no-delete-other-windows . t))))

  ;; Here I insist that *Help* buffers reuse any existing *Help* window
  ;; if such a window exists. And if that is not possible, it must pop up
  ;; a new window. Furthermore, Emacs cannot use the same (selected)
  ;; window, and it must use another.
  (add-to-list 'display-buffer-alist
               '("\\*Help\\*"
                 (display-buffer-reuse-window display-buffer-pop-up-window)
                 (inhibit-same-window . t)))

  ;; This hides *compilation* buffers. You can still switch to them, but
  ;; their display is inhibited when created.
  (add-to-list 'display-buffer-alist
               '("\\*compilation\\*" display-buffer-no-window
                 (allow-no-window . t)))

#+end_src

***** Windmove
Directional selection of windows in a frame.

***** Ace window
Quickly switch current window.

***** Switch windows
Switch-window customization group.

#+begin_src emacs-lisp

  ;; Switch tool, which offer a visual way to choose a window
  ;; to switch to, delete, split or other operations. (useful
  ;; to resize window when switch-window is enabled)
  (use-package switch-window
    :defer t
    :config
    (setq switch-window-extra-map
          (let ((map (make-sparse-keymap)))
            (define-key map (kbd "c") 'switch-window-mvborder-up)
            (define-key map (kbd "t") 'switch-window-mvborder-down)
            (define-key map (kbd "h") 'switch-window-mvborder-left)
            (define-key map (kbd "n") 'switch-window-mvborder-right)
            (define-key map (kbd "SPC") 'balance-windows)
            (define-key map (kbd "a") 'switch-window-resume-auto-resize-window)
            map))
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts
          '("a" "o" "e" "u" "h" "t" "n" "s" "i" "d"
            ";" "," "." "p" "y" "f" "g" "c" "r" "l"
            "'" "q" "j" "k" "x" "b" "m" "w" "v" "z")))

#+end_src

**** Buffer
Control customize buffers.

#+begin_src emacs-lisp

  ;; Switch to the most recently selected buffer.
  ;; https://www.emacswiki.org/emacs/SwitchingBuffers
  (defun switch-to-previous-buffer ()
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))

#+end_src

**** Display
How things are displayed in buffers.

#+begin_src emacs-lisp

  ;; show-paren-mode in all buffers:
  (setopt show-paren-predicate t)

#+end_src

**** Desktop
Save status of Emacs when you exit.

**** Mouse
Input from the mouse.

#+begin_src emacs-lisp

  ;; Mouse scroll one line at a time:
  (setq mouse-wheel-scroll-amount '(1))


  ;; Give the <mouse-9> key a global binding  as TAB command.
  (keymap-global-set "<mouse-9>" "TAB")

#+end_src

**** Cursor
Displaying text cursors.

#+begin_src emacs-lisp

  ;; Set the color of the mouse pointer.
  (set-face-attribute 'cursor nil :background "#ff0000")

#+end_src

**** Scrolling
Properties on the scroll cursor.

#+begin_src emacs-lisp

  ;; To scroll one line at a time, enable only one of these two:
  ;; Scroll up to this many lines, to bring point back on screen:
  (setq scroll-conservatively 100)
  ;; The number of lines to try scrolling a window by when point moves out:
  (setq scroll-step 1)

#+end_src

**** Minibuffer
Controlling the behavior of the minibuffer.

#+begin_src emacs-lisp

  ;; minibuffer, stop cursor going into prompt
  (customize-set-variable
   'minibuffer-prompt-properties
   (quote (read-only t cursor-intangible t face minibuffer-prompt)))

#+end_src

**** Imenu
Mode-specific buffer indexes.

*** Editing
**** Editing basics
Most basic editing facilities.

#+begin_src emacs-lisp

  ;; If t, undo doesn't go through redo entries.
  (setq undo-no-redo t)


  (defun rf-kill-ring-save-wrapper ()
    "Save the region as if killed, but don't kill it.
    If there is no activate region, it saves the whole line
    where the pointer is as the activate region. Useful for
    saving the whole line without having to select it."
    (interactive)
    (if (use-region-p)
        (kill-ring-save nil nil t)
      (kill-ring-save (line-beginning-position) (line-end-position))))


  ;; smilar to the Xah commands but stored just in case
  ;; they have a different function
  (defun wakib-beginning-of-line-or-block ()
    "Move cursor to beginning of line or previous paragraph."
    (interactive)
    (let (($p (point)))
      (if (or (equal (point) (line-beginning-position))
              (equal last-command this-command ))
          (if (re-search-backward "\n[\t\n ]*\n+" nil "move")
              (progn
                (skip-chars-backward "\n\t ")
                ;; (forward-char )
                )
            (goto-char (point-min)))
        (progn
          (back-to-indentation)
          (when (eq $p (point))
            (beginning-of-line))))))

  (defun wakib-end-of-line-or-block ()
    "Move cursor to end of line or next paragraph."
    (interactive)
    (if (or (equal (point) (line-end-position))
            (equal last-command this-command ))
        (progn
          (re-search-forward "\n[\t\n ]*\n+" nil "move" ))
      (end-of-line)))


  ;; There is a minor mode that implements this with support for
  ;; TransientMarkMode
  (defun electric-pair ()
    "If at end of line, insert character pair without surrounding spaces.
      Otherwise, just insert the typed character."
    (interactive)
    (if (eolp) (let (parens-require-spaces) (insert-pair)) (self-insert-command 1)))

  ;; Then enable it by binding the appropriate characters to it in your
  ;; favorite programming modes. For example, for PythonMode:
  (add-hook 'python-mode-hook
            (lambda ()
              (define-key python-mode-map "\"" 'electric-pair)
              (define-key python-mode-map "\'" 'electric-pair)
              (define-key python-mode-map "(" 'electric-pair)
              (define-key python-mode-map "[" 'electric-pair)
              (define-key python-mode-map "{" 'electric-pair)))

#+end_src

**** Killing
Killing and yanking commands.

#+begin_src emacs-lisp

  ;;Shows all kill-ring content in a new buffer.
  (defun xah-show-kill-ring ()
    "Insert all `kill-ring' content in a new buffer named *copy history*.

  URL `http://xahlee.info/emacs/emacs/emacs_show_kill_ring.html'
  Created: 2019-12-02
  Version: 2024-05-07"
    (interactive)
    (let ((xbuf (generate-new-buffer "*copy history*"))
          (inhibit-read-only t))
      (progn
        (switch-to-buffer xbuf)
        (funcall 'fundamental-mode)
        (mapc
         (lambda (x)
           (insert x "\n\nsss97707------------------------------------------------\n\n" ))
         kill-ring))
      (goto-char (point-min))))

#+end_src

**** Indent
Indentation commands.

#+begin_src emacs-lisp

  ;; Enable indentation in all modes except text modes.
  (electric-indent-mode)

  (add-hook 'text-mode-hook
            (lambda ()
              (electric-indent-local-mode -1)))

#+end_src

**** Whitespace
Visualize blanks (TAB, (HARD) SPACE and NEWLINE).

**** CUA
Emulate CUA key bindings including C-x and C-c.

#+begin_src emacs-lisp

  ;; Disable the overriding of standard Emacs binding by CUA
  ;; mode, while retaining the other features of CUA mode.
  (setq cua-enable-cua-keys nil)

  ;; Enable CUA selection mode without the C-z/C-x/C-c/C-v bindings.
  (cua-selection-mode t)

#+end_src

**** Tempel
Tempo templates/snippets with in-buffer field editing.

#+begin_src emacs-lisp

  ;; Setup completion at point
  (defun tempel-setup-capf ()
    ;; Add the Tempel Capf to `completion-at-point-functions'.
    ;; `tempel-expand' only triggers on exact matches. Alternatively use
    ;; `tempel-complete' if you want to see all matches, but then you
    ;; should also configure `tempel-trigger-prefix', such that Tempel
    ;; does not trigger too often when you don't expect it. NOTE: We add
    ;; `tempel-expand' *before* the main programming mode Capf, such
    ;; that it will be tried first.
    (setq-local completion-at-point-functions
                (cons #'tempel-expand
                      completion-at-point-functions)))
  (add-hook 'conf-mode-hook 'tempel-setup-capf)
  (add-hook 'prog-mode-hook 'tempel-setup-capf)
  (add-hook 'text-mode-hook 'tempel-setup-capf)


  ;; Require trigger prefix before template name when completing.
  :custom
  (tempel-trigger-prefix "<"))


  ;; Add tempel-collection (package young doesn't have comprehensive coverage)
  (use-package tempel-collection
    :after tempel)

#+end_src

**** Yasnippet
Yet Another Snippet extension.

#+begin_src emacs-lisp

  ;; Allows to type an abbreviation and automatically expand it in templates:
  (use-package yasnippet
    :hook (prog-mode . yas-minor-mode-on)
    :bind (:map yas-minor-mode-map
                ("TAB" . nil)
                ("<tab>" . nil)
                ("C-<tab>" . yas-expand))
    :config
    (yas-reload-all))


  ;; Point yas-snippet-dirs to good snippet collections out there.
  (setq yas-snippet-dirs
        '("~/.emacs.d/snippets"       ; personal snippets
          "/path/to/some/collection/" ; foo and bar-mode snippet collection
          "/path/to/yasnippet/yasmate/snippets" ; the yasmate collection
          ))


  ;; Set here because use-package throws an error for this binding.
  (with-eval-after-load 'yasnippet
    (define-key yas-minor-mode-map (kbd "TAB") yas-maybe-expand))

  ;; Trigger key
  ;; yas-expand tries to expand a snippet abbrev (also known as snippet
  ;; key) before point. YASnippet also provides a conditional binding for
  ;; this command: the variable yas-maybe-expand contains a special value
  ;; which, when bound in a keymap, tells Emacs to call yas-expand if and
  ;; only if there is a snippet abbrev before point. If there is no
  ;; snippet to expand, Emacs will behave as if yas-expand is unbound and
  ;; so will run whatever command is bound to that key normally.

  ;; When yas-minor-mode is enabled, it binds yas-maybe-expand to TAB and
  ;; <tab> by default, however, you can freely remove those bindings:
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)

  ;; And set your own:
  ;; Bind `SPC' to `yas-expand' when snippet expansion available (it
  ;; will still call `self-insert-command' otherwise).
  (define-key yas-minor-mode-map (kbd "SPC") yas-maybe-expand)
  ;; Bind `C-c y' to `yas-expand' ONLY.
  (define-key yas-minor-mode-map (kbd "C-c y") #'yas-expand)


  ;; A consulting-read interface for yasnippet.
  (use-package consult-yasnippet
    :commands consult-yasnippet)

#+end_src

**** Completion Preview
In-buffer completion preview.

#+begin_src emacs-lisp

  ;; Enable Completion-Preview mode in all buffers.
  (global-completion-preview-mode)

#+end_src

**** Matching
Various sorts of searching and matching.

#+begin_src emacs-lisp

  ;; Isearch the word under cursor (Xah)
  ;; You need to give it a easy key. Such as F8.
  (defun xah-search-current-word ()
    "Call `isearch' on current word or selection.
  “word” here is A to Z, a to z, and hyphen [-] and lowline [_], independent of syntax table.

  URL `http://xahlee.info/emacs/emacs/modernization_isearch.html'
  Created: 2010-05-29
  Version: 2025-02-05"
    (interactive)
    (let (xbeg xend)
      (if (region-active-p)
          (setq xbeg (region-beginning) xend (region-end))
        (save-excursion
          (skip-chars-backward "-_A-Za-z0-9")
          (setq xbeg (point))
          (right-char)
          (skip-chars-forward "-_A-Za-z0-9")
          (setq xend (point))))
      (when (< xbeg (point)) (goto-char xbeg))
      (isearch-mode t)
      (isearch-yank-string (buffer-substring-no-properties xbeg xend))))

#+end_src

**** Isearch
Incremental search minor mode.

**** Electricity
Electric behavior for self inserting keys.

#+begin_src emacs-lisp

  ;; make electric-pair-mode work on more brackets
  (setq electric-pair-pairs
      '(
        (?\" . ?\")
        (?\{ . ?\})))

#+end_src

**** Paren matching
Highlight (un)matching of parens and expressions.

**** Bookmark
Setting, annotation and jumping to bookmarks.

#+begin_src emacs-lisp

  ;; Open Bookmark File on Emacs Start
  (setq inhibit-splash-screen t)
  (require 'bookmark)
  (list-bookmarks)
  (switch-to-buffer "*Bookmark List*")

  ;; save bookmark on change
  (setq bookmark-save-flag 1)

#+end_src

**** Rectangle
Operations on rectangles.

**** Paragraphs
Paragraph and sentence parsing.

**** Undo
Undoing changes in buffers.

**** Region

*** Convenience
**** Convenience basics
Convenience features for faster editing.

#+begin_src emacs-lisp

  ;; It is the opposite of fill-paragraph (emacswiki)
  (defun unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn (barf-if-buffer-read-only) '(t)))
    (let ((fill-column (point-max))
          ;; This would override `fill-column' if it's an integer.
          (emacs-lisp-docstring-fill-column t))
      (fill-paragraph nil region)))

  ;; This command automatically toggle “fill” or “unfill” on the current
  ;; paragraph. If there is a text selection, then the command
  ;; automatically works on the region. (another version)
  (defun xah-fill-or-unfill ()
    "Reformat current block or selection to short/long line.
        First call will break into multiple short lines. Repeated
        call toggles between short and long lines.
        This commands calls `fill-region' to do its work. Set
        `fill-column' for short line length.

        URL `http://xahlee.info/emacs/emacs/modernization_fill-paragraph.html'
        Created: 2020-11-22
        Version: 2025-03-25"
    (interactive)
    ;; This command symbol has a property “'longline-p”, the
    ;; possible values are t and nil. This property is used to
    ;; easily determine whether to compact or uncompact, when
    ;; this command is called again
    (let ( (xisLongline (if (eq last-command this-command)
                            (get this-command 'longline-p) t))
           (deactivate-mark nil)
           xbeg xend )
      (seq-setq (xbeg xend)
                (if (region-active-p)
                    (list (region-beginning) (region-end))
                  (list (save-excursion
                          (if (re-search-backward "\n[ \t]*\n" nil 1)
                              (match-end 0) (point)))
                        (save-excursion
                          (if (re-search-forward "\n[ \t]*\n" nil 1)
                              (match-beginning 0) (point))))))
      (if xisLongline
          (fill-region xbeg xend)
        (let ((fill-column 99999 ))
          (fill-region xbeg xend)))
      (put this-command 'longline-p (not xisLongline))))


  ;; Define an alias to be use with the `query-replace-regexp'
  ;;function by typing like M-x qrr
  (defalias 'qrr 'query-replace-regexp)

  ;; Always use ibuffer
  (defalias 'list-buffers 'ibuffer)

  ;; Answer the questions "yes" or "no" with "y" or "n".
  (defalias 'yes-or-no-p 'y-or-n-p)


  (global-set-key (kbd "<f5> h") #'my-insert-header)


  ;; example. template insertion command
  (defun my-insert-header ()
    "Insert copyright header."
    (interactive)
    (insert ";; This program is free software:
    you can redistribute it and/or modify ..."))


  ;; Toggles tempel mode on and off when dragging.
  ;; Prevents expansion when the abbrev tempel is at the end of a line.
  ;; The downside is that it slows down the pc when dragging quickly.
  (add-hook 'drag-stuff-before-drag-hook
            (lambda () (global-tempel-abbrev-mode -1)))
  (add-hook 'drag-stuff-after-drag-hook
            (lambda () (global-tempel-abbrev-mode 1)))
  ;; another alternative is the 'move-text' (better option)
  (use-package move-text
    :bind
    (("C-S-<up>"   . move-text-up)
     ("C-S-<down>" . move-text-down)))

#+end_src

**** Bind key
A simple way to manage personal keybindings.

#+begin_src emacs-lisp

  ;; Unbind set-fill-column (so as not to press it unintentionally):
  (keymap-global-unset "C-x f")

#+end_src

**** Repeat
Convenient way to repeat previous commands.

#+begin_src emacs-lisp

  (defvar-keymap line-paragraph-movement-repeat-map
    :doc "Keymap for repeating line and paragraph movement."
    :repeat t
    "d" #'xah-beginning-of-line-or-block
    "b" #'xah-end-of-line-or-block)

#+end_src

**** Ibuffer
Advanced replacement for ‘buffer-menu’.

#+begin_src emacs-lisp

  ;; Remap the list-buffers mode to ibuffer mode (doesn't work):
  (setq major-mode-remap-alist
        '((list-buffers-mode . ibuffer-mode)))

#+end_src

**** Compare
Compare, view/edit files and tools such as diff and ediff (comprehensive visual interface to ‘diff’ and ‘patch’).

#+begin_src emacs-lisp

  ;; Split the window depending on the frame width:
  (setq ediff-split-window-function (if (> (frame-width) 150)
                                        'split-window-horizontally
                                      'split-window-vertically))

#+end_src

**** Company
Extensible inline text completion mechanism.

#+begin_src emacs-lisp

  ;; Better completions:
  (use-package company
    :bind
    (:map company-active-map
          ("<tab>" . company-complete-selection))
    (:map lsp-mode-map
          ("<tab>" . company-indent-or-complete-common))
    :custom
    company-dabbrev-downcase 0))


  ;; Orderless configurations:
  ;; Add separator that's allowed to occur in identifiers(useful in company)
  (setq orderless-component-separator "[ &]")
  ;; Highlight the matching parts of the candidates.
  (defun just-one-face (fn &rest args)
    (let ((orderless-match-faces [completions-common-part]))
      (apply fn args)))
  (advice-add 'company-capf--candidates :around #'just-one-face)


  ;; Show suggestions for YASnippets when using eglot:
  (add-hook 'eglot-managed-mode-hook
            (lambda () (add-to-list 'company-backends
                                    '(company-capf :with company-yasnippet))))


  ;; A company front-end with icons.
  (use-package company-box
    :hook (company-mode . company-box-mode))

#+end_src

**** Abbreviations
Abbreviation handling, typing shortcuts, macros.

***** Abbrev mode
Word abbreviations mode.

#+begin_src emacs-lisp

  ;; turn on abbrev mode globally
  (abbrev-mode)

  (load "~/.emacs.d/lisp/my-abbrev.el")

  ;; Auto save when you quit
  (setq save-abbrevs 'silently)


  ;; Make abbrev not add space
  (defun xah-abbrev-ahf ()
    "Abbrev hook function, used for `define-abbrev'.
  Our use is to prevent inserting the char that triggered expansion.
  Experimental.
  The “ahf” stand for abbrev hook function.
  Version 2016-10-24"
    t)

  (put 'xah-abbrev-ahf 'no-self-insert t)

#+end_src

***** Dynamic Abbreviations
Dynamic Abbreviations.

#+begin_src emacs-lisp

  (global-set-key (kbd "C-<tab>") 'dabbrev-expand)
  (define-key minibuffer-local-map (kbd "C-<tab>") 'dabbrev-expand)
  ;; You need the second statement because in the MiniBuffer,
  ;; `C-<tab>’ has a separate binding which overrides the global one.

#+end_src

***** Expand
Make abbreviations more usable.

***** Hippie Expand
Expand text trying various ways to find its expansion.

#+begin_src emacs-lisp

  ;; You see, for nearly 30 years, Emacs has had a well-kept secret. It’s
  ;; called Hippie Expand. It’s everything Dynamic Abbrev should’ve been,
  ;; if only the latter had tried harder in school. It’s surely also a
  ;; better default than the current one, but I won’t hold out hopes of
  ;; the default changing. It’s been this way for decades; it’s unlikely
  ;; to change now. So let’s right this injustice:
  (global-set-key [remap dabbrev-expand] 'hippie-expand)
  ;; Now you can press M-/ and invoke hippie-expand instead.


  ;; Gavin Freeborn (youtube)
  (use-package hippie-exp
    :bind ([remap dabbrev-expand] . hippie-expand)
    :commands (hippie-expand)
    :config
    ;; Order matters in the next list
    (setq hippie-expand-try-functions-list
          '(
            try-expand-dabbrev
            try-expand-dabbrev-all-buffers
            try-expand-dabbrev-from-kill
            try-complete-lisp-symbol-partially
            try-complete-lisp-symbol
            try-complete-file-name-partially
            try-complete-file-name
            try-expand-all-abbrevs
            try-expand-list
            try-expand-line
            )))
#+end_src

**** Minad stack
***** Vertico
VERTical Interactive COmpletion.

#+begin_src emacs-lisp

  ;; Enable vertico
  (use-package vertico
    :custom
    ;; (vertico-scroll-margin 0) ; Different scroll margin
    ;; (vertico-count 20) ; Show more candidates
    ;; (vertico-resize t) ; Grow and shrink the Vertico minibuffer
    (vertico-cycle t) ; Enable cycling for `vertico-next/previous'
    :bind (:map minibuffer-local-map
    ;; Overwrites the `file-cache-minibuffer-complete' which I don't use.
                ("M-<tab>" . vertico-insert))
    :init
    (vertico-mode))

#+end_src

***** Marginalia
***** Orderless
Provides a completion style that divides the pattern into space-separated components, and matches candidates that match all of the components in any order.

#+begin_src emacs-lisp

  ;; Customization:
  (use-package orderless
    :custom
    (orderless-style-dispatchers '(orderless-affix-dispatch))
    (orderless-component-separator #'orderless-escapable-split-on-space)
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles partial-completion))))
    (completion-category-defaults nil) ;; Disable defaults, use our settings
    :config
    ;; Defining custom orderless styles
    (orderless-define-completion-style orderless+initialism
      (orderless-matching-styles '(orderless-initialism
                                   orderless-literal
                                   orderless-regexp)))
    (setq completion-category-overrides
          '((command (styles orderless+initialism))
            (symbol (styles orderless+initialism))
            (variable (styles orderless+initialism)))))
  ;; Note that in order for the orderless+initialism style to kick-in with
  ;; the above configuration, you’d need to use commands whose metadata
  ;; indicates that the completion candidates are commands or
  ;; symbols. ctivating marginalia-mode from the Marginalia package
  ;; provides this metadata automatically for many built-in commands and is
  ;; recommended if you use the above example configuration, or other
  ;; similarly fine-grained control of completion styles according to
  ;; completion category.

#+end_src

***** Consult
Provides search and navigation commands based on the Emacs completion function completing-read.

#+begin_src emacs-lisp

  ;; -*- lexical-binding: t -*-
  ;; Previewing files in find-file
  (setq read-file-name-function #'consult-find-file-with-preview)

  (defun consult-find-file-with-preview (prompt &optional dir default
                                                mustmatch initial pred)
    (interactive)
    (let ((default-directory (or dir default-directory))
          (minibuffer-completing-file-name t))
      (consult--read #'read-file-name-internal :state (consult--file-preview)
                     :prompt prompt
                     :initial initial
                     :require-match mustmatch
                     :predicate pred)))


  ;; -*- lexical-binding: t -*-
  ;; Emacs and web colors list.
  (defvar consult-colors-history nil
    "History for `consult-colors-emacs' and `consult-colors-web'.")

  ;; No longer preloaded in Emacs 28.
  (autoload 'list-colors-duplicates "facemenu")
  ;; No preloaded in consult.el
  (autoload 'consult--read "consult")

  (defun consult-colors-emacs (color)
    "Show a list of all supported colors for a particular frame.\

    You can insert the name (default), or insert or kill the hexadecimal or RGB value of the
    selected color."
    (interactive
     (list (consult--read (list-colors-duplicates (defined-colors))
                          :prompt "Emacs color: "
                          :require-match t
                          :category 'color
                          :history '(:input consult-colors-history)
                          )))
    (insert color))

  ;; Adapted from counsel.el to get web colors.
  (defun counsel-colors--web-list nil
    "Return list of CSS colors for `counsult-colors-web'."
    (require 'shr-color)
    (sort (mapcar #'downcase (mapcar #'car shr-color-html-colors-alist)) #'string-lessp))

  (defun consult-colors-web (color)
    "Show a list of all CSS colors.\

    You can insert the name (default), or insert or kill the hexadecimal or RGB value of the
    selected color."
    (interactive
     (list (consult--read (counsel-colors--web-list)
                          :prompt "Color: "
                          :require-match t
                          :category 'color
                          :history '(:input consult-colors-history)
                          )))
    (insert color))

  ;; A toggle for the `consult-find' command.
  (defun rf-consult-find-toggle ()
    "Toggle to find for any file or all files except hidden ones."
    (interactive)
    (if (string= "find . -not ( -path */.[A-Za-z]* -prune )"
                 consult-find-args)
        (setq consult-find-args "find . ")
      (setq consult-find-args
            "find . -not ( -path */.[A-Za-z]* -prune )")))

#+end_src
***** Corfu
Corfu enhances in-buffer completion with a small completion popup.

#+begin_src emacs-lisp

  ;; Combined sorting:
  (defun my-corfu-combined-sort (candidates)
    "Sort CANDIDATES using both display-sort-function and corfu-sort-function."
    (let ((candidates
           (let ((display-sort-func (corfu--metadata-get 'display-sort-function)))
             (if display-sort-func
                 (funcall display-sort-func candidates)
               candidates))))
      (if corfu-sort-function
          (funcall corfu-sort-function candidates)
        candidates)))
  (setq corfu-sort-override-function #'my-corfu-combined-sort)


  ;; Configuring corfu for eglot:
  ;; Filter list of all possible completions with completion-style Orderless
  ;; Option 1: Specify explicitly to use Orderless for Eglot
  (setq completion-category-overrides '((eglot (styles orderless))
                                        (eglot-capf (styles orderless))))
  ;; Option 2: Undo the Eglot modification of completion-category-defaults
  (with-eval-after-load 'eglot
    (setq completion-category-defaults nil))


  ;; Show suggestions for YASnippets when using eglot:
  (straight-use-package 'cape)
  (defun my/eglot-capf ()
    (setq-local completion-at-point-functions
                (list (cape-super-capf  ;; or cape-super-capf
                       #'eglot-completion-at-point
                       (cape-company-to-capf #'company-yasnippet)))))
  (add-hook 'eglot-managed-mode-hook #'my/eglot-capf)


  ;; Buffer-local/Corfu-only completion styles (orderless)
  (orderless-define-completion-style orderless-literal-only
    (orderless-style-dispatchers nil)
    (orderless-matching-styles '(orderless-literal)))

  (add-hook 'corfu-mode-hook
            (lambda ()
              (setq-local completion-styles '(orderless-literal-only basic)
                          completion-category-overrides nil
                          completion-category-defaults nil)))


  ;; If you want to combine fast prefix filtering and Orderless:
  ;; filtering you can still do that by defining a custom Orderless
  ;; completion style via orderless-define-completion-style. We use a
  ;; custom style dispatcher, which enables efficient prefix filtering
  ;; for input shorter than 4 characters.
  (defun orderless-fast-dispatch (word index total)
    (and (= index 0) (= total 1) (length< word 4)
         (cons 'orderless-literal-prefix word)))

  (orderless-define-completion-style orderless-fast
    (orderless-style-dispatchers '(orderless-fast-dispatch))
    (orderless-matching-styles '(orderless-literal orderless-regexp)))

  (setq corfu-auto        t
        corfu-auto-delay  0  ;; TOO SMALL - NOT RECOMMENDED
        corfu-auto-prefix 0) ;; TOO SMALL - NOT RECOMMENDED

  (add-hook 'corfu-mode-hook
            (lambda ()
              (setq-local completion-styles '(orderless-fast basic)
                          completion-category-overrides nil
                          completion-category-defaults nil)))


  ;; Gavin Freeborn:
  (use-package corfu
    :custom
    (corfu-cycle t)
    (corfu-auto t)         ; Enable auto completion (automatically pop-up)
    (corfu-auto-prefix 2)  ; Enable auto completion
    (corfu-auto-delay 0.0) ; Enable auto completion
    (corfu-quit-at-boundary 'separator) ; Enable M-SPC to spc (orderless)
    (corfu-echo-documentation 0.25)
    (corfu-preview-current 'insert)
    (corfu-preselect-first nil)
    ;; Optionally use TAB for cycling, defalut is `corfu-complete'.
    :bind (:map conrfu-map
                ("M-SPC" . corfu-insert-separator) ; (if you use orderless)
                ("RET" . nil) ; Leave my enter alone!
                ("TAB" . corfu-next)
                ([tab] . corfu-next)
                ("S-TAB" . corfu-previous)
                ([backtab] . corfu-previous)
                ("S-<return>" . corfu-insert))
    :init
    ;; use corfu everywhere
    (global-corfu-mode)
    ;; Save completion history for better sorting
    (corfu-history-mode)
    (corfu-popupinfo-mode)
    :config
    (add-hook 'eshell-mode-hook
              (lamda () (setq-local corfu-quit-at-boundary t
                                    corfu-quit-no-match t
                                    corfu-auto nil)
                     (corfu-mode))))


  ;; Use Tempel in combination with other completion functions
  (setq-local completion-at-point-functions
              `(,(cape-capf-super
                  (cape-capf-predicate
                   #'elisp-completion-at-point
                   #'mi-ignore-elisp-keywords)
                  #'tempel-complete
                  #'cape-dabbrev)
                cape-file)
              cape-dabbrev-min-length 5)

#+end_src

***** Cape
Cape provides Completion At Point Extensions which can be used in combination with Corfu, Company or the default completion UI.

#+begin_src emacs-lisp

  ;; Cache busting: Ensures that you always get a fresh set of candidates
  (setq-local completion-at-point-functions
              (list (cape-capf-buster #'some-caching-capf)))
  ;; cape-capf-buster is needed to rerequest the candidates again if
  ;; you add more input, if you make the filter prefix longer.


  ;; Merge the dabbrev, dict and keyword capfs, display candidates together.
  ;; Let the UI (Corfu) sort the candidates by overriding the sort function.
  (add-hook 'elisp-mode-hook
            (lambda ()
              (setq-local completion-at-point-functions
                          (list (cape-capf-sort
                                 (cape-capf-super
                                  #'tempel-expand
                                  #'cape-dabbrev
                                  #'elisp-completion-at-point
                                  #'cape-elisp-symbol
                                  #'cape-file))))))


  ;; Gavin Freeborn
  (use-package cape
    :bind ("C-c f" . cape-file)
    :init
    ;; Add `completion-at-point-functions', used by `completion-at-point'.
    (add-to-list 'completion-at-point-functions #'cape-file)
    ;; Nice completion to have available everywhere
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (defun my/add-shell-completion ()
      (interactive)
      (add-to-list 'completion-at-point-functions 'cape-history)
      (add-to-list 'completion-at-point-functions
                   'pcomplete-completions-at-point))
    (add-hook 'shell-mode-hook #'my/add-shell-completion nil t)
    :config
    ;; Make capfs composable
    (advice-add #'eglot-completion-at-point :around #'cape-wrap-nonexclusive)
    (advice-add #'comint-completion-at-point :around #'cape-wrap-nonexclusive)
    ;; Silence then pcomplete capf, no errers or messages!
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)
    ;; Ensure that pcomplete does not write to the buffer
    ;; and behaves as a pure `completion-at-point-functions'
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify)
    )

#+end_src

***** Embark
“Emacs Mini-Buffer Actions Rooted in Keymaps” makes it easy to choose a command to run based on what is near point, both during a minibuffer completion session and in normal buffers. You can think of ~embark-act~ as a keyboard-based version of a right-click contextual menu.

#+begin_src emacs-lisp

  ;; Kill-buffer from the minibuffer after M-x switch-to-buffer.
  ;; https://www.reddit.com/r/emacs/comments/16g08me/
  ;; killbuffer_from_the_minibuffer_after_mx/
  (defun my/switch-to-buffer-kill (&optional arg)
    (interactive "P")
    (let ((embark-default-action-overrides '((buffer . kill-buffer)
                                             (file . embark-recentf-remove)))
          (embark-pre-action-hooks (assq-delete-all 'kill-buffer embark-pre-action-hooks))
          embark-quit-after-action)
      (embark-dwim arg)))

  (defvar my/consult-buffer-map
    (let ((map (make-sparse-keymap)))
      (define-key map "\C-w" #'my/switch-to-buffer-kill)
      map))
  (consult-customize consult-buffer :keymap my/consult-buffer-map)

#+end_src

**** Prescient
Simple but effective candidate sorting by usage. Prescient does not offer the same flexibility as Orderless with its style dispatchers. However in addition to matching, Prescient supports sorting of candidates, while Orderless leaves that up to the candidate source and the completion UI.

#+begin_src emacs-lisp

  ;; Configures filtering locally in buffers in which corfu-mode is active.
  (use-package corfu-prescient
    :after corfu
    :bind (:map corfu-map
                ;; Remove "M-s" from the `prescient-toggle-map' binding
                ("M-s" . nil))
    :config
    ;; Set another keymap to `prescient-toggle-map'
    (keymap-set corfu-map "M-l" prescient-toggle-map)
    ;; Use Prescient only to sort candidates (to filter: Orderless).
    (setq corfu-prescient-enable-filtering nil
          corfu-prescient-enable-sorting t
          corfu-prescient-override-sorting t) ;; or nil
    (corfu-prescient-mode 1))


  ;; vertico-prescient.el provides an interface for using prescient.el
  ;; to sort and filter candidates in Vertico menus.
  (use-package vertico-prescient
    :demand t
    :config
    (setq prescient-filter-method '(literal initialism prefix regexp)
          prescient-use-char-folding t
          prescient-use-case-folding 'smart
          prescient-sort-full-matches-first t ; Works well with `initialism'.
          prescient-sort-length-enable t)
    (vertico-prescient-mode 1)
    ;; Save recency and frequency rankings to disk, which let them become
    ;; better over time.
    (prescient-persist-mode 1))


  ;; Configures filtering locally in buffers in which company-mode is active.
  (use-package company-prescient
    :after company
    :config
    (company-prescient-mode 1))

#+end_src

**** Kmacro
Simplified keyboard macro user interface.

**** Hydra
How to use defhydra

#+begin_src emacs-lisp

  ;; Example:
  (global-set-key (kbd "C-c m")
                  (defhydra hydra-transpose (:color red)
                    "Transpose"
                    ("w" transpose-words "words")
                    ("o" org-transpose-words "Org mode words")
                    ("l" transpose-lines "lines")
                    ("q" nil "cancel" :color blue)))

  ;; auto-saves buffers, when certain events happen (e.g. you switch
  ;; between buffers, an Emacs frame loses focus)
  (use-package super-save
    :defer 1
    :diminish super-save-mode
    :config
    (super-save-mode +1))


  ;; Another example:
  (defhydra hydra-buffers (:color blue :hint nil)
    "
                                                                       ╭─────────┐
     Move to Window         Switch                  Do                 │ Buffers │
  ╭────────────────────────────────────────────────────────────────────┴─────────╯
           ^_k_^          [_b_] switch (ido)       [_d_] kill the buffer
           ^^↑^^          [_i_] ibuffer            [_r_] toggle read-only mode
       _h_ ←   → _l_      [_a_] alternate          [_u_] revert buffer changes
           ^^↓^^          [_s_] switch (helm)      [_w_] save buffer
           ^_j_^
  --------------------------------------------------------------------------------
              "
    ("<tab>" hydra-master/body "back")
    ("<ESC>" nil "quit")
    ("a" joe-alternate-buffers)
    ("b" ido-switch-buffer)
    ("d" joe-kill-this-buffer)
    ("i" ibuffer)
    ("h" buf-move-left  :color red)
    ("k" buf-move-up    :color red)
    ("j" buf-move-down  :color red)
    ("l" buf-move-right :color red)
    ("r" read-only-mode)
    ("s" helm-buffers-list)
    ("u" joe-revert-buffer)
    ("w" save-buffer))


  ;; Another example:
  (defhydra hydra-window (:color blue :hint nil)
    "
                                                                       ╭─────────┐
     Move to      Size    Scroll        Split                    Do    │ Windows │
  ╭────────────────────────────────────────────────────────────────────┴─────────╯
        ^_k_^           ^_K_^       ^_p_^    ╭─┬─┐^ ^        ╭─┬─┐^ ^         ↺ [_u_] undo layout
        ^^↑^^           ^^↑^^       ^^↑^^    │ │ │_v_ertical ├─┼─┤_b_alance   ↻ [_r_] restore layout
    _h_ ←   → _l_   _H_ ←   → _L_   ^^ ^^    ╰─┴─╯^ ^        ╰─┴─╯^ ^         ✗ [_d_] close window
        ^^↓^^           ^^↓^^       ^^↓^^    ╭───┐^ ^        ╭───┐^ ^         ⇋ [_w_] cycle window
        ^_j_^           ^_J_^       ^_n_^    ├───┤_s_tack    │   │_z_oom
        ^^ ^^           ^^ ^^       ^^ ^^    ╰───╯^ ^        ╰───╯^ ^
  --------------------------------------------------------------------------------
            "
    ("<tab>" hydra-master/body "back")
    ("<ESC>" nil "quit")
    ("n" joe-scroll-other-window :color red)
    ("p" joe-scroll-other-window-down :color red)
    ("b" balance-windows)
    ("d" delete-window)
    ("H" shrink-window-horizontally :color red)
    ("h" windmove-left :color red)
    ("J" shrink-window :color red)
    ("j" windmove-down :color red)
    ("K" enlarge-window :color red)
    ("k" windmove-up :color red)
    ("L" enlarge-window-horizontally :color red)
    ("l" windmove-right :color red)
    ("r" winner-redo :color red)
    ("s" split-window-vertically :color red)
    ("u" winner-undo :color red)
    ("v" split-window-horizontally :color red)
    ("w" other-window)
    ("z" delete-other-windows))

#+end_src

**** Completion
Dynamic word-completion code.

**** Abbreviations
Abbreviation handling, typing shortcuts, macros.

**** Ivy
Incremental vertical completion/selection.

Ivy is an interactive interface for listing sorting, filtering, previewing, and applying actions on selection from a list. When Emacs prompts for a string from a list of several possible choices, Ivy springs into action to assist in narrowing and picking the right string from a vast number of choices.

Ivy is installed as part of the ~counsel~ package. Ivy is split into three packages: ~ivy~, ~swiper~ and ~counsel~, by installing ~counsel~, the other two are brought in as dependencies. If you are not interested in the extra functionality provided by ~swiper~ and ~counsel~, you can install only ~ivy~.

Counsel provide versions of common Emacs commands that are customised to make the best use of Ivy. For example, ~counsel-find-file~ has some additional keybindings. Pressing =DEL= will move you to the parent directory.

#+begin_src emacs-lisp

  ;; Ivy (alternative to Ido) a generic completion mechanism for Emacs.
  ;; ivy-mode ensures any cmd using completing-read-fun uses ivy for completion:
  (use-package ivy
    :demand t
    :bind (:map ivy-minibuffer-map
                ("TAB" . ivy-alt-done)
                ("C-<tab>" . ivy-alt-done))
    :config
    (ivy-mode 1)
    ;; Aallow minibuffer commands while in the minibuffer.
    (setq enable-recursive-minibuffers t)
    ;; Delete ./ and .// to the front of the list when completing file names.
    (setq ivy-extra-directories nil)
    ;; Completion Styles: custom regex builder assigned to file name completion:
    (setq ivy-re-builders-alist
          '((read-file-name-internal . ivy--regex-ignore-order)
            (t . ivy--regex-plus))))

  ;; Add recentf-mode and bookmarks to ivy-switch-buffer completion candidates.
  (setq ivy-use-virtual-buffers t)

  ;; Completion Styles: custom regex builder assigned to file name completion:
  (setq ivy-re-builders-alist
        '((read-file-name-internal . ivy--regex-ignore-order)
          ;; '((read-file-name-internal . ivy--regex-fuzzy)
          (t . ivy--regex-plus))))


  ;; A collection of Ivy-enhanced versions of common Emacs commands.
  ;; counsel-mode remaps built-in functions that have counsel replacements.
  (use-package counsel
    :after ivy
    :bind (("C-M-j" . 'counsel-switch-buffer)
           ("C-x j" . 'counsel-recentf))
    :config
    (counsel-mode 1))

  ;; Fuzzy match anywhere within the cmd name (take out the leading ^): (IDK)
  (ivy-configure 'counsel-M-x :initial-input "")


  ;; Display icons for all buffers in ivy:
  ;; Should M-x all-the-icons-install-fonts to install the necessary fonts:
  (use-package all-the-icons-ivy-rich
    :after (ivy all-the-icons)
    :init (all-the-icons-ivy-rich-mode 1))


  ;; Friendly interface for ivy. Transformers for cmds from ivy and counsel:
  (use-package ivy-rich
    :after all-the-icons-ivy-rich
    :init (ivy-rich-mode 1)
    :config
    (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
    ;; Abbreviate paths using abbreviate-file-name:
    (setq ivy-rich-path-style 'abbrev))

#+end_src

*** Text
**** Org
***** Org properties
Options concerning properties in Org mode.

#+begin_src emacs-lisp

  ;; move-begining/end-of-line behave specially in headlines and items
  (setq org-special-ctrl-a/e t)

  ;; Start an org file with all headers collapsed.
  (setq org-startup-folded 't)

  ;; Start an org file showing only 2-levels headers.
  (setq org-startup-folded 'show2levels)

  ;; Start an org file showing all headers (not content).
  (setq org-startup-folded 'content)

  ;; Make shift-cursor commands select text always (headlines,
  ;; property lines, item lines, and table cells).
  ;; C-c - to cycle item bullet types
  (setq org-support-shift-select t)

#+end_src

***** Org general
General settings of the org mode.

***** Org modes
Options concerning the minor modes active in org.

***** Org faces
Options concerning the org faces.

***** Org bindings
Manage local org bindings unsing ~org-mode-map~.

#+begin_src emacs-lisp


  (defun rf-org-bindings ()
    "Wrapper that manage and enables all `org-mode-map' bindings."

    (keymap-set org-mode-map "C-c C-d" 'rf-outline-down-heading)


    (keymap-unset org-mode-map "C-S-<up>")
    (keymap-unset org-mode-map "C-S-<down>")

    ;; org-emphasize (*) bold with F5, (~) code with F6 and others.
    (keymap-set org-mode-map "<kp-subtract>" 'rf-org-emphasize-bold)
    (keymap-set org-mode-map "<kp-multiply>" 'rf-org-emphasize-code)
    (keymap-set org-mode-map "S-<kp-subtract>" 'rf-org-emphasize-italic)
    (keymap-set org-mode-map "S-<kp-multiply>" 'rf-org-emphasize-verbatim)

    ;; Allow org-cycle in headings while pressing the ctrl key.
    (keymap-set org-mode-map "M-<tab>" 'org-cycle)

    )

#+end_src

***** Org appearance
Settings for Org mode appearance.

***** Org TODO
Options concerning TODO items in Org mode.

***** Org editing
Options concerning the editing in org.

***** Babel
Code block evaluation and management in ‘org-mode’ documents

#+begin_src emacs-lisp

  ;; Add lisp and python as execution languages for babel org.
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (python . t)))

    (push '("conf-unix" . conf-unix) org-src-lang-modes))


  ;; Don't ask for confirmation before executing code blocks.
  (setq org-confirm-babel-evaluate nil)

#+end_src

***** Org LaTeX
Options for embedding LaTeX code into Org mode.

#+begin_src emacs-lisp

  ;;Activate LaTeX letters in Org:
  (with-eval-after-load 'ox-latex
    (add-to-list 'org-latex-classes '("letter" "\\documentclass{letter}")))

#+end_src

***** Org agenda
Options concerning agenda views in Org mode.

***** Org export
Options for exporting Org mode files.

***** Org goto
Options concerning Org Goto navigation interface.

***** Org ID
Options concerning global entry identifiers in Org mode.

***** Org indent
Options concerning dynamic virtual outline indentation.

***** Org link
Options concerning links in Org mode.

***** Org mobile
Options concerning support for a viewer/editor on a mobile device.

***** Org structure
Options concerning the general structure of Org files.

***** Org table
Options concerning tables in Org mode.

***** Org tags
Options concerning tags in Org mode.

***** Org time
Options concerning time stamps and deadlines in Org mode.

**** Htmlize
Convert buffer text and faces to HTML.

**** Outlines
Support for hierarchical outlining.

**** Markdown
Major mode for editing text files in Markdown format.

**** Tex
Code related to the TeX formatter.

**** Table
Text based table manipulation utilities.

**** Picture
Editing text-based pictures ("ASCII art").

**** View
Peruse file or buffer without editing.

*** Files
**** Save place
Automatically save place in files.

**** Auto revert
Revert individual buffers when files on disk change.

#+begin_src emacs-lisp

  ;; Revert other buffers like Dired, buffer-menu... (IDK)
  (setq global-auto-revert-non-file-buffers t)

#+end_src

**** Dired
Directory editing.

#+begin_src emacs-lisp

  ;; Dired commands operate only on files in the active region, if any:
  (setq dired-mark-region t)

#+end_src

**** Recentf
Maintain a menu of recently opened files.

**** Persistent scratch
Preserve the state of scratch buffers across Emacs sessions

**** Auto Save
Preventing accidental loss of data.

**** Backup
Backups of edited data files.

#+begin_src emacs-lisp

  ;; Placing all files in one directory (EmacsWiki):
  (setq backup-directory-alist
        `(("." . ,(concat user-emacs-directory "backups"))))

#+end_src

**** Treemacs
Shows the file system outlines of your projects in a simple tree layout allowing quick navigation and exploration.

#+begin_src emacs-lisp

  ;; Provides a theme using all-the-icons.
  (use-package treemacs-all-the-icons
    :after treemacs)

#+end_src

**** Find file
Finding files.

*** Help
**** Helpful
A rich help system with contextual information.

#+begin_src emacs-lisp

  ;; Use helpful with counsel.
  (use-package helpful
    :bind
    ;; Replace the default Emacs help keybindings:
    (([remap describe-key] . helpful-key)
     ([remap describe-command] . helpful-command)
     ([remap describe-variable] . counsel-describe-variable)
     ([remap describe-function] . counsel-describe-function))
    :custom
    ;; Use Helpful with counsel commands:
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable))

#+end_src

**** Which key
Customization options for which-key-mode.

**** Help features
Features for displaying local help.

**** Info
Info subsystem.

*** Communication
**** Simple httpd
A simple web server.

**** Impatient
Serve buffers live over HTTP.

**** Skewer
Live browser JavaScript interaction.

**** Browse url
Use a web browser to look at a URL.

**** Tramp
Edit remote files with a combination of ssh, scp, etc.

**** Server
Emacs running as a server process.

*** Programming
**** Prog mode
Generic programming mode, from which others derive.

#+begin_src emacs-lisp

  ;; To show paren mode only in programming modes
  (add-hook 'prog-mode-hook #'show-paren-local-mode)


  ;; Automatically turn on some tree-sitter based modes for the same
  ;; files for which a "built-in" mode would be turned on:
  (add-to-list 'major-mode-remap-alist '(ruby-mode . ruby-ts-mode))
  ;; or:
  (setq major-mode-remap-alist
        '((yaml-mode . yaml-ts-mode)
          (js2-mode . js-ts-mode)
          (typescript-mode . typescript-ts-mode)
          (json-mode . json-ts-mode)
          (css-mode . css-ts-mode)
          (python-mode . python-ts-mode)))


  ;; Tell Emacs where to find the language grammars. Then call the command
  ;; M-x treesit-install-language-grammar for each language.
  (setq treesit-language-source-alist
        '((css "https://github.com/tree-sitter/tree-sitter-css")
          (html "https://github.com/tree-sitter/tree-sitter-html")
          (javascript "https://github.com/tree-sitter/tree-sitter-javascript"
                      "master" "src")
          (json "https://github.com/tree-sitter/tree-sitter-json")
          (tsx "https://github.com/tree-sitter/tree-sitter-typescript"
               "master" "tsx/src")
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript"
                      "master" "typescript/src")))


  ;; Example of hook to set local variables:
  (add-hook 'prog-mode-hook
            (lambda ()
              (setq-local imenu-auto-rescan t)
              (setq-local imenu-sort-function #'imenu--sort-by-name)))

#+end_src

**** Tools
***** Combobulate
Combobulate group: Structured Editing and Movement with Combobulate.

#+begin_src emacs-lisp

  ;; Complete installation with tree-sitter grammar installation.
  (use-package treesit
    :mode (("\\.tsx\\'" . tsx-ts-mode))
    :preface
    (defun mp-setup-install-grammars ()
      "Install Tree-sitter grammars if they are absent."
      (interactive)

    ;; Optional. Combobulate works in both xxxx-ts-modes and
    ;; non-ts-modes.

    ;; You can remap major modes with `major-mode-remap-alist'. Note
    ;; that this does *not* extend to hooks! Make sure you migrate them
    ;; also
    (dolist (mapping
             '((python-mode . python-ts-mode)
               (css-mode . css-ts-mode)
               (typescript-mode . typescript-ts-mode)
               (js2-mode . js-ts-mode)
               (bash-mode . bash-ts-mode)
               (conf-toml-mode . toml-ts-mode)
               (go-mode . go-ts-mode)
               (css-mode . css-ts-mode)
               (json-mode . json-ts-mode)
               (js-json-mode . json-ts-mode)))
      (add-to-list 'major-mode-remap-alist mapping))
    :config
    (mp-setup-install-grammars)
    ;; Do not forget to customize Combobulate to your liking:
    ;;
    ;;  M-x customize-group RET combobulate RET
    ;;
    (use-package combobulate
      :custom
      ;; You can customize Combobulate's key prefix here.
      ;; Note that you may have to restart Emacs for this to take effect!
      (combobulate-key-prefix "C-c o")
      :hook ((prog-mode . combobulate-mode))
      ;; Amend this to the directory where you keep Combobulate's source
      ;; code.
      :load-path ("path-to-git-checkout-of-combobulate")))

  ;; Don't display s tree outline of nodes.
  (setq combobulate-flash-node nil)))

  ;; Remove highlighting in js console functions.
  :custom
  (combobulate-query-highlight-serene-shade-face ((t nil)))


  ;; Adds structured editing and movement to a range of programming languages.
  (use-package combobulate
    :vc (combobulate :url "https://github.com/mickeynp/combobulate"
                     :lisp-dir "extensions/"))

#+end_src

***** Eglot
Provides infrastructure and a set of commands for enriching the source code editing capabilities of Emacs via LSP.

#+begin_src emacs-lisp

  ;; Start an Eglot session for each buffer in which foo-mode is turned on
  (add-hook 'foo-mode-hook 'eglot-ensure)


  ;; Feature that Eglot shouldn’t automatically try to manage on
  ;; the user’s behalf. Eglot stay away from flymake Emacs feature.
  (add-to-list 'eglot-stay-out-of 'flymake)


  ;; Eglot hooks onto existing Emacs packages and features by setting
  ;; special variables in its special minor mode. To gain finer control of
  ;; Eglot’s operation, the `eglot-managed-mode-hook should' be used to
  ;; tweak, subdue or completely override Eglot’s setting of these
  ;; variables.
  ;; To turn off inlay hints and semantic tokens by default
  (add-hook 'eglot-managed-mode-hook
            (lambda ()
              (eglot-inlay-hints-mode -1)
              (eglot-semantic-tokens-mode -1)))


  ;; Eglot hooks onto Flymake’s flymake-diagnostic-functions variable,
  ;; completely replacing its value with Eglot’s own eglot-flymake-backend
  ;; function. Additional backends may be added to work alongside Eglot’s.
  (add-hook 'foo-mode-hook
            (lambda ()
              (add-hook 'eglot-managed-mode-hook
                        (lambda ()
                          (add-hook 'flymake-diagnostic-functions
                                    #'my/special-foo-mode-backend
                                    nil t))
                        nil t)))


  ;; Add server associations to the default list:
  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 '(foo-mode . ("fools" "--stdio"))))
  ;; Multiple servers are acceptable alternatives:
  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 `(foo-mode . ,(eglot-alternatives
                                '(("fools" "--stdio")
                                  ("phewls" "--fast"))))))


  ;; If you find Eglot is operating correctly but slowly, try to
  ;; customize the variable. This will disable recording any
  ;; events and may speed things up
  (setq eglot-events-buffer-config '(:size 0 :format full))


  ;; Requesting more completions from your LSP server:
  ;; If you use the Orderless completion style and your LSP server
  ;; doesn’t give all completions from Data.Vector. or
  ;; java.util.list. that exist, you may wish to request more completions
  ;; from the server to filter them with Orderless. WARNING: Your LSP
  ;; server likely limits completions due to performance concerns and
  ;; raising the limit could cause performance issues.
  (setq-default eglot-workspace-configuration
                '((haskell (maxCompletions . 200))))


  ;; Example of eglot configuration (Mickey Petersen):
  (use-package eglot
    :preface
    (defun mp-eglot-eldoc ()
      (setq eldoc-documentation-strategy
            'eldoc-documentation-compose-eagerly))
    :hook ((eglot-managed-mode . mp-eglot-eldoc)))


  ;; Example of eglot configuration:
  (use-package eglot
    :defer t
    ;; :pin gnu
    ;; :hook (js-mode . eglot-ensure)
    :hook ((js-ts-mode css-ts-mode mhtl-mode) . eglot-ensure))


  ;; Example of eglot configuration (Andrey Listopadov):
  (use-package eglot
    :hook ((( clojure-mode clojurec-mode clojurescript-mode
              java-mode scala-mode)
            . eglot-ensure)
           ((cider-mode eglot-managed-mode) . eglot-disable-in-cider))
    :preface
    (defun eglot-disable-in-cider ()
      (when (eglot-managed-p)
        (if (bound-and-true-p cider-mode)
            (progn
              (remove-hook
               'completion-at-point-functions 'eglot-completion-at-point t)
              ;; remove annoying code action suggestions
              (remove-hook
               'eldoc-documentation-functions 'eglot-code-action-suggestion t)
              (remove-hook
               'xref-backend-functions 'eglot-xref-backend t))
          (add-hook
           'completion-at-point-functions 'eglot-completion-at-point nil t)
          (add-hook
           'xref-backend-functions 'eglot-xref-backend nil t))))
    :custom
    (eglot-autoshutdown t)
    (eglot-events-buffer-size 0)
    (eglot-extend-to-xref nil)
    (eglot-ignored-server-capabilities
     '(:hoverProvider              ; disable hovering
       :documentHighlightProvider  ; disable syntax highlighting
       :documentFormattingProvider ; disable formatting
       ;; disable annoying code action suggestions
       :codeActionProvider
       :documentRangeFormattingProvider
       :documentOnTypeFormattingProvider
       :colorProvider
       :foldingRangeProvider))     ; disable folding
    (eglot-stay-out-of '(yasnippet)))


  (defun rf-flycheck-on-off ()
    "Turn on `flycheck-mode' if it is off, and turn it off if it is on.

  Useful when enabling or disabling `eglot'."
    (interactive)
    (if (and (featurep 'flycheck) flycheck-mode)
        (flycheck-mode -1)
      (flycheck-mode 1)))

#+end_src

***** Xref
Cross-referencing commands.

#+begin_src emacs-lisp

  ;; Adding a consult function for visualizing xref. (INS)
  (defvar consult--xref-history nil
    "History for the `jf/consult-recent-xref' results.")

  (defun jf/consult-recent-xref (&optional markers)
    "Jump to a marker in MARKERS list (defaults to `xref--history'.

  The command supports preview of the currently selected marker position.
  The symbol at point is added to the future history."
    (interactive)
    (consult--read
     (consult--global-mark-candidates
      (or markers (flatten-list xref--history)))
     :prompt "Go to Xref: "
     :annotate (consult--line-prefix)
     :category 'consult-location
     :sort nil
     :require-match t
     :lookup #'consult--lookup-location
     :history '(:input consult--xref-history)
     :add-history (thing-at-point 'symbol)
     :state (consult--jump-state)))

#+end_src

***** Flycheck
Modern on-the-fly syntax checking for GNU Emacs.

#+begin_src emacs-lisp

  ;; Variable to set for use local eslint from node_modules
  (setq-local flycheck-javascript-eslint-executable
              "/home/rich/trials/trial-test/project-name
                /node_modules/eslint/bin/eslint.js")


  ;; Merge flycheck and eldoc messages (Mickey Petersen):
  (use-package flycheck
    :preface
    (defun mp-flycheck-eldoc (callback &rest _ignored)
      "Print flycheck messages at point by calling CALLBACK."
      (when-let ((flycheck-errors (and flycheck-mode
                                       (flycheck-overlay-errors-at (point)))))
        (mapc
         (lambda (err)
           (funcall callback
                    (format "%s: %s"
                            (let ((level (flycheck-error-level err)))
                              (pcase level
                                ('info
                                 (propertize
                                  "I" 'face 'flycheck-error-list-info))
                                ('error
                                 (propertize
                                  "E" 'face 'flycheck-error-list-error))
                                ('warning
                                 (propertize
                                  "W" 'face 'flycheck-error-list-warning))
                                (_ level)))
                            (flycheck-error-message err))
                    :thing (or (flycheck-error-id err)
                               (flycheck-error-group err))
                    :face 'font-lock-doc-face))
         flycheck-errors)))

    (defun mp-flycheck-prefer-eldoc ()
      (add-hook 'eldoc-documentation-functions #'mp-flycheck-eldoc nil t)
      (setq eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
      ;; (setq eldoc-documentation-strategy 'eldoc-documentation-compose)
      (setq flycheck-display-errors-function nil)
      (setq flycheck-help-echo-function nil))
    :hook ((flycheck-mode . mp-flycheck-prefer-eldoc)))


  ;; Permanently disable c/c++-clang syntax checkers in all buffers.
  (setq-default flycheck-disabled-checkers '(c/c++-clang))
  ;; You can also disable syntax checkers per project with directory local
  ;; variables. For instance type M-x add-dir-local-variable RET
  ;; emacs-lisp-mode RET flycheck-disabled-checkers RET
  ;; (emacs-lisp-checkdoc) in your user emacs directory to disable
  ;; emacs-lisp-checkdoc for all Emacs Lisp files in your personal
  ;; configuration.


  ;; Enable Flycheck-Eglot mode only for certain major modes
  (use-package python-mode
    :hook (python-mode . (lambda ()
                           (eglot-ensure)
                           (flycheck-eglot-mode 1))))


  ;; Show flycheck errors with sideline.
  (use-package sideline-flycheck
    :defer t
    :init
    ;; 'point to show errors only on point - 'line to show errors on line
    (setq sideline-flycheck-display-mode 'line)
    (setq sideline-backends-right '(sideline-flycheck)))


  ;; This Flycheck extension shows errors under point in pos-tip popups.
  (use-package flycheck-pos-tip-mode
    :after flycheck
    :config
    (flycheck-pos-tip-mode))


  ;; Example of eglot configuration (Jeff Barczewski):
  ;; https://codewinds.com/blog/2015-04-02-emacs-flycheck-eslint-jsx.html
  ;; disable jshint since we prefer eslint checking
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint)))
  ;; use eslint with web-mode for jsx files
  (flycheck-add-mode 'javascript-eslint 'web-mode)
  ;; customize flycheck temp file prefix
  (setq-default flycheck-temp-prefix ".flycheck")
  ;; use local eslint from node_modules before global
  ;; http://emacs.stackexchange.com/questions
  ;; /21205/flycheck-with-file-relative-eslint-executable
  (defun my/use-eslint-from-node-modules ()
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "node_modules"))
           (eslint (and root
                        (expand-file-name "node_modules/eslint/bin/eslint.js"
                                          root))))
      (when (and eslint (file-executable-p eslint))
        (setq-local flycheck-javascript-eslint-executable eslint))))
  (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)


  ;; Always display the error list at the bottom side of the frame,
  ;; occupying a third of the entire height of the frame.
  (add-to-list 'display-buffer-alist
               `(,(rx bos "*Flycheck errors*" eos)
                 (display-buffer-reuse-window
                  display-buffer-in-side-window)
                 (side            . bottom)
                 (reusable-frames . visible)
                 (window-height   . 0.33)))

#+end_src

***** Formatting

#+begin_src emacs-lisp

  (use-package apheleia
    :hook (prog-mode . apheleia-mode)
    :config
    (self (alist-get 'prettier apheleia-formatters)
          ("prettier" "--stdin-filepath)))

#+end_src

***** Flymake
Universal on-the-fly syntax checker.

#+begin_src emacs-lisp

  ;; Variable to set for use local eslint from node_modules
  (setq-local flymake-eslint-executable-name
              "/home/rich/trials/trial-test/project-name
       /node_modules/eslint/bin/eslint.js")

  ;; Variable to set for use local stylelint from node_modules
  (setq-local flymake-stylelint-executable-name
              "/home/rich/trials/trial-test/project-name
  /node_modules/stylelint/bin/stylelint.mjs")


  ;; flymake-jsts: A Flymake backend for Javascript/Typescript:
  ;; eglot is pretty aggressive in taking over your Flymake configuration;
  ;; it assumes that your language server is the only source of diagnostic
  ;; messages, and completely overwrites the value of
  ;; flymake-diagnostic-functions to suit its own needs. One workaround you
  ;; can try is to add a flymake-jsts backend function after eglot has been
  ;; enabled:
  (add-hook 'eglot-managed-mode-hook
            (lambda ()
              (flymake-jsts-eslint-enable))
            nil t)
  ;; Alternately, you can tell eglot to stay out of your Flymake
  ;; configuration and then add eglot's backend yourself:
  (add-to-list 'eglot-stay-out-of 'flymake)
  (add-hook 'flymake-mode-hook
            (lambda ()
              (add-hook 'flymake-diagnostic-functions
                      #'eglot-flymake-backend
                      nil
                      t)))


  ;; Enable eslint in web-mode:
  (add-hook 'web-mode-hook
            (lambda ()
              (flymake-eslint-enable)))


  ;; This Flycheck extension shows errors under point in pos-tip popups.
  (use-package flycheck-pos-tip
    :defer t)
  ;; Enable with `flycheck-pos-tip-mode'


  ;; Show flymake errors with sideline.
  ;; (it doesn't work, but sideline-flycheck does)
  (use-package sideline-flymake
    :defer t
    :init
    ;; 'point to show errors only on point - 'line to show errors on line
    (setq sideline-flymake-display-mode 'line)
    (setq sideline-backends-right '(sideline-flymake)))


  ;; Flymake backend for Javascript using eslint. (legacy)
  ;; Enable it with M-x flymake-eslint-enable RET
  (use-package flymake-eslint
    :defer t
    :init
    ;; Use local eslint from node_modules before global (Jeff Barczewski).
    (defun jb-use-eslint-from-node-modules ()
      "Use local eslint from node_modules before global.

      This code looks for a node_modules directory in any parent of
      the buffer's directory and configures flymake-eslint to use an
      eslint executable from that directory if any exists."
      (interactive)
      (let* ((root (locate-dominating-file
                    (or (buffer-file-name) default-directory)
                    "node_modules"))
             (eslint (and root
                          (expand-file-name
                           "node_modules/eslint/bin/eslint.js" root))))
        (when (and eslint (file-executable-p eslint))
          (setq-local flymake-eslint-executable-name eslint)))))
  ;; Make sure eslint is installed and present on your emacs exec-path.
  ;; npm install -g eslint

#+end_src

***** ESlint
Linting for JavaScript.

#+begin_src emacs-lisp

  ;; Use local eslint from node_modules before global (Jeff Barczewski).
  (defun jb/use-eslint-from-node-modules ()
    "Use local eslint from node_modules before global.

  This code looks for a node_modules directory in any parent of
  the buffer's directory and configures Flycheck to use an eslint
  executable from that directory if any exists."
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "node_modules"))
           (eslint (and root
                        (expand-file-name "node_modules/eslint/bin/eslint.js"
                                          root))))
      (when (and eslint (file-executable-p eslint))
        (setq-local flycheck-javascript-eslint-executable eslint))))
  (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)
  ;; or
  ;; Grab eslint executable from node_modules instead of global (zdx.cat).
  (defun lunaryorn-use-js-executables-from-node-modules ()
    "Set executables of JS and TS checkers from local node modules."
    (-when-let* ((file-name (buffer-file-name))
                 (root (locate-dominating-file file-name "node_modules"))
                 (module-directory (expand-file-name "node_modules" root)))
      (pcase-dolist (`(,checker . ,module) '((javascript-jshint . "jshint")
                                             (javascript-eslint . "eslint")
                                             (typescript-tslint . "tslint")
                                             (javascript-jscs   . "jscs")))
        (let ((package-directory (expand-file-name module module-directory))
              (executable-var (flycheck-checker-executable-variable checker)))
          (when (file-directory-p package-directory)
            (set (make-local-variable executable-var)
                 (expand-file-name (if (string= module "tslint")
                                       (concat "bin/" module)
                                     (concat "bin/" module ".js"))
                                   package-directory)))))))

#+end_src

***** Eldoc
Show function arglist or variable docstring in echo area.

#+begin_src emacs-lisp

  ;; Truncate if the doc is longer than a single screen line.
  (setq eldoc-echo-area-use-multiline-p 1)


  ;; Displays ElDoc documentations in a childframe.
  (use-package eldoc-box
    :bind ( "C-h ," . eldoc-box-help-at-point))


  ;; Start with M-x eldoc-doc-buffer. It opens a dedicated Eldoc buffer
  ;; for your documentation. The only annoying thing about it is that it
  ;; prefers to pop open in an existing window. The rule forces the
  ;; buffer to appear at the bottom of the frame instead with a fixed
  ;; window height of about 4 lines.
  (add-to-list 'display-buffer-alist
               '("^\\*eldoc for" display-buffer-at-bottom
                 (window-height . 4)))

  (use-package eldoc
    :preface
    (add-to-list 'display-buffer-alist
                 '("^\\*eldoc for" display-buffer-at-bottom
                   (window-height . 4)))
    (setq eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
    :config
    ;; Adding More Trigger Commands
    (eldoc-add-command-completions "paredit-")
    (eldoc-add-command-completions "combobulate-"))

#+end_src

***** Debug
Bringing rich debugging capabilities to Emacs via the Debug Adapter Protocol.

#+begin_src emacs-lisp

  ;; Debug adapter client for Emacs that has no dependencies outside Emacs.
  (use-package dape
    :hook
    ;; Save breakpoints on quit
    ((kill-emacs . dape-breakpoint-save)
     ;; Load breakpoints on startup
     (after-init . dape-breakpoint-load))
    :config
    ;; Save buffers on startup, useful for interpreted languages
    (add-hook 'dape-start-hook (lambda () (save-some-buffers t t)))
    ;; Kill compile buffer on build success
    (add-hook 'dape-compile-hook #'kill-buffer)
    ;; Turn on global bindings for setting breakpoints with mouse
    (dape-breakpoint-global-mode)
    ;; Info buffers like gud (gdb-mi)
    (setq dape-buffer-window-arrangement 'gud)
    (setq dape-info-hide-mode-line nil)
    ;; Showing inlay hints
    (setq dape-inlay-hints t)
    ;; Pulse source line (performance hit)
    (add-hook 'dape-display-source-hook
              'pulse-momentary-highlight-one-line))
  ;; Left and right side windows occupy full frame height
  (use-package emacs
    :custom
    (window-sides-vertical t))


  ;; DAP mode configuration:
  ;; Debug Adapter Protocol client for Emacs focused on VScode.
  (use-package dap-mode
    ;; Usage: dap-debug/dap-debug-edit-template and select the node template.
    :commands dap-debug-edit-template
    :custom
    (lsp-enable-dap-auto-configure nil)
    :config
    (require 'dap-node) ; (require 'dap-chrome) ; (require 'dap-firefox)
    ;; You need call dap-node-setup after requiring dap-node.
    (dap-ui-mode 1)
    (use-package dap-ui-mode
      :ensure nil
      :bind (:map dap-ui-mode-map
                  ("C-c d" . dap-hydra))))
  ;; Make sure that dap-node-debug-program is pointing to the proper file.

  ;; Enabling only some features
  (setq dap-auto-configure-features '(sessions locals controls tooltip))

  ;; Enable only specific modes:
  (dap-ui-mode 1)
  ;; enables mouse hover support
  (dap-tooltip-mode 1)
  ;; use tooltips for mouse hover
  ;; if it is not enabled `dap-mode' will use the minibuffer.
  (tooltip-mode 1)
  ;; displays floating panel with debug buttons
  (dap-ui-controls-mode 1)

  ;; Automatically trigger the hydra when the program hits a breakpoint.
  (add-hook 'dap-stopped-hook
            (lambda (arg) (call-interactively #'dap-hydra)))

#+end_src

***** Magit
Controlling Git from Emacs.

***** Projectile
Manage and navigate projects easily.

***** Language server
Language Server Protocol client.

#+begin_src emacs-lisp

  ;; If you seeing significant problems in responsiveness. Set
  ;; `gc-cons-threshold' to big number like most of the popular starter
  ;; kits (Spacemacs/Doom/Prelude,...).  This is due to the fact that
  ;; client/server communication generates a lot of memory/garbage.
  (setq gc-cons-threshold (* 2 50 1000 1000))

  ;; Lock files will kill `npm start'
  (setq create-lockfiles nil)


  ;; Emacs client/library for the Language Server Protocol.
  (use-package lsp-mode
    :hook((prog-mode . lsp-deferred)
          (lsp-mode . lsp-enable-which-key-integration))
    :config
    ;; Turn off automatically detect and config lsp-ui and company-mode.
    (setq lsp-auto-configure nil))
  ;; This way lsp-mode won't autoload the client packages, and
  ;; other features, so you need either to set it to '(lsp-LANG)
  ;; or to require lsp-LANG manually, and other features manually.


  ;; Defer LSP server startup (and DidOpen notification) until buffer visible.
  (add-hook 'XXX-mode-hook #'lsp-deferred)


  ;; Remap xref-find-{definitions,references}:
  (define-key lsp-ui-mode-map [remap xref-find-definitions]
              #'lsp-ui-peek-find-definitions)
  (define-key lsp-ui-mode-map [remap xref-find-references]
              #'lsp-ui-peek-find-references)


  ;; Project errors on modeline.
  (with-eval-after-load 'lsp-mode
    ;; :global/:workspace/:file
    (setq lsp-modeline-diagnostics-scope :workspace))

#+end_src

**** Languages
***** Html
Hypertext Markup Language editing mode.

#+begin_src emacs-lisp

  ;; Remap one of the keymaps used by default in html and derived
  ;; modes, so it doesn't interfere with the global keymap.
  (add-hook 'html-mode-hook
            (lambda ()
              (keymap-set html-mode-map "M-o" nil)
              (keymap-set html-mode-map "M-i"
                          'facemenu-keymap)))


  ;; Defines the key binding in mhtl-mode and its derivatives. (INS)
  (with-eval-after-load 'mhtml-mode
    (define-key mhtml-mode-map (kbd "C-c d") 'html-div))


  ;; A simple tree-sitter major mode for HTML and Emacs 29.
  (use-package html-ts-mode
    :vc
    (html-ts-mode :url "https://github.com/mickeynp/html-ts-mode"))


  ;; Enable display of line numbers
  (add-hook 'html-ts-mode-hook
            (lambda () (display-line-numbers-mode 1)))

#+end_src

***** JavaScript
Customization variables for JavaScript mode.

#+begin_src emacs-lisp

  ;; Customizations for js-mode.
  (use-package js
    ;; Use 'eslint' from local modules along with 'eglot' in 'flymake'
    :hook ((js-ts-mode js-mode) .
           (lambda ()
             (add-hook 'eglot-managed-mode-hook
                       (lambda ()
                         ;; It must go in this order
                         (jb-use-eslint-from-node-modules-flymake)
                         (flymake-jsts-eslint-enable)
                         (flymake-mode -1)
                         (flymake-mode 1))
                       nil t))))


  ;; Use M-. xref-find-definition in js buffers (disable js-find-symbol).
  (with-eval-after-load 'js
    (define-key js-mode-map (kbd "M-.") nil))


  ;; Indent js-mode at level 2.
  (use-package js
    :config
    (setq js-indent-level 2))


  ;; Searches the current files parent directories for the
  ;; node_modules/.bin/ dir and adds it to the buffer local exec-path.
  ;; This allows Emacs to find project based installs of e.g. eslint.
  (use-package add-node-modules-path
    :defer t)
  ;; In a monorepo scenario it might make sense to add multiple directories.
  ;; :custom
  ;; (add-node-modules-path-command '("pnpm bin" "pnpm bin -w"))
  ;; To automatically run it when opening a new buffer:
  (eval-after-load 'js-mode
    '(add-hook 'js-mode-hook #'add-node-modules-path))

#+end_src

***** Css
Cascading Style Sheets (CSS) editing mode.

#+begin_src emacs-lisp

  (use-package css-mode
    ;; Use 'stylelint' from local modules along with 'eglot' in 'flymake'
    ;; It doesn't work. The `flymake-stylelint-enable' doesn't work.
    :hook (css-ts-mode .
                       (lambda ()
                         (add-hook
                          'eglot-managed-mode-hook
                          (lambda ()
                            ;; It must go in this order
                            (setq-local flymake-stylelint-use-global nil)
                            (jb-use-stylelint-from-node-modules-flymake)
                            (flymake-stylelint-enable)
                            (flymake-mode -1)
                            (flymake-mode 1))
                          nil t)))
    :custom
    (css-indent-offset 2))

#+end_src

***** Web-mode
Major mode for editing web templates.

#+begin_src emacs-lisp

  ;; adjust indents for web-mode to 2 spaces
  (defun my-web-mode-hook ()
    "Hooks for Web mode. Adjust indents"
      ;;; http://web-mode.org/
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2))
  (add-hook 'web-mode-hook  'my-web-mode-hook)


  ;; for better jsx syntax-highlighting in web-mode
  ;; - courtesy of Patrick @halbtuerke
  (defadvice web-mode-highlight-part (around tweak-jsx activate)
    (if (equal web-mode-content-type "jsx")
        (let ((web-mode-enable-part-face nil))
          ad-do-it)
      ad-do-it))

#+end_src

***** TypeScript
Customization variables for TypeScript mode.

***** Lisp
Lisp support, including Emacs Lisp.

*** Applications
**** Eshell
Command shell implemented entirely in Emacs Lisp.

#+begin_src emacs-lisp

  (setq eshell-history-size 1000)
  (setq eshell-buffer-maximum-lines 10000)

  ;; It's an error for a glob pattern not to match.
  ;; Note: when used, aliases do not work perfectly.
  (setq eshell-error-if-no-glob t)


  ;; Set here because eshell-mode-map is loaded after esh-mode feature.
  (with-eval-after-load 'esh-mode
    (keymap-set eshell-mode-map "C-d" 'consult-history))

  ;; Disables the C-c prefix in eshell mode
  (keymap-set eshell-pred-mode-map "C-c" nil)

#+end_src

**** Calc
Advanced desk calculator and mathematical tool.

**** Mail
Modes for electronic-mail handling.

**** Gnus
The coffee-brewing, all singing, all dancing, kitchen sink newsreader.

**** Calendar
Calendar and time management support.

*** External
**** Vterm
Emacs-libvterm (vterm) is fully-fledged terminal emulator inside GNU Emacs based on libvterm, a C library.
**** Google translate
Emacs core UI script for the Google Translate package.
**** Proced
Proced mode.

**** Term
General command interpreter in a window.

**** Shell
Running shell from within Emacs buffers.

**** EasyPG
Interface to the GNU Privacy Guard (GnuPG).

**** Sql
Running a SQL interpreter from within Emacs buffers.

**** Executable
Base functionality for executable interpreter scripts.

**** FlySpell
Spell checking on the fly.

*** Multimedia
**** Image
Image support.

**** Doc view
In-buffer viewer for PDF, PostScript, DVI, and DJVU files.

*** Local
Code local to your site.

#+begin_src emacs-lisp

  ;; You can use this command to show minor mode key priority.
  (defun xah-display-minor-mode-key-priority  ()
    "Print out minor mode's key priority.
  URL `http://xahlee.info/emacs/emacs/minor_mode_key_priority.html'
  Version 2017-01-27"
    (interactive)
    (mapc
     (lambda (x) (prin1 (car x)) (terpri))
     minor-mode-map-alist))

#+end_src

*** Test configuration
Start a bare bone Emacs instance with ~emacs -Q~ on the command line. Execute the following minimal code snippets in the scratch buffer. This way we can exclude side effects due to configuration settings. If other packages are relevant to reproduce the issue, include them in the minimal configuration snippet.

You can also put some configurations  in a file called ~init-test.el~ and then run ~emacs -Q -l init-test.el~.

#+begin_src emacs-lisp

  ;; Minimal setup with Vertico and the default completion system (emacs -Q):
  (package-initialize)
  (require 'consult)
  (require 'vertico)
  (vertico-mode)
  (setq completion-styles '(substring basic))

  ;; Minimal setup for general testing (emacs -Q):
  (package-initialize)
  (vertico-mode)
  (marginalia-mode)
  (setq completion-styles '(orderless basic))
  (keymap-global-set "C-." 'embark-act)
  (keymap-global-set "M-o" 'other-window)
  (repeat-mode)
  ;; (find-file "" t)

#+end_src

** Keyboard macro
*** Define keyboard macros
*To save a macro (Xah)*
1. ~M-x name-last-kbd-macro~ and give it a name.
2. ~M-x insert-kbd-macro~ this will insert the lisp code for a named kmacro at the cursor position.
3. Copy & Paste the code into your emacs init file.
4. In any future emacs session, you can call your kmacro by name just like any emacs command.

Once you've saved your macro with a name, you can also give it a keyboard shortcut, such as ~F8~.

#+begin_src emacs-lisp

  ;; macro for bold region, add two *
  (fset 'bold
        (kmacro-lambda-form [?\C-c ?\C-x ?\C-f kp-multiply] 0 "%d"))
  (global-set-key (kbd "<f7>") 'bold)

  ;; macro for code region, add tow =
  (fset 'code
        (kmacro-lambda-form [?\C-c ?\C-x ?\C-f ?=] 0 "%d"))
  (global-set-key (kbd "<f8>") 'code)

#+end_src

*** Interactive keyboard macros
One neat, little feature is the ability to insert a /macro query/ flag when you are recording a macro. A macro query is only triggered when you play it back. Emacs detects the query and pauses execution and cedes control back to you. To use it, type ~C-x q~ when you’re recording. There is no visual indicator when you type it, though.

| /Opts/ | /Specify how to proceed with keyboardmacro execution/ |
|------+-----------------------------------------------------|
| /Y/    | Finish this iteration and continue with the next    |
| /N/    | Skip the rest of this iteration, and start the next |
| /RET/  | Stop the macro entirely right now                   |
| /C-l/  | Redisplay the screen, then ask again                |
| /C-r/  | Enter recursive edit; (press /SCP/) to ask again      |
|      | when you exit from that                             |

That makes it excellent for what I call *interactive* macros that require user input. You can place the /macro query/ anywhere you like — even in a prompt, like query replace regexp with ~C-M-%~. You can even prefill the prompt; Emacs will remember that also.

*** Repeat keyboard macros
You can optionally give a prefix argument to ~C-x e~ or ~F4~ to make it repeat the macro that many times. Use ~0~ to tell Emacs to *run the macro until it gets an error signal*. A macro plays back until it encounters an error (end of buffer, end of matches in ~*Grep*~ if you advance with ~M-g M-n~, and so on.) Watch out if you’re waving ~C-g~ around in a macro — it terminates the recording!

*** Insert counter in keyboard macros
If you call ~F3~ when you’re recording, it’ll insert a number from a counter and increment it. Use a universal arg ~C-u~ and it’ll repeat the last number without incrementing it. You can pass a numeric arg to ~F3~ to start the recording with a different number. This feature’s obviously great for numerating lists.

*** Notes
*Mickey Petersen*
- To modifying window layout, just make sure you start with a call to ~C-x 1~ to reset the windows back to one when you start the recording.
- To call up a Shell, make it run ~C-u M-x shell~ (or Eshell, or Vterm, or…) and run some commands that you frequently need to do.

*Xah*
- To move to the next logical line (line with a line return at the end), move to end of line first, then right cursor moves it to beginning of next line. Because if you have Emacs: Visual Line Mode on, down arrow may move to the next visual line.

*Emacswiki*
- You want to add the text “– foobar was here” at the end of each of the lines in a file. What’s important here is to stop defining the macro at a *similar position to where you started it* – so that you are in a position to execute it again, after it executes. This is a general rule that you will often follow when defining keyboard macros: try to make them executable N times in a row.

** YASnippet template
Special Characters

1. ~$0~ → the position the cursor (after the snippte is inserted). You don't need to put a ~$0~ if you don't need to.
2. ~$‹n›~ → a field, where the ~‹n›~ is a integer starting with 1. (Example: ~$1~, ~$2~, …). Pressing tab will move cursor to these stops for user to fill in. Multiple occurrence of the same ~$‹n›~ means typing in one field will automatically fill the other.
3. ~${‹n›:‹default text›}~ → same as ~$‹n›~, but provides a default text.
4. ~$&~ → means indent the line according to the mode's indentation rule.
5. ~`…`~ → (backtick) is used to enclose elisp code. The lisp code will be evaluated in the same buffer the snippet is being expanded.

Once you create a template file, you have to load it. Call ~yas-reload-all~.

#+begin_example

Examples of defining HTML tags with field stop points:

<h1>$1</h1>

<img src="$1" class="$2" alt="$3">

You can also include lisp code in your template. For example,
you might want to have a date stamp. Here's a example that
insert user's email address and datestamp.

`user-mail-address`

`(current-time-string)`

#+end_example

** Abbrev mode by commands
*** Turn on abbrev mode
~M-x abbrev-mode~ to turn it on. Call again to turn off.

To turn on globally when emacs starts, put this in your Emacs Init File:
~(setq-default abbrev-mode t)~

*** Define abbrev
Suppose you want to define “bg” → “background”.

1.  Type “background”.
2. ~M-x add-global-abbrev~, in the prompt, type “bg”.

Now, when you type “bg” followed by a space or return, it'll expand to “background”.

If you want the abbrev only for the current major mode,

~M-x add-mode-abbrev~

If the expanded text is more than one word, for example, suppose you want to define “faq” → “frequently asked questions”.

1. Type “frequently asked questions”.
2. Select the text.
3. ~C-u 0~
4. ~M-x add-global-abbrev~, in the prompt, type “faq”.

*NOTE*:
I put “z” in the beginning of my abbrevs. This way, i don't have to worry about clash with short words that i don't want to expand.

#+begin_src emacs-lisp

  ;; signature
  "zxl"   →   "Xah Lee"

  ;; url
  "zuxl"   →   "http://xahlee.info/"

  ;; emacs regex
  "zd"   →   "\\([0-9]+?\\)"
  "zstr"   →   "\\([^\"]+?\\)\""

  ;; shell commands
  "zditto"   →   "ditto -ck --sequesterRsrc --keepParent src dest"
  "zim"   →   "convert -quality z5% "

  ;; math/unicode symbols
  "zin"   →   "∈"
  "znin"   →   "∉"
  "zinf"   →   "∞"
  "zluv"   →   "♥"
  "zsmly"   →   "☺"

  ;; email
  "zme"   →   "someone@example.com"

  ;; computing tech
  "zwp"   →   "Wikipedia"
  "zg"   →   "Google"

  ;; normal english words
  "zalt"   →   "alternative"
  "zchar"   →   "character"
  "zdef"   →   "definition"

#+end_src

*** Remove abbrev
To remove a definition, give a negative argument to add-global-abbrev or add-mode-abbrev.

For example, to undefine the abbrev “bg”.

1. ~C-u -1~.
2. ~M-x add-global-abbrev~, in the prompt, type “bg”.

*** Save abbrev
When you quit, emacs will ask you if you want to save.

To auto save, put this in your Emacs Init File:

~(setq save-abbrevs 'silently)~

The abbrevs is saved in a file at a path specified by the variable

~abbrev-file-name~

By default, it's at ~~/.emacs.d/abbrev_defs~

*** List and edit
Display a list of defined abbrevs.
~M-x list-abbrevs~

Edit Abbrevs
~M-x edit-abbrevs~

*** Abbrev file location
The abbrevs is saved in a file at a path specified by the variable ~abbrev-file-name~

By default, it's at  ~(~/.emacs.d/abbrev_defs)~

You can change it, for example, put this in emacs init:

~(setq abbrev-file-name "~/emacs_abbre.el")~

*** Edit abbrevs
Call ~edit-abbrevs~ to edit abbrev.

To remove a abbrev, just delete the line.
To add a abbrev, just add a line.

When done, to load and or save, call any of:

~edit-abbrevs-redefine~  → Redefine abbrevs according to current buffer contents.
~abbrev-edit-save-buffer~  → Redefine and save to abbrev file.
~abbrev-edit-save-to-file~ → Redefine and save to abbrev file, but ask for a location.

*** Reference

[[http://xahlee.info/emacs/emacs/emacs_abbrev_mode_tutorial.html]]

https://wilkesley.org/~ian/xah/emacs/emacs_abbrev_mode.html

*** Abbrev mode by lisp code
Emacs's abbrev feature lets you type a short word and expand into a full word or code template.

[[http://xahlee.info/emacs/emacs/emacs_abbrev_mode.html]]

** Elisp commands
*** Define a command for cursor point
[[http://xahlee.info/emacs/emacs/emacs_mouse_click_command.html][Xah]]

When you bind a mouse button to a command, the command acts on the current cursor position, not clicked point.

#+begin_src emacs-lisp

  ;; make right button show char info (of current cursor position, not clicked point)
  (global-set-key (kbd "<mouse-3>") 'describe-char)

#+end_src

*** Define command for mouse click
[[http://xahlee.info/emacs/emacs/emacs_mouse_click_command.html][Xah]]

To make the command act on mouse clicked point, you need to write a wrapper command that sets the position, then call the command you want.

For example, suppose the command you want is ~describe-char~ on clicked point. You write a wrapper, like this:

#+begin_src emacs-lisp

  (defun xah-click-describe-char (Click)
    "Mouse click to `describe-char' at clicked point.
  URL `http://xahlee.info/emacs/emacs/emacs_mouse_wheel_config.html'
  Version: 2016-07-18"
    (interactive "e")
    (let ((xp (posn-point (event-start Click))))
      (goto-char xp)
      (describe-char xp)))

  ;; make right button show char info on clicked point
  (global-set-key (kbd "<mouse-3>") 'xah-click-describe-char)

#+end_src

*** Mouse click to highlight matching words
[[http://xahlee.info/emacs/emacs/emacs_mouse_click_highlight_word.html][Xah]]

You can set mouse right-click to call ~isearch-forward-symbol-at-point~ (highlight clicked word).

#+begin_src emacs-lisp

  (defun xah-mouse-click-to-search (Click)
    "Mouse click to start `isearch-forward-symbol-at-point' (emacs 24.4) at clicked point.
  URL `http://xahlee.info/emacs/emacs/emacs_mouse_click_highlight_word.html'
  Version 2016-07-18"
    (interactive "e")
    (let ((xp1 (posn-point (event-start Click))))
      (goto-char xp1)
      (isearch-forward-symbol-at-point)))

  (global-set-key (kbd "<mouse-3>") 'xah-mouse-click-to-search)

#+end_src

*** Lisp script to count emacs lisp function frequency
[[http://xahlee.info/emacs/emacs/function-frequency.html][Xah]]

This list is generated by reading all top level lisp files bundled with GNU Emacs 28.1 of 2022-04-04. at ~/bin/emacs-28.1/share/emacs/28.1/lisp/ Total of 302 files. Then count the occurrences of the first word after the left parenthesis.

#+begin_src emacs-lisp

  ;; -*- coding: utf-8; lexical-binding: t; -*-

  ;; file name: elisp_count_func_frequency.el
  ;; run it by
  ;; emacs --script elisp_count_func_frequency.el
  ;;
  ;; created: 2022-05-28
  ;; version: 2023-08-23

  (setq xOutputFileName "xfuncfreq.txt")

  (set-default-coding-systems 'utf-8-unix)

  (defun xah-hash-to-list (HashTable)
    "Return a list that represent the HASHTABLE
  Each element is a list: '(key value).

  URL `http://xahlee.info/emacs/emacs/elisp_hash_table.html'
  Version 2019-06-11 2022-05-28"
    (let ((xresult nil))
      (maphash
       (lambda (k v)
         (push (list k v) xresult))
       HashTable)
      xresult))

  (defun xah-report-func-freq ()
    "go thru emacs lisp source code dir, computer function usage frequency.
  version 2022-05-28"
    (interactive)
    (let ((xDir (expand-file-name (concat invocation-directory "../" "share/emacs/28.1/lisp/")))
          xFuncName
          (xHash (make-hash-table :test 'equal))
          xKeyExistVal xFnSortedList
          )
      ;; walk the directory. for each file, open it. find text like ã€Œ(some-thingã€ put it in a hashtable
      (mapc
       (lambda (fPath)
         (with-temp-buffer
           (insert-file-contents fPath)
           (goto-char (point-min))
           (while (re-search-forward "(+\\([^ )\n]+\\)" nil t)
             (setq xFuncName (match-string 1))
             (setq xKeyExistVal (gethash xFuncName xHash))
             (if xKeyExistVal
                 (puthash xFuncName (1+ xKeyExistVal) xHash)
               (puthash xFuncName 1 xHash)))))
       (directory-files xDir t "\\.el$"))
      (setq xFnSortedList
            (sort (xah-hash-to-list xHash)
                  (lambda (a b)
                    (< (cadr a)
                       (cadr b)))))
      (setq xFnSortedList (nreverse xFnSortedList))

      (with-temp-file xOutputFileName
        (mapc
         (lambda (x)
           (insert
            (format "ã€Œ%sã€ %s\n" (car x) (cadr x))))
         xFnSortedList))))

  (xah-report-func-freq)

#+end_src

*** Call the command that has keyboard shortcut (call-interactively)

#+begin_src emacs-lisp

  (defun ergoemacs-call-keyword-completion ()
  "Call the command that has keyboard shortcut M-TAB."
  (interactive)
  (call-interactively
   (key-binding (kbd "M-TAB"))))


  (defun ergoemacs-move-cursor-previous-pane (&optional number)
    "Move cursor to the previous pane."
    (interactive "p")
    (setq current-prefix-arg (if number (- 0 number) -1))
    (call-interactively 'other-window))

#+end_src

*** Smart command (major-mode dependent key)
[[http://xahlee.info/emacs/emacs/emacs_smart_key.html][Xah]]

You can have a key do different things depending on what's the current ~major-mode~ .

The most simple way, is to write a wrapper command. The wrapper command checks current mode and call different commands. Then, you bind the wrapper command to a key in global map.

Here's a example of a wrapper command.

suppose you want =F9= to call:

- ~x1-cmd~ if current mode is ~x1-mode~
- ~x2-cmd~ if current mode is ~x2-mode~

Then, just bind this command to a key.

#+begin_src emacs-lisp

  (defun my-smart-command ()
    "call different commands depending on what's current major mode."
    (interactive)
    (cond
     ((eq major-mode 'x1-mode) (x1-cmd))
     ((eq major-mode 'x2-mode) (x2-cmd))
     ;; more major-mode checking here

     ;; if nothing match, do nothing
     (t nil)))

#+end_src

** Edit column text, rectangle commands
[[http://xahlee.info/emacs/emacs/emacs_string-rectangle_ascii-art.html][Xah]]

This page shows you how to edit text in a rectangular region.

Example, add a prefix to every line (such as # or //):

  1- Move to the beginning of first line you want.
  2- Press ~C-SPC~ (~set-mark-command~) to mark cursor position.
  3- Move cursor to the beginning of the last line.
  4- Then ~M-x string-rectangle~ ( ~C-x r t~ )
  5- Then type what you want to insert, then Enter.

The command ~string-rectangle~ can be used to insert a vertical column of string across mulitple lines at any column position, not just at the beginning of lines.

- Delete the first few n chars of every line ( ~kill-rectangle~ )
- Delete a column of text ( ~kill-rectangle~ )
- replace-rectangle
- Paste Rectangle ( ~yank-rectangle~ )
- Insert a Column of Numbers ( ~rectangle-number-lines~ )

ExampIe, insert A to Z Vertically:

1- Move cursor to before specific start word.
2- ~set-mark-command~ ( ~C-SPC~ ).
3- Move cursor to before specific end word.
4- ~universal-argument~ ( ~C-u~ ).
5- Now, ~M-x rectangle-number-lines~. It will prompt you to enter arguments.
6- Type ~65~ (Letter ~A~ has Unicode codepoint ~65~. ~a~ is ~97~).
7- Remove the default ~%2d~ , type ~%c~. (the ~%c~ is for character format)

** Writing scripts
1. Create ~some.el~ file
2. Change modes (~chmod a+x some.el~)
3. Write the code with the shebang line

#+begin_src emacs-lisp

  #!emacs --script

  (defun main ()
    (print (version))
    (print (format "I did it. you passed in %s" command-line-args-left)))

  (main)

#+end_src

4. Run with or without arguments (~./some.el arg1 arg2~)
5. Or run with ~-Q~ to disabled initial messages (~./some.el -Q arg1 arg2~)

** Install the package manually
Manual Install

Put the file ~xah-fly-keys.el~ in ~~/.emacs.d/lisp/~

Put the following in your emacs init:

#+begin_src emacs-lisp

  (add-to-list 'load-path "~/.emacs.d/lisp/")

  (require 'xah-fly-keys)

  ;; specify a layout. optional
  (xah-fly-keys-set-layout "qwerty")
  ;; (xah-fly-keys-set-layout "dvorak")

  ;; possible values

  ;; azerty
  ;; colemak-dh
  ;; dvorak
  ;; programer-dvorak
  ;; qwerty
  ;; qwerty-abnt (Brazil)

  (xah-fly-keys 1)

#+end_src

** Org how to
*** Markup for Rich Contents
Org is primarily about organizing and searching through your plain-text notes. However, it also provides a lightweight yet robust markup language for rich text formatting and more. For instance, you may want to center or emphasize text. Or you may need to insert a formula or image in your writing. Org offers syntax for all of this and more. Used in conjunction with the export framework, you can author beautiful documents in Org—like the fine manual you are currently reading.

*Paragraphs*
Paragraphs are separated by at least one empty line. If you need to enforce a line break within a paragraph, use ‘\\’ at the end of a line.

#+BEGIN_VERSE
 Great clouds overhead
 Tiny black birds rise and fall
 Snow covers Emacs

    ---AlexSchroeder
#+END_VERSE

#+BEGIN_QUOTE
Everything should be made as simple as possible,
but not any simpler ---Albert Einstein
#+END_QUOTE

*Literal Examples*
You can include literal examples that should not be subjected to markup. Such examples are typeset in monospace, so this is well suited for source code and similar examples.

#+BEGIN_EXAMPLE
  Some example from a text file.
#+END_EXAMPLE

*** Estructure of Org code blocks
Org offers two ways to structure source code in Org documents: in a 'src' code block, and directly inline. Both specifications are shown below.

A source code block conforms to this structure:

#+NAME: <name>
#+BEGIN_SRC <language> <switches> <header arguments>
  <body>
#+END_SRC

Org also works with other completion systems in Emacs, some of which predate Org and have custom domain-specific languages for defining templates.

An inline code block conforms to this structure:

src_<language>{<body>}

or

src_<language>[<header arguments>]{<body>}

Examples:

src_sh{ echo "hola" }

src_js{ function foo () { return 'exit';} }

*** Define org links

#+begin_src org

  # Syntax: (url can also be a file path, full path or relative path.)
  [[URL][description]]


  # WEB
  [[http://orgmode.org/][Org-mode]]
  # or
  [[http://orgmode.org/]]


  # FILE
  [[file:Emacs-guide.org][Emacs-Guide]]
  # or
  [[file:Emacs-guide.org]]
  # path
  [[file:~/path/Emacs-guide.org::Outline][Outline]]
  # line 255
  [[file:~/code/main.c::255]]
  # <<Mi objetive>>
  [[file:~/xx.org::Mi objective]]
  # my-personal-id
  [[file:~/xx.org::#my-personal-id]]


  # ANCHOR
  [[Heading name][whatever]]
  # or
  [[Heading name]]
  # CUSTOM_ID property (name different from outline)
  # * Source Code
  :PROPERTIES:
  :CUSTOM_ID: source-code-layout-organization
  :END:
  [[#source-code-layout-organization][Source Code Layout & Organization]]

#+end_src

*** Build website on org
**** Creating project folders
Create a folder called ~my-org-site~ with a subfolder called ~content~ which contains a single ~index.org~ file. This will create a file called ~index.html~.

**** Creating the build script
Create a script that will generate the HTML files for the Org documents.

#+begin_src emacs-lisp

  ;; ~/my-org-site/build-site.el

  ;; Load the publishing system
  (require 'ox-publish)

  (message "Build complete!")

#+end_src

We also need a shell script that can run our Emacs Lisp script (no es necesario pero garantiza que el emac se levante desde cero sin configuraciones o dependencias que puedan causar problemas al generar los archivos)

#+begin_src sh

  # ~/my-org-site/build.sh

  #!/bin/sh
  emacs -Q --script build-site.el

  # Dont forget to use chmod +x build.sh to make the script executable!
  # The -Q parameter prevents Emacs from loading your own Emacs configuration

#+end_src

Now in the shell, change directory to ~my-org-site~ and run the script ~./build.sh~ to launch emacs with ~build-site.el~

**** Setting up the publish project

#+begin_src emacs-lisp

  (require 'ox-publish)

  ;; set up a Org publishing configuration for our website
  ;; Define the publishing project
  (setq org-publish-project-alist
        (list
         (list "my-org-site"
               :recursive t
               :base-directory "./content"
               :publishing-directory "./public"
               :publishing-function 'org-html-publish-to-html)))
  ;;publishing-funtion -> we want to publish the files as HTML
  ;;first list -> list of all project configuration
  ;;second list -> list configuration one

  ;; Generate the site output
  ;;publish every project configured in org-publish-project-alist
  (org-publish-all t)
  ;;t -> don't use any cached files just regenerate everything from scratch

  (message "Build complete!")

#+end_src

**** Creating the index.org example to test
Create ~~/my-org-site/content/index.org~ file to test

#+begin_src org

  #+title: Org Mode Example Site

  * Overview

  This is an *example* of a _website_ written with Org Mode.

  * Links

  - [[https://www.google.com][External link]]
  - [[file:///home/richard/Test/index.html][Internal pc link]]
  - [[./other-page.org][Link to another file in same public folder]]

#+end_src

Run the script ~./build.sh~ to generate the output of our site that are put in ~~/my-org-site/public~ folder. (se debe ejecutar cada vez que se quiera transformar nuevos archivos .org -> .html)

**** Install simple-httpd local server
Host the files as a website on the local machine. Run ~M-x httpd-serve-directory~. It will prompt you for a directory to serve from within Emacs.

Default http://localhost:8080 . Set ~httpd-port~ to change the default port if necessary.

#+begin_src emacs-lisp

  (use-package simple-httpd
    :ensure t)

#+end_src

**** Settings customizations
Note: ~C-h v org-publish-project-alist~ da una descripción sobre las variables de personalización y que otras estan disponibles.

#+begin_src emacs-lisp

  ;;set a different variable to get rid of the validate link at the bottom
  (setq org-html-validation-link nil)

  (setq org-publish-project-alist
        (list
         (list "org-site:main"
               :recursive t
               :base-directory "./content"
               :publishing-directory "./public"
               :publishing-function 'org-html-publish-to-html
               :with-author nil        ;; Don't include author name
               :with-creator t   ;; Include Emacs and Org versions in footer
               :with-toc t             ;; Include a table of contents
               :section-numbers nil    ;; Don't include section numbers
               :time-stamp-file nil))) ;; Don't include time stamp in file

#+end_src

**** Aditional customizations
We can use a nice stylesheet to give our site a more polished look:

#+begin_src emacs-lisp

  ;; Customize the HTML output
  (setq org-html-validation-link nil            ;; Don't show validation link
        org-html-head-include-scripts nil       ;; Use our own scripts
        org-html-head-include-default-style nil ;; Use our own styles
        org-html-head "<link rel=\"stylesheet\"
  href=\"https://cdn.simplecss.org/simple.min.css\" />")
  ;;Place before (setq org-publish-project-alist...

#+end_src

This will remove the default JavaScript and CSS code that gets injected into the HTML output by default and replace it with the link to a nice stylesheet.

Nota: It can use a own css file by adding it in the public folder.

**** Generating pages with code blocks
Enhance the code and avoid the error "Cannot fontify source block (htmlize.el >= 1.34 required)"

#+begin_src emacs-lisp

  ;; Set the package installation directory so that packages aren't
  ;; stored in ~/.emacs.d/elpa path.
  (require 'package)
  (setq package-user-dir (expand-file-name "./.packages"))
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))

  ;; Initialize the package system
  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))

  ;; Install dependencies
  (package-install 'htmlize)

#+end_src

**** Linking between pages
One last thing I want to show you is how you can create links between pages on your site. Let's open up ~index.org~ and create a link to the ~Emacs.org~ file.

Inside ~index.org~, we can press /C-c C-l/ (~org-insert-link~), enter the path of the Org file we want to link to (~./Emacs.org~), press Enter, then enter the text for the link ("My Emacs configuration").

**** The final build script

#+begin_src emacs-lisp

  ;; Set the package installation directory so that packages aren't
  ;; stored in the ~/.emacs.d/elpa path.
  (require 'package)
  (setq package-user-dir (expand-file-name "./.packages"))
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))

  ;; Initialize the package system
  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))

  ;; Install dependencies
  ;;(package-install 'htmlize) ;;Enhanced block code

  ;; Load the publishing system
  (require 'ox-publish)

  ;; Customize the HTML output
  (setq org-html-validation-link nil            ;; Don't show validation link
        org-html-head-include-scripts nil       ;; Use our own scripts
        org-html-head-include-default-style nil ;; Use our own styles
        org-html-head "<link rel=\"stylesheet\"
  href=\"https://cdn.simplecss.org/simple.min.css\" />")

  ;; set up a Org publishing configuration for our website
  ;; Define the publishing project
  (setq org-publish-project-alist
        (list
         (list "my-org-site"
               :recursive t
               :base-directory "./content"
               :publishing-directory "./public"
               :publishing-function 'org-html-publish-to-html
               :with-author nil ;; Don't include author name
               :with-creator t ;; Include Emacs and Org versions in footer
               :with-toc t     ;; Include a table of contents
               :section-numbers nil    ;; Don't include section numbers
               :time-stamp-file nil))) ;; Don't include time stamp in file
  ;;publishing-funtion -> we want to publish the files as HTML
  ;;first list -> list of all project configuration
  ;;second list -> list configuration one

  ;; Generate the site output
  ;;publish every project configured in org-publish-project-alist
  (org-publish-all t) ;; t -> don't use any cached files just
                      ;; regenerate everything from scratch

  (message "Build complete!")

#+end_src

*** Letter on org latex
https://www.miskatonic.org/2022/01/28/latex-letters-in-org/

First, need to turn on the  LaTeX letters in Org in the Emacs init file.

#+begin_src emacs-lisp

  ;;Activate LaTeX letters in Org
  (with-eval-after-load 'ox-latex
    (add-to-list 'org-latex-classes '("letter" "\\documentclass{letter}"))
    )

#+end_src

#+begin_src org

  # #+title: Comment out, or do not use
  #+date: Wednesday

  #+options: toc:nil

  #+latex_header: \usepackage[osf]{Baskervaldx}

  #+latex_class: letter

  #+latex_header: \signature{Lucy}
  #+latex_header: \address{17, Chatham Street}

  #+latex: \begin{letter}{[s.l.]}
  #+latex: \opening{My dearest Mina,---}

  I must say you tax me very unfairly with being a bad correspondent.
  I wrote to you /twice/ since we parted, and your last letter was only
  your /second/.
  Besides, I have nothing to tell you.  There is really nothing to interest you.
  Town is very pleasant just now, and we go a good deal to picture-galleries
  and for walks and rides in the park.  As to the tall, curly-haired man,
  I suppose it was the one who was with me at the last Pop.  Some one
  has evidently
  been telling tales.  That was Mr. Holmwood.  He often comes to see us,
  and he and
  mamma get on very well together; they have so many things to talk about
  in common.
  We met some time ago a man that would just /do for you/, if you were
  not already
  engaged to Jonathan.  He is an excellent /parti/, being handsome,
  well off, and
  of good birth.  He is a doctor and really clever.  Just fancy!
  He is only nine-and-twenty, and he has an immense lunatic asylum all
  under his own care.

  #+latex: \closing{Sincerely,}
  #+latex: \ps{P.S.  I need not tell you this is a secret.  Good-night again.}
  #+latex: \end{letter}

#+end_src

** Dired how to
*** Batch rename a bunch of  files in dired directory

1. ~M-x dired~ to go to the directory.
2. ~M-x dired-toggle-read-only~ ( =C-x C-q= ).
3. Then, just edit the file names. (You can use ~M- query-replace~ or ~M- query-replace-regexp~ or rectangle commands).
4. When done, wdired-finish-edit ( =C-c C-c= ) to commit the changes.

To abort, ~M- wdired-abort-changes~ ( =C-c C-k= ).

*** Interactively find/replace a bunch of files in dired directory
Suppose you need to do find/replace of a string pattern, for the hundreds of files in a directory. However, you do not want to replace all of them. You need to look at it in a case-by-case basis. What can you do?

1. Call dired to list files in dir, or call ~find-dired~ if you need all subdirectories.
2. Mark the files you want. You can mark by regex by typing ~% m~.
3. Type Q to call ~dired-do-query-replace-regexp~.
4. Type your find regex and replace string.
5. For each occurrence, type y to replace, ~n~ to skip.
6. Type ~!~ to replace all occurrences in current file without asking, ~N~ to skip all possible replacement for rest of the current file. (N is emacs 23 only)
7. To do the replacement on all files without further asking, type ~Y~. (Emacs 23 only)
8. Call ~ibuffer~ to list all opened files.
9. Type ~* u~ to mark all unsaved files, type ~S~ to save all marked files, type ~D~ to close them all.

https://wilkesley.org/~ian/xah/emacs/find_replace_inter.html

** Setup magit forge for Github.com
[[https://magit.vc/manual/forge/Setup-for-Githubcom.html][Magit manual]]

First inform Forge about your https://github.com username:

#+begin_src sh

  git config --global github.user USERNAME

#+end_src

Create and Store an Access Token

Visit https://github.com/settings/tokens in a browser to generate a new "classic" token using the repo, user and read:org scopes. Do not close the browser window just yet, because the token will only be shown once.

The auth-sources variable controls how and where Auth-Source keeps its secrets.

#+begin_src emacs-lisp

  (setq auth-sources '("~/.authinfo"))
  ;; Make sure you put one of these forms in your init file and to evaluate it

#+end_src

Next add a line like the following to the chosen file:

machine api.github.com login USERNAME^forge password TOKEN

- The value of machine must be api.github.com. Variations of this won’t work.
- USERNAME must be the same as the value used for the github.user Git variable above. You must append ^forge to that, without any space in between.
- TOKEN is the token you generated earlier.

~/.authinfo
#+begin_src conf

  machine api.github.com login USERNAME^forge password TOKEN

#+end_src

Finish by typing ~M-x auth-source-forget-all-cached RET~. If you don’t do this, then Auth-Source may fail to look up the token.

** Use a live web server
*** impatien-mode
Works perfectly well with HTML and CSS, with JS it might cause problems due to browser cache. One way to be able to sometimes use JS is to include the meta tag ~<meta http-equiv="refresh" content="1" >~ (refresh the page every sec) at the beginning and comment it out and uncomment it to update the JS.

*Activate the impatien-mode*:
1. Enable the web server provided by simple-httpd: ~M-x httpd-start~ or ~M-x httpd-serve-directory~
2. Publish each buffers that you want to edit by enabling the minor mode impatient-mode on it: ~M-x impatient-mode~
3. Point your browser to http://localhost:8080/imp/, and watch your changes appear as you type!

If you are editing HTML that references resources in other files (like CSS) you can enable impatient-mode on those buffers as well. This will cause your browser to live refresh the page when you edit a referenced resource.

*Note*: I think the problem happens when variables are declared with "let", when the program reloads the code it see the variable "let" assigned again. I think that when the package was created it didn't give problem because at that time JS used "var" in the variables, and nothing happens when it's declared again.

*** skewer-mode
**** To skewer your own document
Works perfectly well in JS, HTML and CSS, following the steps below, but it only updates values (I really don't know if it can create new values), that is, it doesn't create new values, for example, in HTML it doesn't render new tags it only updates existing ones, in JS depending on what you want to do, it may create new things.

1. Start the HTTP server (~httpd-start~ or ~httpd-serve-directory~)
2. Add this tag at the end (~<script src="http://localhost:8080/skewer"></script>~) of the ~index.html~ file (check your httpd-port)
3. ~M-x run-skewer~ to attach a browser to Emacs
4. Visit the document from your browser. Can be through:
   - http://localhost:8080/index.html (~http-server-directory~ => ~~/Downloads/Project-folder~)
   - http://localhost:8000/Project-folder/ (server directory => ~~/Downloads~)
   - file:///home/richard/Downloads/Project-folder/index.html
   - http://127.0.0.1:8080/skewer/demo (totally empty but renders new tags)
5. Enabled respective mode (.html -> ~skewer-mode~ and ~skewer-html-mode~ , .js -> ~skewer-mode~ and ~js2-mode~ (optional enable ~lsp~ ) or .css ->  ~skewer-mode~ and ~skewer-css-mode~)
6. From a ~js2-mode~ buffer with ~skewer-mode~ minor mode enabled, send forms to the browser to evaluate
7. Evaluate each statement (~C-x C-e~) or the entire buffer (~C-c C-k~). The results should be displayed on the server opened by skewer or the one you open yourself, and also is echoed in the minibuffer.

Note: to simple test (provided blank document), enable ~httpd-start~ run ~run-skewer~ to open skewer demo, create a empty ~js~ file, type some comands, enable ~js2-mode~ and ~skewer-mode~, and evaluate the statements. Skewer demo URL http://127.0.0.1:8080/skewer/demo.

#+begin_src html

  <!-- Original document -->
  <p>This is a paragraph</p>

  <!-- After use skewer -->
  <p>This is a paragraph inside the document</p> <!-- update tag (works) -->
  <p>This is a new tag</p> <!-- create new tag (doesn't work) -->

#+end_src

**** How to evalutationg expressions
https://github.com/skeeto/skewer-mode
The keybindings for evaluating expressions in the browser are just like the Lisp modes. These are provided by the minor mode ~skewer-mode~.

- C-x C-e :: Evaluate the form before the point and display the result in the minibuffer. If given a prefix argument, insert the result into the current buffer.
- C-M-x :: Evaluate the top-level form around the point.
- C-c C-k :: Load the current buffer.
- C-c C-z :: Select the REPL buffer.

The result of the expression is *echoed in the minibuffer*.

Additionally, ~css-mode~ and ~html-mode~ get similar sets of bindings for modifying the CSS rules and HTML on the current page.

*CSS*:
- C-x C-e :: Load the declaration at the point.
- C-M-x :: Load the entire rule around the point (point must be inside the tag).
- C-c C-k :: Load the current buffer as a stylesheet.

*HTML*:
- C-M-x :: Load the HTML tag immediately around the point (point must be inside the tag).

*Note*: ~run-skewer~ uses ~browse-url~ to launch the browser. This may require further setup depending on your operating system and personal preferences.

Multiple browsers and browser tabs can be attached to Emacs at once. JavaScript forms are sent to all attached clients simultaneously, and each will echo back the result individually. Use ~list-skewer-clients~ to see a list of all currently attached clients.

Sometimes Skewer's long polls from the browser will timeout after a number of hours of inactivity. If you find the browser disconnected from Emacs for any reason, use the browser's console to call ~skewer()~ to reconnect. This avoids a page reload, which would lose any fragile browser state you might care about.

**** Format document example
The format should be like this

#+begin_src html

  <!DOCTYPE html>
  <html>
    <head>
      <title>Something</title>
      <link rel="stylesheet" href="./style.css">
    </head>
    <body>
      <h1>Here</h1>
      <p>START</p>
      <img src="img/cat.png" id="cat" style="position: absolute">
      <img src="img/hat.png" id="hat" style="position: absolute">
      <script src="./javascript.js"></script>
      <p>LAST</p>
      <script src="http://localhost:8080/skewer"></script>
      <p>REALLY LAST</p>
    </body>
  </html>

#+end_src

and not like this (can also be done by just opening a js file and typing but will only see the js not the html or css)

#+begin_src javascript

  <!doctype html>

  <style>body { min-height: 200px }</style>
  <img src="img/cat.png" id="cat" style="position: absolute">
  <img src="img/hat.png" id="hat" style="position: absolute">

  <script>
    let cat = document.querySelector("#cat");
    let hat = document.querySelector("#hat");

    let angle = 0;
    let lastTime = null;
    function animate(time) {
        if (lastTime != null) angle += (time - lastTime) * 0.001;
        lastTime = time;
        cat.style.top = (Math.sin(angle) * 40 + 40) + "px";
        cat.style.left = (Math.cos(angle) * 220 + 230) + "px";

        // Your extensions here.

        requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>

#+end_src

**** REPL
A REPL into the browser can be created with ~M-x skewer-repl~ , or ~C-c C-z~. This should work like a console within the browser. Messages can be logged to this REPL with ~skewer.log()~ (like ~console.log()~).

Results of expressions evaluated in the REPL are printed more verbosely than in the minibuffer, when possible. This may help in debugging.

** Basic emacs installation
*** Xah
http://xahlee.info/emacs/emacs/building_emacs_on_linux.html

*** Building Emacs from Source with pgtk
https://batsov.com/articles/2021/12/19/building-emacs-from-source-with-pgtk/

*** emacs-mirror
https://github.com/emacs-mirror/emacs/blob/master/INSTALL
On most Unix systems, you build Emacs by first running the 'configure'
shell script.  This attempts to deduce the correct values for
various system-dependent variables and features, and find the
directories where certain system headers and libraries are kept.
In a few cases, you may need to explicitly tell configure where to
find some things, or what options to use.

'configure' creates a 'Makefile' in several subdirectories, and a
'src/config.h' file containing system-dependent definitions.
Running the 'make' utility then builds the package for your system.

Building Emacs requires GNU make, <https://www.gnu.org/software/make/>.
On most systems that Emacs supports, this is the default 'make' program.

Here's the procedure to build Emacs using 'configure' on systems which
are supported by it.  In some cases, if the simplified procedure fails,
you might need to use various non-default options, and maybe perform
some of the steps manually.  The more detailed description in the other
sections of this guide will help you do that, so please refer to those
sections if you need to.

  1.  Obtain and unpack the Emacs release, with commands like this:

       wget https://ftp.gnu.org/gnu/emacs/emacs-VERSION.tar.xz
       tar -xf emacs-VERSION.tar.xz

       where VERSION is the Emacs version number.

  2a. 'cd' to the directory where you unpacked Emacs and invoke the
        'configure' script:

        ./configure

  2b. Alternatively, create a separate directory, outside the source
        directory, where you want to build Emacs, and invoke 'configure'
        from there:

        SOURCE-DIR/configure

        where SOURCE-DIR is the top-level Emacs source directory.

  2c. If you don't have write access to the default directory where
        Emacs and its data files will be installed, specify an alternative
        installation directory:

        ./configure --prefix=/SOME/OTHER/DIRECTORY

        where /SOME/OTHER/DIRECTORY is a directory writable by your user,
        for example, a subdirectory of your home directory.

  3. When 'configure' finishes, it prints several lines of details
       about the system configuration.  Read those details carefully
       looking for anything suspicious, such as wrong CPU and operating
       system names, wrong places for headers or libraries, missing
       libraries that you know are installed on your system, etc.

       If you find anything wrong, you may have to pass to 'configure'
       one or more options specifying the explicit machine configuration
       name, where to find various headers and libraries, etc.
       Refer to the section DETAILED BUILDING AND INSTALLATION below.

       If 'configure' didn't find some image support libraries, such as
       Xpm and jpeg, refer to "Image support libraries" below.

       If the details printed by 'configure' don't make any sense to
       you, but there are no obvious errors, assume that 'configure' did
       its job and proceed.

  4. Invoke the 'make' program:

       make

  5. If 'make' succeeds, it will build an executable program 'emacs'
       in the 'src' directory.  You can try this program, to make sure
       it works:

       src/emacs -Q

       To test Emacs further (intended mostly to help developers):

       make check

  6. Assuming that the program 'src/emacs' starts and displays its
       opening screen, you can install the program and its auxiliary
       files into their installation directories:

       make install

    You are now ready to use Emacs.  If you wish to conserve space,
    you may remove the program binaries and object files from the
    directory where you built Emacs:

    make clean

    You can delete the entire build directory if you do not plan to
    build Emacs again, but it can be useful to keep for debugging.
    If you want to build Emacs again with different configure options,
    first clean the source directories:

    make distclean

    Note that the install automatically saves space by compressing
    (provided you have the 'gzip' program) those installed Lisp source (.el)
    files that have corresponding .elc versions, as well as the Info files.

    You can read a brief summary about common make targets:

    make help

*** Install with tree-sitter support
https://www.masteringemacs.org/article/how-to-get-started-tree-sitter

** How to deal with command keys conflict (C-x, C-c)
*** Brief
[[https://ergoemacs.github.io/cua-conflict.html][Xah]]

There is a conflict between standard shortcuts and emacs shortcuts. In most applications =Ctrl+c= is copy and =Ctrl+x= is cut. In emacs =Ctrl+x= generally refer to global commands, while =Ctrl+c= refers to language specific commands.

Ergoemacs provides a few options to work with the =Ctl+c= and =Ctl+x= keys.

*** Binding Ctrl+c and Ctrl+x to only copy and cut
If you wanted =Ctrl+c= and =Ctrl+x= to only be copy and cut, you add the ability to copy/cut the current line when nothing is selected. This can be done by:

#+begin_src emacs-lisp

  (setq ergoemacs-handle-ctl-c-or-ctl-x 'only-copy-cut)

#+end_src

The possible disadvantage to this is you would have to use another key to access the defined emacs commands. Currently ergoemacs-mode allows you to use QWERTY 【 =▤ Menu d= 】 or 【 =Ctrl+⇧ Shift+x= 】 to access emacs =Ctrl+x= commands and QWERTY 【 =▤ Menu f= 】 or 【 =Ctrl+⇧ Shift+c= 】 to access =Ctrl+c= commands.

The 【 =▤ Menu= 】 keybindings are slightly different than plan =Ctrl+x= or =Ctrl+c=:

- For =Ctrl+x=, the =Alt= and =Ctrl= keys are swapped. Hence for the equivalent of 【 =Ctrl+x Ctrl+b= 】, you would press 【 =▤ Menu s Alt+b= 】
- For =Ctrl+c=, control keys are mapped to plain keys. Plain keys are mapped to =Alt= keys. =Alt= keys are mapped to =Ctl= keys. Hence:
    - 【 =Ctrl+c Ctrl+c= 】 would be 【 =▤ Menu f c= 】
    - 【 =Ctrl+c c= 】 would be 【 =▤ Menu f Alt+c= 】
    - 【 =Ctrl+c Alt+c= 】 would be 【 =▤ Menu f Ctl+c= 】
    - This is called unchorded mapping
- You can swap between Normal, =Alt= <-> =Ctl= and unchorded keyboard translations in ergoemacs by pressing 【 =▤ Menu= 】

*** Binding Ctrl+c and Ctrl+x to emacs commands only
Another option is to ditch copy and paste with =Ctrl+c= and =Ctrl+x=, even though they are standard keys. Instead you can use =Alt+c= and =Alt+x= to do copy and paste.

This can be done in ergoemacs by the following variable:

#+begin_src emacs-lisp

  (setq ergoemacs-handle-ctl-c-or-ctl-x 'only-C-c-and-C-x)

#+end_src

The disadvantage to this approach is that you use different keys in different applications.

*** Binding Ctrl+c and Ctrl+x to both copy and cut and emacs keys
Like ~cua-mode~, ~ergoemacs-mode~ allows =Ctrl+c= and =Ctrl+x= to be bound to both copy/cut, and the emacs key sequences.

The default method will copy text when selected with =Ctrl+c= and cut text when selected with =Ctrl+x=. This is fine, but if you wish to perform an emacs command on selected region, this could be problematic as discussed in Xah's blog. (For example python shift indent is bound to 【 =Ctrl+c <= 】)

When you wish to do issue emacs commands on a region you can:

-  Add a shift to the first =Ctrl+c= and =Ctrl+x=.
    - For example press 【 =Ctrl+⇧ Shift+c <= 】 for python's shift indent command
    - This will not work in a terminal (most terminals cannot tell the difference between 【 =Ctrl+⇧ Shift+c= 】 and 【 =Ctrl+c= 】)
-  Press the next key within 0.2 seconds.
    - This can be tuned by setting ~ergoemacs-ctl-c-or-ctl-x-delay~
    - If you tune this to a higher setting, it takes longer to copy and cut and other problems may be introduced.

If you wanted the time required to press the next key be 1 second, you could use the following in your emacs startup file:

#+begin_src emacs-lisp

  (setq ergoemacs-ctl-c-or-ctl-x-delay 1)

#+end_src

* References
- [[https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html][An Introduction to Programming in Emacs Lisp]]
- [[https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html][GNU Emacs Manual]]
- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/][The GNU Emacs Lisp Reference Manual]]
- [[https://orgmode.org/orgguide.html][Org Mode Compact Guide]]
- [[https://wilkesley.org/~ian/xah/][∑XAH]]
- [[https://www.youtube.com/watch?v=48JlgiBpw_I][System Crafters Youtube]]
