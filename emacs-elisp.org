#+title: EMACS Lisp
#+date: 2022-05-20

* Key bindings
** Org
*** Heading

| /M-RET/          | org-meta-return (new heading)      |
| /C-RET/          | org-insert-heading-respect-content |
| /M-left/right/   | org-do-promote                     |
| /M-S-left/right/ | org-promote-subtree                |
| /M-up/down/      | org-metaup/down(bullet)            |
| /M-S-up/down/    | org-shiftmetaup/down(line)         |
| /C-c C-x b/      | org-tree-to-indirect-buffer        |
|                |                                    |
| /C-c C-n/        | org-next-visible-heading           |
| /C-c C-p/        | org-previous-visible-heading       |
| /C-c C-u/        | outline-up-heading                 |
| /C-c C-f/        | org-forward-heading-same-level     |
| /C-c C-b/        | org-backward-heading-same-level    |
| /C-c C-j/        | org-goto                           |
|                |                                    |
| /TAB/            | org-cycle (expand header)          |
| /S-TAB/          | org-shifttab(expandHeader)         |
| /M-# S-TAB/      | all headlines at level #           |
| /C-# C-c TAB/    | only current headlines at level #  |
| /S-TAB-TAB/      | outline-show-all                   |
| /C-u C-u TAB/    | org-set-startup-visibility         |
|                |                                    |
|                | org-toggle-narrow-to-subtree       |
| /C-x n s/        | org-narrow-to-subtree              |

*** Todo

| /M-S-RET/      | org-insert-todo-heading                 |
| /C-S-RET/      | org-insert-todo-heading-respect-content |
| /S-right/left/ | org-shiftright (cursor)                 |
| /S-up/down/    | org-priority (cursor)                   |
|              |                                         |
| /- [ ]/        | to create checkbox                      |
| /S-M-RET/      | create another checkbox                 |
| /C-c C-c/      | org-toggle-checkbox                     |
|              |                                         |
| /C-c ./        | org-time-stamp                          |

*** Agenda

|                | org-agenda                     |
| /C-c ./          | org-time-stamp (date)          |
| /C-u C-c ./      | org-time-stamp (datetime)      |
| /S-left / right/ | change date day (cursor)       |
| /S-up / down/    | change time (cursor)           |
| /C-c C-d/        | org-deadline                   |
| /C-c C-s/        | org-scheduled                  |
| /C-c C-q/        | org-set-tags-command           |
| /C-c C-q/        | org-match-sparse-tree          |
| /C-c C-t/        | org-todo     (change state)    |
| /C-c ,/          | org-priority                   |
|                |                                |
|                | counsel-org-tags (add/remove)  |
| /C-c C-c/        | Set tag (cursor)               |
| /S-left/right/   | change state org task (cursor) |
|                |                                |
| /C-c [/          | org-agenda-file-to-front       |
| /C-c ]/          | org-remove-file                |

*** Timer

| /C-c C-x C-i/   | org-clock-in         |
| /C-c C-x C-o/   | org-clock-out        |
| /C-c C-x C-x/   | org-clock-in-last    |
| /C-c C-x C-q/   | org-clock-cancel     |
| /C-c C-x C-j/   | org-clock-jump       |
|               | org-clock-report     |
|               |                      |
| /C-c C-x C-e/   | org-clock-modify-eff |
| /C-c C-x e 3/   | org-set-effort 3     |
| /C-c C-x p/     | org-set-property     |
| /C-c C-x C-d/   | org-clock-display    |
| /C-c C-c/       | set run cancel       |
|               |                      |
| /C-c C-x 0/     | org-timer-start      |
| /C-c C-x ,/     | org pause o continue |
| /C-u C-c C-x ,/ | stop timer           |
| /C-c C-x -/     | org-timer-item       |

*** Table

| /C-c Â¦/     | org-table-create-or-convert-from     |
| /S-TAB/     | org-table-previous-field             |
| /S-RET/     | org-table-copy-down                  |
| /M-left/    | org-table-move-column-left           |
| /M-S-left/  | org-table-delete-column              |
| /M-S-right/ | org-table-insert-column              |
| /M-up/      | org-table-move-row-up                |
| /M-S-up/    | org-table-kill-row                   |
| /M-a/       | org-table-beginning-of-field         |
| /M-e/       | org-table-end-of-field               |
|           |                                      |
| /C-c SPC/   | org-table-blank-field                |
|           |                                      |
| /C-c ^ n/   | org-table-sort-lines numeric         |
| /C-c ^ N/   | org-table-sort-lines numeric reverse |
| /C-c ^ a/   | org-table-sort-lines alphabetic      |
| /C-c ^ A/   | org-table-sort-lines alphabetic reve |
|           |                                      |
| /C-c +/     | org-table-sum                        |
| /C-c ~/     | org-table-create-with-table.el       |
| /C-c '/     | org-edit-special (inside table)      |
| /C-c C-c </ | adjusts the column width             |

*** Miscellaneous

| /C-c '/       | org-edit-special (open bufer code) |
| /C-c C-v v/   | org-babel-expand-src-block         |
| /C-c C-c/     | org-ctrl-c (eval code)             |
| /C-x C-s/     | org-edit-src-save                  |
|             |                                    |
| /C-c C-x C-f/ | org-emphasize                      |
| /C-c C-x C-b/ | org-toggle-inline-images           |
| /C-c C-e #/   | org-export-dispatch                |
| /C-c C-o/     | org-open-at-point (go to link)     |
|             |                                    |
| /C-c C-,/     | org-insert-structure-template      |
| /C-c C-x C-l/ | org-latex-preview                  |

** Files
*** Files

| /C-x C-f/      | find-file                           |
| /C-x C-r/      | find-file-read-ONLY                 |
| /C-x C-s/      | save-buffer                         |
| /C-x C-w/      | write-file (save-as)                |
| /C-x s/        | save-many-buffer                    |
| /C-x C-q/      | mode-edit(change-only-read or edit) |
| /C-x i/        | insert-file-in-buffer               |
|              |                                     |
| /C-x 4 f/      | find-file-other-window              |
| /C-x 4 b/      | switch-to-buffer-other-window       |
| /C-x 4 C-o/    | display-buffer(other window)        |
| /C-x 4 r/      | find-file-read-only-other-win       |
| /C-x 4 c/      | clone-inderect-buffer-other-window  |
| /C-x 4 0/      | kill-buffer-and-window              |
| /C-x 4 d/      | dired-other-window                  |
|              |                                     |
| //sudo::/name/ | sudo open file                      |

*** Dired
**** Files

| /C-x d/   | dired (list all files)                |
|         | find-dired (list all file and subdir) |
| /C-t d/   | image-dired-display-thumbs            |
|         |                                       |
| /o/       | dired-find-file-other-window          |
| /C-o/     | dired-display-file                    |
| /v/       | dired-view-file (only read)           |
| /r/       | dired-single-buffer                   |
| /b/       | dired-single-up-directory             |
| '/!/      | dired-do-shell-command                |
| /&/       | dired-do-async-shell-command          |
| /C-x C-q/ | d-toggle-read-only (edi dire bufer)   |
|         |                                       |
| /m/       | dired-mark                            |
| /u/       | dired-unmark                          |
| /U/       | dired-unmark-all-marks                |
| /% m/     | dired-mark-files-regexp               |
| /t/       | dired-toggle-marks                    |
| /Q/       | dired-do-query-replace-regexp         |

**** Navigate

| /r/     | dired-single-buffer       |
| /b/     | dired-single-up-directory |
| /RET/   | dired-find-file           |
| /g/     | revert-buffer (refresh)   |
| '/^/    | dired-up-directory        |
| />/     | dired-next-dirline        |
| /</     | dired-prev-dirline        |
| /z/     | dired-hide-dotfiles-mode  |
| /i/     | dired-maybe-insert-subdir |
| /s/     | dired-sort-toggle-or-edit |
| /j/     | dired-goto-file           |
| /%/ / /*/ | Prefix command            |

**** Copy - Rename - Delete - Compress

| /+/ | dired-create-directory       |
| /C/ | dired-do-copy                |
| /R/ | dired-do-rename              |
| /D/ | dired-do-delete              |
| /d/ | dired-flag-file-deletion     |
| /x/ | dired-do-flagged-deletion    |
| /k/ | dired-do-kill-lines          |
| /Z/ | dired-do-compress/decompress |
| /c/ | dired-to-compress-to         |

**** Group - Symlink - Load

| /M/ | dired-do-chmod   |
| /O/ | dired-do-chown   |
| /G/ | dired-do-chgrp   |
| /T/ | dired-do-touch   |
| /S/ | dired-do-symlink |
| /L/ | dired-do-load    |

*** Treemacs

|              | treemacs-add-project                 |
|              | treemacs-remove-project-from-workspa |
|              | treemacs-switch-workspace            |
|              | treemacs-resize-icons                |

*** Image dired

|         | /Dired Mode/                                              |
| /C-t i/   | image-dired-dired-display-image (display)               |
| /C-t x/   | image-dired-dired-display-external (display external)   |
| /C-t d/   | image-dired-display-thumbs (display thumbs)             |
| /C-t C-t/ | image-dired-dired-toggle-marked-thumbs (view inline)    |
| /C-d/     | image-dired-delete-char (delete from thumbnails buffer) |
| /r/       | image-rotate                                            |
|         |                                                         |
|         | /Image Dired Thumbnail Mode/                              |
|         | image-dired                                             |
| /n/SPC/   | image-dired-display-next                                |
| /p/DEL/   | image-dired-display-previous                            |
| /RET/     | image-dired-display-this                                |
| /C-RET/   | image-dired-thumbnail-display-external                  |
| /m/       | image-dired-mark-thumb-original-file                    |
| /d/       | image-dired-flag-thumb-original-file (mark D flag)      |
| /u/       | image-dired-unmark-thumb-original-file                  |
| /U/       | image-dired-unmark-all-marks                            |
| /x/       | image-dired-do-flagged-delete                           |
| /r/       | image-rotate                                            |
| /s/       | image-dired-display-current-image-sized                 |
| /f/       | image-dired-display-current-image-full                  |
| /w/       | image-dired-copy-filename-as-kill                       |

*** Images

| /n/       | image-next-file                       |
| /p/       | image-previous-file                   |
| /w/       | image-mode-copy-file-name-as-kill     |
|         |                                       |
| /s w/     | image-transform-fit-to-window         |
| /s s/     | image-transform-set-scale             |
| /s p/     | image-transform-set-percent           |
| /s o/     | image-transform-reset-to-original     |
| /s 0/     | image-transform-reset-to-initial      |
|         |                                       |
| /C-f/C-p/ | point motion keys (scroll buffer)     |
| /C-c C-c/ | image-toggle-display (display vs raw) |
| /C-c C-x/ | image-toggle-hex-display              |
|         |                                       |
| /m/       | image-mode-mark-file                  |
| /u/       | image-mode-unmark-file                |
|         |                                       |
| /RET/     | image-toggle-animation (starts/stop)  |
| /f/       | image-next-frame                      |
| /b/       | image-previous-frame                  |
| /F/       | image-goto-frame                      |
|         | a + image-increase-speed              |
|         | a - image-decrease-speed              |
|         | a r image-reverse-speed               |
|         | a 0 image-reset-speed                 |
|         |                                       |
| /i +/     | image-increase-size (by 20%)          |
| /i -/     | image-decrease-size (by 20%)          |
| /i r/     | image-rotate                          |
| /i h/     | image-flip-horizontally               |
| /i v/     | image-flip-vertically                 |
| /i o/     | image-save                            |
| /i c/     | image-crop                            |
| /i x/     | image-cut                             |

*** Packages

| /C-h P/ | describe-package           |
|       | list-packages              |
| /i/     | package-install            |
| /d/     | package-delete             |
| /U/     | package-menu-mark-upgrades |
| /x/     | package-menu-execute       |
| ///     | package-menu-filter-by     |
| /h/     | package-menu-quick-help    |

** Windows - Frames
*** Windows

| /C-x o/     | other-window                  |
| /C-x 0/     | delete-select-window          |
| /C-x 1/     | delete-all-other-window       |
| /C-x 2/     | split-window-below            |
| /C-x 3/     | split-window-right            |
|           |                               |
| /C-c b/     | windmove-left                 |
| /C-c n/     | windmove-down                 |
| /C-c p/     | windmove-up                   |
| /C-c f/     | windmove-right                |
|           |                               |
| /C-c left/  | winner-undo                   |
| /C-c right/ | winner-redo                   |
|           | rotate-frame-clockwise        |
|           | window-swap-states            |
|           |                               |
| /M-o/       | ace-window (other window)     |
| /M-o m 1/   | swap windows 1                |
| /M-o x 1/   | delete window 1               |
| /M-o M 1/   | move windows 1                |
| /M-o z/     | new frame with current window |
| /M-o ?/     | show command bindings         |
|           |                               |
| /C-l/       | recenter-top-bottom           |
| /S-M-C-l/   | recenter-other-window         |
|           |                               |
| /C-x ^/     | enlarge-window                |
|           | shrink-window                 |
| /C-x }/     | enlarge-window-horizontally   |
| /C-x {/     | shrink-window-horizontally    |
| /C-x +/     | balance-windows               |

*** Frames

| /C-x 5 o/ | switch-frame             |
| /C-x 5 0/ | delete-select-frame      |
| /C-x 5 1/ | delete-all-frames        |
| /C-x 5 2/ | make-frame-same-terminal |
|         | rotate-frame-clockwise   |

** Buffer - Minibuffer
*** Buffer

| /C-x k/       | kill-buffer            |
| /C-x b/       | switch-to-buffer       |
|             |                        |
| /C-x p/       | previous-buffer        |
| /C-x c/       | next-buffer            |
|             |                        |
| /C-x ESC ESC/ | repeat-complex-command |

*** Ibuffer

| /C-x C-b/ | ibuffer                         |
| /C-x d/   | dired (list all files)          |
|         | find-dire (all file and subdir) |
|         |                                 |
| /m/       | Mark                            |
| /u/       | Unmark                          |
| /U/       | Unmark all                      |
| /t/       | toogel                          |
| /* u/     | Mark unsaved                    |
| /* M/     | Mark by mode                    |
| /% m/     | Mark by mode using regexp       |
| /% n/     | Mark by name using regexp       |
|         |                                 |
| /S/       | Save marked buffer              |
| /D/       | Kill marked buffers             |
| /i/       | list subdirectories (on a dir)  |
|         |                                 |
| /RET/     | View the buffer on this line    |
| /o/       | As above, but in another window |
| /C-o/     | As both above,but no new window |

*** Vertico

| /TAB/   | vertico-insert     |
| /RET/   | vertico-exit       |
| /M-RET/ | vertico-exit-input |

*** Embark
**** embark

| /C-./     | embark-act                  |
| /C-;/     | embark-dwim                 |
| /C-h B/   | embark-bindings             |
| /g/       | restart completion session  |
| /C-. C-h/ | embark buffer to minibuffer |
| /C-. C/   | +embark-consult-search-map  |
|         |                             |
|         | /minibuffer-local-map/        |
| /C-x SPC/ | embark-select               |
| /C-x E/   | embark-export               |
| /C-x S/   | embark-collect              |
| /C-x A/   | embark-act-all              |

| To deselect embark selections                  |
|------------------------------------------------|
| embark-select (again over selection)           |
| M-x embark-act-all SPC (remove all selections) |

| Asynchronous search                            |
|------------------------------------------------|
| Search among file *names* and then search        |
| within the matching files                      |
| consult-find -> embark-act-all -> consult-grep |

**** embark-general

| /C-SPC/ | mark                        |
| /SPC/   | embark-select               |
| /A/     | embark-act-all              |
| /E/     | embark-export               |
| /S/     | embark-collect              |
| /L/     | embark-live                 |
| /B/     | embark-become               |
| /q/     | embark-toggle-quit          |
| /w/     | embark-copy-as-kill         |
| /1/     | digit-argument              |
| /C/     | +embark-consult-search-map  |
|       |                             |
|       | /EMBARK COLLECT BUFFER/       |
| /a SPC/ | select candidate            |
| /a/     | embark-act                  |
| /A/     | embark-act-all              |
| /g/     | revert-buffer               |

**** embark-buffer

| /k/ | kill-buffer                    |
| /o/ | switch-to-buffer-other-window  |
| /r/ | embark-rename-buffer           |
| /</ | insert-buffer                  |
| /$/ | eshell                         |
| /=/ | ediff-buffers                  |

**** embark-file

| /f/ | find-file              |
| /o/ | find-file-other-window |
| /F/ | find-file-literally    |
| /x/ | embark-open-externally |
|   |                        |
| /</ | insert-file            |
| /+/ | make-directory         |
| /j/ | embark-dired-jump      |
| /c/ | copy-file              |
| /r/ | rename-file            |
| /d/ | delete-file            |
| /D/ | delete-directory       |
|   |                        |
| /$/ | eshell                 |
| /!/ | shell-command          |
| /&/ | async-shell-command    |
| /=/ | ediff-files            |

**** embark-region

| /c/ | capitalize-region           |
| /l/ | downcase-region             |
| /u/ | upcase-region               |
|   |                             |
| /n/ | narrow-to-region            |
| /d/ | delete-duplicate-lines      |
| /e/ | eval-region                 |
| /+/ | append-to-file              |
| /W/ | write-region                |
|   |                             |
| /m/ | apply-macro-to-region-lines |
| /o/ | org-table-convert-region    |
| /$/ | ispell-region               |
| /=/ | count-words-region          |

**** embark-command

| /o/ | occur                        |
| /e/ | pp-eval-expression           |
| /$/ | ispell-word                  |
|   |                              |
| /p/ | embark-previous-symbol       |
| /n/ | embark-next-symbol           |
| /r/ | xref-find-references         |
| /H/ | embark-toggle-highlight      |
|   |                              |
| /I/ | Info-goto-emacs-command-node |
| /h/ | describe-symbol              |
| /a/ | apropos                      |
| /b/ | where-is                     |

**** embark-defun

| e   | embark-pp-eval-defun |
| <   | embark-eval-replace  |
| TAB | indent-region        |
| N   | narrow-to-defun      |
| o   | checkdoc-defu        |
|     |                      |
| p   | backward-list        |
| n   | forward-list         |
| u   | backward-up-list     |
| t   | transpose-sexps      |
| k   | kill-region          |
| r   | raise-sexp           |

**** embark-org-heading

| /N/ | org-narrow-to-subtree       |
| /k/ | org-cut-subtree             |
| /T/ | org-tree-to-indirect-buffer |

**** embark-org-src-block

| /c/   | embark-org-copy-block-contents |
| /TAB/ | org-indent-block               |

*** Consult
**** Virtual buffers

| /C-x b/   | consult-buffer              |
| /C-x 4 b/ | consult-buffer-other-window |
| /C-x 5 b/ | consult-buffer-other-frame  |
| /C-x p b/ | consult-project-buffer      |
| /C-x r b/ | consult-bookmark            |
|         | consult-recent-file         |
|         |                             |
| /f SPC/   | narrow recent files         |
| /* SPC/   | narrow modified buffers     |
| /p SPC/   | narrow project              |
| /r SPC/   | narrow file registers       |
| /m SPC/   | narrow bookmarks            |
| /b SPC/   | narrow buffers              |
| /SPC/     | narrow hidden buffers       |

**** Editing

| /M-y/ | consult-yank-pop |
|     | consult-kmacro   |

**** Register

|     | consult-register       |
| /M-'/ | consult-register-store |
| /M-#/ | consult-register-load  |

**** Navigation

|       | consult-org-heading     |
| /M-g o/ | consult-outline         |
| /M-g i/ | consult-imenu           |
| /M-g I/ | consult-imenu-multi     |
| /M-g g/ | consult-goto-line (l:c) |
| /M-g m/ | consult-mark            |
| /M-g k/ | consult-global-mark     |

**** Search

| /M-s l/     | consult-line                                |
| /M-s L/     | consult-line-multi                          |
|           |                                             |
| /M-s k/     | consult-keep-line (keep/flush replacement)  |
| /! SPC/     | the filter matches the complement           |
|           |                                             |
| /M-s f/     | consult-focus-line (temporarily hide)       |
| /! SPC/     | the filter matches the complement           |
| /C-u M-s f/ | consult-focus-line (reveal again)           |
| /M-s f RET/ | consult-focus-line (reveal again,other way) |
|           |                                             |
| /M-e/       | consult-isearch-history                     |

**** Grep and find

| /C-u M-x/  | consult- (specifies initial dir)       |
|          |                                        |
| /M-s d/    | consult-find                           |
| /M-s d/    | add /-- -type d/ to find only dir        |
| /variable/ | consult-find-args (arguments for find) |
|          | consult-fd                             |
|          | consult-locate                         |
|          |                                        |
| /M-s g/    | consult-grep                           |
| /M-s G/    | consult-git-grep                       |
|          | consult-ripgrep                        |
|          |                                        |
|          | #regexps#filter-string                 |
| /\SPC/     | match space literally                  |

**** Compilation

|       | consult-xref    |
| /M-g f/ | consult-flymake |
|       |                 |
| /e SPC/ | show errors     |
| /w SPC/ | show warnings   |
| /n SPC/ | show notes      |

**** Histories

| /M-s/ | consult-history         |
| /M-r/ | consult-history         |
| /M-e/ | consult-isearch-history |
|     | consult-complex-command |

**** Modes

|       | consult-mode-command    |
|       | consult-minor-mode-menu |
|       |                         |
| /i SPC/ | on modes                |
| /o SPC/ | off modes               |
| /l SPC/ | local modes             |
| /g SPC/ | global modes            |

**** Miscellaneous

|   | consult-man   |
|   | consult-theme |

*** Orderless

| /!/ | orderless-not            |
| /,/ | orderless-initialism     |
| /=/ | orderless-literal        |
| /^/ | orderless-literal-prefix |
| /~/ | orderless-flex           |
| /&/ | orderless-annotation     |
| /%/ | ignoring diacritics      |

| /\/  | whitespace |
| /\b/ | boundary   |
| /\</ |            |

** Cursor - Scroll - Mark
*** Cursor

| /C-</         | mc/previous-next(duplicat up) |
| /C->/         | mc/mark-next(duplicate down)  |
| /C-S-c C-S-c/ | mc/edit-lines(mark to cursor) |
| /C-u C-x =/   | what-cursor-position          |

*** Move cursor

| /C-f/       | forward-char                   |
| /C-b/       | backward-char                  |
| /M-f/       | forward-word                   |
| /M-b/       | bakcward-word                  |
|           |                                |
| /C-a/       | beginning-of-visual-line       |
| /C-e/       | end-of-visual-line             |
| /M-a/       | backward-sentence              |
| /M-e/       | end-sentence                   |
|           |                                |
| /C-x C-x/   | exchange-point-and-mark        |
| /C-SPC/     | set-mark-command               |
| /C-u C-SPC/ | jump into marks ring           |
| /M-r/       | move-to-window-line-top-bottom |

| /^/            | /^/             |
| start-buffer | previous-line |
| /M-</          | /C-p/           |
|--------------+---------------|
| /v/            | /v/             |
| end-buffer   | next-line     |
| /M->/          | /C-n/           |


| /<-----/   | /<----/     | /<---/     | /<--/      | /<-/       |
| back ele | back-sent | beg line | back-wor | back-cha |
| /M-{/      | /M-a/       | /C-a/      | /M-b/      | /C-b/      |
|----------+-----------+----------+----------+----------|
| /----->/   | /---->/     | /--->/     | /-->/      | /->/       |
| forw ele | forw-sent | end line | forw-wor | forw-cha |
| /M-}/      | /M-e/       | /C-e/      | /M-f/      | /C-f/      |

*** Scroll

| /C-l/       | recenter-top-bottom   |
| /S-M-C-l/   | recenter-other-window |
| /C-M-l/     | reposition-window     |
| /C-u 7 M-</ | 70% position buffer   |

| /^/                | /^/           |
| scroll-other-w   | scroll-up   |
| /C-M-v/            | /M-v/         |
|------------------+-------------|
| /v/                | /v/           |
| scroll-other-w d | scroll-down |
| /C-M-S-v/          | /C-v/         |

*** Mark

| /M-h/       | mark-paragraph                |
| /C-x h/     | mark-whole-buffer             |
|           |                               |
| /C-SPC-SPC/ | set-mark                      |
| /C-x C-x/   | exchange-point-and-mark       |
| /C-u C-SPC/ | return to point mark          |
| /C-x C-SPC/ | pop-global-mark(other buffer) |

*** Region

| /C-x n n/ | narrow-to-region                |
| /C-x n w/ | remove restrictions narrowing   |
| /C-=/     | er/expand-region                |
|         | /=/ to expand again /-/ to contract |

** Text - Help
*** Text

| /M-w/       | kill-ring-save(copy)                 |
| /C-w/       | kill-region(cut)                     |
| /C-y/       | reinsert-text-last(paste)            |
| /M-y/       | reinsert-text-befores (paste others) |
| /C-//       | deshacer(undo)                       |
| /C-g C-//   | rehacer(redo)                        |
| /C-x r k/   | kill-rectangle(cut first n char)     |
|           |                                      |
| /M-S-down/  | duplicate-things                     |
| /M-up/down/ | drag-stuff-up/down(move line)        |
|           |                                      |
| /M-s h p/   | highlight-phrase                     |
| /M-s h u/   | unhilight-regexp                     |
| /C-x r s/   | copy-to-register                     |
| /C-x r i/   | insert-register                      |
| /M-%/       | query-replace                        |
| /C-q TAB/   | quoted-insert                        |
|           |                                      |
| /C-x r N/   | rectangle-number-lines               |
| /M-=/       | count-words-region                   |

*** Kill text

| /---->/       | /--->/        | /-->/         | /->/          |
| kill-sent f | kill line f | kill-word f | del char f  |
| /M-k/         | /C-k/         | /M-d/         | /C-d/         |
|-------------+-------------+-------------+-------------|
| /<-----/      | /<---/        | /<--/         | /<-/          |
| kill-region | kill line b | b kill word | del chart b |
| /C-w/         | /C-x DEL/     | /M-DEL/       | /DEL/         |
|             | /C-0 C-k/     |             |             |

*** Regexp

| /C-s/     | search (swiper)                  |
| /C-M-s/   | isearch-forw -regexp             |
| /C-s C-s/ | last searched                    |
|         |                                  |
| /Q/       | dired-do-query-replace-regexp    |
| /M-c/     | case conversion on\off           |
|         | regexp-builder                   |
|         |                                  |
|         | In minibuffer during search      |
| /C-q C-j/ | enter new line (interactive cmd) |
| /C-q TAB/ | enter new TAB (interactive cmd)  |
|         | toggle-case-fold-search          |

*** Spelling

| /M-$/                    | check spelling word              |
| /M-x flyspell-prog-mode/ | enabl/disabl Flyspell comments   |
| /M-//                    | complete partial word            |
| /M-/                     | corrects misspelled word         |
| /M-x ispell-change-dict/ | ispell change dictionary         |
| /M-x ispell-region/buff/ | spellcheck active region/current |

| /x/      | quit spellcheck, moveback cursor start position |
| /r word/ | replaces current word while spellchecking       |
| /?/      | display other options                           |
| /i/      | accept spelling and add to dictionary           |
| /q/      | quit                                            |
| /a/      | accept spelling for all buffers                 |
| /X/      | halt at current location                        |

*** Occur

| /RET/     | occur-mode-goto-occurrence    |
| /C-o/     | occur-mode-display-occurrence |
| /c/       | clone-buffer                  |
| /e/       | occur-edit-mode               |
| /g/       | revert-buffer                 |
| /h/       | describe-mode                 |
| /o/       | occur-mode-goto other window  |
| /q/       | quit-window                   |
| /r/       | occur-rename-buffer           |
| /DEL/     | scroll-down-command           |
| /C-c C-c/ | occur-mode-goto-occurrence    |
| /C-c C-c/ | Return to Occur mode          |

*** Help

| /C-h x/      | describe-command               |
| /C-h f/      | describe-function              |
| /C-h v/      | describe-variable              |
| /C-h k/      | describe-key                   |
| /C-h m/      | describe-mode                  |
| /C-h b/      | describe-bindings              |
| /C-u M-x/    | embark-bindings                |
|            |                                |
| /C-h c/      | describe-key-briefly           |
| /C-h s/      | describe-syntax                |
| /C-h P/      | describe-package               |
| /C-h o/      | describe-symbol                |
|            | describe-keymap                |
|            | customize-variable             |
|            |                                |
| /C-h l/      | view-lossage (last input keys) |
| /C-h a/      | counsel-apropos(pattern)       |
| /C-h e/      | view-echo-area-messages        |
| /C-h w/      | where-is                       |
|            |                                |
| /C-h C-q/    | help-quick-toggle              |
| /prefix C-h/ | display which-key bindings     |
|            |                                |
| /C-h C-h/    | help-for-help                  |
| /cmd C-h/    | what valid keys follow cmd     |
| /M-./        | xref-find-definition(cursor)   |

** IDE
*** Eglot
**** Commands

|   | eglot-find-declaration    |
|   | eglot-find-implementation |
|   | eglot-find-typeDefinition |
|   |                           |
|   | eglot-format              |
|   | eglot-format-buffer       |
|   |                           |
|   | eglot-code-actions        |
|   | eglot-inlay-hints-mode    |
|   | eglot-rename              |

**** Start/Stop

|   | eglot                             |
|   | eglot-reconnect                   |
|   | eglot-shutdown                    |
|   | eglot-shutdown-all                |
|   |                                   |
|   | eglot-events-buffer               |
|   | eglot-stderr-buffer               |

**** Variables

|   | eglot-server-programs             |
|   | eglot-workspace-configuration     |
|   | eglot-diagnostics-map             |
|   |                                   |
|   | eglot-stay-out-of                 |
|   | eglot-ignored-server-capabilities |
|   | eglot-managed-mode-hook           |
|   | eglot-report-progress             |

*** Identifiers (xref)

| /M-./     | xref-find-definitions                  |
| /M-?/     | xref-find-references                   |
| /C-M-./   | xref-find-apropos                      |
| /C-x 4/   | xref-find-definitions-other-window     |
| /C-x 5/   | xref-find-definitions-other-frame      |
|         |                                        |
| /M-,/     | xref-go-back                           |
| /C-M-,/   | xref-go-forward                        |
|         | xref-pop-marker-stack                  |
|         | xref-etags-mode                        |
|         |                                        |
|         | xref-find-references-and-replace       |
|         | xref-query-replace-in-results          |
| /C-u M-x/ | xref-query-replace-in-results (regexp) |
|         |                                        |
|         | tags-search                            |
|         | tags-query-replace                     |
|         | list-tags                              |
|         | tags-next-file                         |

*** Diagnostic (flymake)

|           | flymake-goto-next-error          |
|           | flymake-goto-prev-error          |
|           | flymake-show-buffer-diagnostics  |
|           | flymake-show-project-diagnostics |
| /M-g f/     | consult-flymake                  |
| /C-u M-g f/ | consult-flymake (all buffers)    |
|           |                                  |
|           | flymake-diagnostic-functions     |
|           | flymake-reporting-backends       |
|           | flymake-running-backends         |
|           | flymake-disabled-backends        |

*** Diagnostic (flycheck)

|               | flycheck-set-checker-executable      |
| /C-c ! n/M-g n/ | flycheck-next-error                  |
| /C-c ! p/M-g p/ | flycheck-previous-error              |
| /C-c ! l/       | flycheck-list-errors                 |
|               | flycheck-first-error                 |
|               |                                      |
| /C-c ! e/       | flycheck-explain-error-at-point      |
| /C-c ! c/       | flycheck-buffer                      |
| /C-c ! C/       | flycheck-clear                       |
| /C-u C-c ! C/   | flycheck-clear (interrupt)           |
|               |                                      |
| /C-c ! v/       | flycheck-verify-setup                |
| /C-c ! C-c/     | flycheck-compile                     |
|               |                                      |
| /C-c ! ?/       | flycheck-describe-checker            |
| /C-c ! s/       | flycheck-select-checker              |
| /C-c ! x/       | flycheck-disable-checker             |
|               |                                      |
|               | flycheck-disabled-checkers (list)    |
|               | flycheck-checkers (list)             |
|               | flycheck-checker                     |
|               |                                      |
|               | flycheck-local-config-file-functions |
|               | flycheck-config-files (customize)    |

*** Documentation (eldoc)

|   | eldoc                           |
|   | eldoc-doc-buffer                |
|   | eldoc-print-current-symbol-info |

*** Navigation (imenu)

| /M-g i/ | imenu |

*** Completion

| /C-M-i/M-TAB/ | completion-at-point |

*** lsp-mode
**** Lsp

|         | lsp                            |
| /C-u M-x/ | lsp (prompt server)            |
|         | lsp-deferred                   |
|         | lsp-rename                     |
|         | lsp-format-region              |
|         | lsp-format-buffer              |
|         | lsp-execute-code-action        |
|         | lsp-headerline-breadcrumb-mode |

**** Code navigation

|   | lsp-find-definition          |
|   | lsp-find-references          |
|   | lsp-ui-peek-find-definitions |
|   | lsp-ui-peek-find-references  |

**** Treemacs

|         | lsp-treemacs-errors-list               |
|         | lsp-treemacs-symbols                   |
|         | lsp-treemacs-references                |
|         | lsp-treemacs-implementations           |
|         | lsp-treemacs-call-hierarchy            |
| /C-u M-x/ | lsp-treemacs-call-hierarchy (outgoing) |
|         | lsp-treemacs-type-hierarchy            |
|         | lsp-treemacs-deps-list                 |

**** Help

|   | lsp-doctor                   |
|   | lsp-describe-session         |
|   | lsp-ui-doc-focus-frame       |
|   | lsp-ui-doc-unfocus-frame     |
|   | lsp-register-custom-settings |

** Code
*** Navigation

| /C-M-f/      | forward-sexp              |
| /C-M-b/      | backward-sexp             |
|            |                           |
| /C-M-d/down/ | down-list                 |
| /C-M-u/up/   | backward-up-list          |
|            |                           |
| /C-M-a/      | beginning-of-defun        |
| /C-M-e/      | end-of-defun              |
| /C-M-h/      | mark-defun                |
| /M-m/        | back-to-indentation       |
|            |                           |
| /C-M-k/      | kill-sexp                 |
| /C-M-t/      | transpose-sexp            |
| /C-M-SPC/    | mark-sexp                 |
| /C-M-z/      | paredit-wrap-sexp         |
| /C-=/        | er/expand-region          |
|            | /=/ expand again /-/ contract |
|            |                           |
| /M-s/        | paredit-splice-sexp       |
| /M-J/        | paredit-join-sexp         |
| /M-;/        | paredit-comment-dwim      |

*** Evaluate

| /C-x C-e/     | eval-last-expression    |
| /C-u C-x C-e/ | eval-print-last-sexp    |
| /C-M-x/       | eval-defun (within)     |
| /M-:/         | eval-expression (print) |
|             | eval-region             |
|             | eval-buffer             |
| /ielm/        | emacs lisp shell (REPL) |

*** Html
**** Create

| /C-c C-t/   | sgml-tag                |
|           | web-mode-element-insert |
| /C-c RET/   | html-paragraph          |
| /C-c d/     | html-div                |
| /C-c 1/     | html-headline-1         |
| /C-c 2/     | html-headline-2         |
|           | web-mode-element-wrap   |
|           | web-mode-snippet-insert |
|           |                         |
|           | web-mode-file-link      |
| /C-c C-c h/ | html-href-anchor        |
| /C-c C-c n/ | html-name-anchor        |
| /C-c C-c #/ | html-id-anchor          |
| /C-c C-c i/ | html-image              |
| /C-c C-c u/ | html-unordered-list     |
| /C-c C-c o/ | html-ordered-list       |
| /C-c C-c l/ | html-list-item          |

**** Edit

| /C-c //   | sgml-close-tag          |
| /C-c C-a/ | sgml-attributes         |
|         | web-mode-element-rename |
|         | web-mode-element-kill   |
|         | web-mode-buffer-indent  |

**** Navigate

| /C-c C-b/ | sgml-skip-tag-backward    |
| /C-c C-f/ | sgml-skip-tag-forward     |
| /C-c C-d/ | sgml-delete-tag           |
|         | web-mode-navigate         |
|         | web-mode-element-previous |
|         | web-mode-element-next     |

**** Mark

|         | mc/mark-sgml-tag-pair   |
|         | er/mark-html-attribute  |
|         | web-mode-fold-or-unfold |
| /C-c TAB/ | sgml-tags-invisible     |

**** Browser

| /C-c C-v/ | browse-url-of-buffer         |
|         | browse-url-of-region         |
|         | browse-url-of-firefox        |
|         | impatient-mode               |
|         | run-skewer                   |
|         | skewer-mode                  |
|         | skewer-html-mode             |
|         | js2-mode                     |
|         | skewer-repl                  |
|         |                              |
| /C-x C-e/ | Evaluatebeforepoint          |
| /C-M-x/   | Evaluatetop-levelaroundpoint |
| /C-c C-k/ | Loadthecurrentbuffer         |
| /C-c C-z/ | SelecttheREPLbuffer          |

*** Debug

| /M-x debu func/  | debug-on-entry (d)           |
|                | cancel-debug-on-entry        |
| /M-x edebu func/ | edebug-defun(within/next to) |
| /C-x C-e/        | to revaluate & cancel edebug |

*** dape

| /C-c d d/ | dape                       |
| /C-c d r/ | dape-restart               |
|         |                            |
| /C-c d b/ | dape-breakpoint-toggle     |
| /C-c d B/ | dape-breakpoint-remove-all |
| /C-c d e/ | dape-breakpoint-expression |
| /C-c d h/ | dape-breakpoint-hits       |
| /C-c d l/ | dape-breakpoint-log        |
|         |                            |
| /C-c d w/ | dape-watch-dwim            |
| /C-c d x/ | dape-evaluate-expression   |
|         |                            |
| /C-c d c/ | dape-continue              |
| /C-c d n/ | dape-next                  |
| /C-c d o/ | dape-step-out              |
| /C-c d s/ | dape-step-in               |
| /C-c d p/ | dape-pause                 |
| /C-c d d/ | dape-quit                  |
| /C-c d D/ | dape-disconnect-quit       |
|         |                            |
| /C-c d R/ | dape-repl                  |
| /C-c d i/ | dape-info (windows)        |
|         | dape-configs               |

*** dap-mode
**** Start

|   | dap-debug               |
|   | dap-debug-last          |
|   | dap-debug-recent        |
|   | dap-debug-edit-template |
|   | dap-go-to-output-buffer |

**** Breakpoints

|     | dap-breakpoint-toggle                        |
|     | dap-breakpoint-delete                        |
|     | dap-breakpoint-add                           |
|     | dap-breakpoint-condition                     |
|     | dap-breakpoint-hit-condition                 |
|     | dap-breakpoint-log-message                   |
|     |                                              |
| /RET/ | dap-ui-breakpoints-goto (cursor)             |
| /d/   | dap-ui-breakpoints-delete (cursor)           |
| /D/   | dap-ui-breakpoints-delete-selected           |
| /m/   | bui-list-mark (breakpoint under point)       |
| /u/   | bui-list-unmark (breakpoint under point)     |
| /U/   | bui-list-unmark-all (breakpoint under point) |

**** Navigation

|   | dap-continue           |
|   | dap-next               |
|   | dap-step-out           |
|   | dap-step-in            |
|   | dap-disconnect         |
|   |                        |
|   | dap-stop-thread        |
|   | dap-restart-frame      |
|   |                        |
|   | dap-switch-stack-frame |
|   | dap-switch-thread      |
|   | dap-switch-session     |

**** Windows

|   | dap-ui-locals             |
|   | dap-ui-sessions           |
|   | dap-ui-breakpoints        |
|   | dap-ui-expressions        |
|   | dap-ui-repl               |
|   |                           |
|   | dap-ui-show-many-windows  |
|   | dap-ui-hide-many-windows  |
|   |                           |
|   | dap-ui-expressions-add    |
|   | dap-ui-expressions-remove |
|   |                           |
|   | dap-tm-loaded-sources     |

**** Evaluating

|   | dap-eval                |
|   | dap-eval-region         |
|   | dap-eval-thing-at-point |

** Shells - Terms
*** Eshell

| /M-r/            | eshell history           |
| /M-n/            | eshell-next-matching     |
| /M-p/            | eshell-previous-matching |
| /C-c C-n/        | eshell-next-prompt       |
| /C-c C-p/        | eshell-previous-prompt   |
| /C-c C-l/        | eshell-list-history      |
|                | counsel-esh-history      |
| /C-2 M-x eshell/ | open second eshell       |

*** Terms

| /emacs -q/               | open without load init file       |
| /emacs -q -l path/       | open with differen init file      |
| /emacs -nw/              | open in terminal                  |
| /emacs -Q -nw/           | open in terminal vanilla          |
| /emacs --user/           | open user diferent file           |
| /emacs --no-desktop/     | open without last session file    |
|                        |                                   |
| /emacs --no-site-file/   | dont load site-wide site-start.el |
| /emacs --load="path"/    | execute the elisp file at path    |
| /emacs --batch --load/   | dont launch emacs as a editor     |
| /emacs --script path/    | run like --batch with --load=path |
| /emacs --script nam.el/  | run emacs lisp script in shell    |
| /emacs --init-directory/ | run setting user-emacs-directory  |
|                        |                                   |
| /C-x C-c/                | save-buffers-kill-terminal        |
| /M-!/                    | shell-command                     |
| /C-u M-!/                | shell cmd(sameBuffer)             |
|                        |                                   |
|                        | /VTERM/                             |
| /C-n/                    | next command                      |
| /C-p/                    | previous command                  |
| /C-2 M-x vterm/          | open different vterm              |
|                        |                                   |
|                        | /TERM/                              |
| /C-c C-k/                | char-mode                         |
| /C-c C-j/                | line-mode                         |
| /C-2 M-x term/           | open different term               |

** Miscellaneous
*** Register

| /C-x r s/   | copy-to-register             |
| /C-x r r/   | copy-rectangle-to-register   |
| /C-x r n/   | number-to-register           |
| /C-x r SPC/ | point and buffer to register |
|           |                              |
| /C-x C-k x/ | kmacro-to-register           |
| /C-x r w/   | window to-register           |
| /C-x r f/   | frameset-to-register         |
|           |                              |
| /C-x r SPC/ | point-to-register            |
| /C-x r j/   | jump-to-register             |
| /C-x r i/   | insert-register              |
|           |                              |
| /C-x r m/   | bookmark-set                 |
| /C-x r l/   | bookmark-bmenu-list          |
| /C-x r b/   | counsel-bookmark             |
|           | bookmark-save                |

*** Bookmarks

| /C-x r m/ | bookmark-set              |
| /C-x r m/ | bookmark-set (with name)  |
| /C-x r M/ | bookmark-set-no-overwrite |
| /C-x r b/ | bookmark-jump             |
| /C-x r l/ | list-bookmark             |
|         | bookmark-save             |
|         |                           |
| /o/       | other window              |
| /C-o/     | switch other window       |
| /D/       | mark                      |
| /d/       | delete                    |
| /s/       | save                      |
| /r/       | rename                    |
| /x/       | execute                   |
| /a/       | ahow annotation           |
| /m/       | mark                      |

*** Kmacro

| /F3/C-x (/    | kmacro-start-macro(sequence)  |
| /F4/C-x )/    | kmacro-end-or-call-macro      |
|             |                               |
| /C-x e/       | kmacro-end-and-call-macro     |
| /C-u 5 C-x e/ | repeat 5 times kmacro         |
|             |                               |
| /C-x C-k n/   | kmacro-name-last-macro        |
| /C-x C-k C-n/ | kmacro-cycle-ring-next        |
|             |                               |
|             | call-last-kbd-macro (call)    |
|             | name-last-kbd-macro (save)    |
| /M-x name/    | call the macro /name/           |
|             |                               |
| /C-x C-k C-e/ | kmacro-edit-macro             |
| /C-x C-k l/   | kmacro-edit-lossage           |
| /C-x C-k SPC/ | kmacro-step-edit-macro        |
|             |                               |
|             | /STEPS KMACRO FUNCTION CMMD/    |
| /F3/          | start kmacro                  |
| /C-4 M-x/     | call eval-expresion           |
| /F4/          | end kmacro                    |

*** Calc

| /E/        | exp(x)                         |
| /Q/        | sqrt(x)                        |
| /L/        | ln(x)                          |
| /I C/      | arccos(x)                      |
| /S/        | sin(x)                         |
| /B/        | log_b(x)                       |
|          |                                |
| /m d/      | degree mode                    |
| /m r/      | radian mode                    |
| /m a/      | numerical mode                 |
| /m s/      | symbolic mode                  |
| /m f/      | fraction mode                  |
| /m a/ / /'/  | algebraic mode                 |
|          |                                |
| /P/        | pi number                      |
| /pi M-RET/ | pi number (algebraic mode)     |
| /N/        | eval numerical aprox           |
| /$/        | reference index of stack       |
|          | 1: pi/6 -> sin($1) => 1/2      |
| /c r/      | convert degrees radians        |
| /c d/      | convert radians degrees        |
|          |                                |
| /TAB/      | exchange order results         |
| /=/        | eval expressions               |
| /M-RET/    | calc-last-args                 |
| /t d/      | calc-trail-display             |
| /t y/      | calc-trail-yank                |
| /t p/      | calc-trail-previous            |
| /t n/      | calc-trail-next                |
| /t b/      | calc-trail-backwards           |
| /t f/      | calc-trail-forwards            |
| /C-x * q/  | quick-calc                     |
|          |                                |
| /d 0/      | to turn display into decimal   |
| d 2      | to turn display into binary    |
| /d 6/      | to turn display into hexa      |
| /16#FF/    | to turn FF into decimal        |
| /d f 3/    | display 3 digits after decimal |
| /d f 0/    | display 0 digits after decimal |

*** Artist

|             | artist-mode                     |
| /C-c C-c/     | exits artis mode                |
| /C-c C-a p/   | art poly-line                   |
| /RET/         | artist-key-set-point            |
| /C-u RET/     | for final segment               |
|             |                                 |
| /C-c C-a C-o/ | artist-select-operation         |
| /C-c C-a C-f/ | artist-select-fill-char         |
| /C-c C-a C-l/ | artist-select-line-char         |
|             |                                 |
| /C-c C-a C-r/ | artist-toggle-rubber-banding    |
| /C-c C-a C-t/ | artist-toggle-trim-line-endings |
| /C-c C-a C-s/ | artist-toggle-borderless-shapes |
|             |                                 |
| />/           | set unset arrow begin           |
| /</           | set unset arrow end             |
|             |                                 |
| /C-c </       | move left                       |
| /C-c >/       | move right                      |
| /C-c ^/       | move up                         |
| /C-c ./       | move down                       |

*** Characters

| /C-u C-x =/   | what-cursor-position         |
| /C-x 8 RET/   | insert-char                  |
|             | describe-char (cursor)       |
|             |                              |
| /C-q/         | quoted-insert (literaly)     |
| /C-q TAB/     | insert tab char              |
| /C-q C-i/     | insert tab char              |
| /C-q C-[/     | insert escape char           |
| /C-q C-m/     | insert carriage char         |
| /C-q C-j/     | insert Line Feed char        |
|             |                              |
| /\n/          | newline                      |
| /\t/          | tab                          |
| /\r/          | carriage return              |
| /\b/          | backspace                    |
| /\e/          | escape                       |
| /\d/          | delete                       |
| /\f/          | formfeed (control-L)         |
|             |                              |
| /\u3501/      | unicode 3501                 |
| /\C-/         | control                      |
| /\M-/         | meta                         |
| /\M-\C-a/     | Control-Meta-A               |
|             |                              |
| /?x/          |                              |
| /?\n/         |                              |
| /?\"/         |                              |
|             |                              |
| /C-u C-\/     | toggle-input-method (select) |
|             | toggle-input-method (toggle) |
| /C-S-e <SPC>/ | emoticons                    |
| /C-x 8 e e/i/ | emoji-insert                 |
| /C-x 8 e s/   | emoji-search                 |
| /C-x 8 e l/   | emoji-list                   |
| /C-x 8 e d/   | emoji-describe               |

*** Keys

|            | /KEY OVERVIEW/                         |
| /M-x/        | command by name                      |
| /C-letter/   | frequently command                   |
| /M-letter/   | less frequently cmd                  |
| /C-x .../    | globally command                     |
| /C-c .../    | major-mode command                   |
| /C-h .../    | help or info                         |
| /C-M .../    | lisp coding command                  |
|            |                                      |
|            | /AVOID KEYBINDING/                     |
| /C-?/        | due technical implementation         |
| /F1/ / /C-h/   | special status emacs help system     |
| /ESC/ / /C-[/  | ESC is tied C-[ complicated meanings |
| /C-S-letter/ | in text terminal cannot distinguish  |
| /C-m/ / /RET/  | these are tied together              |
| /C-j/ / /TAB/  | these are tied together              |
|            |                                      |
|            | /KEY SPACE FOR USERS/                  |
| /F5/ - /F9/    |                                      |
| /C-c letter/ |                                      |

*** Misc

| /C-x z/     | repeat                             |
|           |                                    |
| /M-x/       | execute- extend-command            |
| /M-S-x/     | execute- extend-command-for-buffer |
|           |                                    |
| /C-x -/ / /+/ | zoom-in/out                        |
| /F10/       | menu-bar-open                      |
| /ESC x/     | same /M-x/ in no GUI term            |
|           |                                    |
| /C-x C-c/   | finish-sesion                      |
| /C-x C-c/   | save-buffers-kill-terminal         |
|           | save-buffers-kill-emacs            |

* Functions-
** buffer-
*** current-buffer
Return the buffer in which Emacs is active; it may not be the buffer that is visible on the screen.

*** buffer-name
Without an argument, return the name of the buffer, as a string.

*** buffer-file-name
Without an argument, return the name of the file the buffer is visiting.

*** other-buffer
Return the most recently selected buffer.

*** switch-to-buffer
Select a buffer for Emacs to be active in and display it in the current window so users can look at it.

*** find-file-noselect
Reads the named file into a buffer and returns the buffer.

Ãtil para cuando se le pasa el nombre de un archivo como argumento a una funciÃ³n y esta retorna el nombre del buffer, con este nombre se puede setear el buffer con la funciÃ³n  [[set-buffer]] y asÃ­ trabajar temporalmente en ese buffer.

#+begin_src emacs-lisp

  (defun lengths-list-file (filename)
    "Return list of definitions' lengths within FILE.
  The returned list is a list of numbers.
  Each number is the number of words or
  symbols in one function definition."

    (message "Working on `%s' ... " filename)
    (save-excursion
      (let ((buffer (find-file-noselect filename))
            (lengths-list))
        (set-buffer buffer)
        (setq buffer-read-only t)
        (widen)
        (goto-char (point-min))
        (while (re-search-forward "^(defun" nil t)
          (setq lengths-list
                (cons (count-words-in-defun) lengths-list)))
        (kill-buffer buffer)
        lengths-list)))

  (lengths-list-file
   "/usr/share/emacs/27.1/lisp/emacs-lisp/lisp.el.gz")
  ;; => (110 42 118 112 39 50 80 255 239 278 285 37 ...)

#+end_src

*** set-buffer
Switch the attention of Emacs to another buffer, but does not redisplay it on the screen.

Para trabajar temporalmente en otro buffer, cambia la atencion al buffer que
se le indique pero no lo muestra en pantalla, trabaja en segundo plano por asÃ­ decirlo.

*** get-buffer
Find a named buffer or create one if a buffer of that name does not exist. The get-buffer function returns nil if the named buffer does not exist.

*** get-buffer-create
Return the buffer specified by BUFFER-OR-NAME, creating a new one if needed.

*** save-buffer
Save current buffer in visited file if modified.

#+begin_src emacs-lisp

  ;; Example:
  ;; Given a file of many lines, like this:

  ;; at_target(integer tnum, vector targetpos, vector ourpos)

  ;; For each line, create a file of the same name as first part of
  ;; the line â¢ for example: ãat_target.txtã
  ;; The file content should be the whole line, with other static
  ;; text, like this:

  ;; # --
  ;; at_target(integer tnum, vector targetpos, vector ourpos)
  ;; {
  ;; $0
  ;; }


  ;; First, we define few global vars.
  ;; input file
  (setq inputFile "xx_event_forms.txt")

  ;; other vars
  (setq splitPos 0) ;; cursor position of split, for each line
  (setq fName "")
  (setq restLine "")
  (setq moreLines t ) ;; whether there are more lines to parse

  ;; Now, we open the file, like this:
  ;; open the file
  (find-file inputFile)
  (goto-char 1) ;; needed in case the file is already open.

  ;; Now, we loop thru the lines, like this:
  (while moreLines
    (search-forward "(")

    (setq splitPos (1- (point)))
    (beginning-of-line)
    (setq fName (buffer-substring-no-properties (point) splitPos))

    (end-of-line)
    (setq restLine (buffer-substring-no-properties splitPos (point) ))

    ;; create the file
    (find-file fName)
    (insert "# --\n")
    (insert fName restLine "\n{\n$0\n}" )
    (save-buffer)
    (kill-buffer (current-buffer)) ;; close the input file

    (setq moreLines (= 0 (forward-line 1))))

#+end_src

*** with-current-buffer
Temporarily sets a buffer as current to work with. Execute the forms in BODY with BUFFER-OR-NAME temporarily current

Notes: ~find-file~, ~write-file~, or any function that visits a file has many unwanted side-effects, and it can be up to 40 times slower. Here's example of side-effects:

- It keeps undo info.
- It syntax color the buffer.
- It displays the file. (very slow if you have ~global-linum-mode~, etc.)
- It may have tons of hooks added by others. (~desktop-save-mode~, ~recentf-mode~, ~tabbar-mode~, ~snippet-mode~ (~yasnippet~), â¦)
- It may do backup.

#+begin_src emacs-lisp

  (with-current-buffer "xyz"
    ;; do something here. delete/insert text, etc.
    )

#+end_src

*** with-temp-buffer
Create a temporary buffer, and evaluate BODY there like progn.

Elisp has a buffer data type that's powerful and flexible, and you have over 3 thousand functions that acts on text in a buffer. When you have a string, and you need to do more than just getting substring or number of chars, put it in a temp buffer.

Notes:
- with temp buffer, emacs doesn't do syntax-coloring (which is very slow), disables undo, or any other thing emacs normally do when opening a file for interactive edit.
- I think the difference between ~with-temp-buffer~ and ~with-output-to-temp-buffer~ is that latter works inside the buffer and then outputs the result in that buffer while the other just works inside the buffer but then kills the buffer.

#+begin_src emacs-lisp

  ;; process string in a temp buffer
  (setq myStr "some big string here you need to process")
  (setq myStrNew
        (with-temp-buffer
          (insert myStr)
          ;; code to manipulate your string as buffer text
          ;; â¦
          (buffer-string))) ; get result


  ;; read-only processing a file without user interaction
  (defun my-process-file (fPath)
    "Process the file at path FPATH â¦"
    (with-temp-buffer fPath
                      (insert-file-contents fPath)
                      ;; process it â¦
                      ) )

  ;; write to file ONLY when you actually changed the file
  (defun my-process-file (fPath)
    "Process the file at path FPATH â¦"
    (let ((fileChanged-p nil))
      (with-temp-buffer
        (insert-file-contents fPath)

        ;; process text
        ;; set fileChanged-p to t or nil

        (when fileChanged-p (write-region 1 (point-max) fPath)))))

#+end_src

*** with-output-to-temp-buffer
Bind standard-output to buffer BUFNAME, eval BODY, then show that buffer.

Note: I think the difference between ~with-temp-buffer~ and ~with-output-to-temp-buffer~ is that latter works inside the buffer and then outputs the result in that buffer while the other just works inside the buffer but then kills the buffer.

#+begin_src emacs-lisp

  ;; Example script

  ;; -*- coding: utf-8 -*-
  ;; 2010-11-03
  ;; add ãtitle="product title"ã to amazon links on a HTML page.


  ;; Example:
  ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20">amazon</a>
  ;; =>
  ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20" title="Dr. Strangelove; movie">amazon</a>


  ;; rough steps:
  ;; find amazon link of the form
  ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20">amazon</a>

  ;; find a Wikipedia link above it, of this form
  ;; <a href="http://en.wikipedia.org/wiki/Dr._Strangelove">Dr. Strangelove</a>
  ;; extract the movie title

  ;; insert the attribute
  ;; title="â¦"
  ;; into the amazon link. Like this
  ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20" title="Dr. Strangelove; movie">amazon</a>

  (setq outputBuffer "*xah output*" )
  (with-output-to-temp-buffer outputBuffer

    (find-file "~/web/xahlee_org/Periodic_dosage_dir/skina/nelci_skina.html" )
    (goto-char 1)

    (while
        (search-forward-regexp "<a class=\"amz\" href=\"http://www.amazon.com/dp/[^\"]+?\">amazon</a>"  nil t)

      (progn
        ;; set points for amazon link
        (backward-char 11)
        (setq amzLinkInsertPoint (point) )

        ;; get title from preceding Wikipedia link
        (search-backward-regexp
         "<a href=\"http://...wikipedia.org/wiki/[^\"]+?\">\\([^<]+?\\)</a>")
        (setq titleText (match-string 1 ) )

        (when (yes-or-no-p titleText)
          (goto-char amzLinkInsertPoint)
          (insert (concat " title=\"" titleText "; movie\"")) )
        )

      (progn (print "not found"))
      )

    (princ "Done deal!")
    )

#+end_src

*** buffer-size
Return the number of characters in the current buffer.

*** buffer-string
This function returns the contents *of the entire accessible portion* of the current buffer, as a string.

#+begin_src emacs-lisp

  (defun get-string-from-file (filePath)
    "Return filePath's file content."
    (with-temp-buffer
      (insert-file-contents filePath)
      (buffer-string)))

#+end_src

*** buffer-substring
Return the contents of part of the current buffer as a string.

#+begin_src emacs-lisp

  ;; ---------- Buffer: foo ----------
  ;; This is the contents of buffer foo
  ;;
  ;; ---------- Buffer: foo ----------

  (buffer-substring 1 10)
  ;; => "This is t"

  (buffer-substring (point-max) 10)
  ;; => "he contents of buffer foo\n"

#+end_src

If the text being copied has any text properties, these are copied into the string along with the characters they belong to. However, overlays (see Overlays) in the buffer and their properties are ignored, not copied.

For example, if Font-Lock mode is enabled, you might get results like these:

#+begin_src emacs-lisp

  (buffer-substring 1 10)
  ;; => #("This is t" 0 1 (fontified t) 1 9 (fontified t))

#+end_src

*** buffer-substring-no-properties
Emacs's string can have text properties for the purposes of syntax coloring, button, clickable link, etc. if you are doing text processing, usually you don't need text properties.

The ~buffer-substring-no-properties~ function just return a plain string without these properties.

Note: most function that take string as argument can also accept a string that has properties. The function simply ignore the properties.

#+begin_src emacs-lisp

  ;; get the string from buffer
  (setq myStr (buffer-substring-no-properties startPos endPos))

  (defun xah/html-get-html-file-title (fname)
    "Return FNAME <title> tag's text.
  Assumes that the file contains the string
  â<title>â¦</title>â."
    (with-temp-buffer
      (insert-file-contents fname nil nil nil t)
      (goto-char 1)
      (buffer-substring-no-properties
       (search-forward "<title>") (- (search-forward "</title>") 8))))

#+end_src

*** insert-buffer-substring
Copy a region of text from a buffer that is passed to the function as an
argument and insert the region into the current buffer.

*** mark-whole-buffer
Mark the whole buffer as a region.

*** buffer-modified-p
Return t if BUFFER was modified since its file was last read or saved.

*** ibuffer
Begin using Ibuffer to edit a list of buffers.

*** bufferp
Return t if its argument is a buffer; otherwise return nil.

** string-
*** message
Print a message in the echo area. The first argument is a string that can contain ~%s~, ~%d~, or ~%c~ to print the value of arguments that follow the string.

- %s :: must be a string or a symbol
- %d :: must be a number
- %c :: must be an ASCII code number; it will be printed as the character with that ASCII code

If there is more than one ~%s~ in the quoted string, the value of the first argument following the quoted string is printed at the location of the first ~%s~ and the value of the second argument is printed at the location of the second ~%s~ and so on.

#+begin_src emacs-lisp

  (message "The name of this buffer is: %s." (buffer-name))
  ;; => "The name of this buffer is: Emacs.org."


  (message "There are %d %s in the office!"
           (- fill-column 14) "pink elephants")
  ;; => "There are 56 pink elephants in the office!"


  (message "%s has %d line%s, %d word%s, and %d character%s."
           str
           lines (if (= lines 1) "" "s")
           words (if (= words 1) "" "s")
           chars (if (= chars 1) "" "s"))
  ;; => "Region has 5 lines, 26 words, and 167 characters."

#+end_src

*** format
How a lisp object is converted to string for printing is done by the ~format~ function. It takes a input string, and several other arguments of lisp objects, and output a string.

#+begin_src emacs-lisp

  ;; print a date format in yyyy-mm-dd, padding with leading â0â
  ;; format yyyy-mm-dd, ISO 8601 format
  (print (format "%04d-%02d-%02d" 2012 4 10))
  ;; -> "2012-04-10"

  ;; %x means print a number in hex.
  (format "%04x" 1) ;; => "0001"
  (format "%02x" 1) ;; => "01"
  (format "%01x" 1) ;; => "1"
  (format "%x"   1) ;; => "1"
  (format "%1x"  1) ;; => "1"
  (format "%2x"  1) ;; => " 1"
  (format "%4x"  1) ;; => "   1"

  (defun xah/insert-random-uuid ()
    "Insert a random UUID.
  Example of a UUID: 1df63142-a513-c850-31a3-535fc3520c3d

  WARNING: this is a simple implementation. The chance of generating
  the same UUID is much higher than a robust algorithm.."
    (interactive)
    (insert
     (format "%04x%04x-%04x-%04x-%04x-%06x%06x"
             (random (expt 16 4))
             (random (expt 16 4))
             (random (expt 16 4))
             (random (expt 16 4))
             (random (expt 16 4))
             (random (expt 16 6))
             (random (expt 16 6)))))


  (defun wikipedia-url-to-link (url)
    "Return the URL as HTML link string.
  Example:
   http://en.wikipedia.org/wiki/Emacs%20Lisp
  becomes
   <a href=\"http://en.wikipedia.org/wiki/Emacs%20Lisp\">Emacs Lisp</a>
  "
    (let ((linkText url))
      ;; ...
      (format "<a href=\"%s\">%s</a>" url linkText)))


  ;; How to convert between Decimal and Hexadecimal.
  (format "%x" 10)  ; decimal to hex. Returns ãaã
  (format "%d" #xa) ; hex ãaã to decimal. Returns ã10ã.

#+end_src

*** print
Output the printed representation of OBJECT, with newlines around it.

The âOBJECTâ is any elisp object you want to print. It can be any lisp datatype, such as string, number, list, buffer, frame, â¦, etc.

Note: output can be read back by function ~read~.

There're also other similar functions:
~prin1~ like ~print~, but does not add newline at end.
~princ~ print without newline nor delimiters. For human reading.

#+begin_src emacs-lisp

  (print '("x" "y")) ;; => ("x" "y")
  (princ '("x" "y")) ;; => (x y)
  (prin1 '("x" "y")) ;; => ("x" "y")

#+end_src

*** princ
Output the printed representation of OBJECT, any Lisp object.

#+begin_src emacs-lisp

  ;; -*- coding: utf-8 -*-
  ;; 2011-07-15
  ;; go thru a file, check if all brackets are properly matched.
  ;; â¢ for example: good: (â¦{â¦}â¦ ââ¦ââ¦)
  ;; bad: ( [)]
  ;; bad: ( ( )

  (setq inputFile "xx_test_file.txt" ) ; a test file.
  (setq inputDir "~/web/xahlee_org/p/time_machine/") ; must end in slash

  (defvar matchPairs '() "a alist. For each pair,
  the car is opening char, cdr is closing char.")
  (setq matchPairs '(
                     ("(" . ")")
                     ("{" . "}")
                     ("[" . "]")
                     ("â" . "â")
                     ("â¹" . "âº")
                     ("Â«" . "Â»")
                     ("ã" . "ã")
                     ("ã" . "ã")
                     ("ã" . "ã")
                     ("ã" . "ã")
                     ("ã" . "ã")
                     ("ã" . "ã")
                     )
        )

  (defvar searchRegex "" "regex string of all pairs to search.")
  (setq searchRegex "")
  (mapc
   (lambda (mypair) ""
     (setq searchRegex (concat searchRegex (regexp-quote (car mypair)) "|"
                               (regexp-quote (cdr mypair)) "|") )
     )
   matchPairs)

  (setq searchRegex (substring searchRegex 0 -1)) ; remove the ending â|â

  (setq searchRegex (replace-regexp-in-string "|" "\\|" searchRegex t t))
  ; change | to \\| for regex âorâ operation

  (defun my-process-file (fPath)
    "Process the file at FPATH â¦"
    (let (myBuffer myStack Î¾char Î¾pos)

      (setq myStack '() ) ; each entry is a vector [char position]
      (setq Î¾char "") ; the current char found

      (when t
  ;; (not (string-match "/xx" fPath)) ; in case you want to skip certain files

        (setq myBuffer (get-buffer-create " myTemp"))
        (set-buffer myBuffer)
        (insert-file-contents fPath nil nil nil t)

        (goto-char 1)
        (while (search-forward-regexp searchRegex nil t)
          (setq Î¾pos (point)  )
          (setq Î¾char (buffer-substring-no-properties Î¾pos (- Î¾pos 1))  )

  ;; (princ (format "-----------------------------\nfound char: %s\n" Î¾char) )

          (let ((isClosingCharQ nil) (matchedOpeningChar nil) )
            (setq isClosingCharQ (rassoc Î¾char matchPairs))
            (when isClosingCharQ (setq matchedOpeningChar
                                       (car isClosingCharQ) ) )

  ;; (princ (format "isClosingCharQ is: %s\n" isClosingCharQ) )
  ;; (princ (format "matchedOpeningChar is: %s\n" matchedOpeningChar) )

            (if
                (and
                 (car myStack) ; not empty
                 (equal (elt (car myStack) 0) matchedOpeningChar )
                 )
                (progn
  ;; (princ (format "matched this top item on stack: %s\n" (car myStack)) )
                  (setq myStack (cdr myStack) )
                  )
              (progn
;; (princ (format "did not match this top item on stack: %s\n" (car myStack)) )
                (setq myStack (cons (vector Î¾char Î¾pos) myStack) ) )
              )
            )
          ;; (princ "current stack: " )
          ;; (princ myStack )
          ;; (terpri )
          )

        (when (not (equal myStack nil))
          (princ "Error file: ")
          (princ fPath)
          (print (car myStack) )
          )
        (kill-buffer myBuffer)
        )
      ))

  (require 'find-lisp)

  (let (outputBuffer)
    (setq outputBuffer "*xah match pair output*" )
    (with-output-to-temp-buffer outputBuffer
      ;; (my-process-file inputFile) ; use this to test one one single file
      (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
                                          ; do all HTML files
      (princ "Done deal!")))

#+end_src

*** insert
Insert the arguments, either strings or characters, at point.

#+begin_src emacs-lisp

  ;; insert string at current cursor position
  (insert "i â¥ cats")

#+end_src

*** insert-char
Insert COUNT copies of CHARACTER.

*** delete-char
Delete the following N characters (previous if N is negative).

*** concat
Links together or unites two or more strings of text to produce a string. The arguments are strings.

#+begin_src emacs-lisp

  (concat "a" "b") ;; => "ab"

#+end_src

*** substring
The function returns a substring of the first argument. This function takes three arguments. Its first argument is the string of characters, the second and third arguments are numbers that indicate the beginning (inclusive) and end (exclusive) of the substring.

You can think of the substring function as a kind of atom smasher since it takes an otherwise indivisible atom (string) and extracts a part.

#+begin_src emacs-lisp

  (substring "The quick brown fox jumped." 16 19) ;; => "fox"

#+end_src

*** split-string
Split STRING into substrings bounded by matches for SEPARATORS.

#+begin_src emacs-lisp

  (defun read-lines (filePath)
    "Return a list of lines of a file at filePath."
    (with-temp-buffer
      (insert-file-contents filePath)
      (split-string (buffer-string) "\n" t)))

  ;; Once you have a list, you can use mapcar to process each element in
  ;; the list. If you don't need the resulting list, use mapc.

  ;; Note: in elisp, it's more efficient to process text in a buffer than
  ;; doing complicated string manipulation with string data type. But, if
  ;; your lines are all short and you don't need to know the text that
  ;; comes before or after current line, then, list of lines can be easier
  ;; to work with.

#+end_src

*** string-fill
Try to word-wrap STRING so that no lines are longer than LENGTH.

*** string-match
Returns the *index* of the start of the first match for the regular expression regexp in string, or ~nil~ if there is no match. If start is non-~nil~, the search starts at that index in string.

#+begin_src emacs-lisp

  (string-match
   "quick" "The quick brown fox jumped quickly.")   ;; => 4

  (string-match
   "quick" "The quick brown fox jumped quickly." 8) ;; => 27

  (defun xah/drop-last-slashed-substring (path)
    "Drop the last path separated by â/â.
  For example:
  â/a/b/c/dâ â â/a/b/câ
  â/a/b/c/d/â â â/a/b/c/dâ
  â/â â ââ
  â//â â â/â
  ââ â ââ"
    (if (string-match "\\(.*/\\)+" path)
        (substring path 0 (1- (match-end 0)))
      path))

#+end_src

*** search-forward
Search for a *string*, and if the string is found, *move point*. With a regular expression, use the similar [[re-search-forward]].

~search-forward~ and ~re-search-forward~ take four arguments:

1. The string or regular expression to search for.
2. Optionally, the limit of the search.
3. Optionally, what to do if the search fails, return nil or an error message.
4. Optionally, how many times to repeat the search; if negative, the search goes backwards.

Note: Due the way computers are built, the Lisp interpreter may treat a single character as being different from a string of characters. Inside the computer, a single character has a different electronic format than a string of one character. (A single character can often be recorded in the computer using exactly one byte; but a string may be longer, and the computer needs to be ready for this.)

In emacs buffer, newline char is ~\n~. So, you can use ~(search-forward "\n")~ if you really need to find the end of line character.

#+begin_src emacs-lisp

  (search-forward "target-string"
                  limit-of-search
                  what-to-do-if-search-fails
                  repeat-count)


  ;; idiom for string replacement in current buffer;
  (let ((case-fold-search t)) ; or nil

    (goto-char (point-min))
    (while (search-forward "myStr1" nil t) (replace-match "myReplaceStr1"))

    (goto-char (point-min))
    (while (search-forward "myStr2" nil t) (replace-match "myReplaceStr2"))
    ;; repeat for other string pairs
    )
  ;; if you need regexp, use search-forward-regexp


  ;; You want to do more than one pair of find/replace strings
  ;;    & â &amp;
  ;;    < â &lt;
  ;;    > â &gt;
  (defun replace-html-chars-region (begin end)
    "Replace â<â to â&lt;â etc in region."
    (interactive "r")
    (save-restriction
      (narrow-to-region begin end)

      (goto-char (point-min))
      (while (search-forward "&" nil t) (replace-match "&amp;" nil t))

      (goto-char (point-min))
      (while (search-forward "<" nil t) (replace-match "&lt;" nil t))

      (goto-char (point-min))
      (while (search-forward ">" nil t) (replace-match "&gt;" nil t))))

#+end_src

*** search-backward
Search backward from point for STRING. Move cursor to the location of a string, returns the new position.

*** current-word
This function returns the symbol (or word) at or near point, as a string. The return value includes no text properties.

*** symbol-name
Return SYMBOL's name, a string.

*** thing-at-point
Return the thing around or next to point, as a string.

The argument thing is a symbol which specifies a kind of syntactic entity (symbol, list, sexp, defun, filename, url, word, sentence, whitespace, line, page, and others).

~thing-at-point~ does have some annoyances. For example, when getting a line, it'll normally include the newline char "\n", but not if the line is at the end of buffer.

Note: emacs's concept of âsymbolâ is like a âidentifierâ. It usually includes a to z, 0 to 9, underscore â_â, and sometimes hyphen â-â. The exact charset of âsymbolâ depends on current major mode's Syntax Table.

#+begin_src emacs-lisp

  ;; ---------- Buffer: foo ----------
  ;; Gentlemen may cry ``Peaâce! Peace!,''
  ;; but there is no peace.
  ;; ---------- Buffer: foo ----------

  (thing-at-point 'word)
  ;; => "Peace"
  (thing-at-point 'line)
  ;; => "Gentlemen may cry ``Peace! Peace!,''\n"
  (thing-at-point 'whitespace)
  ;; => nil

  (defun xah/print-current-word-and-line ()
    "print current word and line."
    (interactive)
    (message "%s and %s" (thing-at-point 'word))
    (thing-at-point 'line))

  ;; Without thing-at-point
  (defun xah/print-current-word-2 ()
    "print current word."
    (interactive)
    (let (p1 p2)
      (save-excursion
        (skip-chars-backward "-a-z0-9")
        (setq p1 (point))
        (skip-chars-forward "-a-z0-9")
        (setq p2 (point))
        (message "%s" (buffer-substring-no-properties p1 p2)))))

  ;; grab the current âsymbolâ.
  (setq myStr (thing-at-point 'symbol))

  ;; If you are writing PHP reference lookup command, and the cursor is on
  ;; p in print_r($y);, you want to grab the whole âprint_râ not just
  ;; âprintâ.

  ;; Here's a example of PHP reference lookup command that grabs by
  ;; âsymbolâ if there's no active region.
  (defun xah/php-lookup ()
    "Look up current word in PHP ref site in a browser.

  If a region is active (a phrase), lookup that phrase."
    (interactive)
    (let (myWord myUrl)
      (setq myWord
            (if (use-region-p)
                (buffer-substring-no-properties (region-beginning)
                                                (region-end))
              (thing-at-point 'symbol)))
      (setq myUrl
            (concat "http://us.php.net/" myWord))
      (browse-url myUrl)))

#+end_src

*** make-string
Return a newly created string of length LENGTH, with INIT in each element.

#+begin_src emacs-lisp

  (make-string 3 65) ;; => "AAA"

  (make-string 3 ? ) ;; => "   "

#+end_src

*** char-equal
Return t if two characters match, optionally ignoring case.

*** char-before
Return character in current buffer preceding position POS.

Similar functions is ~char-after~.

*** fill-paragraph
Fill paragraph at or after point.

#+begin_src emacs-lisp

  ;; This example shows how to temporarily change a pre-defined variable's
  ;; value, then call a function whose behavior depends on the var.
  (defun remove-line-breaks ()
    "Remove line endings in current paragraph."
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))

#+end_src

*** gnus-url-unhex-string
Remove %XX, embedded spaces, etc in a url.

#+begin_src emacs-lisp

  (require 'gnus-util) ; for gnus-url-unhex-string

  (defun xah/wikipedia-url-to-link (url)
    "Return the URL as HTML link string.
  Example:
   http://en.wikipedia.org/wiki/Emacs%20Lisp
  becomes
   <a href=\"http://en.wikipedia.org/wiki/Emacs%20Lisp\">Emacs Lisp</a>
  "
    (let ((linkText url))
                          ; decode percent encoding. â¢ for example: %20
      (setq linkText (gnus-url-unhex-string linkText nil))
                                          ; get last part
      (setq linkText (car (last (split-string linkText "/"))))
                                          ; low line â space
      (setq linkText (replace-regexp-in-string "_" " " linkText ))
      (format "<a href=\"%s\">%s</a>" url linkText)))

#+end_src

** regexp-
*** looking-at
Return t for true if the text directly following *point* matches the argument, which should be a regular expression.

This function does not move point, but it updates the match data, which you can access using [[match-beginning]] and [[match-end]].

#+begin_src emacs-lisp

  (looking-at "The cat in the hat$") ;; => t
  ;; The cat in the hat comes back" twice.

#+end_src

*** re-search-forward
Search for a *pattern* (regular expression), and if the pattern is found, *move point* to rest just after it. With a string, use the similar [[search-forward]].

~search-forward~ and ~re-search-forward~ take four arguments:

1. A regular expression that specifies the pattern to search for. (Remember to put quotation marks around this argument!)
2. Optionally, the limit of the search.
3. Optionally, what to do if the search fails, return nil or an error message.
4. Optionally, how many times to repeat the search; if negative, the search goes backwards.

#+begin_src emacs-lisp

  (re-search-forward "\*+ *" nil t)
  ;; This function moves ahead of the match string
  ;; (1 or more * and 0 or more blanks) and returns the
  ;; point number or nil in case of no match, instead of error.


  ;; This lets you select current block of text. (a block here is text
  ;; between empty lines.)
  (defun xah/select-current-block ()
    "Select the current block of text between blank lines.
  URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
  Version 2016-07-22"
    (interactive)
    (let (-p1)
      (progn
        (if (re-search-backward "\n[ \t]*\n" nil "move")
            (progn (re-search-forward "\n[ \t]*\n")
                   (setq -p1 (point)))
          (setq -p1 (point)))
        (re-search-forward "\n[ \t]*\n" nil "move"))
      (set-mark -p1)))


  (defun xah/select-block ()
    "Select the current/next block of text between blank lines.
  If region is active, extend selection downward by block.
  URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
  Version 2016-07-22"
    (interactive)
    (if (region-active-p)
        (re-search-forward "\n[ \t]*\n" nil "move")
      (xah-select-current-block)))


  ;; Sometimes when you you write text, you duplicate wordsâas with âyou
  ;; youâ near the beginning of this sentence. I call the function for
  ;; detecting duplicated words, the-the.
  (defun the-the ()
    "Search forward for for a duplicated word."
    (interactive)
    (message "Searching for for duplicated words ...")
    (push-mark)

    ;; This regexp is not perfect
    ;; but is fairly good over all:
    (if (re-search-forward
         "\\b\\([^@ \n\t]+\\)[ \n\t]+\\1\\b" nil 'move)
        (message "Found duplicated word.")
      (message "End of buffer")))

#+end_src

*** search-forward-regexp
Is a function alias and interactive for [[re-search-forward]].

*Xah*
Put your cursor to the right of the closing parenthesis, then call ~eval-last-sexp~. If your regex matches, it'll move cursor to the last char of the matched text. If you get a lisp error saying search failed, then your regex didn't match. If you get a lisp syntax error, then you probably screwed up on the backslashs.

One interesting aspect about ~search-forward-regexp~ is that you must use 2 backslashes to represent one backslash. This is because backslash in emacs string needs a backslash to represent it. Then, this string is passed to emacs's regex engine.

#+begin_src emacs-lisp

  (defun xah/clean-Mathematica-graphics-buffer ()
    "Remove whitespace, truncate numbers, of current buffer of Mathematica graphics file.
  This command does several find/replace on the current buffer.
  Removing spaces, removing new lines, truncate numbers to 3 decimals,
  e.g., 0.123456 -> 0.123.
  \
  \\
  The goal of these replacement is to reduce the file size of a Mathematica Graphics file (.mgs) that are read over the net by JavaView."
    (interactive)

    (goto-char 1)
    (while (search-forward "\n" nil t) (replace-match "" nil t))

    (goto-char 1)
    (while (search-forward-regexp "  +" nil t) (replace-match " " nil t))

    (goto-char 1)
    (while (search-forward ", " nil t) (replace-match "," nil t))

    (goto-char 1)
    (while (search-forward-regexp "\\([0-9]\\)\\.\\([0-9][0-9][0-9]\\)[0-9]+" nil t) (replace-match "\\1.\\2" t nil)))

#+end_src

*** match-beginning
Return the *position* of the start of the text found by the *last* regular expression search.

#+begin_src emacs-lisp

  (let ((case-fold-search nil) p1 p2)
    (re-search-forward "\\([0-9]+\\)")
    (setq p1 (match-beginning 1))
    (setq p2 (match-end 1))
    (buffer-substring-no-properties p1 p2))
  ;; lots sample text 123 abc
  ;; => "123"

#+end_src

*** match-end
Return *position* of end of text matched by *last* search.

#+begin_src emacs-lisp

  (string-match "\\(qu\\)\\(ick\\)"
                "The quick fox jumped quickly.") ;; => 4

  (match-end 1)             ; The end of the match
  ;;   => 6                 ;   with `qu' is at index 6.

  (match-end 2)             ; The end of the match
  ;;   => 9                 ;   with `ick' is at index 9.

#+end_src

*** match-data
Return a list describing what the last search matched.

*** perform-replace
This function is the guts of ~query-replace~ and related commands. It searches for occurrences of from-string and *replaces* some or all of them. If query-flag is ~nil~, it replaces all occurrences; otherwise, it asks the user what to do about each one.

*** replace-match
This function *replaces* the buffer text matched by the last search, with replacement. It applies only to buffers; you can't use ~replace-match~ to replace a substring found with [[string-match]].

To control letter case of the replacement, use the optional arguments in your ~replace-match~ function. To control the letter case of search, locally set ~case-fold-search~ to ~t~ or ~nil~.

#+begin_src emacs-lisp

  (defun replace-greek-region (start end)
    "Replace âalphaâ to âÎ±â and other greek letters in current region."
    (interactive "r")
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (while (search-forward " alpha" nil t) (replace-match " Î±" nil t))
      (goto-char (point-min))
      (while (search-forward " beta" nil t) (replace-match " Î²" nil t))
      (goto-char (point-min))
      (while (search-forward " gamma" nil t) (replace-match " Î³" nil t))))

  ;; remove js links in html file
  (while (search-forward "<script src=\"http://...</script>" nil t)
    (replace-match ""))

#+end_src

*** replace-regexp-in-string
Replace all matches for REGEXP with REP in STRING.

#+begin_src emacs-lisp

  ;; replace that
  ;; <img src="my_cat.png" alt="" width="832" height="513">
  ;; with that
  ;; <img src="my_cat.png" alt="my cat" width="832" height="513">

  ;; give regex search pattern
  ;; (let regexp "<img src=\"\\([^\"]+?\\)\" alt=\"\" width=\"\\([0-9]+\\)\" height=\"\\([0-9]+\\)\">")

  (search-forward-regexp regexp nil t)

  (concat
   "<img src=\""(match-string 1)"\"

   alt=\""(replace-regexp-in-string ".png" ""
      (replace-regexp-in-string "_" " " (match-string 1)))"\"

   width=\""(match-string 2)"\"

   height=\""(match-string 3)"\">"
   )

  ;; To replace this but in all files of a directory do this

  ;; List and Mark Files in Subdirectories

  ;; Call find-dired, then give the dir name, then give -name "*html". The
  ;; result is all HTML files in that dir and subdir. (open files)

  ;; Now, mark the files you want, by calling dired-mark-files-regexp ã%
  ;; mã. Then give the pattern \.html. This marks all HTML files.  Dired
  ;; Query Replace by Regexp (mark files)

  ;; To do regexp replace on dired marked files, call
  ;; dired-do-query-replace-regexp.

#+end_src

*** regexp-quote
This function returns a *regular expression string* that matches exactly string and nothing else. This allows you to request an exact string match when calling a function that wants a regular expression.

#+begin_src emacs-lisp

  (regexp-quote "^The cat$")
  ;; => "\\^The cat\\$"

#+end_src

One use of ~regexp-quote~ is to combine an exact string match with context described as a regular expression. For example, this searches for the string which is the value of string, surrounded by whitespace:

#+begin_src emacs-lisp

  (re-search-forward
   (concat "\\s " (regexp-quote string) "\\s "))

#+end_src

*** skip-chars-forward
Move point forward, stopping before a char not in STRING, or at pos LIM. Returns the distance traveled.

*NOTE:* STRING is like the inside of a [...] in a regular expression except that ] is never special and \ quotes ^, - or \ (but not at the end of a range; quoting is never needed there).
Thus, *with arg "a-zA-Z", this skips letters stopping before first nonletter. With arg "^a-zA-Z", skips nonletters stopping before first letter*.

#+begin_src emacs-lisp

  ;; Placing point (24) just after the expession
  (skip-chars-forward "h")hhhh hhhh
  ;; => 4 (jump first 4 h)
  (skip-chars-forward "h") hhhh hhhh
  ;; => 0 (no match)
  (skip-chars-forward "^h")hhhh hhhh
  ;; => 0 (no match)
  (skip-chars-forward "^h") hhhh hhhh
  ;; => 1 (jump first 1 space)


  (defun xah/select-inside-quotes ()
    "Select text between double straight quotes
  on each side of cursor."
    (interactive)
    (let (p1 p2)
      ;; p1 is set to the position of the double quote to the left of cursor
      (skip-chars-backward "^\"")
      (setq p1 (point))
      (skip-chars-forward "^\"")
      (setq p2 (point))

      (goto-char p1)
      (push-mark p2)
      (setq mark-active t)))


  (defun xah/delete-enclosed-text ()
    "Delete texts between any pair of delimiters."
    (interactive)
    (save-excursion
      (let (p1 p2)
        (skip-chars-backward "^([<>â") (setq p1 (point))
        (skip-chars-forward "^)]<>â") (setq p2 (point))
        (delete-region p1 p2))))

#+end_src

*** skip-chars-backward
Move point backward, stopping after a char not in STRING, or at pos LIM.

#+begin_src emacs-lisp

  ;; turn on highlight selection
  (transient-mark-mode 1)

  (defun xah/select-current-word ()
    "Select the word under cursor.
  âwordâ here is considered any alphanumeric sequence with â_â or â-â."
    (interactive)
    (let (pt)
      (skip-chars-backward "-_A-Za-z0-9")
      (setq pt (point))
      (skip-chars-forward "-_A-Za-z0-9")
      (set-mark pt)))

#+end_src

*** string-match
~(string-match REGEXP STRING &optional START)~

Return index of start of first match for REGEXP in STRING, or nil.

#+begin_src emacs-lisp

  (string-match "i" (system-name)) ;; => 3

  (system-name) ;; => "debian"

#+end_src

*** match-string
Return string of text matched by last search.

Whenever you call regex functions such as [[re-search-forward]], [[string-match]], [[replace-regexp-in-string]], [[search-forward-regexp]], the captured text is stored in ~match-string~.

NUM an is integer.

- 0 means the whole matched text.
- 1 means first captured group.
- 2 means second captured group.
  etc.

#+begin_src emacs-lisp

  (setq xx "swimming in sea")

  (string-match "\\([a-z]+?ing\\) " xx)

  (match-string 1 xx)
  ;; => "swimming"

#+end_src

#+begin_src html

  <!-- Suppose you have thousands of links like this: -->

  <a href="â¦/this_and_that">this_and_that</a>

  <!-- you want to change the link text so that _ is replaced by space,
       like this: -->

  <a href="â¦/this_and_that">this and that</a>

  <!-- First, you need to use regex find / replace to match the
       links. Then, you need a function to to transform the matched
       pattern. -->

#+end_src

*Call Function in Replacement String*

You can use a function as your replacement string.

In the replace string prompt, give ~\,(function_name)~, where ~function_name~ is your elisp function.

The function needs no argument. Its return value is used as the replacement string.

The task here is to write the replacement function.

#+begin_src emacs-lisp

  ;; So, with this function written, we can call query-replace-regexp, then give this pattern:

  ;; >\([_A-Za-z0-9]+\)</a>

  ;; And the replacement expression would be:

  ;; \,(ff)

  ;; Here's a example where i need to find all Wikipedia links and change the link text to use space instead of _.

  (defun xah/wikipedia-link-replacement ()
    "Returns a canonical form of Wikipedia link from a regex match.

  The regex to be used for this function is:

   <a href=\"http://\\(..\\)\\.wikipedia.org/wiki/\\([^\"]+\\)\">\\(\\([-.A-Za-z0-9]+_\\)+[-.A-Za-z0-9]+ ?\\)</a>

  To use this function, call `query-replace-regexp', then in the replacement prompt give:
   \\,(wikipedia-link-replacement)
  "
    (let (langCode articlePath linkText linkText2 returnText)
      (setq langCode (match-string 1)) ;; \\(..\\)
      (setq articlePath (match-string 2)) ;; \\([^\"]+\\)
      (setq linkText (match-string 3))
      (setq linkText2 (replace-regexp-in-string "_" " " articlePath))
      (setq returnText
            (concat "<a href=\"http://"
                    langCode ".wikipedia.org/wiki/"
                    articlePath "\">" linkText2 "</a>" ))
      returnText ) )

  ;; The (match-string 1) gives you the first captured string. (â1â is for
  ;; 1st captured pattern, â2â for 2nd captured pattern. â0â is the entire
  ;; match.).

#+end_src

*** match-string-no-properties
Same as [[match-string]] but without Text Properties.

#+begin_src emacs-lisp

  (let ((case-fold-search nil))
    (re-search-forward "\\([0-9]+\\)")
    ;; lots text 123 abc
    (match-string-no-properties 1))
                                          ; "123"

#+end_src

*** highlight-lines-matching-regexp
Highlight all lines that match REGEXP using FACE.

#+begin_src emacs-lisp

  ;; This example shows you how to make lines containing the words âERROR:â
  ;; or âNOTE:â highlighted, whenever a file ending in âlogâ is opened.

  (defun highlite-it ()
    "Highlight certain linesâ¦"
    (interactive)
    (if (equal "log" (file-name-extension (buffer-file-name)))
        (progn
          (highlight-lines-matching-regexp "ERROR:" 'hi-red-b)
          (highlight-lines-matching-regexp "NOTE:" 'hi-blue-b))))

  (add-hook 'find-file-hook 'highlite-it)

  ;; The add-hook line will make emacs call âhighlite-itâ whenever a file
  ;; is opened. It works by adding the function âhighlite-itâ to the list
  ;; in the variable find-file-hook.

  ;; find-file is the function that open files. find-file-hook is a
  ;; variable containing list of functions that will run when find-file is
  ;; run.

#+end_src

** point-
*** point
Return the value of the current position of the cursor, as an integer counting the number of characters from the beginning of the buffer.

*** point-min
Return the minimum permissible value of point in the current buffer. This is 1, unless narrowing is in effect.

*** point-max
Return the value of the maximum permissible value of point in the current buffer. This is the end of the buffer, unless narrowing is in effect.

*** goto-char
Set point to the location specified by the value of the argument.

*** line-beginning-position
Return the character position of the first character on the current line.

*** line-end-position
Return the character position of the last character on the current line.

*** forward-char
Move point N characters forward (backward if N is negative).

*** backward-char
Move point N characters backward (forward if N is negative).

*** bounds-of-thing-at-point
Determine the start and end buffer locations for the THING at point.

Often you want a command that works on the current word (or line, paragraph), but if there is a text selection, take the text selection as input. Here's a template for this and other examples.

Sometimes, you need to not just grab current word, but do other things such as delete the word. You need to know the beginning and ending positions of the region you are interested. Use ~bounds-of-thing-at-point~.


#+begin_src emacs-lisp

  (defun xah/downcase-word-or-region ()
    "Downcase current word or region."
    (interactive)
    (let (pos1 pos2 bds)
      (if (use-region-p)
          (setq pos1 (region-beginning) pos2 (region-end))
        (progn
          (setq bds (bounds-of-thing-at-point 'symbol))
          (setq pos1 (car bds) pos2 (cdr bds))))

      ;; now, pos1 and pos2 are the starting and ending positions of the
      ;; current word, or current text selection if exist.
      (downcase-region pos1 pos2)))


  (defun xah/get-boundary-and-thing ()
    "Returns the boundary positions of the text unit under cursor."
    (interactive)
    (let (bounds pos1 pos2 mything)
      (setq bounds (bounds-of-thing-at-point 'symbol))
      (setq pos1 (car bounds))
      (setq pos2 (cdr bounds))
      (setq mything (buffer-substring-no-properties pos1 pos2))

      (message
       "thing begin at [%s], end at [%s], thing is [%s]"
       pos1 pos2 mything)))


  (defun ake/html-table-string (textblock delim)
    "Turn a text string into a HTML table.
  See make-html-table."
    (let ()
      (setq textblock (replace-regexp-in-string delim "</td><td>" textblock))
      (setq textblock (replace-regexp-in-string "\n" "</td></tr>\n<tr><td>" textblock))
      (setq textblock (substring textblock 0 -8)) ;; delet the beginning â<tr><td>â in last line
      (concat "<table border=\"1\" cellpadding=\"5\" cellspacing=\"0\">\n<tr><td>" textblock "</table>")
      ))

  (defun make-html-table (sep)
    "Turn the current paragraph into a HTML table.

  The âcurrent paragraphâ is defined as having empty lines before and
  after the block of text the cursor is on.

  For example:

  a*b*c
  1*2*3
  this*and*that

  with â*â as separator, becomes

  <table border=\"1\" cellpadding=\"5\" cellspacing=\"0\">
  <tr><td>a</td><td>b</td><td>c</td></tr>
  <tr><td>1</td><td>2</td><td>3</td></tr>
  <tr><td>this</td><td>and</td><td>that</td></tr>
  </table>"
    (interactive "sEnter string pattern for column separation:")
    (let (bds p1 p2 myStr)
      (setq bds (bounds-of-thing-at-point 'paragraph))
      (setq p1 (+ (car bds) 1))
      (setq p2 (cdr bds))
      (setq myStr (buffer-substring-no-properties p1 p2))
      (delete-region p1 p2)
      (insert (make-html-table-string myStr sep) "\n")))

#+end_src

*** eobp
Return t for true if point is at the end of the accessible part of a buffer. The end of the accessible part is the end of the buffer if the buffer is not narrowed; it is the end of the narrowed part if the buffer is narrowed.

** mark-
*** push-mark
Sets a mark at the current position of the cursor.

*** set-mark-command
Set the mark where point is, and activate it; or jump to the mark.

When ~set-mark-command~ is called, the region becomes active (highlighted). When a command is called, it typically set the region status to inactive.

This means, when you set mark using the keyboard or the mouse, text selection become highlighted, then after you called some command, the region returns to inactive again (and the highlighting goes away).

*** transient-mark-mode
Toogle transient mark mode. When enabled, the *region is highlighted* with the region face whenever the mark is active.

~transient-mark-mode~ is on by default, and many command's behavior changed. If there is a text selection, the command acts on it, else it acts on the current word, line, paragraph, buffer (or whatever is its default input).

*** mark-active
Variable. Non-nil means the mark and region are currently active in this buffer.

#+begin_src emacs-lisp

  (defun xar/select-line ()
    "Select current line."
    (interactive)
    (let (p1 p2)
      (setq p1 (line-beginning-position))
      (setq p2 (line-end-position))
      (goto-char p1)
      (push-mark p2)
      (setq mark-active t)))

#+end_src

** region-
*** region-beginning
Return the integer value of point or mark, whichever is smaller.

*** region-end
Return the integer value of point or mark, whichever is larger.

*** delete-region
Delete the text between START and END.

*** use-region-p
Return t if the region is active and it is appropriate to act on it.

The function ~use-region-p~ basically checks 3 things:
- ~transient-mark-mode~ is on.
- ~mark-active~ is true.
- region isn't empty by checking ~use-empty-active-region~.


#+begin_src emacs-lisp

  ;; Often you want a command that works on the current word (or line,
  ;; paragraph), but if there is a text selection, take the text selection
  ;; as input.
  (defun xah/downcase-word-or-region ()
    "Downcase current word or region."
    (interactive)
    (let (pos1 pos2 bds)
      (if (use-region-p)
          (setq pos1 (region-beginning) pos2 (region-end))
        (progn
          (setq bds (bounds-of-thing-at-point 'symbol))
          (setq pos1 (car bds) pos2 (cdr bds))))

      ;; now, pos1 and pos2 are the starting and ending positions of the
      ;; current word, or current text selection if exist.
      (downcase-region pos1 pos2)))

#+end_src

*** kill-region
Cuts the text between point and mark from the buffer and stores that text in the kill ring, so you can get it back by yanking.

#+begin_src emacs-lisp

  ;; cut text between buffer positions and push it to kill-ring.
  (kill-region 247 528)

#+end_src

*** kill-ring-save
Save the region as if killed, but don't kill it.

#+begin_src emacs-lisp

  ;; copy text between buffer positions and push it to kill-ring.
  (kill-ring-save 247 528)

#+end_src

*** kill-new
Make STRING the latest kill in the kill ring.

[[kill-ring-save]] copy text between buffer positions and push it to ~kill-ring~ if you already have a string, use ~kill-new~

#+begin_src emacs-lisp

  ;; push a string into kill-ring
  (kill-new "dragon dragon")

  (defun xah/copy-all ()
    "Put the whole buffer content into the `kill-ring'.
  (respects `narrow-to-region')
  URL `http://ergoemacs.org/emacs/elisp_cut_copy_yank_kill-ring.html'
  Version 2015-05-06"
    (interactive)
    (kill-new (buffer-string))
    (message "Buffer content copied."))

#+end_src

*** kill-append
Append STRING to the end of the latest kill in the kill ring.

*** narrow-to-region
Restrict editing in this buffer to the current region.

Whenever you work in a region, remember that the boundaries of the text that you are interested is changed when you add or remove text in that region. Don't just call ~(something-region p1 p2)~ again, because ~p2~ is no longer the correct boundary. Use ~save-restriction~ and ~narrow-to-region~.

#+begin_src emacs-lisp

  ;; idiom for string replacement within a region
  (save-restriction
    (narrow-to-region pos1 pos2)

    (goto-char (point-min))
    (while (search-forward "myStr1" nil t) (replace-match "myReplaceStr1"))

    ;; repeat for other string pairs
    )

#+end_src

*** copy-region-as-kill
Copies the text between point and mark into the kill ring, from which you can get it by yanking. The function does not cut or remove the text from the buffer.

*** delete-and-extract-region
Removes the text between point and mark from the buffer and throws it away. You cannot get it back. (This is not an interactive command.)

*** widen
Remove restrictions (narrowing) from current buffer.

This function is usually not neededâEmacs creates a fresh buffer if none already exists; but if a buffer visiting the file already exists Emacs returns that one. In this case, the buffer may be narrowed and must be widened.

** file-
*** write-region
Write current region into specified file.

Modify Files: If you want to write to file ONLY when you actually changed the file, you can create flag variable and call write-region, like this:

#+begin_src emacs-lisp

  (defun my-process-file (fPath)
    "Process the file at path FPATH â¦"
    (let ((fileChanged-p nil))
      (with-temp-buffer
        (insert-file-contents fPath)

        ;; process text
        ;; set fileChanged-p to t or nil

        (when fileChanged-p (write-region 1 (point-max) fPath)))))

#+end_src

*** with-temp-file
Create a new buffer, evaluate BODY there, and write the buffer to FILE.

when doing batch text processing of thousands of files, don't use ~find-file~, use ~with-temp-buffer~ or ~with-temp-file~ instead. (use the latter when you need to make changes to the file.

*** insert-file-contents
Insert contents of file FILENAME after point.

#+begin_src emacs-lisp

  (defun get-string-from-file (filePath)
    "Return filePath's file content."
    (with-temp-buffer
      (insert-file-contents filePath)
      (buffer-string)))

#+end_src

*** append-to-file
Append the contents of the region to the end of file FILENAME.

*** file-name-directory
Return the directory component in file name FILENAME.

*** file-name-nondirectory
Return file name FILENAME sans its directory.

*** file-name-extension
Get suffix.

*** file-name-sans-extension
Return FILENAME sans final "extension".

*** file-relative-name
Get relative path.

*** expand-file-name
Convert filename NAME to absolute, and canonicalize it. The function employs the name of the directory in which the function is called.

#+begin_src emacs-lisp

  ;; if expand-file-name is called when Emacs is visiting
  ;; the /usr/local/share/emacs/22.1.1/lisp/emacs-lisp/

  (expand-file-name "debug.el")
  ;; => /usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el

#+end_src

*** dired-get-marked-files
Return the marked files' names as list of strings.

#+begin_src emacs-lisp

  ;; To apply a function to marked files in dired

  ;; idiom for processing a list of files in dired's marked files

  ;; suppose myProcessFile is your function that takes a file path
  ;; and do some processing on the file

  (defun dired-myProcessFile ()
    "apply myProcessFile function to marked files in dired."
    (interactive)
    (require 'dired)
    (mapc 'myProcessFile (dired-get-marked-files)))

#+end_src

*** rename-file
Rename FILE as NEWNAME.  Both args must be strings.

*** copy-file
Copy FILE to NEWNAME.  Both args must be strings.

#+begin_src emacs-lisp

  (defun xah/make-backup ()
    "Make a backup copy of current buffer's file.
  Create a backup of current buffer's file.
  The new file name is the old file name with trailing â~â, in the same dir.
  If such a file already exist, append more â~â.
  If the current buffer is not associated with a file, its a error."
    (interactive)
    (let (fName backupName)
      (setq fName (buffer-file-name))
      (setq backupName (concat fName "~"))

      (while (file-exists-p backupName)
        (setq backupName (concat backupName "~")))

      (copy-file fName backupName t)
      (message (concat "Backup saved as: " (file-name-nondirectory backupName)))))

#+end_src

*** delete-file
Delete file named FILENAME.  If it is a symlink, remove the symlink.

#+begin_src emacs-lisp

  (defun xah/delete-current-file ()
    "Delete the file associated with the current buffer.
  Delete the current buffer too.
  If no file is associated, just close buffer without prompt for save."
    (interactive)
    (let (currentFile)
      (setq currentFile (buffer-file-name))
      (when (yes-or-no-p (concat "Delete file?: " currentFile))
        (kill-buffer (current-buffer))
        (when (not (equal currentFile nil))
          (delete-file currentFile) ) ) ) )

#+end_src

*** file-exists-p
Return t if file FILENAME exists (whether or not you can read it).

#+begin_src emacs-lisp

  (defun xah/make-backup ()
    "Make a backup copy of current buffer's file.
  Create a backup of current buffer's file.
  The new file name is the old file name with trailing â~â, in the same dir.
  If such a file already exist, append more â~â.
  If the current buffer is not associated with a file, its a error."
    (interactive)
    (let (fName backupName)
      (setq fName (buffer-file-name))
      (setq backupName (concat fName "~"))

      (while (file-exists-p backupName)
        (setq backupName (concat backupName "~")))

      (copy-file fName backupName t)
      (message (concat "Backup saved as: "
                       (file-name-nondirectory backupName)))))

#+end_src

*** set-file-modes
Set mode bits of file named FILENAME to MODE (an integer).

** dir-
*** directory-files
Return a list of names of files in DIRECTORY.

No recurse into sub-directories, for using recursive directories you can try these functions, find-lisp-find-files, find-lisp-find-files-internal from find-lisp package.

*** make-directory
Create the directory DIR and optionally any nonexistent parent dirs.

Non existent paren dirs will be created.

*** delete-directory
Delete the directory named DIRECTORY.  Does not follow symlinks.

Whole dir.

*** copy-directory
Copy DIRECTORY to NEWNAME.  Both args must be strings.

Whole dir.

** math-
*** random
Elisp's random function can be called in 3 ways:

- ~(random t)~. Set a random seed based on current time and PID (process ID).
- ~(random n)~. Returns a random number between ~0~ and ~n-1~, including possible ~0~ and ~n-1~.
- ~(random)~. Returns a random number between ~0~ and ~2^29-1~, inclusive.

*** expt
Return the exponential ARG1 ** ARG2.

*** truncate
This returns number, converted to an integer by rounding towards zero.

#+begin_src emacs-lisp

  (truncate  1.2)  ;; =>  1
  (truncate  1.7)  ;; =>  1
  (truncate -1.2)  ;; => -1
  (truncate -1.7)  ;; => -1

#+end_src

*** floor
This returns number, converted to an integer by rounding downward (towards negative infinity).

If divisor is specified, this uses the kind of division operation that corresponds to mod, rounding downward.

#+begin_src emacs-lisp

  (floor  1.2) ;; =>  1
  (floor  1.7) ;; =>  1
  (floor -1.2) ;; => -2
  (floor -1.7) ;; => -2

  (floor 5.99 3) ;; => 1
  (floor 6.01 3) ;; => 2

#+end_src

*** ceiling
This returns number, converted to an integer by rounding upward (towards positive infinity).

#+begin_src emacs-lisp

  (ceiling  1.2) ;; =>  2
  (ceiling  1.7) ;; =>  2
  (ceiling -1.2) ;; => -1
  (ceiling -1.7) ;; => -1

#+end_src

*** round
This returns number, converted to an integer by rounding towards the nearest integer. Rounding a value equidistant between two integers returns the even integer.

#+begin_src emacs-lisp

  (round  1.2) ;; =>  1
  (round  1.7) ;; =>  2
  (round -1.2) ;; => -1
  (round -1.7) ;; => -2

#+end_src

*** max
Return largest of all the arguments (which must be numbers or markers).

#+begin_src emacs-lisp

  (max 5 9 6 3 48) ;; => 48

  ;; max into a list
  (apply 'max '(1 2 3 4)) ;; => 4
  (funcall 'max '(1 2 3 4))
  ;; => error because "funcall" would pass that argument to the function "max"
  ;; which precisely cannot recive the list as an argument while "apply" does,
  ;; "apply" passes each value of the list as an individual argument.

#+end_src

*** zerop
Return t if NUMBER is zero.

*** /
The division operation approximates immediately by default, to change this behavior, the dividend must be placed in decimal notation.

#+begin_src emacs-lisp

  (/ 21 4)   ;; => 5
  (/ 21 4.0) ;; => 5.25

#+end_src

** lines-
*** beginning-of-line
Move cursor to beginning of current line.

Better than ~(goto-char (line-beginning-position))~.

Do not use ~move-beginning-of-line~ or ~move-end-of-line~. Because these are designed for interactive use.

Do not use ~(search-forward "\n")~ for moving cursor to end of line. Because you'll have special cases if the line is at the end of buffer and doesn't have a newline char. It is also slower.

#+begin_src emacs-lisp

  (transient-mark-mode 1)

  (defun xah/select-current-line ()
    "Select the current line"
    (interactive)
    (end-of-line) ; move to end of line
    (set-mark (line-beginning-position)))

#+end_src

*** end-of-line
Move cursor to end of current line.

Better than ~(goto-char (line-end-position))~.

Do not use ~move-beginning-of-line~ or ~move-end-of-line~. Because these are designed for interactive use.

Do not use ~(search-forward "\n")~ for moving cursor to end of line. Because you'll have special cases if the line is at the end of buffer and doesn't have a newline char. It is also slower.

*** line-beginning-position
Return line beginning's position.

#+begin_src emacs-lisp

  ;; grab current line
  (setq myLine
        (buffer-substring-no-properties
         (line-beginning-position)
         (line-end-position)))
  ;; Do not use (thing-at-point 'line). Normally, thing-at-point will
  ;; include the newline char, but if the line is at the end of buffer,
  ;; then it won't.

#+end_src

*** line-end-position
Return line end's position.

*** count-lines
Return number of lines between START and END.
*** forward-line
Move cursor to previous(-1) or next line(1). Cursor will be at beginning of line.

Do not use ~next-line~ , ~previous-line~ or ~goto-line~ because these are for interactive use, ~forward-line~ is better opcion. Their behavior changes depending on the variable ~line-move-visual~.

** ring-
*** kill-append
Append STRING  argument to the end of the latest kill in the kill ring.

*** kill-new
Make STRING argument the latest kill in the kill ring.

*** current-kill
Rotate the yanking point by N places, and then return that kill.

*** yank
Reinsert ("paste") the last stretch of killed text.

*** yank-pop
Replace just-yanked stretch of killed text with a different stretch.

*** rotate-yank-pointer
Rotate the yanking point in the kill ring.

** variable-
*** buffer-read-only
Ãtil para setear momentaneamente un buffer con solo lectura, cuando hay posibilidad de que el buffer cambie al aplicar una funciÃ³n que se esta ejecutando y no sea eso lo que se quiera o mientras se experimenta con funciones que puedan alterar el buffer o en archivos delicados (archivos fuente) que por mÃ¡s seguro que se este que la funciÃ³n no modificarÃ¡ el buffer es mejor estar seguro.

*** line-move-visual
Is variable that controls whether ~next-line~ and ~previous-line~ move by newline char or screen.

Note: there's also a function named ~line-move-visual~. It doesn't have inline doc. It's for moving cursor by visual lines.

*** default-directory
Get the current dir.

*** case-fold-search
Non-nil if searches and matches should ignore case.

#+begin_src emacs-lisp

  (defun search-for-abc ()
    "Search for the string \"abc\", ignoring case differences."
    (let ((case-fold-search t))
      (re-search-forward "abc")))


  ;; -*- coding: utf-8 -*-
  ;; 2011-03-21
  ;; report the line number of a occurrences of string, of a given dir
  ;; script

  (setq inputDir "~/web/ergoemacs_org/emacs/" )

  ;; add a ending slash if not there
  (when (not (string= "/" (substring inputDir -1)))
    (setq inputDir (concat inputDir "/")))

  (defun my-process-file (fPath)
    "process the file at fullpath fPath â¦"
    (let (myBuffer (ii 0) searchStr)

      (when (not (string-match "/xx" fPath)) ; skip dir starting with xx

        (setq myBuffer (get-buffer-create " myTemp"))
        (set-buffer myBuffer)
        (insert-file-contents fPath nil nil nil t)

        (setq case-fold-search nil) ; remember to set case sensitivity here

        (setq searchStr "<style>" )

        (goto-char 1)
        (while (search-forward searchStr nil t) ;for regex, re-search-forward
          (princ (format "this many: %d %s\n"
                         (line-number-at-pos (point)) fPath)))

        (kill-buffer myBuffer))))

  (require 'find-lisp)

  (let (outputBuffer)
    (setq outputBuffer "*xah occur output*" )
    (with-output-to-temp-buffer outputBuffer
      (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
      (princ "Done deal!")))

#+end_src

*** boundp
Return t if SYMBOL's value is not void.

Check if a variable is defined.

The ~boundp~ checks a symbol's value cell. Similarly, the [[fboundp]] actually check a symbol's function cell.

#+begin_src emacs-lisp

  (boundp 'auto-mode-alist)       ; t
  (boundp 'xyz)                   ; nil

#+end_src

*** Notes

#+begin_src emacs-lisp

  ;; input dir
  (setq inputDir "~/web/" ) ; In elisp, dir path should end with a slash

  ;; set output buffer
  (setq outputBuffer "*my occur output*" )

#+end_src

** command-
*** this-command
Normally, whenever a function is executed, Emacs sets the value of this-command to the function being executed.

#+begin_src emacs-lisp

  ;; check if the command is being called repeatedly
  (if (not (eq last-command this-command))
      â¦
      )
  ;; the âthis-commandâ and âlast-commandâ are built-in variables. They
  ;; store the command currently called or last called.

#+end_src

*** last-command
Normally, whenever a function is executed, Emacs sets the value of this-command to the function being executed. At the same time, Emacs sets the value of last-command to the previous value of this-command.

#+begin_src emacs-lisp

  ;; check if the command is being called repeatedly
  (if (not (eq last-command this-command))
      â¦
      )
  ;; the âthis-commandâ and âlast-commandâ are built-in variables. They
  ;; store the command currently called or last calle.

#+end_src

*** shell-command
Execute string COMMAND in inferior shell; display output, if any.

#+begin_src emacs-lisp

  ;; copy file
  (shell-command "cp /somepath/myfile.txt  /somepath")

  ;; gzip file
  ;; ...
  (when gzip-it-p
    (shell-command (concat "gzip " filePath)))

  ;; copy dir recursively
  ;; ...
  (make-directory toDir t)
  (shell-command (concat "cp -R " fromDir " " toDir))

#+end_src

*** shell-command-to-string
Execute shell command COMMAND and return its output as a string.

Idiom for calling a shell command and get its output.

#+begin_src emacs-lisp

  (shell-command-to-string "ls")

#+end_src

** p-
*** sequencep
This function returns t if object is a list, vector, string, bool-vector, or char-table, nil otherwise.

*** functionp
Return t if OBJECT is a function.

Note that ~functionp~ returns ~t~ for symbols that are function names and returns ~nil~ for special forms. It is also possible to find out how many arguments an arbitrary function expects.

*** fboundp
Check if a function is defined.

The ~fboundp~ actually check a symbol's *function* cell. Similarly, the [[boundp]] checks a symbol's *value* cell.

#+begin_src emacs-lisp

  (fboundp 'info)     ; t
  (fboundp 'xyz)      ; nil

#+end_src

*** featurep
Check if a âfeatureâ is loaded (if a library is loaded).

#+begin_src emacs-lisp

  ;; check if a âfeatureâ (package) has been loaded
  (featurep 'ibuffer)

#+end_src

** misc-
*** y-or-n-p
Ask user a "y or n" question.

Return t if answer is "y" and nil if it is "n".

#+begin_src emacs-lisp

  (if (y-or-n-p "Do it?")
      (progn
        ;; code to do something here
        )
    (progn
      ;; code if user answered no.
      ))


  ;; -*- coding: utf-8 -*-
  ;; 2011-07-03
  ;; replace image tags to use HTML5's âfigureâ  and âfigcaptionâ tags.

  ;; Example. This:
  ;; <div class="img">â¦</div>
  ;; should become this
  ;; <figure>â¦</figure>

  ;; do this for all files in a dir.

  ;; rough steps:
  ;; find the <div class="img">
  ;; use sgml-skip-tag-forward to move to the ending tag.
  ;; save their positions.
  ;; ask user whether to replace, if so, delete them and insert new string

  (defun xah/my-process-file (fPath)
    "Process the file at FPATH â¦"
    (let (myBuff p1 p2 p3 p4 )
      (setq myBuff (find-file fPath))

      (widen)
      (goto-char 1) ;; in case buffer already open

      (while (search-forward "<div class=\"img\">" nil t)
        (progn
          (setq p2 (point) )
          (backward-char 17) ; beginning of âdivâ tag
          (setq p1 (point) )

          (forward-char 1)
          (sgml-skip-tag-forward 1) ; move to the closing tag
          (setq p4 (point) )
          (backward-char 6) ; beginning of the closing div tag
          (setq p3 (point) )
          (narrow-to-region p1 p4)

          (when (y-or-n-p "replace?")
            (progn
              (delete-region p3 p4 )
              (goto-char p3)
              (insert "</figure>")

              (delete-region p1 p2 )
              (goto-char p1)
              (insert "<figure>")
              (widen) ) ) ) )

      (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff))))

  (require 'find-lisp)


  (let (outputBuffer)
    (setq outputBuffer "*xah img/figure replace output*" )
    (with-output-to-temp-buffer outputBuffer
      (mapc 'my-process-file (find-lisp-find-files
                              "~/web/xahlee_org/emacs/" "\\.html$"))
      (princ "Done deal!")))

#+end_src

*** read-from-minibuffer
Read a string from the minibuffer, prompting with string PROMPT.

~read-from-minibuffer~ is the most general command for get user input, but there are others such as ~read-string~, ~read-file-name~, read ~-directory-name~, ~read-regexp~.

#+begin_src emacs-lisp

  (defun ff ()
    "Prompt user to enter a file name, with completion and history support."
    (interactive)
    (let ((x (read-file-name "Enter file name:")))
      (message "String is %s." x)))

  (defun ff (arg)
    "Prompt user to enter a string, with input history support."
    (interactive
     (list
      (read-string "Enter your name:")))
    (message "String is %s." arg))

#+end_src

*** start-process
Start a program in a subprocess.  Return the process object for it.

Call a shell command, but don't wait for it to finish before continuing, use ~start-process~ or ~start-process-shell-command~.

#+begin_src emacs-lisp

  ;; open files in Linux desktop
  (mapc
   (lambda (fPath)
     (let ((process-connection-type nil))
       (start-process "" nil "xdg-open" fPath)) )
   myFileList)

#+end_src

*** prefix-numeric-value
Convert the raw prefix argument produced by (interactive "P") to a numeric value.

*** default-value
Check whether the minor mode is enabled in the current buffer.

*** require
If feature FEATURE is not loaded, load it from FILENAME.

When writing a elisp script that does batch processing, it's best to print to your own buffer.

For example, suppose you have a elisp batch script that do find and replace on all files in a dir. For each file visited, it prints out the file path. If you use (message â¦), it prints to the â*Messages*â buffer, which automatically roll off the top if you have more than a hundred lines. Also, it may intermix your script's output with output from other emacs activities.

Here's a example of printing to your own buffer:

#+begin_src emacs-lisp

  (require 'find-lisp)
  (with-output-to-temp-buffer "*my output*"
    (mapc 'my-process-file (find-lisp-find-files "~/" "\\.html$"))
    (princ "Done.\n")
    (switch-to-buffer "*my output*")
    )

  ;; In the above example, any call to print in âmy-process-fileâ is output
  ;; to your temp buffer.

#+end_src

*** catch throw
Use ~catch~ and ~throw~ to exit loop, function or map.

To exit a function, just put ~throw 'tagname value~ where you want to, and, wrap your function body with a ~catch 'tagname~.

~(catch 'tagname body)~ => evaluates ~body~ and return ~body~'s last expression, but if ~body~ contains ~(throw â¦)~ and it is called, return the value throw passes.

~(throw tagName passValue)~ => jump to a outer ~(catch 'tagName)~ and continue there, passing the value of ~passValue~ to it. Both ~tagName passValue~ are evaluated.

#+begin_src emacs-lisp

  (defun test-exit-f ()
    "example. using catch/throw to exit function"
    (interactive)
    (catch 'aaa
      (if (y-or-n-p "exit?")
          (progn
            (message "existing")
            (throw 'aaa 3) ; if yes, exit right away, return 3 to catch
            )
        (progn ; else, go on
          (message "went on")
          4)))) ; return 4


  ;; Exit a map
  (let ((myList [0 1 2 3 4 5]))
    ;; map lambda onto a list. If value 3 is found, return 3, else nil
    (catch 'bbb
      (mapc
       (lambda (x)
         (message "%s" x)
         (when (equal x 3) (throw 'bbb x)))
       myList)
      nil))


  ;; Here's a sample of setting flag:
  (let ((myList [0 1 2 3 4 5] )
        (foundFlag-p nil )
        (i 0))

    (while (and
            (not foundFlag-p)
            (<= i (length myList)))

      ;; if found, set foundFlag-p
      (when (equal (elt myList i) 3)
        (setq foundFlag-p t ))

      (message "value: %s" i)
      (setq i (1+ i))))

#+end_src

*** error
Use ~error~ or ~user-error~ to signal a error and exit.

You can exit by calling ~error~ or ~user-error~.

#+begin_src emacs-lisp

  (defun test-exit-f ()
    "example"
    (interactive)
    (if (y-or-n-p "invoke user-error to exit?")
        (user-error "Error, because: %s" "you said so!")
      (progn ; else, go on
        (message "went on"))))

#+end_src

*** highlight-phrase
Set face of each match of phrase REGEXP to FACE.

Another similar function is ~highlight-lines-matching-regexp~.

#+begin_src emacs-lisp

  (highlight-phrase "\\bKing\\b" (quote hi-blue))

  (highlight-lines-matching-regexp "^#" (quote hi-blue-b))

  ;; You can set a file to automatically eval elisp code when the file
  ;; opens.  add this to the end of file:

  /* Local Variables: */
  /* eval: (highlight-phrase "\\bJane\\b" (quote hi-pink)) */
  /* eval: (highlight-phrase "\\bKing\\b" (quote hi-blue)) */
  /* eval: (highlight-lines-matching-regexp "^#" (quote hi-blue-b)) */
  /* End: */

#+end_src

*** benchmark-run
Time execution of FORMS.

*** sgml-skip-tag-forward
Skip to end of tag or matching closing tag if present.

*** sit-for
Redisplay, then wait for SECONDS seconds.  Stop when input is available.

This expression makes the graph printing operation more interesting to watch than it would be otherwise. The expression causes Emacs to sit or do nothing for a zero length of time and then redraw the screen. Placed here, it causes Emacs to redraw the screen column by column. Without it, Emacs would not redraw the screen until the function exits.

#+begin_src emacs-lisp

  ;; Example of use (sit-for 0)
  (defun graph-body-print (numbers-list)
    "Print a bar graph of the NUMBERS-LIST.
  The numbers-list consists of the Y-axis values."

    (let ((height (apply 'max numbers-list))
          (symbol-width (length graph-blank))
          from-position)


      (while numbers-list
        (setq from-position (point))
        (insert-rectangle
         (column-of-graph height (car numbers-list)))
        (goto-char from-position)
        (forward-char symbol-width)

        ;; Draw graph column by column.
        (sit-for 0)
        (setq numbers-list (cdr numbers-list)))

      ;; Place point for X axis labels.
      (forward-line height)
      (insert "\n")))


  ;; other functions and variables of this graph if you wish to test the
  ;; above function.
  (defvar graph-symbol "*"
    "String used as symbol in graph, usually an asterisk.")


  (defvar graph-blank " "
    "String used as blank in graph, usually a blank space.
  graph-blank must be the same number of columns wide
  as graph-symbol.")


  ;;; Second version.
  (defun column-of-graph (max-graph-height actual-height)
    "Return MAX-GRAPH-HEIGHT strings; ACTUAL-HEIGHT are graph-symbols.

  The graph-symbols are contiguous entries at the end
  of the list.
  The list will be inserted as one column of a graph.
  The strings are either graph-blank or graph-symbol."


    (let ((insert-list nil)
          (number-of-top-blanks
           (- max-graph-height actual-height)))


      ;; Fill in graph-symbols.
      (while (> actual-height 0)
        (setq insert-list (cons graph-symbol insert-list))
        (setq actual-height (1- actual-height)))


      ;; Fill in graph-blanks.
      (while (> number-of-top-blanks 0)
        (setq insert-list (cons graph-blank insert-list))
        (setq number-of-top-blanks
              (1- number-of-top-blanks)))

      ;; Return whole list.
      insert-list))

#+end_src

*** null
Return t if OBJECT is nil, and return nil otherwise.

#+begin_src emacs-lisp

  (null '()) ; => t

#+end_src

*** set-register
Set contents of Emacs register named REGISTER to VALUE.

#+begin_src emacs-lisp

  ;; Example of how to resets/clears register a.
  (set-register ?a nil)

#+end_src

* Elisp
** Proccesing
*** Summary
Whenever you give an editing command to Emacs Lisp, such as the command to move the cursor or to scroll the screen, you are evaluating an expression, the first element of which is a function. *This is how Emacs works*.

- Lisp programs are made up of expressions, which are lists or single atoms.
- Lists are made up of zero or more atoms or inner lists, separated by whitespace and surrounded by parentheses. A list can be empty.
- Atoms are multi-character symbols, like ~forward-paragraph~, single character symbols like ~+~, strings of characters between double quotation marks like ~"string"~ , or numbers ~4~.
- A number evaluates to itself.
- A string between double quotes also evaluates to itself.
- When you evaluate a symbol by itself, its value is returned.
- When you evaluate a list, the Lisp interpreter looks at the first symbol in the list and then at the function definition bound to that symbol. Then the instructions in the function definition are carried out.
- A single-quote â ~'~ â tells the Lisp interpreter that it should return the following expression as written, and not evaluate it as it would if the quote were not there.
- Arguments are the information passed to a function. The arguments to a function are computed by evaluating the rest of the elements of the list of which the function is the first element.
- A function always returns a value when it is evaluated (unless it gets an error); in addition, it may also carry out some action that is a side effect. In many cases, a functionâs primary purpose is to create a side effect.

*** Run a program
A list in Lispâany listâis a program ready to run. If you run it, the computer will do one of three things: do nothing except return to you the list itself; send you an error message; or, treat the first symbol in the list as a command to do something.

The single [[quote]], when it precedes a list, it tells Lisp to do nothing with the list, other than take it as it is written. But if there is no quote preceding a list, the first item of the list is special: it is a command for the computer to obey. (In Lisp, these commands are called functions.)

The list ~(+ 2 2)~ did not have a quote in front of it, so Lisp understands that the ~+~ is an instruction to do something with the rest of the list: add the numbers that follow.

*** The lisp interpreter
What the Lisp interpreter does when we command it to evaluate a list is, first it looks to see whether there is a [[quote]] before the list; if there is, the interpreter just gives us the list. On the other hand, if there is no quote, the interpreter looks at the first element in the list and sees whether it has a function definition. If it does, the interpreter carries out the instructions in the function definition. Otherwise, the interpreter prints an error message.

In addition to lists, the Lisp interpreter can evaluate a symbol that is not quoted and does not have parentheses around it. The Lisp interpreter will attempt to determine the symbolâs value as a [[Variable]].

If the function that the Lisp interpreter is looking at is not a special form, and if it is part of a list, the Lisp interpreter looks to see whether the list has a list inside of it. If there is an inner list, the Lisp interpreter first figures out what it should do with the inside list, and then it works on the outside list. If there is yet another list embedded inside the inner list, it works on that one first, and so on. It always works on the innermost list first. The *interpreter works on the innermost list first*, to evaluate the result of that list.

Otherwise, the *interpreter works left to right*, from one expression to the next.

** Definitions
*** atoms
Es el objeto mÃ¡s simple de Emacs, se evalÃºan a sÃ­ mismos, por lo que evaluar estos objetos simplemente se devolverÃ¡ a sÃ­ mismos.

Este tÃ©rmino proviene del significado histÃ³rico de la palabra Ã¡tomo, que significa *indivisible*. Es cualquier cosa  que no sea una [[cons cell]], por ejemplo, ~forward-paragraph~,  ~+~,  ~string~, ~1234~, entre otros.

#+begin_src

         cons
   atoms ---> cons cell ---> list

  "atoms" con la funciÃ³n "cons" crea "cons cell" y estos pueden crear "list"

 "a" "b" -> (cons "a" "b") = ("a" . "b") -> '("a" . ("b" . nil)) = ("a" "b")

#+end_src

*** Symbol
**** Definition
A symbol, like ~+~, is not itself the set of instructions for the computer to carry out. Instead, the symbol is used, perhaps temporarily, *as a way of locating the definition* or set of instructions. A symbol can have only one function definition attached to it at a time.

A symbol that has a function definition is called, simply, a function (although, properly speaking, the definition is the function and the symbol refers to it.)

You might imagine a symbol as being a chest of drawers. The function definition is put in one drawer,  the value in another, and so on (what is put in each drawer is the address). What is put in the drawer holding the value can be changed without affecting the contents of the drawer holding the function definition, and vice versa.

In addition to its name, symbol definition, and variable value, a symbol has a drawer for a property list which can be used to record other information.

#+begin_src

  (setq bouquet '(rose violet buttercup))

  Symbol bouquet

           Chest of Drawers            Contents of Drawers

            __   o0O0o   __
          /                 \
         ---------------------
        |    directions to    |            [map to]
        |     symbol name     |             bouquet
        |                     |
        +---------------------+
        |    directions to    |
        |  symbol definition  |             [none]
        |                     |
        +---------------------+
        |    directions to    |            [map to]
        |    variable value   |             (rose violet buttercup)
        |                     |
        +---------------------+
        |    directions to    |
        |    property list    |
        |                     |
        +---------------------+
        |/                   \|

#+end_src

**** The concept of symbols in lisp
*âXAH*
LISP differs from most programing languages such as C, Java, Perl, Python, in that it deals with symbols, as opposed to just variables and values.

In practice, this means that in lisp, variables can be manipulated in its un-evaluated state. The situation is like the need for the âevaluateâ command in many languages, where the programer can built code as strings and do ~evaluate(string)~ to achieve meta-programing. In lisp, variable's unevaluated form are always available. You just put a apostrophe in front of it. This is why lisp refers to variable or function names as âsymbolsâ. This makes meta-programing more powerful.

For example, in most languages, once you defined ~x=3~, you cannot manipulate the variable â ~x~ â because it gets evaluated to 3 right away. If you want, you have to build a string "~x~" and manipulate this string, then finally use something like ~evaluate(string)~ to achieve the effect. In most languages, the use of ~evaluate()~ breaks down quickly because the language is not designed for doing it. It's slow, difficult to debug, and there lacks many facilities for such meta programing.

The ability to meta-program has many applications. For example, when you need to take user input as code (such as math formulas), or need to manipulate math expressions, or writing programs that modify itself at run-time. Lisp macros is a direct result of the ability to manipulate symbols.


Each lisp symbol has the following âcellsâ to store things:

- â *name* â cell â a string, typically the same as the symbol.
- â *value* â cell â stores the symbol's value, typically when the symbol is used as variable.
- â *function* â cell â stores function definition object or lisp macros.
- â *property list* â cell â typically hold a list of name/value pairs. It is used for syntax coloring strings, for function's state, etc.

A symbol's {value, function} cell may be empty, it's said to be âvoidâ. When you try to get a cell's value that's void, it's a lisp error. (a empty cell is not the same as having value of nil.)

In normal coding, you don't need to worry about any of these. The only thing that's useful for most elisp code is property list, but many other higher-level functions do it for you. (i.e. add, remove, properties.)

Understanding Lisp Symbol cells is important when you do advanced lisp programing. â¢ for example: macros, create and calling functions at run-time, function inside functions, manipulate evaluation, implementing a language, or any sort of meta-programing. If you don't have a need, you should not exploit these facilities in your program. keep your program normal and simple.

*** cons cell
A cons cell is a data object that represents an ordered pair. That is, it has two slots, and each slot holds, or refers to, some Lisp object. One slot is known as the CAR "Contents of the Address part of Register number", and the other is known as the CDR "Contents of the Decrement part of Register number".

We say that âthe CAR of this cons cell isâ whatever object its CAR slot currently holds, and likewise for the CDR.

Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell. These objects are called [[atoms]].

The names CAR and CDR derive from the history of Lisp. The original Lisp implementation ran on an IBM 704 computer which divided words into two parts, the address and the decrement; CAR was an instruction to extract the contents of the address part of a register, and CDR an instruction to extract the contents of the decrement. By contrast, *cons cells are named for the function cons that creates them*, which in turn was named for its purpose, the construction of cells.

Aunque cons cell se puede usar para contener pares de datos ordenados, se usan mÃ¡s comÃºnmente para construir estructuras de datos compuestas mÃ¡s complejas, en particular listas y Ã¡rboles binarios.

#+begin_src

  cons cell = (cons "abc" "def") = ("abc" . "def")

      car     cdr
   +-------+-------+
   | "abc" | "def" |
   +-------+-------+

      car     cdr           car     cdr
   +-------+-------+     +-------+-------+
   | "abc" |    -------> | "def" |  nil  |
   +-------+-------+     +-------+-------+

#+end_src

*** Dotted pair notation
Is a general syntax for cons cells that represents the CAR and CDR explicitly. In this syntax, ~(a . b)~ stands for a cons cell whose CAR is the object ~a~ and whose CDR is the object ~b~. Dotted pair notation is more general than list syntax because the CDR does not have to be a list. However, it is more cumbersome in cases where list syntax would work.

In dotted pair notation, the list ~(1 2 3)~ is written as ~(1 . (2 . (3 . nil)))~. For /nil/ *-terminated lists, you can use either notation*, but list notation is usually clearer and more convenient. When printing a list, the *dotted pair* notation *is only used if the CDR of a cons cell is not a* /list/.

Nota: al trabajar con dotted notation evaluando resultados se debe colocar [[quote]] antes ~'(rose . violet)~.

#+begin_src

  (rose . violet)

    --- ---
   |   |   |--> violet
    --- ---
     |
     |
      --> rose

#+end_src

You can *combine* dotted pair notation with list notation to represent conveniently a chain of cons cells with a *non-nil final CDR*. You write a dot after the last element of the list, followed by the CDR of the final cons cell.

#+begin_src

  (rose violet . buttercup) = (rose . (violet . buttercup))

    --- ---      --- ---
   |   |   |--> |   |   |--> buttercup
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet

  The syntax (rose . violet . buttercup) is invalid

#+end_src

The list ~(rose violet)~ is equivalent to ~(rose . (violet))~

#+begin_src

    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet

#+end_src

The three-element list ~(rose violet buttercup)~ = ~(rose . (violet . (buttercup)))~

#+begin_src

    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup

#+end_src

As a somewhat peculiar side effect of ~(a b . c)~ and ~(a . (b . c))~ being equivalent, for consistency this means that if you replace ~b~ here with the empty sequence, then it follows that ~(a . c)~ and ~(a . ( . c))~ are equivalent, too. This also means that ~( . c)~ is equivalent to ~c~, but this is seldom used.

*** S-expression
Is an expression, in a like-named notation, for nested list (tree-structured) data.

In the usual parenthesized syntax of Lisp, an S-expression is classically defined as

- an atom of the form ~x~, or
- an expression of the form ~(x . y)~ where ~x~ and ~y~ are S-expressions.

This definition reflects LISP's representation of a list as a series of "cells", each one an ordered pair. In plain lists, y points to the next cell (if any), thus forming a list. The recursive clause of the definition means that both this representation and the S-expression notation can represent any binary tree.

#+begin_src

  Tree data structure representing the S-expression (* 2 (+ 3 4)).

       o
      / \
     *   o
        / \
       2   o
          / \
         o  nil
        / \
       +   o
          / \
         3   o
            / \
           4  nil

#+end_src

*** list
Lists in Lisp are not a primitive data type, they are built up from cons cells. A list is a series of [[cons cell]], linked together so that the CDR slot of each cons cell holds either the next cons cell or the empty list. The empty list is actually the symbol ~nil~.

Hence, the CDR of a proper list is always a proper list. The CDR of a nonempty proper list is a proper list containing all the elements except the first.

Upon reading, each object inside the parentheses becomes an element of the list. That is, a cons cell is made for each element. The CAR slot of the cons cell holds the element, and its CDR slot refers to the next cons cell of the list, which holds the next element in the list. The CDR slot of the last cons cell is set to hold ~nil~.

Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a list structure.

This forms the basis of a simple, singly linked list structure whose contents can be manipulated with ~cons~, ~car~, and ~cdr~. Note that ~nil~ is the only list that is not also a cons pair.

A list is kept using a series of pairs of pointers. A pointer itself is quite simply the electronic address of what is pointed to. Hence, a list is kept as a series of electronic addresses.

#+begin_src

  (cons 1 (cons 2 (cons 3 nil))) = (list 1 2 3) = (1 2 3) = '(1 2 3)

  (1 . (2 . (3 . nil))) ---> Dotted Pair Notation

   +------+------+   +------+------+   +------+------+
   |  *   |   *----->|  *   |   *----->|  *   |   *-----> nil
   +--|---+------+   +--|---+------+   +--|---+------+
      |                 |                 |
      v                 v                 v
      1                 2                 3


  In the computer, the electronic address of â1â is recorded in a
  segment of computer memory along with the address that gives the
  electronic address of where the atom â2â is located; and that address
  (the one that tells where â2â is located) is kept along with an
  address that tells where the address for the atom â3â is located.

              sketched in a different manner
    --------------       --------------       --------------
   | car  | cdr   |     | car  | cdr   |     | car  | cdr   |
   |  1   |   o-------->|  2   |   o-------->|  3   |  nil  |
   |      |       |     |      |       |     |      |       |
    --------------       --------------       --------------
  add of 1 add to 2     add of 2 add to 3    add of 3   nil
  Each arrow points to what the address is the address of, either an
  atom or another pair of addresses.

   *--*--*--nil
   |  |  |
   1  2  3

  Binary tree
       *
      / \
     1   *
        / \
       2   *
          / \
         3  nil

#+end_src

A list with no elements in it is the empty list. Here is the list ~(A ())~, or equivalently ~(A nil)~

#+begin_src

    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> A        --> nil

#+end_src

Here is a more complex, the three-element list, ~((pine needles) oak maple)~, the first element of which is a two-element list:

#+begin_src

    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
     |             --> oak      --> maple
     |
     |     --- ---      --- ---
      --> |   |   |--> |   |   |--> nil
           --- ---      --- ---
            |            |
            |            |
             --> pine     --> needles


    sketched in a different manner
   --------------       --------------       --------------
  | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
  |   o   |   o------->| oak   |   o------->| maple |  nil |
  |   |   |      |     |       |      |     |       |      |
   -- | ---------       --------------       --------------
      |
      |
      |        --------------       ----------------
      |       | car   | cdr  |     | car     | cdr  |
       ------>| pine  |   o------->| needles |  nil |
              |       |      |     |         |      |
               --------------       ----------------

#+end_src

#+begin_src emacs-lisp

  (list
   (re-search-forward "The \\(cat \\)")
   (match-beginning 0)
   (match-beginning 1))
  ;;     => (t 9 13)
  ;;
  ;; ---------- Buffer: foo ----------
  ;; I read "The cat -!-in the hat comes back" twice.
  ;;         ^   ^
  ;;         9  13
  ;; ---------- Buffer: foo ----------

#+end_src

*** Association list type
An association list or alist is a specially-constructed list whose elements are cons cells. In each element, the CAR is considered a key, and the CDR is considered an associated value. (In some cases, the associated value is stored in the CAR of the CDR.)

#+begin_src emacs-lisp

  ;; sets the variable alist-of-colors to an alist of three elements.
  ;; In the first element, rose is the key and red is the value.
  (setq alist-of-colors
        '((rose . red) (lily . white) (buttercup . yellow)))

#+end_src

*Association Lists by Xah*
An association list, or alist for short, records a mapping from keys to values. It is a list of cons cells called associations: the CAR of each cons cell is the key, and the CDR is the associated value.

Here is an example of an alist. The key ~pine~ is associated with the value ~cones~; the key ~oak~ is associated with ~acorns~; and the key ~maple~ is associated with ~seeds~.

#+begin_src emacs-lisp

  ((pine . cones)
   (oak . acorns)
   (maple . seeds))

#+end_src

Both the values and the keys in an alist may be any Lisp objects. For example, in the following alist, the symbol ~a~ is associated with the number ~1~, and the string ~"b"~ is associated with the list ~(2 3)~, which is the CDR of the alist element:

#+begin_src emacs-lisp

  ((a . 1) ("b" 2 3))

#+end_src

Sometimes it is better to design an alist to store the associated value in the CAR of the CDR of the element. Here is an example of such an alist:

#+begin_src emacs-lisp

  ((rose red) (lily white) (buttercup yellow))

#+end_src

Here we regard ~red~ as the value associated with ~rose~. One advantage of this kind of alist is that you can store other related informationâeven a list of other itemsâin the CDR of the CDR. One disadvantage is that you cannot use ~rassq~ to find the element containing a given value. When neither of these considerations is important, the choice is a matter of taste, as long as you are consistent about it for any given alist.

The same alist shown above could be regarded as having the associated value in the CDR of the element; the value associated with ~rose~ would be the list ~(red)~.

Association lists are often used to record information that you might otherwise keep on a stack, since new associations may be added easily to the front of the list. When searching an association list for an association with a given key, the first one found is returned, if there is more than one.

In Emacs Lisp, it is not an error if an element of an association list is not a cons cell. The alist search functions simply ignore such elements. Many other versions of Lisp signal errors in such cases.

Note that property lists are similar to association lists in several respects. A property list behaves like an association list in which each key can occur only once.

*** Variable
A symbol can have a value attached to it just as it can have a function definition attached to it. The value of a symbol can be any expression in Lisp, such as a symbol, number, list, or string. A symbol that has a value is often called a variable.

The variable ~fill-column~ illustrates a symbol with a value attached to it, this symbol is set to some value, usually ~70~.

A symbol can have any value attached to it or, to use the jargon, we can *bind* the variable to a value: to a number, such as ~72~; to a string, ~"such as this"~ ; to a list, such as ~(spruce pine oak)~ ; we can even bind a variable to a function definition.

*** Macro
A macro is a construct defined in Lisp, which differs from a function in that it translates a Lisp expression into another expression that is to be evaluated in place of the original expression. For example, [[if]], [[when]], and so on.

Macros enable you to define new *control constructs* and other language features. A macro is defined much like a function, but instead of telling how to compute a value, it tells *how to compute another Lisp expression* which will in turn compute the value. We call this expression the expansion of the macro.

Macros can do this because they operate on the unevaluated expressions for the arguments, not on the argument values as functions do. They can therefore construct an expansion containing these argument expressions or parts of them.

Suppose we would like to define a Lisp construct to increment a variable value, much like the ~++~ operator in C. We would like to write ~(inc x)~ and have the effect of ~(setq x (1+ x))~. Hereâs a macro definition that does the job:

#+begin_src emacs-lisp

  (defmacro inc (var)
    (list 'setq var (list '1+ var)))

#+end_src

When this is called with ~(inc x)~, the argument var is the symbol ~x~ â *not the value of* ~x~, as it would be in a function. The body of the macro uses this to construct the expansion, which is ~(setq x (1+ x))~. Once the macro definition returns this expansion, Lisp proceeds to evaluate it, thus incrementing x.

*** Classification of emacs lisp function
On a separate subject, Emacs Lisp functions are classified into several types.

- *Function* = Most common. Written in elisp. Usually ~(defun â¦)~
- *Primitive* = elisp function written in C. â¢ for example: {~list~, ~car~, ~append~, ~point~, ~defun~, â¦}. Typically the most fundamental ones.
- *lambda expression* = â¢ for example: ~(lambda â¦)~. Usually temp functions.
- *special for* m = a function that doesn't eval in the normal way. â¢ for example: {~if~, ~cond~, ~and~, ~or~, ~while~, ~progn~}. (normally, arguments to a function are all evaluated first.)
- *macro* = Similar to âspecial formâ, but user-defined. i.e. the arguments are not eval'd, and you can manipulate them and eval them.
- *command* = functions that can be called by ~command-execute~. Typically, ~(defun â¦)~ with ~(interactive â¦)~ clause. All functions you can call by ~M-x~ are commands.

*** Vector
**** Introduction
Emacs lisp has a ~vector~ datatype.

- Vector has constant random access time.
- Elements cannot be added or removed.
- Element's value can be changed.
- Vector elements can be any other lisp object.

**** List vs Vector
Lisp's ~list~ and ~vector~ both are subtypes of the âsequencesâ datatype. Many functions, such as {~elt~, ~mapcar~}, work on any sequence type. Here's their primary differences:

- *Vector*: Access time to any element is constant.
- Vector's length cannot change. (if you create a new copy of a vector, the time required is proportional to the vector's length)

- *List*: Access time to a element is proportional to the distance of the element's position in the list.
- List's length can grow by prepending with ~cons~, and can have the first element dropped by ~cdr~. These operations have constant time.

Lisp culture is to almost always use list. I recommend using vector as much as possible. Use list ONLY IF you need to constantly grow the lis.

#+begin_src

     _____________________________________________
    |                                             |
    |          Sequence                           |
    |  ______   ________________________________  |
    | |      | |                                | |
    | | List | |             Array              | |
    | |      | |    ________       ________     | |
    | |______| |   |        |     |        |    | |
    |          |   | Vector |     | String |    | |
    |          |   |________|     |________|    | |
    |          |  ____________   _____________  | |
    |          | |            | |             | | |
    |          | | Char-table | | Bool-vector | | |
    |          | |____________| |_____________| | |
    |          |________________________________| |
    |_____________________________________________|

#+end_src

*** Dynamic vs lexical binding
**** Dynamic binding
By default, the local variable bindings made by Emacs are dynamic bindings. When a variable is *dynamically bound,* its current binding at any point in the execution of the Lisp program is simply *the most recently-created dynamic local binding* for that symbol, or the global binding if there is no such local binding.

#+begin_src emacs-lisp

  (defvar x -99)  ; x receives an initial value of -99.

  (defun getx ()
    x)            ; x is used free in this function.

  (let ((x 1))    ; x is dynamically bound.
    (getx))       ; => 1

  ;; After the let form finishes, x reverts to its
  ;; previous value, which is -99.

  (getx)          ; =>  -99

#+end_src

Note: Converting to Lexical Binding
Converting an Emacs Lisp program to lexical binding is easy. First, add a file-local variable setting of lexical-binding to t in the header line of the Emacs Lisp source file. Second, check that every variable in the program which needs to be dynamically bound has a variable definition, so that it is not inadvertently bound lexically.

**** Lexical binding
A *lexically-bound* variable has lexical scope, meaning that any reference to the variable must be located textually *within the binding construct*.

#+begin_src emacs-lisp

  (let ((x 1))    ; x is lexically bound.
    (+ x 3))      ; => 4

  (defun getx ()
    x)            ; x is used free in this function.

  (let ((x 1))    ; x is lexically bound.
    (getx))       ; => errorâ Symbol's value as variable is void: x

#+end_src

Here, the variable ~x~ has no global value. When it is lexically bound within a ~let~ form, it can be used in the textual confines of that ~let~ form. But it can not be used from within a ~getx~ function called from the ~let~ form, since the function definition of ~getx~ occurs outside the ~let~ form itself.

Each binding construct defines a lexical environment, specifying the variables that are bound within the construct and their local values. When the Lisp evaluator wants the current value of a variable, it looks first in the lexical environment; if the variable is not specified in there, it looks in the symbolâs value cell, where the dynamic value is stored.

(Internally, the lexical environment is an alist of symbol-value pairs, with the final element in the alist being the symbol t rather than a cons cell. Such an alist can be passed as the second argument to the eval function, in order to specify a lexical environment in which to evaluate a form. Most Emacs Lisp programs, however, should not interact directly with lexical environments in this way; only specialized programs like debuggers.)

Lexical bindings have indefinite extent. Even after a binding construct has finished executing, its lexical environment can be âkept aroundâ in Lisp objects called closures. A [[closure]] is created when you define a named or anonymous function with lexical binding enabled.

When a closure is called as a function, any lexical variable references within its definition use the retained lexical environment. Here is an example:

#+begin_src emacs-lisp

  (defvar my-ticker nil)   ; We will use this dynamically bound
                           ; variable to store a closure.

  (let ((x 0))             ; x is lexically bound.
    (setq my-ticker (lambda ()
                      (setq x (1+ x)))))
  ;; (closure ((x . 0) t) ()
  ;;   (setq x (1+ x)))

  (funcall my-ticker) ;; => 1

  (funcall my-ticker) ;; => 2

  (funcall my-ticker) ;; => 3

  x                   ; Note that x has no global value.
  ;; => errorâ Symbol's value as variable is void: x

#+end_src

The ~let~ binding defines a lexical environment in which the variable ~x~ is locally bound to ~0~. Within this binding construct, we define a lambda expression which increments ~x~ by one and returns the incremented value. This lambda expression is automatically turned into a closure, in which the lexical environment lives on even after the ~let~ binding construct has exited. Each time we evaluate the closure, it increments ~x~, using the binding of ~x~ in that lexical environment.

Note that unlike dynamic variables which are tied to the symbol object itself, the relationship between lexical variables and symbols is only present in the interpreter (or compiler). Therefore, functions which take a symbol argument (like symbol-value, boundp, and set) can only retrieve or modify a variableâs dynamic binding (i.e., the contents of its symbolâs value cell).

**** Using lexical binding
When loading an Emacs Lisp file or evaluating a Lisp buffer, lexical binding is enabled if the buffer-local variable lexical-binding is non-nil:

Variable: lexical-binding
If this buffer-local variable is non-nil, Emacs Lisp files and buffers are evaluated using lexical binding instead of dynamic binding. (However, special variables are still dynamically bound.) If nil, dynamic binding is used for all local variables. This variable is typically set for a whole Emacs Lisp file, as a file local variable. Note that unlike other such variables, this one must be set in the first line of a file.

When evaluating Emacs Lisp code directly using an eval call, lexical binding is enabled if the lexical argument to eval is non-nil.

Even when lexical binding is enabled, certain variables will continue to be dynamically bound. These are called special variables. Every variable that has been defined with ~defvar~, ~defcustom~ or ~defconst~ is a special variable. All other variables are subject to lexical binding.

Using ~defvar~ without a value, it is possible to bind a variable dynamically just in one file, or in just one part of a file while still binding it lexically elsewhere. For example:

#+begin_src emacs-lisp

  (let (_)
    (defvar x)      ; Let-bindings of x will be dynamic within this let.
    (let ((x -99))  ; This is a dynamic binding of x.
      (defun get-dynamic-x ()
        x)))

  (let ((x 'lexical)) ; This is a lexical binding of x.
    (defun get-lexical-x ()
      x))

  (let (_)
    (defvar x)
    (let ((x 'dynamic))
      (list (get-lexical-x)
            (get-dynamic-x))))
  ;; =>  (lexical dynamic)

#+end_src

Note that since this is a function, it can only return non-nil for variables which are permanently special, but not for those that are only special in the current lexical scope.

** Variables
*** let
Declare that a list of variables is for use within the body of the ~let~ and give them an initial value; then evaluate the rest of the expressions in the body of the let and return the value of the last one. Inside the body of the ~let~, the Lisp interpreter does not see the values of the variables of the same names that are bound outside of the ~let~.

A ~let~ expression is a list of three parts.
- The first part is the symbol ~let~.
- The second part is a list, called a /varlist/, each element of which is either a symbol by itself or a two-element list, the first element of which is a symbol.
- The third part of the let expression is the body of the let.

The symbols in the varlist have the initial value of ~nil~.

#+begin_src emacs-lisp

  (let varlist bodyâ¦)
  (let (variable variable variable ...) body...)


  ;; varlist composed of two-element lists
  (let ((variable value)
        (variable value)
        â¦)
    bodyâ¦)

  (let ((zebra "stripes")
        (tiger "fierce"))
    (message "One kind of animal has %s and another is %s."
             zebra tiger))
  ;; "One kind of animal has stripes and another is fierce."


  (let ((birch 3)
        pine
        fir
        (oak 'some))
    (message
     "Here are %d variables with %s, %s, and %s value."
     birch pine fir oak))
  ;; "Here are 3 variables with nil, nil, and some value."

#+end_src

*** let*
It enables Emacs to set each variable in its varlist in *sequence*, one after another. Its critical feature is that variables later in the varlist can make use of the values to which Emacs set variables earlier in the varlist.

#+begin_src emacs-lisp

  (let* ((foo 7)
         (bar (* 3 foo)))
    (message "`bar' is %d." bar)) ;; => "âbarâ is 21."

#+end_src

*** set
To set the value of a symbol, Emacs lisp uses the ~set~ function which return and sets the value as a side effect. The symbol (which can be viewed as a variable) is bound to the value.

Note also, that when you use ~set~, you need to quote both arguments to ~set~, unless you want them evaluated. When you use ~set~ without quoting its first argument, the first argument is evaluated before anything else is done.

#+begin_src emacs-lisp

  (set 'flowers '(rose violet daisy buttercup))
  ;; => (rose violet daisy buttercup)

#+end_src

*** setq
Sets the value of its first argument to the value of the second argument. Is just like [[set]] except that the first argument is quoted automatically, so you donât need to type the quote mark yourself.

Also, ~setq~ can be used to assign different values to different variables. The first argument is bound to the value of the second argument, the third argument is bound to the value of the fourth argument, and so on.

In summary, when a Lisp variable is set to a value, it is provided with the address of the list to which the variable refers.

#+begin_src emacs-lisp

  (setq x 1)
  ;; => x = 1

  (setq a 3 b 2 c 7)
  ;; a=3, b=2, c=7

  (setq flor '(rosa violeta))
  ;; flor = (rosa violeta)

  (setq trees '(pine fir oak maple)
        herbivores '(gazelle antelope zebra))
  ;; trees = (pine fir oak maple)
  ;; herbivores = (gazelle antelope zebra)

  (setq flor (list 'rosa 'violeta))
  ;; flor = (rosa violeta)

#+end_src

When a variable is set to a list, it stores the address of the first box in the variable.

#+begin_src

  (setq bouquet '(rose violet buttercup))

  bouquet
       |
       |     ___ ___      ___ ___      ___ ___
        --> |___|___|--> |___|___|--> |___|___|--> nil
              |            |            |
              |            |            |
               --> rose     --> violet   --> buttercup

#+end_src

Symbols consist of more than pairs of addresses, but the structure of a symbol is made up of addresses. Indeed, the symbol bouquet consists of a group of address-boxes, one of which is the address of the printed word ~bouquet~, a second of which is the address of a function definition attached to the symbol, if any, a third of which is the address of the first pair of address-boxes for the list ~(rose violet buttercup)~, and so on. Here we are showing that the symbolâs third address-box points to the first pair of address-boxes for the list.

#+begin_src

  (setq flowers (cdr bouquet))

  bouquet        flowers
    |              |
    |     ___ ___  |     ___ ___      ___ ___
     --> |   |   |  --> |   |   |    |   |   |
         |___|___|----> |___|___|--> |___|___|--> nil
           |              |            |
           |              |            |
            --> rose       --> violet   --> buttercup

#+end_src

*** defvar
Is similar to [[setq]] in that it sets the value of a variable. It is unlike ~setq~ in two ways: first, it only sets the value of the variable if the variable *does not* already have a value. If the variable already has a value, ~defvar~ does not override the existing value (this is actually useful: packages can define their variables with ~defvar~ and you can set values for them before the package gets loaded! Your settings will not be overridden by the default value). Second, ~defvar~ has a documentation string.

*Note*: When you specified a variable using the ~defvar~ special form, you could distinguish a variable that a user might want to change from others by typing an asterisk, ~*~, in the first column of its documentation string ~(defvar variable "*Buffer name ...")~.

#+begin_src emacs-lisp

  ;; kill-ring is defined by defvar
  (defvar kill-ring nil "...")


  ;; variable defined with a conditional construction
  (defvar X-axis-label-spacing
    (if (boundp 'graph-blank)
        (* 5 (length graph-blank))
      5)
    "Number of units from one X axis label to next.")

#+end_src

*** fset
Set SYMBOL's function definition to DEFINITION, and return DEFINITION.

Emacs Lisp maintains different namespaces for variables and functions so ~fset~ must be used for functions.

#+begin_src emacs-lisp

  ;; Since lambdas are literals and we can assign variable names to
  ;; literals we can set the lambda function.
  (fset 'cube (lambda (x) (* x x x))) (lambda (x) (* x x x))
  (cube 5) ;; => 125


  ;; Sets the function symbol yes-or-or-no-p to the definition y-or-n-p
  ;; and returns the definition y-or-n-p
  (fset 'yes-or-no-p 'y-or-n-p)

#+end_src

** Special forms
*** progn
Evaluate each argument in sequence and then return the value of the last.

Sometimes you need to group several expressions together as one single expression. This can be done with ~progn~.

The purpose of ~(progn â¦)~ is similar to a block of code ~{â¦}~ in C-like languages. It is used to group together a bunch of expressions into one single parenthesized expression.

The preceding expressions are evaluated only for the side effects they perform. The values produced by them are discarded.

#+begin_src emacs-lisp

  (progn
    bodyâ¦)


  (progn 1 2 3 4) ;; => 4


  ;; Most of the time it's used inside âifâ. For example:
  (if something
      (progn ; true
        â¦
        )
    (progn ; else
      â¦
      )
    )

#+end_src

*** save-excursion
Record the values of *point and the current buffer* before evaluating the body of this special form. Restore the value of point and buffer afterward.

~save-excursion~ restores the value of point even if something goes wrong in the code inside of it.

#+begin_src emacs-lisp

  (save-excursion
    first-expression-in-body
    second-expression-in-body
    third-expression-in-body
    â¦
    last-expression-in-body)


  ;; often occurs within the body of a let expression
  (let varlist
    (save-excursion
      bodyâ¦))


  (message "We are %d characters into this buffer."
           (- (point)
              (save-excursion
                (goto-char (point-min)) (point))))

#+end_src

*** save-restriction
Record whatever narrowing is in effect in the current buffer, if any, and restore that narrowing after evaluating the arguments.

When the Lisp interpreter meets with ~save-restriction~, it executes the code in the body of the ~save-restriction~ expression, and then undoes any changes to narrowing that the code caused.

Note: when you use both ~save-excursion~ and ~save-restriction~, one right after the other, you should use ~save-excursion~ outermost. If you write them in reverse order, you may fail to record narrowing in the buffer to which Emacs switches after calling ~save-excursion~.

#+begin_src emacs-lisp

  (save-restriction
    bodyâ¦ )


  ;; when written together should be written like this
  (save-excursion
    (save-restriction
      bodyâ¦))

#+end_src

*** widen
This function undoes any [[narrowing]] the current buffer.

*** quote
This special form quote returns object, as written, without evaluating it. This provides a way to include constant symbols and lists, which are not self-evaluating objects, in a program. (It is not necessary to quote self-evaluating objects such as numbers, strings, and vectors.)

Because quote is used so often in programs, Lisp provides a convenient read syntax for it. An apostrophe character ~'~ followed by a Lisp object (in read syntax) expands to a list whose first element is quote, and whose second element is the object. Thus, the read syntax ~'x~ is an abbreviation for ~(quote x)~.

#+begin_src emacs-lisp

  (quote (+ 1 2)) ;; => (+ 1 2)
  (quote foo)     ;; => foo
  'foo            ;; => foo

  ;; Although the expressions both yield lists equal
  (list '+ 1 2) ;; => (+ 1 2) ;; is a freshly-minted mutable list
  '(+ 1 2)      ;; => (+ 1 2) ;; is a list built from conses that might
                              ;; be shared and shouldn't be modified

#+end_src

*** nil
Is both a symbol (false) ~nil~ and an empty list ~()~. In Emacs Lisp, any value that is not ~nil~ âis not the empty listâis considered true.

For convenience, the symbol ~nil~ is considered to have ~nil~ as its CDR (and also as its CAR).

** Booleans
*** or
Evaluate each argument in sequence, and return the value of the first argument that is not ~nil~; if none return a value that is not ~nil~, return ~nil~.

#+begin_src emacs-lisp

  (or   1 2) ;; => 1
  (or nil 2) ;; => 2

#+end_src

*** and
Evaluate each argument in sequence, and if any are ~nil~, return ~nil~; if none are ~nil~, return the value of the last argument.

*** not
Is a function that returns true if its argument is ~false~ and false if its argument is ~true~.

** Comparing
*** <,>,<=,>=
Tests whether its first argument is smaller than its second argument. Its behavior is similar to these, ~>~, ~<=~, ~>=~ and ~=~. In all cases, both arguments must be numbers or markers.

*** /=
Not equal. It is for comparing *numbers only*.

*** equal
It tests if two values have the same datatype and value.

Test whether two *objects* are the same. ~equal~ uses one meaning of the word âsameâ and [[eq]] uses another: ~equal~ returns true if the two objects have a similar structure and contents, such as two copies of the same book. On the other hand, ~eq~, returns true if both arguments are actually the same object.

The ~eq~ function is similar to the ~equal~ function in that it is used to test for equality, but differs in that it determines whether two representations are actually the same object inside the computer, but with different names. ~equal~ determines whether the structure and contents of two expressions are the same.

Compara recursivamente el contenido de los objetos si son enteros, cadenas, marcadores, vectores, vectores bool, objetos de funciÃ³n de cÃ³digo de bytes, tablas de caracteres, registros u objetos de fuente.

| /a/     | /b/     | /eq/  | /equal/ | /=/     | /string=/ |
|-------+-------+-----+-------+-------+---------|
| 5     | 5     | t   | t     | t     | error   |
| 5     | 5.0   | nil | nil   | t     | error   |
| âaâ   | âaâ   | nil | t     | error | t       |
| âaâ   | âa    | nil | nil   | error | t       |
| a     | a     | t   | t     | error | error   |
| âaâ   | âAâ   | nil | nil   | error | nil     |
| (1 2) | (1 2) | nil | t     | error | error   |

#+begin_src emacs-lisp

  (equal 3 3)   ;; => t
  (equal 3 3.0) ;; => nil
  (eq 3 3)      ;; => t
  (eq 3 3.0)    ;; => nil

  (equal '(1 (2 (3))) '(1 (2 (3)))) ; => t
  (eq    '(1 (2 (3))) '(1 (2 (3)))) ; => nil

  (equal (point-marker) (point-marker)) ; => t
  (eq    (point-marker) (point-marker)) ; => nil

  ;; General way to test inequality.
  (not (equal 3 4)) ; â t

  ;; example of testing a "string"
  (equal "stringHere" ((substring (car variable) -1))) ;; variable may be string

  ;; example of testing a "t"
  (eq t (car someVariable)) ;; variable may be "t"

#+end_src

*** eq
Test whether two *objects* are the same.

~eq~ uses one meaning of the word âsameâ and [[equal]] uses another: ~eq~, returns true if both arguments are actually the same object. On the other hand, ~equal~ returns true if the two objects have a similar structure and contents, such as two copies of the same book.

The ~eq~ function is similar to the ~equal~ function in that it is used to test for equality, but differs in that it determines whether two representations are actually the same object inside the computer, but with different names. ~equal~ determines whether the structure and contents of two expressions are the same.

Dos argumentos con el mismo contenido o elementos no son necesariamente equivalentes entre sÃ­, son equivalentes solo si son el mismo objeto, lo que significa que un cambio en los contenidos de uno se reflejarÃ¡ en el mismo cambio en los contenidos del otro.

| /a/     | /b/     | /eq/  | /equal/ | /=/     | /string=/ |
|-------+-------+-----+-------+-------+---------|
| 5     | 5     | t   | t     | t     | error   |
| 5     | 5.0   | nil | nil   | t     | error   |
| âaâ   | âaâ   | nil | t     | error | t       |
| âaâ   | âa    | nil | nil   | error | t       |
| a     | a     | t   | t     | error | error   |
| âaâ   | âAâ   | nil | nil   | error | nil     |
| (1 2) | (1 2) | nil | t     | error | error   |

#+begin_src emacs-lisp

  (eq    '(1 (2 (3))) '(1 (2 (3)))) ; => nil
  (equal '(1 (2 (3))) '(1 (2 (3)))) ; => t

  (eq    (point-marker) (point-marker)) ; => nil
  (equal (point-marker) (point-marker)) ; => t

#+end_src

*** string-lessp
Tests whether its first argument is smaller than the second argument. A shorter, alternative name for the same function (a defalias) is ~string<~.

The arguments to ~string-lessp~ must be strings or symbols; the ordering is lexicographic, so case is significant. The print names of symbols are used instead of the symbols themselves.

An empty string, ~""~, a string with no characters in it, is smaller than any string of characters.

*** string-equal
Provides the corresponding test for equality. Its shorter, alternative name is ~string=~.

Can be used to compare string and symbol.

#+begin_src emacs-lisp

  (string-equal "abc" 'abc) ; â t

#+end_src

** Conditionals
*** if
Evaluate the first argument to the function; if it is true, evaluate the second argument; else evaluate the third argument, if there is one.

#+begin_src emacs-lisp

  (if true-or-false-test
      action-to-carry-out-if-test-is-true)


  (if (> 5 4)                             ; if-part
      (message "5 is greater than 4!"))   ; then-part

#+end_src

*** ifâthenâelse
An [[if]] expression may have an optional third argument, called the else-part, for the case when the true-or-false-test returns false.

#+begin_src emacs-lisp

  (if true-or-false-test
      action-to-carry-out-if-the-test-returns-true
    action-to-carry-out-if-the-test-returns-false)


  (if (> 4 5)                               ; if-part
      (message "4 falsely greater than 5!") ; then-part
    (message "4 is not greater than 5!"))   ; else-part


  ;; example of doing nothing when "if" is true but doing
  ;; something when we have "else" part
  (if (> 4 5)
      () ;; then do nothing
    (message "4 is not greater than 5!"))

#+end_src

*** when
Is an [[if]] without the possibility of an else clause. In your mind, you can replace ~when~ with ~if~ and understand what goes on. That is what the Lisp interpreter does. Technically speaking, ~when~ is a Lisp [[Macro]].

#+begin_src emacs-lisp

  (when test expr1 expr2 â¦)


  ;; Its meaning is the same as
  (if test (progn expr1 expr2 â¦)).

#+end_src

*** unless
If COND yields nil, do BODY, else return nil.

Is an [[if]] without a then-part clause, just the else-part.

*Note*: ~unless~ (si no) is the inverse of ~if~ , such that ~unless foo~ means the same thing as ~if (not foo)~.

#+begin_src emacs-lisp

  (unless nil
    5) ;; => 5
  (unless t
    5) ;; => nil

#+end_src

*** cond
Try each clause until one succeeds.

Each clause looks like ~(CONDITION BODY...)~.  ~CONDITION~ is evaluated and, if the value is ~non-nil~, this clause succeeds: then the expressions in ~BODY~ are evaluated and the last one's value is the value of the ~cond-form~. If a clause has one element, as in ~(CONDITION)~, then the ~cond-form~ returns ~CONDITION's~ value, if that is ~non-nil~. If no clause succeeds, cond returns ~nil~.

#+begin_src emacs-lisp

  (cond CLAUSES...)


  (cond ( (> 5 10) 55)
        ( (< 5 10) 100)
        ( (= 5  5) 200) ) ;; 100

#+end_src

*** condition-case
Es usada para manejar condicionalmente errores que pueden surgir al aplicar otras funciones, por ejemplo, al ejecutar la funciÃ³n kill-region en un buffer de solo lectura, ella maneja el error no cortando la informaciÃ³n (no puede al ser buffer read-only) pero si copiandola para agregarla al kill-ring.

It takes three arguments.

The first is the var argument, is sometimes bound to a variable that contains information about the error. However, if that argument is nil, that information is discarded.

The second argument determines what should happen when everything works correctly.

If an error occurs, among its other actions, the function generating the error signal will define one or more error condition names.

The third argument is an error handler. An error handler has two parts, a condition-name and a body. If the condition-name part of an error handler matches a condition name generated by an error, then the body part of the error handler is run.

#+begin_src emacs-lisp

  (condition-case
      var              ;; information
      bodyform         ;; If no errors, run only this code
    error-handlerâ¦)  ;; but, if errors, run this other code

#+end_src

** Loops and recursion
*** while
The ~while~ special form tests whether the value returned by evaluating its first argument is true or false. If the value returned by evaluating the first argument is ~false~, the Lisp interpreter skips the rest of the expression and does not evaluate it. If the value is ~true~, the Lisp interpreter evaluates the body of the expression and then again tests whether the first argument to while is ~true~ or ~false~, repeating the proccess.

#+begin_src emacs-lisp

  (while true-or-false-test
    bodyâ¦)


                                          ; Incrementing Loop
  set-count-to-initial-value
  (while (< count desired-number) ; true-or-false-test
    bodyâ¦
    (setq count (1+ count)))      ; incrementer
  ; the expression (1+ count) is te same (+ 1 count)


  ;; Printing a list
  (setq animals '(gazelle giraffe lion tiger))
  (defun print-elements-of-list (list)
    "Print each element of LIST on a line of its own."
    (while list
      (print (car list))
      (setq list (cdr list))))
  (print-elements-of-list animals)
  ;; => gazelle
  ;;    giraffe
  ;;    lion
  ;;    tiger
  ;;    nil

#+end_src

*** dolist
Automatically shortens the list each time it loopsâtakes the ~cdr~ of the listâand binds the ~car~ of each shorter version of the list to the first of its arguments.

#+begin_src emacs-lisp

  ;; Evaluate BODY with VAR bound to each car from LIST, in turn.
  ;; Then evaluate RESULT to get return value, default nil.
  ;; RESULT is optional
  (dolist (var list [result])
    body)


  (dolist (var '(0 2 4 6))
    (princ var))
  ;; 0246nil

  (let ((result "nothing"))
    (dolist (var '(0 2 4 6) result)
      (princ var)))
  ;; 0246"nothing"


  (defun reverse-list-with-dolist (list)
    "Using dolist, reverse the order of LIST."
    (let (result)  ; make sure list starts empty
      (dolist (var list result)
        (setq result (cons var result)))))

  ;; the same function using while
  (defun reverse-list-with-while (list)
    "Using while, reverse the order of LIST."
    (let (result)
      (while list
        (setq result (cons (car list) result))
        (setq list (cdr list)))
      result))

#+end_src

*** dotimes
Loops a specific number of times: you specify the number. ~dotimes~ is useful when you want to go thru a list with a index.

#+begin_src emacs-lisp

  (dotimes (var n) body) ;; run body, with var set to 0 to n-1


  (dotimes (var n result) body) ;; returns result


  (dotimes (number 5)
    (insert (message "%d" number)))
  ;; => 01234nil (supongo que de Ãºltimo imprime nil porque dotimes
  ;; viene del ciclo while que imprime nil cuando no se cumple la
  ;; condicion tru-false)


  (let (value)      ; otherwise a value is a void variable
    (dotimes (number 3)
      (setq value (cons number value)))
    value)
  ;; =>  (2 1 0)

#+end_src

*** Recursive
A recursive function typically contains a conditional expression which has three parts:

- A ~true-or-false-test~ that determines whether the function is called again, here called the ~do-again-test~.
- The name of the function. When this name is called, a new instance of the function is created and told what to do.
- An expression that returns a different value each time the function is called, here called the ~next-step-expression~. Consequently, the argument (or arguments) passed to the new instance of the function will be different from that passed to the previous instance. This causes the conditional expression, the ~do-again-test~, to test false after the correct number of repetitions.

*Note* that although we say that the function âcalls itselfâ, what we mean is that the Lisp interpreter assembles and instructs a *new instance* of the program. The new instance is a clone of the first, but is a separate individual.

#+begin_src emacs-lisp

  (defun name-of-recursive-function (argument-list)
    "documentationâ¦"
    (if do-again-test
        bodyâ¦
      (name-of-recursive-function
       next-step-expression)))


  (defun print-elements-recursively (list)
    "Print each element of LIST on a line of its own.
    Uses recursion."
    (when list                        ; do-again-test
      (print (car list))              ; body
      (print-elements-recursively     ; recursive call
       (cdr list))))                  ; next-step-expression

  (print-elements-recursively '(1 2 3 4)) ;; => 1 2 3 4


  (defun sum-nfirst-number-recursively (number)
    "Return the sum of the numbers 1 through NUMBER inclusive."
    (if (= number 1)                    ; do-again-test
        1                               ; then-part
      (+ number                         ; else-part
         (sum-nfirst-number-recursively ; recursive call
          (1- number)))))               ; next-step-expression

  (sum-nfirst-number-recursively 4) ;; => 10


  ;; This function is a bit odd (novice practice). The next one is better.
  (defun rf/sum-list-recursively (list)
    "Return the sum of the numbers in a LIST."
    (let ((result 0)) ;; VARIABLE para poder entregar el resultado
      ;; si no se se coloca, el Ãºltimo resultado serÃ­a el "nil"
      ;; que arroja el condicional "if" al fallar el Ãºltimo valor
      ;; que rompe la recursividad
      (if (not (eq (car list) nil)) ;; CONDICIONAL que rompe la recursividad
          (setq result
                (+ (car list) (rf/sum-list-recursively (cdr list)))))
      ;; FUNCIÃN que llama la recursividad variando el parÃ¡metro
      result))

  (rf/sum-list-recursively '(1 2 3 4)) ;; => 10

  ;; Enhanced function.
  (defun rf/sum-list-recursively (list)
    "Return the sum of the numbers in a LIST."
    (if (not list)
        0
      (+ (car list) (rf/sum-list-recursively (cdr list)))))

  (rf/sum-list-recursively '(1 2 3 4 5)) ;; 15

  ;; The same function but using a loop.
  (defun rf/sum-list (list)
    "Return the sum of the numbers in a LIST."
    (let ((res 0))
      (while list
        (setq res  (+ res (car list))
              list (cdr list)))
      res))

  (rf/sum-list '(1 2 3 4 5)) ;; 15

#+end_src

*** Recursive Patterns
**** every
In the every recursive pattern, an action is performed on every element of a list.

The pattern is:

If a list be empty, return ~nil~.
Else, act on the beginning of the list (the ~car~ of the list)
- through a recursive call by the function on the rest (the ~cdr~) of the list,
- and, optionally, combine the acted-on element, using ~cons~, with the results of acting on the rest.

#+begin_src emacs-lisp

  (defun square-each (list)
    "Square each of a LIST, recursively."
    (if (not list)                 ; do-again-test
        nil
      (cons
       (* (car list) (car list))
       (square-each (cdr list))))) ; next-step-expression

  (square-each '(1 2 3)) ;; => (1 4 9)

#+end_src

**** accumulate
In the accumulate recursive pattern, an action is performed on every element of a list and the result of that action is accumulated with the results of performing the action on the other elements.

The pattern is:

If a list be empty, return ~zero~ or some other constant.
Else, act on the beginning of the list (the ~car~ of the list),
- and combine that acted-on element, using ~+~ or some other combining function, with
- a recursive call by the function on the rest (the ~cdr~) of the list.

#+begin_src emacs-lisp

  (defun add-elements (list)
    "Add the elements of LIST together."
    (if (not list)
        0
      (+ (car list) (add-elements (cdr list)))))

  (add-elements '(1 2 3 4)) ;; => 10

#+end_src

**** keep
In the keep recursive pattern, each element of a list is tested; the element is acted on and the results are kept only if the element meets a criterion.

The pattern has three parts:

If a list be empty, return ~nil~.
Else, if the beginning of the list (the ~car~ of the list) passes a test
    - act on that element and combine it, using ~cons~ with
    - a recursive call by the function on the rest (the ~cdr~) of the list.
      Otherwise, if the beginning of the list (the ~car~ of the list) fails the test
      - skip on that element,
      - and, recursively call the function on the rest (the ~cdr~) of the list.

#+begin_src emacs-lisp

  (defun keep-three-letter-words (word-list)
    "Keep three letter words in WORD-LIST."
    (cond
     ;; First do-again-test: stop-condition
     ((not word-list) nil)
     ;; Second do-again-test: when to act
     ((eq 3 (length (symbol-name (car word-list))))
      ;; combine acted-on element with recursive call on shorter list
      (cons (car word-list) (keep-three-letter-words (cdr word-list))))
     ;; Third do-again-test: when to skip element;
     ;;   recursively call shorter list with next-step expression
     (t (keep-three-letter-words (cdr word-list)))))

  (keep-three-letter-words '(one two three four five six))
  ;; => (one two six)

#+end_src

**** No deferment solution
The solution to the problem of deferred operations is to write in a manner that does not defer operations (the phrase /tail recursive/ is used to describe such a process, one that uses constant space). This requires writing to a different pattern, often one that involves writing two function definitions, an initialization function and a helper function.

The initialization function sets up the job; the helper function does the work.

*Note*: this is also called [[~/Documents/todo.org::Tail call][tail recursive]].

Here are the two function definitions for adding up numbers. They are so simple, I find them hard to understand.

#+begin_src emacs-lisp

  (defun triangle-initialization (number)
    "Return the sum of the numbers 1 through NUMBER inclusive.
  This is the initialization component of a two function
  duo that uses recursion."
    (triangle-recursive-helper 0 0 number))


  (defun triangle-recursive-helper (sum counter number)
    "Return SUM, using COUNTER, through NUMBER inclusive.
  This is the helper component of a two function duo
  that uses recursion."
    (if (> counter number)
        sum
      (triangle-recursive-helper (+ sum counter)  ; sum
                                 (1+ counter)     ; counter
                                 number)))        ; number
  (triangle-initialization 7)
  ;; (triangle-recursive-helper  0   0   7)  ;; Immediately call
  ;;   (triangle-recursive-helper  1   1   7)
  ;;     (triangle-recursive-helper  3   2   7)
  ;;       (triangle-recursive-helper  6   3   7)
  ;;         (triangle-recursive-helper 10   4   7)
  ;;           (triangle-recursive-helper 15   5   7)
  ;;             (triangle-recursive-helper 21   6   7)
  ;;               (triangle-recursive-helper 28   7   7)
  ;;               => 28
  ;;             => 28
  ;;           => 28
  ;;         ...
  ;; => 28
  ;; This is optimized by the compiler.

  ;; The same recursion function without deferments
  (defun triangle-recursively (number)
    "Return the sum of the numbers 1 through NUMBER inclusive.
  Uses recursion."
    (if (= number 1)                    ; do-again-test
        1                               ; then-part
      (+ number                         ; else-part
         (triangle-recursively          ; recursive call
          (1- number)))))               ; next-step-expression

  (triangle-recursively 7)
  ;; (+ 7 (triangle-recursively 6)) ;; Wait for a new value
  ;; (+ 7 6 (triangle-recursively 5))
  ;; (+ 7 6 5 (triangle-recursively 4))
  ;; (+ 7 6 5 4 (triangle-recursively 4))
  ;; (+ 7 6 5 4 3 (triangle-recursively 4))
  ;; (+ 7 6 5 4 3 2 (triangle-recursively 4))
  ;; (+ 7 6 5 4 3 2 1)
  ;; => 28

#+end_src

Deferments solution allows an interpreter or compiler to reorganize the execution which would ordinarily look like this:

#+begin_src

  call triangle-initialization (7)
    call triangle-recursive-helper  (0   0   7)
      call triangle-recursive-helper  (1   1   7)
        call triangle-recursive-helper  (3   2   7)
          call triangle-recursive-helper  (6   3   7)
            call triangle-recursive-helper (10   4   7)
              call triangle-recursive-helper (15   5   7)
                call triangle-recursive-helper (21   6   7)
                  call triangle-recursive-helper (28   7   7)
                  return 28
                return 28
              return 28
            ...
    return 28

#+end_src

into the more efficient variant, in terms of both space and time:

#+begin_src

  call triangle-initialization (7)
    call triangle-recursive-helper  (0   0   7)
    replace arguments with  (1   1   7)
    replace arguments with  (3   2   7)
    replace arguments with  (6   3   7)
    replace arguments with (10   4   7)
    replace arguments with (15   5   7)
    replace arguments with (21   6   7)
    replace arguments with (28   7   7)
    return 28
  return 28

#+end_src

This reorganization saves space because no state except for the calling function's address needs to be saved, either on the stack or on the heap, and the call stack frame for ~triangle-recursive-helper~ is reused for the intermediate results storage. This also means that the programmer need not worry about running out of stack or heap space for extremely deep recursions. In typical implementations, the tail-recursive variant will be substantially faster than the other variant, but only by a constant factor.

Some programmers working in functional languages will rewrite recursive code to be tail recursive so they can take advantage of this feature. This often requires addition of an "accumulator" argument (~sum~ in the example) to the function.

** Functions
*** defun
In Lisp, a symbol such as ~mark-whole-buffer~ has code attached to it that tells the computer what to do when the function is called. This code is called the function definition and is created by evaluating a Lisp expression that starts with the symbol ~defun~.

A function definition has up to five parts following the word ~defun~:

- The name of the symbol to which the function definition should be attached.
- A list of the arguments that will be passed to the function. If no arguments will be passed to the function, this is an empty list, ~()~.
- Documentation describing the function. (optional)
- An expression to make the function interactive so you can use it by typing ~M-x~ and then the name of the function. (optional)
- The code that instructs the computer what to do: the body of the function definition.

It is helpful to think of the five parts of a function definition as being organized in a template, with slots for each part:

#+begin_src emacs-lisp

  (defun function-name (argumentsâ¦)
    "One sentence summary of what this command do, no more than 67 chars.

  More details here. Be sure to mention the return value if relevant.
  Lines here should not be longer than 70 chars,
  and don't indent them.

  â¢ ARG1 isâ¦. Parameters should be all caps.
  â¢ See URL `http://example.com/' (clickable url)
  â¢ See `dired' (clickable command name)
  â¢ See `(emacs) Dired'. (link to info doc)
  â¢ Type \\[dired] to go into dired. (key of a command.)
  â¢ clickable list of all keys of a given keymap name.
  \\{c-mode-map}
  â¢ \\<c-mode-map> No visible effect. Tell emacs to use this keymap for
  displaying keys in the rest of this inline doc."
    (interactive argument-passing-info)     ; optional
    bodyâ¦)


  (defun multiply-by-seven (number)
    "Multiply NUMBER by seven."
    (* 7 number))

#+end_src

#+begin_src emacs-lisp

  (defun triangulo (numero)
    "Devuelve la suma de nÃºmeros desde el 1 hasta e incluyendo a NUMERO."
    (let ((total 0))
      (while (> numero 0)
        (setq total (+ total numero))
        (setq numero (1- numero)))
      total))


  (defun cuadrado-de-cada-uno (lista-de-numeros)
    "El cuadrado de cada elemento en LISTA DE NUMEROS, recursivamente."
    (if (not lista-de-numeros)		; prueba-hazlo-de-nuevo
        nil
      (cons
       (* (car lista-de-numeros) (car lista-de-numeros))
       (cuadrar-cada-uno (cdr lista-de-numeros))))) ; expresion-del-siguiente-paso

#+end_src

*** Parameters
Emacs's function parameter's features and syntax is very basic. It is simply a list of items. If you want optional parameters, just add ~&optional~. Any parameter after that will be optional.

#+begin_src emacs-lisp

  ;; defining a function with 2 optional params named cc and dd
  (defun myfun (aa bb &optional cc dd)
    ""
    (let ((varOptional (or cc 5))))) ;; if send cc, put it on, if not, do not
  ;; When you call, a and b are required, c and d are optional.
  ;; When a optional parameter is not given, its value is nil.

#+end_src

If you want to give a argument to some optional parameters but not all, use ~nil~ for those you don't care.

#+begin_src emacs-lisp

  ;; calling a function with 3rd parameter omitted
  (myfun "mya" "myb" nil "myd")

#+end_src

If a function received a ~nil~ as argument for one of its optional parameter, there is no way for a function to know if it is specified by user or omitted.

Elisp also support the *unspecified number of parameters*. It is done by adding ~&rest~ similar to ~&optional~. You can have both ~&optional~ and ~&rest~, in that order.

*** interactive
Declare to the interpreter that the function can be used interactively (by typing ~M-x~ and then the name of the function).

This special form may be followed by a string with one or more parts that pass the information to the arguments of the function, in sequence. These parts may also tell the interpreter to prompt for information. Parts of the string are separated by newlines,  ~\n~ (can be use with a [[prefix argument]] like this ~C-u 3 M-x multiply-by-seven~).

The ~(interactive â¦)~ is used to fill out the parameters, when your function is called by user interactively (as opposed to from a lisp program).

- p :: The *numeric prefix argument*. It will pass converted numerical value of ~current-prefix-arg~ to your function's first argument. Prefix arg converted to number. Does not do I/O.
- P :: *Prefix arg in raw* form. It will pass the value of ~current-prefix-arg~ to your function's first argument. Does not do I/O.
- b :: The *name* of an existing *buffer*.
- f :: The *name* of an existing *file*.
- r :: *Point and the mark*, as two numeric arguments, smallest first. This is the only code letter that specifies two successive arguments rather than one.
- s :: Any *string*.  Does not inherit the current input method.

Tech detail: In emacs, âcommandsâ are a subset of âfunctionsâ. Commands are functions that can be called interactively (by typing ~M-x~). A function is a command when its definition contains the ~(interactive â¦)~ clause.

#+begin_src emacs-lisp

  (defun multiply-by-seven (number)       ; Interactive version.
    "Multiply NUMBER by seven."
    (interactive "p") ;; current-prefix-arg
    (message "The result is %d" (* 7 number)))
  ;; "C-u 3 M-x multiply-by-seven" => 21
  ;; 1 if universal-argument isn't called


  (defun f (x)
    "print argument received"
    (interactive "P")
    (message "%s" x)) ;; value of x is from universal argument
  ;; nil if universal-argument isn't called


  (defun multiple-hello (someone num)
    "Say hello to SOMEONE via M-x hello, for NUM times."
    ;;(interactive "code_letter_and_promp_string")
    (interactive "sWho do you want to say hello to? \nnHow many times?")
    ;; "s" prompt user for a string as argument.
    ;; "n" prompt user for a number as argument.
    ;; "\n" part that separates the arguments.
    (dotimes (i num)
      (insert (message "Hello %s!\n" someone))))
  ;; "s" is any string "n" number read using minibuffer
  ;; "M-x multiple-hello Carlos 2"
  ;; => Hello Carlos!
  ;;    Hello Carlos!


  ;;The following is a basic function definition taking region as arg.
  (defun myFunction (myStart myEnd)
    "Prints region start and end positions"
    (interactive "r")
    ;; "r" for commands that takes 2 arguments, the beginning and
    ;; ending positions of the current region..
    (message "Region begin at: %d, end at: %d" myStart myEnd))

#+end_src

One way to use the ~interactive~ function is for it to return a list. This list's element will be fed to the function as arguments.

#+begin_src emacs-lisp

  ;; Interesting quick example of the behavior of the interactive function
  (defun xah/wrap-html-tag (tagName &optional className Î¾id)
    ;;(interactive (list â¦))
    (interactive '(1 2 3))
    (message "uno %s dos %s tercer %s" tagName className Î¾id))
  ;; => 1 dos 2 tercer 3

#+end_src

Sometimes you do not want your function's parameter spec to explicitly contain universal argument, because it is not relevant to the function. So, ~(interactive "P")~ is not appropriate.

Example of a command that we want to create a HTML tag like this:

#+begin_src html

  cat
  â
  <div>cat</div>
  or
  <div class="xyz">cat</div>
  or
  <div id="id8295" class="xyz">cat</div>

#+end_src

#+begin_src emacs-lisp

  (defun xah/wrap-html-tag (tagName &optional className Î¾id)
    "Add a HTML tag to beginning and ending of current word or text selection.

  When preceded with `universal-argument',
  no arg = prompt for tag, class.
  2 = prompt for tag, id.
  any = prompt for tag, id, class.

  When called interactively,
  Default id value is ãidâ¹random numberâºã.
  Default class value is ãxyzã.

  When called in lisp program, if className is nil or empty string, don't add the attribute. Same for Î¾id."
    (interactive
     (cond
      ((equal current-prefix-arg nil)     ; universal-argument not called
       (list
        (read-string "Tag (span):" nil nil "span") ))
      ((equal current-prefix-arg '(4))    ; C-u
       (list
        (read-string "Tag (span):" nil nil "span")
        (read-string "Class (xyz):" nil nil "xyz") ))
      ((equal current-prefix-arg 2)       ; C-u 2
       (list
        (read-string "Tag (span):" nil nil "span")
        (read-string "id:" nil nil (format "id%d" (random (expt 2 28 ))))
        ))
      (t                                  ; all other cases
       (list
        (read-string "Tag (span):" nil nil "span")
        (read-string "Class (xyz):" nil nil "xyz")
        (read-string "id:" nil nil (format "id%d" (random (expt 2 28 )))))))))
  ;; now, all the parameters of your function is filled.
  ;; code body here

#+end_src

*** lambda
Is the symbol for an anonymous function, a function without a name. Every time you use an anonymous function, you need to include its whole body. It let you define a function in the middle of your code.

The read syntax ~#'~ is a short-hand for using ~function~.

#+begin_src emacs-lisp

  (lambda (arg-variables)
    [documentation-string]
    [interactive-declaration]
    body-forms)


  (lambda (x y) (+ x y))
  ;; is a function that takes two arguments, x and y, and returns their sum.

  ;; these are some of the ways of calling the function
  (funcall (lambda (x y) (+ x y)) 5 3) ;; => 8
  ((lambda (x y) (+ x y)) 5 3) ;; => 8


  ;; If we want to multiply 3 by 7, we can write:
  (multiply-by-seven 3)
   \_______________/ ^
           |         |
        function  argument
  ;; Similarly, we can write:
  ((lambda (number) (* 7 number)) 3)
   \____________________________/ ^
                 |                |
        anonymous function     argument


  ;; We had a function multiply-by-seven; it multiplied its argument by 7.
  (defun multiply-by-seven (number)
    (* 7 number))
  ;; The anonymous equivalent of multiply-by-seven is:
  (lambda (number) (* 7 number))


  ;; The following forms are all equivalent:
  (lambda (x) (* x x))
  (function (lambda (x) (* x x)))
  #'(lambda (x) (* x x))

  ;; Note:
  ;; function (aka #') is used to quote functions, whereas quote (aka ')
  ;; is used to quote data.

#+end_src

*** funcall
~funcall function &rest arguments~

Call first argument as a function, passing remaining ARGUMENTS to it, and returns whatever FUNCTION returns.

Since funcall is a function, all of its ARGUMENTS, including FUNCTION, are evaluated before funcall is called. This means that you can use any expression to obtain the function to be called. It also means that funcall does not see the expressions you write for the arguments, only their values. These values are not evaluated a second time in the act of calling function; the operation of funcall is like the normal procedure for calling a function, once its arguments have already been evaluated.

The argument FUNCTION must be either a Lisp function or a primitive function. Special forms and macros are not allowed, because they make sense only when given the unevaluated argument expressions. funcall cannot provide these because, as we saw above, it never knows them in the first place.

#+begin_src emacs-lisp

  (setq f 'list)          ;; list
  (funcall f 'x 'y 'z)    ;; (x y z)
  (funcall f 'x 'y '(z))  ;; (x y (z))

  (funcall 'and t nil)    ;; error â Invalid function: #<subr and>(special form)

  (apply 'max '(1 2 3 4)) ;; 4
  (funcall 'max '(1 2 3 4))
  ;; => error because "funcall" would pass that argument to the function "max"
  ;; which precisely cannot recive the list as an argument while "apply" does,
  ;; "apply" passes each value of the list as an individual argument.

#+end_src

*** apply
~apply~ calls function with arguments, just like [[funcall]] but with one difference: the last of arguments is a list of objects, which are passed to function as separate arguments, rather than a single list. We say that apply spreads this list so that each individual element becomes an argument.

~apply~ with a single argument is special: the first element of the argument, which must be a non-empty list, is called as a function with the remaining elements as individual arguments. Passing two or more arguments will be faster.

~apply~ returns the result of calling function. As with funcall, function must either be a Lisp function or a primitive function; special forms and macros do not make sense in apply.

#+begin_src emacs-lisp

  (setq f 'list)     ;; => list
  (apply f 'x 'y 'z) ;; => errorâ Wrong type argument: listp, z


  (apply '+ 1 2 '(3 4)) ;; => 10
  (apply '+ '(1 2 3 4)) ;; => 10


  (apply 'append '((a b c) nil (x y z) nil)) ;; => (a b c x y z)
  ;; append sends each argument as an individual argument in itself.
  (apply '(+ 3 4)) ;; => 7
  (apply '(lambda (x) (+ x 5)) '(6)) ;; => 11


  (apply 'max '(1 2 3 4)) ;; => 4
  (funcall 'max '(1 2 3 4))
  ;; => error because "funcall" would pass that argument to the function "max"
  ;; which precisely cannot recive the list as an argument while "apply" does,
  ;; "apply" passes each value of the list as an individual argument.

#+end_src

*** High-order
Functions that take other functions as arguments.

#+begin_src emacs-lisp

  (defun transform-unless-zero (fn n)
    (if (= n 0) 0
      (funcall fn n)))


  (transform-unless-zero (lambda (n) (+ 1 n)) 7) ;; => 8

#+end_src

*** closure
Emacs can optionally enable lexical binding of variables. When lexical binding is enabled, any named function that you create (e.g., with ~defun~), as well as any anonymous function that you create using the ~lambda~ macro or the function special form or the ~#'~ syntax, is automatically converted into a *closure*.

A closure is a function that also carries a record of the lexical environment that existed when the function was defined. When it is invoked, any lexical variable references within its definition use the retained lexical environment. In all other respects, closures behave much like ordinary functions; in particular, they can be called in the same way as ordinary functions.

Currently, an Emacs Lisp closure object is represented by a list with the symbol closure as the first element, a list representing the lexical environment as the second element, and the argument list and body forms as the remaining elements:

#+begin_src emacs-lisp

  ;; lexical binding is enabled.
  (lambda (x) (* x x))
  ;; => (closure (t) (x) (* x x))

#+end_src

However, the fact that the internal structure of a closure is exposed to the rest of the Lisp world is considered an internal implementation detail. For this reason, we recommend against directly examining or altering the structure of closure objects.

#+begin_src emacs-lisp

  (defvar my-ticker nil)   ; We will use this dynamically bound
                           ; variable to store a closure.


  (let ((x 0))             ; x is lexically bound.
    (setq my-ticker (lambda ()
                      (setq x (1+ x)))))
  ;; (closure ((x . 0) t) ()
  ;;   (setq x (1+ x)))

  (funcall my-ticker) ;; => 1
  (funcall my-ticker) ;; => 2
  (funcall my-ticker) ;; => 3

  x                   ; Note that x has no global value.
  ;; => errorâ Symbol's value as variable is void: x

#+end_src

*** defadvice
Advising Emacs Lisp Functions

When you need to modify a function defined in another library, or when you need to modify a hook like foo-function, a process filter, or basically any variable or object field which holds a function value, you can use the appropriate setter function, such as fset or defun for named functions, setq for hook variables, or set-process-filter for process filters, but those are often too blunt, completely throwing away the previous value.

The advice feature lets you add to the existing definition of a function, by advising the function. This is a cleaner method than redefining the whole function.

#+begin_src emacs-lisp

  (defun my-double (x)
    (* x 2))

  (my-double 5) ;; 10


  (defun my-increase (x)
    (+ x 1))
  (advice-add 'my-double :filter-return #'my-increase)

  (my-double 5) ;; 11

#+end_src

** List processing
*** Get
**** car
Return the first item in the list.

~car~ does not remove the first item from the list; it only reports what it is. ~car~ is ânon-destructiveâ.

Thus, in Lisp, to get the ~car~ of a list, you get the address of the first element of the list.

#+begin_src emacs-lisp

  (car '(first second third)) ;; => first

#+end_src

**** nth
Takes the ~car~ of the result returned by [[nthcdr]]. It returns the Nth element of the list. The function is ânon-destructiveâ.

Note that the elements are numbered from zero, not one. That is to say, the first element of a list, its ~car~ is the zeroth element.

#+begin_src emacs-lisp

  (nth 0 '(zero first second third)) ;; => zero
  (nth 1 '(zero first second third)) ;; => first

#+end_src

**** elt
This function returns the element of sequence indexed by index. Legitimate values of index are integers ranging from 0 up to one less than the length of sequence. If sequence is a list, out-of-range values behave as for [[nth]].

#+begin_src emacs-lisp

  (elt [1 2 3 4] 2) ;; => 3

  (elt '(1 2 3 4) 2) ;; => 3

  ;; We use string to show clearly which character elt returns.
  (string (elt "1234" 2)) ;; => "3"

  (elt [1 2 3 4] 4) ;; errorâ Args out of range: [1 2 3 4], 4

#+end_src

**** last
Return the last link of LIST.  Its car is the last element.

#+begin_src emacs-lisp

  (last '(1 4 7)) ;; => (7)

#+end_src

**** cdr
Returns the second and subsequent elements of a list.

~cdr~ does not remove any elements from the listâit just returns a report of what the second and subsequent elements are.  ~cdr~ is ânon-destructiveâ

Thus, in Lisp, to get the ~cdr~ of a list, you just get the address of the next cons cell in the series.

#+begin_src emacs-lisp

  (cdr '(first second third)) ;; => (second third)

  (cdr (cdr '(zero first second third))) ;; => (second third)
  (nthcdr 2 '(zero first second third)) ;; => (second third)

#+end_src

**** nthcdr
Return the result of taking [[cdr]] ~n~ times on a list. The ârest of the restâ.

Is associated with the ~cdr~ function. What it does is take the ~cdr~ of a list repeatedly. The function is ânon-destructiveâ.

#+begin_src emacs-lisp

  (nthcdr 2 '(zero first second third)) ;; => (second third)

  (cdr (cdr '(zero first second third))) ;; => (second third)

#+end_src

**** seq-take
This function returns the first N (an integer) elements of SEQUENCE. If N is negative or zero, the result is nil.

#+begin_src emacs-lisp

  (seq-take '(1 2 3 4) 3)  ;; => (1 2 3)

  (seq-take [1 2 3 4] 0)   ;; =>  []

#+end_src

**** pop
This macro provides a convenient way to examine the CAR of a list, and take it off the list, all at once. It operates on the list stored in LISTNAME. It removes the first element from the list, saves the CDR into listname, then returns the removed element. *It changed the list*.

#+begin_src emacs-lisp

  (pop listname)
  ; In the simplest case, listname is an unquoted symbol naming a list
  ; in that case, this macro is equivalent to
  (prog1 (car  listname)
    (setq listname (cdr listname)))


  x       ;; => (a b c)
  (pop x) ;; => a
  x       ;; => (b c)

  ; More generally, listname can be a generalized variable.
  ; In that case, this macro saves into listname using setf.

#+end_src

**** seq-drop-while
This function returns the members of SEQUENCE in order, starting from the first one for which PREDICATE returns nil.

#+begin_src emacs-lisp

  (seq-drop-while (lambda (x) (> x 0)) '(1 2 3 -1 -2))
  ;; => (-1 -2)

  (seq-drop-while (lambda (x) (< x 0)) [1 4 6])
  ;; => [1 4 6]

#+end_src

*** Add
**** cons
Return a new list, with new element added to front. (prepend)

Constructs a list by prepending its first argument to its second argument. ~cons~ does not change an existing list, but creates a new one. ~cons~ is ânon-destructiveâ.

- ~cons~ must have a list to attach to. You cannot start from absolutely nothing. If you are building a list, you need to provide at least an empty list at the beginning.
- ~cons~, can put together or construct a list, but not an array.

The function ~cons~ adds a new pair of addresses to the front of a series of addresses. Thus, to ~cons~ a new element on a list, you add a new cons cell to the front of the list.

#+begin_src emacs-lisp

  (cons 'zero '(first second third)) ;; => (zero first second third)

  (cons 'born ()) ;; => (born)

  (cons 'born 'now) ;; => (born . now) ;; build cons cell

#+end_src

**** append
Return a new list, join two lists.

#+begin_src emacs-lisp

  (append '(1 2 3 4) '(5 6 7 8))
  ;; => (1 2 3 4 5 6 7 8)


  ;; The results contrast with cons, which constructs a new list in which
  ;; the first argument to cons becomes the first element of the new list:
  (cons '(1 2 3 4) '(5 6 7 8))
  ;; => ((1 2 3 4) 5 6 7 8)

#+end_src

**** push
Add new element to the list *stored* in the generalized variable. Like [[cons]] but *this does changed the list*.

#+begin_src emacs-lisp

  (push value list)

  ;; it's the same that
  (add-to-list list value)
  ;; and
  (setq list (cons value list))

  ;; example
  (setq list '(1 2 3 4)) ;; =>   (1 2 3 4)
  (push 5 list)          ;; => (5 1 2 3 4)
  list                   ;; => (5 1 2 3 4)

#+end_src

*Caution*: Si a ~push~ se le pasa una lista modificada (por ejemplo, la cola de la lista), solo cambiarÃ¡ esa parte de la lista (o sea, la cola) la primera parte quedarÃ¡ exactamente igual.

#+begin_src emacs-lisp

  (setq list '(1 2 3 4))              ;; => (1 2 3 4)
  (push (car list) (cdr (cdr list)))  ;; => (1 3 4)
  list                                ;; => (1 2 1 3 4)

#+end_src

*** Remove
**** pop
Remove first element from the variable. Returns the removed element. The argument must be a generalized variable whose value is a list.

#+begin_src emacs-lisp

  (setq mylist '(7 4 2 1 0)) ;; => (7 4 2 1 0)
  (pop mylist)               ;; => 7

#+end_src

**** butlast
Return a copy of LIST with the *last N elements removed*. It *doesn't change the list*.

#+begin_src emacs-lisp

  (butlast '(1 3 5 7 9) 2)  ;; => (1 3 5)

  (butlast '("a" "b" "c"))  ;; => ("a" "b")

#+end_src

**** nbutlast
Modify LIST to *remove the last N elements*. It *changed the list*.

#+begin_src emacs-lisp

  (nbutlast '(1 3 5 7 9) 2)  ;; => (1 3 5)

#+end_src

**** seq-drop
Returns all but the first ~n~ (an integer) elements of SEQUENCE. If ~n~ is negative or zero, the result is SEQUENCE.

#+begin_src emacs-lisp

  (seq-drop [1 2 3 4 5 6] 3)  ;; => [4 5 6]

  (seq-drop "hello world" -4) ;; => "hello world"

#+end_src

**** delq
~(delq ELT LIST)~
Delete members of LIST which are [[eq]] to ELT, and return the result.

#+begin_src emacs-lisp

  (delq   "b" '("a" "b" "c" "b")) ;; => ("a" "b" "c" "b")
  (delete "b" '("a" "b" "c" "b")) ;; => ("a" "c")

  (delq   2 '(1 2 3 2 4)) ;; => (1 3 4)
  (delete 2 '(1 2 3 2 4)) ;; => (1 3 4)

  (delq   '(0) '(1 (0) 2 3 (0) 4 5 6)) ;; => (1 (0) 2 3 (0) 4 5 6)
  (delete '(0) '(1 (0) 2 3 (0) 4 5 6)) ;; => (1 2 3 4 5 6)

#+end_src

**** delete
~(delete ELT SEQ)~
Delete members of SEQ which are [[equal]] to ELT, and return the result.

#+begin_src emacs-lisp

  (delete "b" '("a" "b" "c" "b")) ;; => ("a" "c")
  (delq   "b" '("a" "b" "c" "b")) ;; => ("a" "b" "c" "b")

  (delete 2 '(1 2 3 2 4)) ;; => (1 3 4)
  (delq   2 '(1 2 3 2 4)) ;; => (1 3 4)

  (delete '(0) '(1 (0) 2 3 (0) 4 5 6)) ;; => (1 2 3 4 5 6)
  (delq   '(0) '(1 (0) 2 3 (0) 4 5 6)) ;; => (1 (0) 2 3 (0) 4 5 6)

#+end_src

*** Replace
**** setcar
Changes the first element of a list.

Set the [[car]] of a list to a new value.

~setcar~ did not add a new element to the list as ~cons~ would have; it replaced first element of the list with new value; *it changed the list*.

The result we are interested in is the side effect, which we can see by evaluating the variable what will change.

#+begin_src emacs-lisp

  ;; first set value of a variable to the list
  (setq numbers (list 'first 'second 'third 'fourth))
  numbers ;; =>  (first second third fourth)

  ;; apply the function setcar to set a new first value
  (setcar numbers 'new)
  ;; evaluted the variable to check result
  numbers ;; =>  (new second third fourth)

#+end_src

**** setcdr
Changes the second and subsequent elements of a list.

Set the [[cdr]] of a list to a new value.

~setcdr~ did not add elements to the list as ~cons~ would have; it replaced the second and subsequent elements of the list with new values; *it changed the list*.

The result we are interested in is the side effect, which we can see by evaluating the variable what will change.

#+begin_src emacs-lisp

  ;; first set value of a variable to the list
  (setq numbers (list 'first 'second 'third 'fourth))
  numbers ;; =>  (first second third fourth)

  ;; apply the function setcar to set a new first value
  (setcdr numbers '(2 3))
  ;; evaluted the variable to check result
  numbers ;; =>  (first 2 3)

#+end_src

#+begin_src emacs-lisp

  ;; Ejemplo de acortar una lista se debe poneniendo
  ;; el Ãºltimo valor con nil
  (setq numbers (list 'first 'second 'third 'fourth))
  ;; numbers => (first second third fourth)

  (setcdr (nthcdr 2 numbers) nil)
  ;; (nthcdr 2 numbers) no altera la lista, solo trabaja
  ;; temporalmente entregando (third fourt) y luego
  ;; setcdr la altera (third fourt) => (third nil)
  ;; numbers => (first second third)
  ;; SE PUEDE VER MEJOR USANDO LAS DIRECCIONES DE LISTA, I.E.
  ;; CADA CONS CELL TIENE LA DIRECCIÃN PROPIA Y LA DE EL PUNTERO
  ;; AL SIGUIENTE VALOR

#+end_src

*** Misc
**** length
Return the length of vector, list or string.

#+begin_src emacs-lisp

  (length '(first second third)) ;; => 3

  (length "first") ;; => 5

  (length (make-bool-vector 5 nil)) ;; => 5

#+end_src

**** sort
This function sorts SEQUENCE stably. Note that this function doesnât work for all sequences; it may be used only for lists and vectors. If SEQUENCE is a list, it is modified *destructively*. This functions returns the sorted SEQUENCE and compares elements using PREDICATE. A stable sort is one in which elements with equal sort keys maintain their relative order before and after the sort. Stability is important when successive sorts are used to order elements according to different criteria.

*WARNING*: The destructive aspect of ~sort~ for lists is that it rearranges the cons cells forming SEQUENCE by changing CDRs. A nondestructive sort function would create new cons cells to store the elements in their sorted order. If you wish to make a sorted copy without destroying the original, copy it first with [[copy-sequence]] and then sort.

#+begin_src emacs-lisp

  (setq nums (list 1 3 2 6 5 4 0)) ;; => (1 3 2 6 5 4 0)
  (sort nums #'<)                  ;; => (0 1 2 3 4 5 6)
  nums                             ;; => (1 2 3 4 5 6)

  ;;Most often we store the result back into the variable
  ;;that held the original list:
  (setq nums (sort nums #'<))


  ;; to sort the list in alphabetical order
  (sort
   (files-in-below-directory "/some/path/")
   'string-lessp)

#+end_src

**** copy-sequence
This function returns a copy of its ARGUMENT, which should be either a sequence or a record. The copy is the same type of object as the original, and it has the same elements in the same order. However, if ARGUMENT is empty, like a string or a vector of zero length, the value returned by this function might not be a copy, but an empty object of the same type and identical to ARGUMENT.

*Storing a new element into the copy does not affect the original ARGUMENT, and vice versa. However, the elements of the copy are not copies; they are identical (eq) to the elements of the original. Therefore, changes made within these elements, as found via the copy, are also visible in the original.*

This function does not work for dotted lists. Trying to copy a circular list may cause an infinite loop.

#+begin_src emacs-lisp

  (setq x '(1 2 3))       ;; => (1 2 3)
  (setq y (copy-sequence x))  ;; => (1 2 3)

  (eq x y)     ;; => nil
  (equal x y)  ;; => t

  (eq (nth 1 x) (nth 1 y)) ;; => t

#+end_src

**** mapcar
Apply FUNCTION to each element of SEQUENCE, and make a list of the results. SEQUENCE may be a list, a vector, a bool-vector, or a string.

Contrast this with [[apply]], which applies its first argument to all the remaining.

The âmapâ part of the name comes from the mathematical phrase, âmapping over a domainâ, meaning to apply a function to each of the elements in a domain. The mathematical phrase is based on the metaphor of a surveyor walking, one step at a time, over an area he is mapping. And âcarâ, of course, comes from the Lisp notion of the first of a list.

#+begin_src emacs-lisp

  ; add one to each list member
  (mapcar '1+ (list 1 2 3 4)) ; (2 3 4 5)
  ; same, but using the "lambda" function created inline
  (mapcar
   (lambda (x) (+ x 1))
   (list 1 2 3 4)) ;; => (2 3 4 5)


  ; take the 1st element of each
  (mapcar 'car '((1 2) (3 4) (5 6))) ; (1 3 5)


  ;; take the 2nd element of each
  (mapcar (lambda (x) (nth 1 x))
          '((1 2) (3 4) (5 6))) ;; => (2 4 6)

#+end_src

**** mapc
Apply FUNCTION to each element of SEQUENCE *for side effects only*. Like [[mapcar]], but returns ~nil~.

#+begin_src emacs-lisp

  ;; apply a file processing function to a list of files
  (mapc 'my-update-html-footer
        (list
         "~/web/file1.html"
         "~/web/file2.html"
         "~/web/file3.html"))

#+end_src

**** reverse
Creates a new sequence whose elements are the elements of SEQUENCE, but in reverse order. The original argument sequence *is not altered*. Note that char-tables cannot be reversed.

#+begin_src emacs-lisp

  (setq x '(1 2 3 4)) ;; => (1 2 3 4)
  (reverse x)         ;; => (4 3 2 1)
  x                   ;; => (1 2 3 4)


  (setq x [1 2 3 4]) ;; => [1 2 3 4]
  (reverse x)        ;; => [4 3 2 1]
  x                  ;; => [1 2 3 4]

  (setq x "xyzzy") ;; => "xyzzy"
  (reverse x)      ;; => "yzzyx"
  x                ;; => "xyzzy"

#+end_src

**** nreverse
This function reverses the order of the elements of SEQUENCE. Unlike [[reverse]] the original SEQUENCE may be *modified*.

Note that unlike ~reverse~, this function doesnât work with strings. Although you can alter string data by using ~aset~, it is strongly encouraged to treat strings as immutable even when they are mutable.

#+begin_src emacs-lisp

  (setq list '(1 3 5 7))   ;; => (1 3 5 7)
  (nreverse list)          ;; => (7 5 3 1)
  list                     ;; => (1)

  ;; To avoid confusion, we usually store the result of nreverse back in
  ;; the same variable which held the original list:
  (setq x (nreverse x))


  ;; For the vector, it is even simpler because you donât need setq
  (setq x (copy-sequence [1 2 3 4])) ;; => [1 2 3 4]
  (nreverse x)                       ;; => [4 3 2 1]
  x                                  ;; => [4 3 2 1]

#+end_src

**** make-list
Return a newly created list of length LENGTH, with each element being INIT.

#+begin_src emacs-lisp

  (make-list 8 0) ;; => (0 0 0 0 0 0 0 0)

  (make-list 3 'pigs) ;; => (pigs pigs pigs)

#+end_src

**** number-sequence
Return a sequence of numbers from FROM to TO (both inclusive) as a list.

#+begin_src emacs-lisp

  (number-sequence 5 20 5) ;; (5 10 15 20)

#+end_src

**** seq-random-elt
This function returns an ELEMENT of sequence taken at random.

#+begin_src emacs-lisp

  (seq-random-elt [1 2 3 4]) ;; => 2

  (seq-random-elt [1 2 3 4]) ;; => 3

#+end_src

**** seqp
This function returns non-nil if object is a sequence (a list or array), or any additional type of sequence defined via seq.el generic functions. This is an extensible variant of ~sequencep~.

#+begin_src emacs-lisp

  (seqp [1 2])  ;; => t

  (seqp 2)      ;; => nil

#+end_src

* Glossary
** point
*** point
Is the current position of the cursor. The expression ~(point)~ returns a number that tells you where the cursor is located as a count of the number of characters from the beginning of the buffer up to point.

*** point-min
Is somewhat similar to ~point~, but it returns the value of the minimum permissible value of point in the current buffer. This is the number ~1~ unless narrowing is in effect.

*** point-max
Returns the value of the maximum permissible value of point in the current buffer.

** mark
Like [[point]] the ~mark~ is another position in the buffer; its value can be set, for the purpose of making a text selection with a command such as ~(set-mark-command)~ linked to ~C-SPC~, this value is kept as a marker. The mark can be considered a numberâthe number of characters the location is from the beginning of the buffer.

In lisp code, you should call ~push-mark~ or ~set-mark~.

If a mark has been set, you can use the command ~(exchange-point-and-mark)~ linked to ~C-x C-x~ to cause the cursor to jump to the mark and set the mark to be the previous position of point.

In addition, if you set another mark, the position of the previous mark is saved in the mark ring. Many mark positions can be saved this way. You can jump the cursor to a saved mark by typing ~C-u C-SPC~ one or more times.

** region
Is the part of the buffer between point and mark. Numerous commands work on the region, including ~center-region~, ~count-words-region~, ~kill-region~, and ~print-region~.

Once a user sets a mark in a buffer, a region exists. So, almost always, there exists a region in a buffer.

Emacs has a minor mode called [[transient-mark-mode]]. When on, it will highlight the region when it's active.

*Caution*:
*region* => The last marked position to the current cursor position.
*Active Region* => Because a region exists once a user sets a mark, and always having a section of text highlighted to the cursor position is annoying, so there's a new concept of Active Region. A Region is Active when the variable ~mark-active~ is true.

Note:
Emacs's concept of âactive regionâ is practically the same as the modern term âText Selectionâ.

Text Selection = when region is active, and is not empty.

** prefix argument
A prefix argument is passed to an [[interactive]] function by typing the ~META~ key followed by a number, for example, ~M-3 M-x command~ , or through ~universal-command~ this way ~C-u 3 M-x command~ .

- ~C-u~ is bound to ~universal-argument~.
- if you type ~C-u~ without a number, it defaults to ~4~.

To make your command aware of universal argument, there are 3 simple ways:

- The global variable ~current-prefix-arg~ holds the value of universal argument.
- Add ~(interactive "P")~ to your function.
- Add ~(interactive "p")~ to your function.

Can be raw prefix argument or can be numerical prefix argument, to see the difference [[Raw vs Numerical Prefix Arg]].

The following table shows the possible values of current-prefix-arg.

| /KEY INPUT/ | /current-prefix-arg/ | /VALUE/ |
|-----------+--------------------+-------|
| /No called/ | nil                |     1 |
| /C-u -/     | Symbol -           |    -1 |
| /C-u - 2/   | Number -2          |    -2 |
| /C-u 1/     | Number 1           |     1 |
| /C-u 4/     | Number 4           |     4 |
| /C-u/       | List '(4)          |     4 |
| /C-u C-u/   | List '(16)         |    16 |

Raw vs Numerical Prefix Arg

#+begin_src emacs-lisp

  (defun print-raw-prefix-arg (arg)
    "Print the current raw prefix argument value."
    (interactive "P")
    (insert (message "%S" arg)))
  ;; "M-x         print-raw-prefix-arg => nil
  ;; "C-u M-x     print-raw-prefix-arg => (4)
  ;; "C-u C-u M-x print-raw-prefix-arg => (16)
  ;; "C-u 3 M-x   print-raw-prefix-arg => 3
  ;; "M-- M-x     print-raw-prefix-arg => -

  (defun print-numeric-prefix-arg (arg)
    "Print the current numeric prefix argument value."
    (interactive "p")
    (insert (message "%S" arg)))
  ;; "M-x         print-numeric-prefix-arg =>  1
  ;; "C-u M-x     print-numeric-prefix-arg =>  4
  ;; "C-u C-u M-x print-numeric-prefix-arg => 16
  ;; "C-u 3 M-x   print-numeric-prefix-arg =>  3
  ;; "M-- M-x     print-numeric-prefix-arg => -1

#+end_src

** \\[...]
Tells the Lisp interpreter to substitute whatever key is currently bound to the ~[...]~.

#+begin_src emacs-lisp

  \\[universal-argument]
  In the case of "universal-argument", that is usually "C-u", but it might be different.

#+end_src

** narrowing
Is a feature of Emacs that makes it possible for you to focus on a specific part of a buffer, and work without accidentally changing other parts. Narrowing is normally disabled since it can confuse novices.

** kill ring
The kill ring is called a âringâ rather than just a âlistâ. However, the actual data structure that holds the text is a list.

** kill-ring-yank-pointer
Is a variable, just as kill-ring is a variable. It points to something by being bound to the value of what it points to.

The variable ~kill-ring~ and the variable ~kill-ring-yank-pointer~ are pointers.

#+begin_src emacs-lisp

  ;; If the value of the kill ring is:

  ("some text" "a different piece of text" "yet more text")

  ;; and the kill-ring-yank-pointer points to the second clause
  ;; the value of kill-ring-yank-pointer is:

  ("a different piece of text" "yet more text")

  kill-ring     kill-ring-yank-pointer
      |               |
      |      ___ ___  |     ___ ___      ___ ___
       ---> |   |   |  --> |   |   |    |   |   |
            |___|___|----> |___|___|--> |___|___|--> nil
              |              |            |
              |              |            |
              |              |             --> "yet more text"
              |              |
              |               --> "a different piece of text"
              |
              --> "some text"

#+end_src

** predicate
Is a function that determines whether some property is true or false.

It's used for example in the ~(sort SEQ PREDICATE)~ function. The ~sort~ function takes two arguments, the list to be sorted, and a predicate that determines whether the first of two list elements is less than the second  ~(sort '(4 8 21 17 33 7 21 7) '<)~.

PREDICATE is called with two elements of SEQ, and should return non-nil if the first element should sort before the second.

* Regexp
** Regexp
Regular expressions have a syntax in which a few characters are *special constructs* and the rest are *ordinary*. An ordinary character matches that same character and nothing else. The special characters are ~$^.*+?[\~ .

*Nota*: La expresiÃ³n regular de emacs es bÃ¡sicamente BRE, pero se ha ampliado para tratar ~+~ y ~?~ como metacaracteres asÃ­ como en ERE. Por lo tanto, no hay necesidad de escaparlos con ~\~ en la expresiÃ³n regular de emacs.

** Special characters
*** . , * , + , ?
**** .
Is a special character that matches *any single* character *except a newline*.

~a.b~ matches any three-character string that begins with ~a~ and ends with ~b~.

**** *
Is not a construct by itself; it is a postfix operator that means to match the *preceding regular expression* repetitively *any number of times*, as many times as possible. Thus, ~o*~ matches any number of ~o~ s, *including no* ~o~ s.

~*~ always applies to the smallest possible preceding expression. Thus, ~fo~ has a repeating ~o~, not a repeating ~fo~. It matches ~f~, ~fo~, ~foo~, and so on.

*Nota*: cuando se estÃ¡ realizando una busqueda con alguna funciÃ³n regex y el programa destaca (highlight) las expresiones que coinciden, se debe tener cuidado en no confundir cuando el programa resalta todas las coincidencias seÃ±alando varias coincidencias independientes como si fuera una sola coincidencia, por ejemplo:

~fo*~ destacarÃ¡ (highlight) ~fofofofofo~ pero no es que realmente coincida con todo este string junto, si no que destaca ~fo~ repetidas veces, es decir, la coincidencia es ~fo~ otro ~fo~ otro ~fo~ pero no el string completo ~fofofofofo~ .

The matcher processes a ~*~ construct by matching, immediately, as many repetitions as can be found. Then it continues with the rest of the pattern. If that fails, backtracking occurs, discarding some of the matches of the ~*~-modified construct in case that makes it possible to match the rest of the pattern. For example, in matching ~ca*ar~ against the string ~caaar~, the ~a*~ first tries to match all three ~a~ s; but the rest of the pattern is ~ar~ and there is only ~r~ left to match, so this try fails. The next alternative is for ~a*~ to match only two ~a~ s. With this choice, the rest of the regexp matches successfully.

*Nota*: la regex ~ca*ar~ enlaza con ~car~ de la siguiente manera:
Enlazando con la ~c~ del principio que es fija y con el ~ar~ del final que tambiÃ©n es fijo, esto es lo que realmente enlaza con ~car~. La ~a*~ no enlaza ya que esta puede ser o bien la cantidad de ~a~ que sea o ninguna ~a~ , lo cual es este caso, es decir 1 ~c~ + 0 ~a*~ + 1 ~ar~ .

- Using [[\{n,m\}]] notation, ~\{0,\}~ is equivalent to ~*~.

**** +
Is a postfix operator, similar to ~*~ except that it must match the preceding expression *at least once*.

Thus, ~ca+r~ matches the strings ~car~ and ~caaaar~ but not the string ~cr~, whereas ~ca*r~ matches all three strings.

- Using [[\{n,m\}]] notation, ~\{1,\}~ is equivalent to ~+~.

**** ?
Is a postfix operator, similar to ~*~ except that it can match the preceding expression *either once or not at all*.

Thus, ~ca?r~ matches ~car~ or ~cr~, and nothing else.

- Using [[\{n,m\}]] notation, ~\{0,1\}~ is equivalent to ~?~.

*** *? , +? , ??
Are non-greedy variants. The normal operators ~*~, ~+~, ~?~ match as much as they can, as long as the overall regexp can still match. With a following ~?~, they will *match as little as possible* .

For example, ~ab*~ can match the string ~a~ and the string ~abbbb~; but  ~ab*?~ match only with ~a~ (the shortest valid match).

Non-greedy operators match the shortest possible string starting at a given starting point; in a forward search, though, the earliest possible starting point for match is always the one chosen. Thus, if you search for ~a.*?$~ against the text ~abbab~ followed by a newline, it matches the whole string. Since it can match starting at the first ~a~, it does.

In the following example you can see the difference when using the normal operators against the non-greedy search (?).

We want to replace the "=" markup with "~" (each match is marked with numbers).

#+begin_example

REGEXP: =\\(.+\\)=

- =/dev/clip= and =/dev/kill=(1) you can redirect shell commands to the emacs clipboard and killring
- REPL alias =alias ffo "find-file-other-window $1"=(2) y proporciona una manera sencilla.
- Puede correr comandos en la shell como =find-file=, =dired=, ...,  tambiÃ©n correr funciones =(+ 20 5)=(3) completas.
- Puede usar comandos con pipe para enviar salida a un buffer =echo "Hello" > #<buffer test-buffer>=(4).
- La sintaxis de la subshell es un poco diferente se utiliza =${ }= en vez de =$( )=(5).

MATCHES: 5


REGEXP: =\\(.+?\\)=

- =/dev/clip=(1) and =/dev/kill=(2) you can redirect shell commands to the emacs clipboard and killring
- REPL alias =alias ffo "find-file-other-window $1"=(3) y proporciona una manera sencilla.
- Puede correr comandos en la shell como =find-file=(4), =dired=(5), ...,  tambiÃ©n correr funciones =(+ 20 5)=(6) completas.
- Puede usar comandos con pipe para enviar salida a un buffer =echo "Hello" > #<buffer test-buffer>=(7).
- La sintaxis de la subshell es un poco diferente se utiliza =${ }=(8) en vez de =$( )=(9).

MATCHES: 9

#+end_example

*** \{n\}
**** \\{n\\}
Is a postfix operator specifying ~n~ repetitionsâthat is, the preceding regular expression must match *exactly ~n~ times in a row*.

For example, ~x\\{4\\}~ matches the string ~xxxx~ and nothing else.

Caution: maybe it's just one ~\~ , e.g.  ~x\{4\}~.

**** \\{n,m\\}
Is a postfix operator specifying between ~n~ and ~m~ repetitionsâthat is, the preceding regular expression must match *at least ~n~ times, but no more than ~m~ times*. If ~m~ is omitted, then there is no upper limit, but the preceding regular expression must match at least ~n~ times.

-  ~\\{0,1\\}~ is equivalent to ~?~.
-  ~\\{0,\\}~ is equivalent to ~*~.
-  ~\\{1,\\}~ is equivalent to ~+~.

Caution: maybe it's just one ~\~ , e.g.  ~\{0,1\}~.

*** [ ... ]
**** [ â¦ ]
The characters between the two brackets are what this set can match.

- ~[ad]~ matches either one ~a~ or one ~d~.
- ~[ad]*~ matches any string composed of just ~a~ s and ~d~ s (including the empty string).
- ~c[ad]*r~ matches ~cr~, ~car~, ~cdr~, ~caddaar~, etc.

You can also include character ranges in a character set, by writing the starting and ending characters with a ~-~ between them. Thus, ~[a-z]~ matches any lower-case ASCII letter.

To include a ~]~ in a character set, you must make it the first character. For example, ~[]a]~ matches ~]~ or ~a~. To include a ~-~, write ~-~ as the last character of the set, tho you can also put it first or after a range. Thus, ~[]-]~ matches both ~]~ and ~-~.

**** [^ â¦ ]
~[^~ begins a *complemented* (caracter complementario como en matemÃ¡tica, el complemento de todos esos caracteres, cualquier caracter menos los que estan en los corchetes, es como un "No estos caracteres") character set, which *matches any character except the ones specified*, even new line (put a newline in the list if you want it not to be matched).

Thus, ~[^a-z0-9A-Z]~ matches all characters except ASCII letters and digits.

~^~ is not special in a character set unless it is the first character. The character following the ~^~ is treated as if it were first (in other words, ~-~ and ~]~ are not special there).

Note: A complemented character set can match a newline, unless newline is mentioned as one of the characters not to match. This is in contrast to the handling of regexps in programs such as grep.

**** \|
*Specifies an alternative*. Two regular expressions ~a~ and ~b~ with ~\|~ in between form an expression that matches some text if either ~a~ matches it or ~b~ matches it. It works by trying to match ~a~, and if that fails, by trying to match ~b~.

Thus, ~foo\|bar~ matches either ~foo~ or ~bar~ but no other string.

*** ^ , $
**** ^
Is a special character that matches the empty string, but *only at the beginning of a line* in the text being matched. Otherwise it fails to match anything.

Thus, ~^foo~ matches a ~foo~ that occurs at the beginning of a line.

**** $
Is similar to ~^~ but matches *only at the end of a line*.

Thus, ~x+$~ matches a string of one ~x~ or more at the end of a line.

*** \
**** \
Has two functions: it *quotes the special characters* (including ~\~), and it introduces additional special constructs.

Because ~\~ quotes special characters, ~\$~ is a regular expression that matches only ~$~, and ~\[~ is a regular expression that matches only ~[~, and so on.

Backslashes must be entered as ~\\~.

Literal backslash with doubling backslash ~\\\\~.

*Caution*: when it's an interactive command search one ~\~ by executing Lisp code two ~\\~.

**** \b
Matches the *empty string*, but only at the *beginning or end of a word*.

- ~\bfoo\b~ matches any occurrence of ~foo~ as a separate word.
- ~\bballs?\b~ matches ~ball~ or ~balls~ as a separate word.

~\b~ matches at the beginning or end of the buffer regardless of what text appears next to it.

~\b~ word boundary marker. If you want to match with word boundary, use it, like this ~\bcat\b~. This will find ~cat~ but not ~cats~.

**** \B
Matches the *empty string*, but *NOT at the beginning or end of a word*.

~\Blab\B~ matches of any occurrence of "e~lab~oration" but not for "The ~lab~ is".

**** \( â¦ \)
Is a grouping construct that serves three purposes:

1. To enclose a set of ~\|~ *alternatives* for other operations. Thus, ~\(foo\|bar\)x~ matches either ~foox~ or ~barx~.
2. To enclose a *complicated expression* for the postfix operators ~*~, ~+~ and ~?~ to operate on. Thus, ~ba\(na\)*~ matches ~bananana~, etc., with any (zero or more) number of ~na~ strings.
3. To *record* a <<matched substring>> for future reference.

Capture pattern. ~\\(pattern\\)~

**** \d
Matches the same text that matched the ~dth~ occurrence of a ~\( â¦ \)~ construct. This is called a *back reference*.

After the end of a ~\( â¦ \)~ construct, the matcher remembers the beginning and end of the text matched by that construct. Then, later on in the regular expression, you can use ~\~ followed by the digit ~d~ to mean âmatch the same text matched the ~dth~ time by the ~\( â¦ \)~ constructâ.

For example, ~\(.*\)\1~ matches any newline-free string that is composed of two identical halves. The ~\(.*\)~ matches the first half, which may be anything, but the ~\1~ that follows must match the same exact text.

If a particular ~\( â¦ \)~ construct matches more than once (which can easily happen if it is followed by ~*~), only the last match is recorded.

Note: The construct ~\d~ for any digit is not supported, use ~[0-9]~ or ~[[:digit:]]~ instead.

**** \w
Matches any word-constituent *character*. The syntax table determines which characters these are.

Note: The construct ~\w~ for any word is not always supported, use ~[[:word:]]~ instead.

**** \W
Matches any *character* that is not a word-constituent.

*** misc
**** \`
Matches the empty string, but only at the *beginning of the string or buffer* (or its accessible portion) being matched against.

~\`â¦~ Beginning of {string, buffer}

**** \'
Matches the empty string, but only at the *end of the string or buffer* (or its accessible portion) being matched against.

~â¦\'~ End of {string, buffer}

**** \(?: â¦ \)
Specifies a shy group that does not record the [[matched substring]]; you can~t refer back to it with ~\d~. This is useful in mechanically combining regular expressions, so that you can add groups for syntactic purposes without interfering with the numbering of the groups that are meant to be referred to.

**** \=
Matches the empty string, but only at point.

**** \<
Matches the *empty string*, but only at the *beginning of a word*.

~\<~ matches at the beginning of the buffer only if a word-constituent character follows.

**** \>
Matches the *empty string*, but only at the *end of a word*.

~\>~ matches at the end of the buffer only if the contents end with a word-constituent character.

**** \sc
Matches any character whose syntax is ~c~. Here ~c~ is a character which represents a syntax code: thus, ~w~ for word constituent, ~-~ for whitespace, ~(~ for open parenthesis, etc.

**** \Sc
Matches any character whose syntax is not ~c~.

** Examples
*** End of sentence
End of a sentence together with any whitespace that follows. It is the value of the variable ~sentence-end~.

#+begin_src emacs-lisp

  "[.?!][]\"')}]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"

  ;; or in contrast, if you evaluate the variable sentence-end
  "[.?!][]\"')}]*\\($\\| $\\|  \\|  \\)[
  ]*"
  ;; In this output, tab and newline appear as themselves.


  ;; With rx expressions
  (rx (any ".?!")                    ; Punctuation ending sentence.
      (zero-or-more (any "\"')]}"))  ; Closing quotes or brackets.
      (or line-end
          (seq " " line-end)
          "\t"
          "  ")                      ; Two spaces.
      (zero-or-more (any "\t\n ")))  ; Optional extra whitespace.

  ;; =>

  "[!.?][]\"')}]*\\(?:$\\| $\\|	\\|  \\)[
   ]*"

#+end_src

~[.?!]~ match with one of three characters, a period, a question mark and an exclamation mark.

~[]\"')}]*~ matches any closing braces and quotation marks, zero or more of them, that may follow the period, question mark or exclamation mark.

~\\($\\| \\|\t\\| \\)~ matches the whitespace that follows the end of a sentence: the end of a line, or a tab, or two spaces. The parentheses mark the group and the vertical bars separate alternatives. The dollar sign is used to match the end of a line.

~[ \t\n]*~ matches any additional whitespace beyond the minimum needed to end a sentence.

*** At least one character that is a word or symbol

#+begin_src emacs-lisp

  "\\(\\w\\|\\s_\\)+"

#+end_src

The ~\\(~ is the first part of the grouping construct that includes the ~\\w~ and the ~\\s_~ as alternatives, separated by the ~\\|~. The ~\\w~ matches any word-constituent character and the ~\\s_~ matches any character that is part of a symbol name but not a word-constituent character. The ~+~ following the group indicates that the word or symbol constituent characters must be matched at least once.

*** Word or symbol followed optionally by
Word or symbol constituents are followed optionally by characters that are not white space and then followed optionally by white space.

#+begin_src emacs-lisp

  "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"

#+end_src

*** Replace the decimal point by a comma
Here are two ways to replace the decimal point by a comma (~1.5 -> 1,5~), first by an interactive command, second by executing Lisp code (type ~C-x C-e~ after the expression to get it executed).

Note: The construct ~\d~ for any digit is not supported, use ~[0-9]~ or ~[:digit:]~ instead.

#+begin_src emacs-lisp

  M-x replace-regexp RET \([0-9]+\)\. RET \1, RET

  (while (re-search-forward "\\([0-9]+\\)\\." nil t)
    (replace-match "\\1,"))

#+end_src

*** Detect consecutive duplicate words

#+begin_src emacs-lisp

  ;; \\(\\w+[ \t\n]+\\)\\1
  ;; This regexp matches one or more word-constituent characters followed
  ;; by one or more spaces, tabs, or newlines. However, it does not detect
  ;; duplicated words on different lines, since the ending of the first
  ;; word, the end of the line, is different from the ending of the second
  ;; word, a space

  ;; \\(\\(\\w+\\)\\W*\\)\\1
  ;; Another possible regexp searches for word-constituent characters
  ;; followed by non-word-constituent characters, reduplicated. Here,
  ;; â\\w+â matches one or more word-constituent characters and â\\W*â
  ;; matches zero or more non-word-constituent characters. Again, not
  ;; useful.

  ;; Here is the pattern that I use. It is not perfect, but good enough.
  \\b\\([^@ \n\t]+\\)[ \n\t]+\\1\\b
  ;; â\\bâ matches the empty string, provided it is at the beginning or end
  ;; of a word; â[^@ \n\t]+â matches one or more occurrences of any
  ;; characters that are not an @-sign, space, newline, or tab.

#+end_src

*** Swiper
**** Matches only the word without -

#+begin_src emacs-lisp

  ;; Will match calc but not with hello- or hellos
  hello\b!-

#+end_src

*** Mix

#+begin_src emacs-lisp

  ;; Delete new lines
  ;; replacing "\n" by "^$"

  ;; Empty line
  "^$"

  ;; Word with 20 letters or more
  "\\w\\{20,\\}"

  ;; Year 1900-2099
  "\\(19\\|20\\)[0-9]\\{2\\}"

  ;;At least 6 symbols
  "^.\\{6,\\}"

  ;; Capture text between double quotes.
  ;; "\([^"]+\)" ;; or ;; "\([^"]+?\)"
  ;; \"\\([^\"]+\\)\" ;; or ;; \"\\([^\"]+?\\)\"

  ;; To truncate decimals to 3 places, e.g. 0.123456 -> 0.123
  "\([0-9]\)\.\([0-9][0-9][0-9]\)[0-9]+"
  ;;and replace it with
  "\1.\2."

  ;; Digit or + or - sign.
  [-+[:digit:]]

  ;; Decimal number (-2 or 1.5 but not .2 or 1.).
  \(\+\|-\)?[0-9]+\(\.[0-9]+\)?

  ;; Two consecutive, identical words.
  \&lt;\(\w+\) +\1\&gt;

  ;; Word starting with an uppercase letter.
  \&lt;[[:upper:]]\w*

  ;; Trailing whitespaces (note the starting SPC).
  +$

#+end_src

** Classes

| /Character/    | /Class Description/                         |
|--------------+-------------------------------------------|
| /[:digit:]/    | a digit, same as [0-9]                    |
| /[:alpha:]/    | a letter (an alphabetic character)        |
| /[:alnum:]/    | a letter or a digit(an alphanumeric char) |
| /[:upper:]/    | a letter in uppercase                     |
| /[:lower:]/    | a letter in lowercase                     |
| /[:graph:]/    | a visible character                       |
| /[:print:]/    | a visible character plus the space char   |
| /[:space:]/    | a whitespace char,typically [\t\r\n\v\f]  |
| /[:blank:]/    | a space or tab character                  |
| /[:xdigit:]/   | an hexadecimal digit                      |
| /[:cntrl:]/    | a control character                       |
| /[:ascii:]/    | an ascii character                        |
| /[:nonascii:]/ | any non ascii character                   |

*Syntax Class Usage*:
One must remember that *syntax classes must be used within square brackets*, as one would in specifying any other sequence to match or reject: e.g. ~[[:upper:]\|[:digit:]\.]~. This is easy to overlook when using square-bracket-delimited syntax classes, since they include their own square brackets! E.g., if searching for a single whitespace character in a regexp, this

#+begin_src emacs-lisp

  [:space:]

#+end_src

will *fail*. Just remember to add a 2nd/outer pair of square brackets: e.g., this

#+begin_src emacs-lisp

  [[:space:]]

#+end_src

will succeed in finding a single whitespace character, this

#+begin_src emacs-lisp

  [[:space:]]*

#+end_src

will succeed in finding zero-or-more single whitespace characters, etc.

** Table

| /Character/   | /Description/                                       |
|-------------+---------------------------------------------------|
| /./           | any char (but newline)                            |
| /*/           | previous char or group, repeated 0 or more time   |
| /+/           | previous char or group, repeated 1 or more time   |
| /?/           | previous char or group, repeated 0 or 1 time      |
| /^/           | start of line                                     |
| /$/           | end of line                                       |
| /[...]/       | any char between brackets                         |
| /[^..]/       | any char not in the brackets                      |
| /[a-z]/       | any char between a and z                          |
| /\/           | prevents interpretation of following special char |
| /\Â¦/          | or                                                |
| /\w/          | word constituent                                  |
| /\b/          | word boundary                                     |
| /\sc/         | char with c syntax (e.g. \s- for whitespace char) |
| /\( \)/       | start/end of group                                |
| /\&lt; \&gt;/ | start/end of word (faulty rendering*)             |
| /\_< \_>/     | start/end of symbol                               |
| /\` \'/       | start/end of buffer/string                        |
| /\1/          | string matched by the first group                 |
| /\n/          | string matched by the nth group                   |
| /\{3\}/       | previous char or group, repeated 3 times          |
| /\{3,\}/      | previous char or group, repeated 3 or more times  |
| /\{3,6\}/     | previous char or group, repeated 3 to 6 times     |
| /\=/          | match succeeds if it is located at point          |

/*/  faulty rendering: backslash + less-than and backslash + greater-than

** Commands descriptions

| /Command/              | /Description/                             |
|------------------------+-------------------------------------------|
| /C-M-s/                | incremental forward search regexp         |
| /C-M-r/                | incremental backward search regexp        |
| /query-replace-regexp/ | same, but query before each replacement   |
| /replace-regexp/       | replace string matching regexp            |
| /dired-do-query-re/    | replace maked files in dired              |
| /replace-string/       | find & replace in 1 shot without asking   |
| /replace-regexp/       | same replace-string but with regexp       |
| /highlight-regexp/     | highlight strings matching regexp         |
| /unhighlight-regexp/   | remove highlighting                       |
| /occur/list-match lin/ | show lines containing a match             |
| /multi-occur/          | show lines in all buffers contain a match |
| /how-many/             | count the number of strings match regexp  |
| /keep-lines/           | delete all lines except contain match     |
| /flush-lines/          | delete lines containing matches           |
| /align-regexp/         | alig using strings match regex delimiters |

Note that ~list-matching-lines~ is an alias for ~occur~ and ~delete-matching-lines~ is an alias for ~flush-lines~.

** Rx
A nifty macro that generates regular expressions for you, from reasonably-comprehensible s-expressions. This notation is usually easier to read, write and maintain than regexp strings, and can be indented and commented freely. It requires a conversion into string form since that is what regexp functions expect, but that conversion typically takes place during byte-compilation rather than when the Lisp code using the regexp is run.

The ~rx~ notation is mainly useful in Lisp code; it cannot be used in most interactive situations where a regexp is requested, such as when running ~query-replace-regexp~ or in variable customization.

When given just a single string argument, it acts just like ~regexp-to-string~.

Here is an ~rx~ regexp that matches a block comment in the C programming language:

#+begin_src emacs-lisp

  (rx "/*"                          ; Initial /*
      (zero-or-more
       (or (not (any "*"))          ;  Either non-*,
           (seq "*"                 ;  or * followed by
                (not (any "/")))))  ;  non-/
      (one-or-more "*")             ; At least one star,
      "/")                          ; and the final /

  ;; =>
  "/\\*\\(?:[^*]\\|\\*[^/]\\)*\\*+/"

  ;; or, using shorter synonyms and written more compactly,
  (rx "/*"
      (* (| (not "*")
            (: "*" (not "/"))))
      (+ "*") "/")

  ;; other example
  (rx bol
      (zero-or-more blank)
      (one-or-more digit)
      ":")
  ;; =>
  "^[[:blank:]]*[[:digit:]]+:"

#+end_src

** Search
*** Consult asynchronous search
Consult has support for asynchronous generation of candidate lists. This feature is used for search commands like consult-grep, where the list of matches is generated dynamically while the user is typing a regular expression. The grep process is executed in the background. When modifying the regular expression, the background process is terminated and a new process is started with the modified regular expression.

The matches, which have been found, can then be narrowed using the installed Emacs completion-style. This can be powerful if you are using for example the ~orderless~ completion style.

This two-level filtering is possible by splitting the input string. Part of the input string is treated as input to grep and part of the input is used for filtering. There are multiple splitting styles available, configured in ~consult-async-split-styles-alist~: ~nil~, ~comma~, ~semicolon~ and ~perl~. The default splitting style is configured with the variable consult-async-split-style.

With the ~comma~ and ~semicolon~ splitting styles, the first word before the comma or semicolon is passed to grep, the remaining string is used for filtering. The ~nil~ splitting style does not perform any splitting, the whole input is passed to grep.

The ~perl~ splitting style splits the input string at a punctuation character, using a similar syntax as Perl regular expressions.

Examples:

#+begin_src emacs-lisp

  ;; Search for âdefunâ using grep.
  #defun

  ;; Search for both âconsultâ and âembarkâ using grep in any order.
  #consult embark

  ;; Search for âfirstâ followed by âsecondâ using grep.
  #first.*second

  ;; Search for âconsultâ or âembarkâ using grep. Note the usage
  ;; of Emacs-style regular expressions.
  #\(consult\|embark\)

  ;; Search for âdefunâ using grep, filter with the word âconsultâ.
  #defun#consult

  ;; It is also possible to use other punctuation characters.
  /defun/consult

  ;; Force searching for âtoâ using grep, since the grep pattern
  ;; must be longer than consult-async-min-input characters by default.
  #to#

  ;; Pass argument --invert-match to grep.
  #defun -- --invert-match#

#+end_src

*** Orderless package
**** Consecutive and not consecutive words

1. there are
2. there         are
3. are there
4. there some words here are
5. thereare
6. thereZare
7. there}are

#+begin_src emacs-lisp

  M-x consult-line: there\ are
  ;;1. there are

  M-x consult-line: there.are
  ;;1. there are
  ;;6. thereZare
  ;;7. there}are

  M-x consult-line: there.*are
  ;;1. there are
  ;;2. there         are
  ;;4. there some words here are
  ;;5. thereare
  ;;6. thereZare
  ;;7. there}are

#+end_src

**** Literal word

1. casa
2. lacasa
3. la casa
4. otra la casa
5. la la casa
6. lal casa

#+begin_src emacs-lisp

  M-x consult-line: \<casa\>
  ;; 1. casa
  ;; 3. la casa
  ;; 4. otra la casa
  ;; 5. la la casa
  ;; 6. lal casa

  M-x consult-line: \bcasa\b
  ;; 1. casa
  ;; 3. la casa
  ;; 4. otra la casa
  ;; 5. la la casa
  ;; 6. lal casa

#+end_src

**** Whitespace
Backward slash ( ~\~ ) + whitespace (    )

1. lacasablanca
2. la casa blanca
3. lacasa blanca
4. la casablanca

#+begin_src emacs-lisp


  M-x consult-line: \ casa
  ;; 2. la casa blanca
  ;; 4. la casablanca

  M-x consult-line: \ casa\
  ;; 2. la casa blanca

#+end_src

** Notes
- For backslash escaping (magic vs literal), Emacs uses a mixture of BRE and ERE. Like in ERE, Emacs supports unescaped ~+~ , ~?~ . Like in BRE, Emacs supports escaped ~\(~ , ~\)~ , ~\|~ , ~\{~ , ~\}~ .
- GNU extensions to regular expressions supported by Emacs include ~\w~ , ~\W~ , ~\b~ , ~\B~ , ~\<~ , ~\>~ , ~\`~  , ~\'~ (start and end of buffer)
- No ~\s~ like in PCRE; whitespace is matched by ~\s-~ .
- No ~\d~ like in PCRE; use ~[0-9]~ or ~[[:digit:]]~
- No lookahead and no lookbehind like in PCRE
- Emacs regexp can match characters by syntax using mode-specific syntax tables ( ~\sc~ , ~\s-~ , ~\s ~ ) or by categories ( ~\cc~ , ~\cg~ ).


- By default, the case of the replaced text is smartly dependent on the matched text. For example, if you want to replace ~dragon~ for ~here~ in this ~{here, Here, HERE}~ the result will be ~{dragon, Dragon, DRAGON}~. If you want the letter case of your replacement string be exactly as you have it, you need to set the variable ~case-replace~ to ~nil~.

- When using ~[a-z]~, it is not case sensitive by default. Case sensitivity is controlled by the variable ~case-fold-search~. Call ~toggle-case-fold-search~ to toggle it.

- Do not use ~[A-z]~, because that'll match some punctuation chars too. Use ~[A-Za-z]~.

- To insert a literal tab, ~C-q C-i~.

- To insert a newline, press ~C-q C-j~.

- Regexp commands use regex to search. So, if you simply want to search plain words or phrases, and if your phrase contains any of regex characters, you need to escape them. Here's some commonly used regex characters that you'll need to place a backslash before it: ~[ ] \ + * ?~ .

- If you are doing a regex search, and you want to force the replacement to upper case or lower case, in the replace prompt, give ~\,(upcase \1)~ or ~\,(downcase \1)~. Suppose you want all paragraphs to start with a capital letter. So, you use a pattern that catches the first letter after ~<p>~, like this ~<p>\([a-z]\)~. To make your captured pattern upper case, give your replacement string this expression: ~<p>\,(upcase \1)~. The ~\,~ tells emacs that what follows should be a lisp expression. The ~(upcase \1)~ is a lisp expression. The upcase is a lisp function and the ~\1~ means the 1st captured string in your regex pattern.

- Unicode character can be used literally. But for non-printable ones such as âRIGHT-TO-LEFT MARKâ, you can represent them by a code.

- whitespace ~[[:space:]]~

Warning: the meaning of a character class in emacs is dependent on the current major mode's syntax table. For example, what chars are considered âwordâ in ~[[:word:]]~ depends on how its defined in syntax table of current major mode.

* Emacs
** Loading
*** Brief
Loading a file of Lisp code means bringing its contents into the Lisp environment in the form of Lisp objects. *Emacs finds and opens the file, reads the text, evaluates each form, and then closes the file*. Such a file is also called a /Lisp library/.

The load functions evaluate all the expressions in a file just as the ~eval-buffer~ function evaluates all the expressions in a buffer. The difference is that the load functions read and evaluate the text in the file as found on disk, not the text in an Emacs buffer.

The loaded file must contain Lisp expressions, either as source code or as byte-compiled code. Each form in the file is called a /top-level/ form. There is no special format for the forms in a loadable file; any form in a file may equally well be typed directly into a buffer and evaluated there. (Indeed, most code is tested this way.) Most often, the forms are function definitions and variable definitions.

Emacs can also load compiled dynamic modules: shared libraries that provide additional functionality for use in Emacs Lisp programs, just like a package written in Emacs Lisp would. When a dynamic module is loaded, Emacs calls a specially-named initialization function which the module needs to implement, and which exposes the additional functions and variables to Emacs Lisp programs.

*** Load
**** Brief
You can use a ~load~ command to evaluate a complete file and thereby install all the functions and variables in the file into Emacs. For example:

#+begin_src emacs-lisp

  (load "~/emacs/slowsplit")

#+end_src

This *evaluates*, i.e., *loads*, the ~slowsplit.el~ file or if it exists, the faster, byte compiled ~slowsplit.elc~ file from the ~emacs~ sub-directory of your home directory.

#+begin_src emacs-lisp

  ;; Load the installed Lisp library named foo
  (load "foo")
  ;; When the argument to load is a relative file name, not starting
  ;; with â/â or â~â, load searches the directories in load-path.

#+end_src

If you load many extensions, then instead of specifying the exact location of the extension file, you can specify that directory as part of Emacsâs [[Load path][load-path]]. Then, when Emacs loads a file, it will search that directory as well as its default list of directories.

#+begin_src emacs-lisp

  ;; Adds your ~/emacs directory to the existing load path:
  (setq load-path (cons "~/emacs" load-path))

#+end_src

**** Load file
To *load* an Emacs Lisp file, type ~M-x load-file~. This command *reads a file name using the minibuffer*, and executes the contents of that file as Emacs Lisp code. It is not necessary to visit the file first; this command reads the file directly from disk, not from an existing Emacs buffer.

**** Load library
If an Emacs Lisp *file is installed in the Emacs Lisp* [[Load path][load path]], you can load it by typing ~M-x load-library~, instead of using ~M-x load-file~. The ~M-x load-library~ command prompts for a /library name/ rather than a file name; it searches through each directory in the Emacs Lisp load path, trying to find a file matching that library name.

Emacs Lisp programs usually load Emacs Lisp files using the ~load~ function. This is similar to ~load-library~, but is lower-level and accepts additional arguments.

**** Unloading
You can discard the functions and variables loaded by a library to reclaim memory for other Lisp objects. To do this, use the function ~unload-feature~.

**** Hooks for loading
You can ask for code to be executed each time Emacs loads a library, by using the variable ~after-load-functions~:

This abnormal hook is run after loading a file. Each function in the hook is called with a single argument, the absolute filename of the file that was just loaded.

If you want code to be executed when a *particular* library is loaded, use the macro ~with-eval-after-load~:

This macro arranges to evaluate /body/ at the end of loading the file /library/, each time /library/ is loaded. If /library/ is already loaded, it evaluates body right away.

#+begin_src emacs-lisp

  (with-eval-after-load "js" (keymap-set js-mode-map "C-c C-c" 'js-eval))

#+end_src

/library/ can also be a feature (i.e., a symbol), in which case /body/ is evaluated at the end of any file where ~(provide library)~ is called.

Normally, well-designed Lisp programs should not use ~with-eval-after-load~. If you need to examine and set the variables defined in another library (those meant for outside use), you can do it immediatelyâthere is no need to wait until the library is loaded. If you need to call functions defined by that library, you should load the library, preferably with [[require feature][require]].

**** Which file defined a certain symbol
The ~symbol-file~ function returns the name of the file that defined /symbol/.

The value is normally an absolute file name. It can also be ~nil~, if the definition is not associated with any file. If /symbol/ specifies an autoloaded function, the value can be a relative file name without extension.

The basis for ~symbol-file~ is the data in the variable ~load-history~.

The value of this variable is an *alist that associates the names of loaded library files with the names of the functions and variables they defined*, as well as the features they provided or required.

Each element in this alist describes one loaded library (including libraries that are preloaded at startup).

The value of ~load-history~ may have one element whose CAR is ~nil~. This element describes definitions made with ~eval-buffer~ on a buffer that is not visiting a file.

The command ~eval-region~ updates ~load-history~, but does so by adding the symbols defined to the element for the file being visited, rather than replacing that element.

**** site-wide
In addition to your personal initialization file, Emacs automatically loads various site-wide initialization files, if they exist. These have the same form as your ~.emacs~ file, but are loaded by everyone.

Two site-wide initialization files, ~site-load.el~ and ~site-init.el~, are loaded into Emacs and then dumped if a dumped version of Emacs is created, as is most common.

Three other site-wide initialization files are loaded automatically each time you start Emacs, if they exist. These are ~site-start.el~ (it pretty much means a init file for all users of this emacs installation), which is loaded /before/ your ~.emacs~ file, and ~default.el~, and the terminal type file, which are both loaded /after/ your ~.emacs~ file.

Settings and definitions in your ~.emacs~ file will overwrite conflicting settings and definitions in a ~site-start.el~ file, if it exists; but the settings and definitions in a ~default.el~ or terminal type file will overwrite those in your ~.emacs~ file. (You can prevent interference from a terminal type file by setting ~term-file-prefix~ to ~nil~.)

The ~INSTALL~ file that comes in the distribution contains descriptions of the ~site-init.el~ and ~site-load.el~ files.

The ~loadup.el~, ~startup.el~, and ~loaddefs.el~ files control loading. These files are in the lisp directory of the Emacs distribution and are worth perusing.

*** Load path
The Emacs Lisp load path is specified by the variable ~load-path~. Its value should be a list of directories (strings). These directories are searched, in the specified order, by the [[Load library][M-x load-library]] command, the lower-level [[Load][load]] function, and other Emacs functions that find Emacs Lisp libraries.

The default value of ~load-path~ is a list of directories where the Lisp code for Emacs itself is stored. If you have libraries of your own in another directory, you can add that directory to the load path.

#+begin_src emacs-lisp

  ;; Add a directory (not need to end with a slash) to load-path:
  (add-to-list 'load-path "/path/to/my/lisp/library")
  ;; Adding a directory to variable load-path does not also add any of
  ;; its descendants (its subdirectories, their subdirectories, and
  ;; so on, recursively)

#+end_src

It is customary to put locally installed libraries in the ~site-lisp~ directory that is already in the default value of ~load-path~, or in some subdirectory of ~site-lisp~. This way, you donât need to modify the default value of ~load-path~.

On GNU/Linux, the default value of ~load-path~ includes two special directories and their descendants: ~/usr/local/share/emacs/VERSION/site-lisp~ and ~/usr/local/share/emacs/site-lisp~ . The first directory contains packages for a particular Emacs version; the second contains packages for all installed versions of Emacs. These directories contain files for the current site, for use by the system administrator when installing software locally.

~~/.emacs.d/~, on the other hand, contains files for the current user, and is independent of system-wide changes. This makes it the best choice for storing your personal changes. Installing all packages in a sub-directory of ~~/.emacs.d/~ also makes it very easy to move them along with your configuration to a different machine.

*** Autoload
**** Brief
The /autoload/ facility lets you *register the existence of a function or macro, but put off loading the file that defines it*. The first call to the function automatically loads the proper library, in order to install the real definition and other associated code, then runs the real definition as if it had been loaded all along.

Autoloading can also be triggered by looking up the documentation of the function or macro, and completion of variable and function names.

There are two ways to set up an autoloaded function: by calling ~autoload~, and by writing a âmagicâ comment in the source before the real definition. ~autoload~ is the low-level primitive for autoloading; any Lisp program can call ~autoload~ at any time.

Magic comments are the most convenient way to make a function autoload, for packages installed along with Emacs. These comments do nothing on their own, but they serve as a guide for the command ~loaddefs-generate~, which constructs calls to ~autoload~ and arranges to execute them when Emacs is built.

The ~M-x compile~ command is autoloaded; if you call it, Emacs automatically loads the "compile" library first. In contrast, the command ~M-x recompile~ is not autoloaded, so it is unavailable until you load the compile library.

To tell Emacs to find the definition for the function ~myfunction~ by loading a Lisp library named ~mypackage~ (i.e., a file ~mypackage.elc~ or ~mypackage.el~):

#+begin_src emacs-lisp

  ;; The autoload object has this form:
  (autoload filename docstring interactive type)

  ;; Will load mypackage.elc or mypackage.el when myfunction is invoked.
  (autoload 'myfunction "mypackage" "Do what I say." t)
  ;; The string "Do what I say." is the functionâs documentation string.
  ;; You specify it in the autoload definition so it will be available
  ;; for help commands even when the package is not loaded.
  ;; The last argument, t, indicates that this function is interactive.

  ;; Loads my-shining-package.elc unconditionally.
  (require 'my-shining-package)

#+end_src

Once you put your library in a directory where Emacs can find and load it, you may wish to make it available at startup. This is useful when the library defines features that should be available automatically on demand, and manually loading the library is thus inconvenient. In these cases, make sure the library will be loaded by adding suitable forms to your init file: either ~load~ or [[require feature][require]] (if you always need to load the library at startup), or ~autoload~ if you need Emacs to load the library when some command or function is invoked.

Do not add an autoload comment unless it is really necessary. Autoloading code means it is always globally visible. Once an item is autoloaded, there is no compatible way to transition back to it not being autoloaded (after people become accustomed to being able to use it without an explicit load).

The most common items to autoload are the interactive entry points to a library. For example, if ~python.el~ is a library defining a major-mode for editing Python code, autoload the definition of the ~python-mode~ function, so that people can simply use ~M-x python-mode~ to load the library.

**** Magic comment
A magic autoload comment (often called an /autoload cookie/) consists of ~;;;###autoload~, on a line by itself, just before the real definition of the function in its autoloadable source file. The function ~loaddefs-generate~ writes a corresponding autoload call into ~loaddefs.el~. Building Emacs loads ~loaddefs.el~ and thus calls autoload.

You can also use a magic comment to execute a form at build time /without/ executing it when the file itself is loaded. To do this, write the form on the /same/ line as the magic comment. Since it is in a comment, it does nothing when you load the source file; but ~loaddefs-generate~ copies it to ~loaddefs.el~, where it is executed while building Emacs.

The following example shows how ~doctor~ is prepared for autoloading with a magic comment:

#+begin_src emacs-lisp

  ;;;###autoload
  (defun doctor ()
    "Switch to *doctor* buffer and start giving psychotherapy."
    (interactive)
    (switch-to-buffer "*doctor*")
    (doctor-mode))

#+end_src

Hereâs what that produces in ~loaddefs.el~:

#+begin_src emacs-lisp

  (autoload 'doctor "doctor" "\
  Switch to *doctor* buffer and start giving psychotherapy.

  \(fn)" t nil)

#+end_src

**** Notes
- *Reply stack overflow* (âactivatesâ a package, package-initialize)
The Emacs package manager *automatically loads the autoloads file of a package, when it âactivatesâ a package*. Emacs also automatically initializes the package manager and activates all installed packages, but only after your ~init.el~ was processed.

Hence, packages (and this their autoloads as well) are not available while your ~init.el~ is loaded, so you can't use packages in your ~init.el~.

To address this, you can either postpone all your setup to ~after-init-hook~, or force Emacs to initialize the package manager by adding ~(package-initialize)~ at the top of your init file.

BTW, in Emacs-27 we have changed this so that ~package-initialize~ is called before loading ~~/.emacs~.

- *Reply stack overflow* (start Emacs, install Elpa package, [package]-autoloads.el)
When you install an Elpa package, Emacs scans through all the ~.el~ files in the package for autoload tokens and adds stubs for those functions/variables to a ~[package]-autoloads.el~ file. The stubs just attach information to the function/variable symbols that tell Emacs where to find the actual definitions, and what the docstring says. Then it compiles all the ~.el~ files to ~.elc~ files, including the autoloads file.

Then (and every time you start Emacs) it loads and evaluates the ~[package]-autoloads.elc~ file, rather than the ~main .elc~ files. That way it's much faster to load packages, as the main ~.elc~ files will only be loaded when one of the autoloaded symbols is invoked. The other functions/variables in the main ~.el~ files are not known to Emacs until then.

- *Reddit reply* (autoload, start Emacs, example)
Installing, for example, the ~evil~ package with the package manager *will have generated an autoload for* the ~evil-mode~ function, and when ~package-initialize~ is called when you start Emacs *any such autoloads are read and defined*; so when you subsequently call ~(evil-mode 1)~ which is only defined as an autoload, Emacs firstly loads the associated package and then evaluates the function you called, all in one smooth move.

The ~PACKAGENAME-autoloads.el~ file is loaded into Emacs (when ~package-initialize~ runs, which happens automatically). Which is the reason why, you can call ~evil-mode~ without having loaded the rest of the package.

*** Features (provide, require)
**** Features
~provide~ and ~require~ are an alternative to ~autoload~ for *loading files automatically*. They work in terms of named /features/. Autoloading is triggered by calling a specific function, but a feature is *loaded the first time another program asks for it* by name.

A /feature/ name is a *symbol* that stands for a *collection of functions, variables, etc*. The file that defines them should /provide/ the feature. Another program that uses them may ensure they are defined by /requiring/ the feature. This loads the file of definitions if it hasnât been loaded already.

*Xah*: ~features~ is a elisp symbol that represent a lisp package. It is a global variable, holding a list of elisp symbols that are features. Its purpose is for emacs to know if a package is already loaded.

To require the presence of a feature, call ~require~ with the feature name as argument. ~require~ looks in the global variable ~features~ to see whether the desired feature has been provided already. If not, it loads the feature from the appropriate file. This file should call ~provide~ at the top-level to add the feature to ~features~; if it fails to do so, ~require~ signals an error.

For example, in ~idlwave.el~, the definition for ~idlwave-complete-filename~ includes the following code:

#+begin_src emacs-lisp

  (defun idlwave-complete-filename ()
    "Use the comint stuff to complete a file name."
    (require 'comint)
    (let* ((comint-file-name-chars "~/A-Za-z0-9+@:_.$#%={}\\-")
           (comint-completion-addsuffix nil)
           ...)
      (comint-dynamic-complete-filename)))

#+end_src

The expression ~(require 'comint)~ loads the file ~comint.el~ if it has not yet been loaded, ensuring that ~comint-dynamic-complete-filename~ is defined. Features are normally named after the files that provide them, so that ~require~ need not be given the file name.

The ~comint.el~ file contains the following top-level expression:

#+begin_src emacs-lisp

  (provide 'comint)

#+end_src

This adds ~comint~ to the global ~features~ list, so that ~(require 'comint)~ will henceforth know that nothing needs to be done.

When ~require~ is used at top level in a file, it takes effect when you byte-compile that file as well as when you load it. This is in case the required package contains macros that the byte compiler must know about. It also avoids byte compiler warnings for functions and variables defined in the file loaded with ~require~.

Although top-level calls to ~require~ are evaluated during byte compilation, ~provide~ calls are not. Therefore, you can ensure that a file of definitions is loaded before it is byte-compiled by including a ~provide~ followed by a ~require~ for the same feature, as in the following example.

#+begin_src emacs-lisp

  (provide 'my-feature)  ; Ignored by byte compiler,
                         ;   evaluated by load.
  (require 'my-feature)  ; Evaluated by byte compiler.

#+end_src

The compiler ignores the ~provide~, then processes the ~require~ by loading the file in question. Loading the file does execute the ~provide~ call, so the subsequent ~require~ call does nothing when the file is loaded.

**** provide feature
This function announces that /feature/ is now loaded, or being loaded, into the current Emacs session. This means that the facilities associated with /feature/ are or will be available for other Lisp programs.

The direct effect of calling ~provide~ is to *add feature* to the front of ~features~ if it is not already in that list and call any ~eval-after-load~ code waiting for it. The argument feature must be a symbol. ~provide~ returns /feature/.

#+begin_src emacs-lisp

  features
  ;; (bar bish)

  (provide 'foo)
  ;; â foo
  features
  ;; â (foo bar bish)

#+end_src

When a file is loaded to satisfy an autoload, and it stops due to an error in the evaluation of its contents, any function definitions or ~provide~ calls that occurred during the load are undone.

**** require feature
This function *checks* whether /feature/ is present in the current Emacs session (using ~(featurep feature)~). The argument /feature/ must be a symbol.

If the feature is not present, then ~require~ *loads* filename with [[Load][load]]. If filename is not supplied, then the name of the symbol /feature/ is used as the base file name to load. However, in this case, ~require~ insists on finding /feature/ with an added ~.el~ or ~.elc~ suffix (possibly extended with a compression suffix); a file whose name is just /feature/ wonât be used.

Best used in elisp libraries or scripts, similar to other lang's ârequireâ or âimportâ.

Using ~require~ adds a dependency: Not only must a file with the same name exist, but in that file, Emacs wants to see a statement such as this:

#+begin_src emacs-lisp

  (provide 'foo)

#+end_src

Thus, in your package, you can ~require~ several so-called [[Features][features]]. This will load the files with the same name, and these files must ~provide~ the feature. These features are recorded in the ~features~ variable.

If loading the file succeeds but does not provide /feature/, ~require~ signals an error about the missing feature.

*Note*: reply stack overflow
There is not difference between ~require~ and ~load~ with regards to ~autoload~. ~require~ is just a frontend to ~load~, which more or less comes down to:

#+begin_src emacs-lisp

  (defun require (feature &optional filename noerror)
    (unless (featurep feature)
      (let ((filename (or filename (symbol-name feature))))
        (load filename noerror))))

#+end_src

As you can see, the symbol name given to ~require~ is equal to the filename given to ~load~. As a matter of fact, the first ~(require 'foo)~ evaluated in an Emacs session is equivalent to ~(load "foo")~.

*** Configuring packages
The autoloads for installed packages will automatically be loaded after your /InitFile/ has finished processing, so common commands will be available without any additional configuration. You can also use Customize to change the settings for your installed files.

If you need to configure other settings in your /InitFile/ and youâre running into undefined functions or variables, you can use ~(package-initialize)~ to *set up the load-paths and autoloads for installed packages*. Then you can use ~(require 'package-name)~ to fully load the package, [[Hooks for loading][(with-eval-after-load "package-name" ...)]] or ~(eval-after-load 'package-name ...)~ to run code after a package is loaded, or something like the [[Use package]] macro to organize your package-related configuration.

*** The early init file
Most customizations for Emacs should be put in the normal init file. However, it is sometimes necessary to have customizations take effect during Emacs startup earlier than the normal init file is processed. Such customizations can be put in the early init file, ~~/.config/emacs/early-init.el~ or ~~/.emacs.d/early-init.el~. This file is loaded before the package system and GUI is initialized, so in it you can customize variables that affect the package initialization process, such as ~package-enable-at-startup~, ~package-load-list~, and ~package-user-dir~. Note that variables like ~package-archives~ which only affect the installation of new packages, and not the process of making already-installed packages available, may be customized in the regular init file.

We do not recommend that you move into ~early-init.el~ customizations that can be left in the normal init files. That is because the early init file is read before the GUI is initialized, so customizations related to GUI features will not work reliably in ~early-init.el~. By contrast, the normal init files are read after the GUI is initialized. If you must have customizations in the early init file that rely on GUI features, make them run off hooks provided by the Emacs startup, such as ~window-setup-hook~ or ~tty-setup-hook~.

** Set variable
*** Setq
You can set any Lisp variable with [[setq]], but with certain variables ~setq~ wonât do what you probably want in the init file. Some variables automatically become buffer-local when set with ~setq~; what you want in the init file is to set the default value, using [[Setting default values (setq-default)][setq-default]].

The second argument to ~setq~ is an expression for the new value of the variable. This can be a constant, a variable, or a function call expression. In the init file, constants are used most of the time. They can be:

- Numbers :: numbers are written in decimal, with an optional initial minus sign.

- Strings :: lisp string syntax is the same as C string syntax with a few extra features. Use a double-quote character to begin and end a string constant.

  In a string, you can include newlines and special characters literally. But often it is cleaner to use backslash sequences for them: ~\n~ for newline, ~\b~ for backspace, ~\r~ for carriage return, ~\t~ for tab, ~\f~ for formfeed (control-L), ~\e~ for escape, ~\\~ for a backslash, ~\"~ for a double-quote, or ~\ooo~ for the character whose octal code is ooo. Backslash and double-quote are the only characters for which backslash sequences are mandatory.

  ~\C-~ can be used as a prefix for a control character, as in ~\C-s~ for ASCII control-S, and ~\M-~ can be used as a prefix for a Meta character, as in ~\M-a~ for Meta-A or ~\M-\C-a~ for Ctrl-Meta-A.

- Characters :: lisp character constant syntax consists of a ~?~ followed by either a character or an escape sequence starting with ~\~. Examples: ~?x~ , ~?\n~ , ~?\"~ , ~?\~ ). Note that strings and characters are not interchangeable in Lisp; some contexts require one and some contexts require the other.

- True :: ~t~ stands for âtrueâ.

- False :: ~nil~ stands for âfalseâ.

- Other Lisp objects :: write a single-quote ( ~'~ ) followed by the Lisp object you want.

*** Setting default values (setq-default)
You can set any Lisp variable with [[setq]], but with certain variables ~setq~ wonât do what you probably want in the init file. Some variables automatically become buffer-local when set with ~setq~; what you want in the init file is to set the default value, using ~setq-default~.

Keep in mind that ~setq-default~ does not set the value in the current buffer, only future buffers!

Make searches case sensitive by default (in all buffers that do not override this).

#+begin_src emacs-lisp

  (setq-default case-fold-search nil)

#+end_src

This sets the default value, which is effective in all buffers that do not have local values for the variable. Setting ~case-fold-search~ with ~setq~ affects only the current bufferâs local value, which is probably not what you want to do in an init file.

#+begin_src emacs-lisp

  ;; Text mode the default mode for new buffers
  (setq-default major-mode 'text-mode)

  (setq-default tab-width 2
                evil-shift-width 2)

  ;; BEWARE!  Unexpected results using buffer-local variables:
  (setq-default evil-shift-width tab-width)

  ;; This will create a variable that doesn't exist
  (setq-default will-i-be-created t)

#+end_src

*** Buffer local variables (setq-local)
You can set the value of a variable for the current buffer only using ~setq-local~. Any code that runs in that buffer will receive the buffer-local value instead of the global value!

Why do this? There are many settings that should only be set per buffer, like editor settings for different programming languages and customization variables for major modes.

If the variable isnât already buffer-local, ~setq-local~ will make it so, but only for the current buffer!

#+begin_src emacs-lisp

  ;; some-value doesn't exist yet!
  (setq some-value 2)
  ;; Make it buffer-local
  (setq-local some-value 4)

#+end_src

You can make any variable local for all future buffers with the ~make-variable-buffer-local~ function:

#+begin_src emacs-lisp

  (setq not-local-yet t)
  (make-variable-buffer-local 'not-local-yet)

#+end_src

If you are writing an Emacs Lisp package and want to provide a buffer-local variable, this is the way to do it!

#+begin_src emacs-lisp

  ;; Defining a variable with defvar and then making it buffer local
  (defvar new-buffer-local-var 311)
  (make-variable-buffer-local 'new-buffer-local-var)

#+end_src

*** Defining customization variables (defcustom)
Customizable variables are used to define user-facing settings for customizing the behavior of Emacs and packages.

You can specify variables using ~defcustom~ so that you and others can then use Emacsâs ~customize~ feature to set their values.

The ~customize~ feature depends on the ~defcustom~ macro. Although you can use [[defvar]] or [[setq]] for variables that users set, the ~defcustom~ macro is designed for the job.

- The first argument to ~defcustom~ is the name of the variable.
- The second argument is the variableâs initial value, if any; and this value is set only if the value has not already been set.
- The third argument is the documentation.
- The fourth and subsequent arguments to defcustom specify types and options; these are not featured in defvar.

#+begin_src emacs-lisp

  ;; the customizable user option variable text-mode-hook looks like this:
  (defcustom text-mode-hook nil
    "Normal hook run when entering Text mode and many related modes."
    :type 'hook ;; tells Emacs the kind of data to which text-mode-hook
    ;; should be set and how to display the value in a
    ;; Customization buffer.
    :options '(turn-on-auto-fill flyspell-mode) ;; specifies a suggested list
    ;; of values for the variable.
    ;; Usually, applies to a hook.
    :group 'wp) ;; tells command in which group the variable is located.

#+end_src

~defcustom~ takes some additional parameters after the documentation string:

-  ~:type~ - The expected value type
-  ~:group~ - The symbol that identifies the âgroupâ this variable belongs to (defined with ~defgroup~)
-  ~:options~ - The list of possible values this variable can hold
-  ~:set~ - A function that will be invoked when this variable is customized
-  ~:get~ - A function that will be invoked when this variable is resolved
-  ~:initialize~ - A function to be used to initialize the variable when it gets defined
-  ~:local~ - When ~t~, automatically marks the variable as buffer-local

Incidentally, to be more complete concerning defines:
~defsubst~ defines an inline function. The syntax is just like that of defun.
~defconst~ defines a symbol as a constant.

*customize-set-variable*
Some customizable minor mode variables do special things to enable the mode when you set them with Customize, but ordinary ~setq~ wonât do that; to enable the mode in your init file, call the minor mode command. Finally, a few customizable user options are initialized in complex ways, and these have to be set either via the customize interface or by using ~customize-set-variable~.

*** set-variable
You could use the ~set-variable~ command to change the value of ~shell-command-default-error-buffer~ temporarily. However, options set using ~set-variable~ are set only for the duration of your editing session. The new values are not saved between sessions.

For me, the major use of the ~set-variable~ command is to suggest variables that I might want to set in my ~.emacs~ file. You can press ~TAB~ after calling the ~M-x set-variable~ command to see the list of variables.

*** File local variables
**** Specifying file variables
There are two ways to specify file local variable values: in the first line, or with a local variables list.

Hereâs how to specify them in the first line:

#+begin_src elisp

  ;; -*- mode: Lisp; fill-column: 75; comment-column: 50; -*-

#+end_src

A local variables list starts with a line containing the string âLocal Variables:â, and ends with a line containing the string âEnd:â. In between come the variable names and values, one set per line:

#+begin_src c

  /* Local Variables:  */
  /* mode: c           */
  /* comment-column: 0 */
  /* End:              */

#+end_src

If a file has both a local variables list and a ~-*-~ line, Emacs processes everything in the ~- -~ line first, and everything in the local variables list afterward. The exception to this is a major mode specification. Emacs applies this first, wherever it appears, since most major modes kill all local variables as part of their initialization.

*Note*: In shell scripts, the first line is used to identify the script interpreter, so you cannot put any local variables there. To accommodate this, Emacs looks for local variable specifications in the *second* line if the first line specifies an interpreter. The same is true for man pages which start with the magic string ~'\"~ to specify a list of troff preprocessors (not all do, however).

**** Per-directory local variables
Sometimes, you may wish to define the same set of local variables to all the files in a certain directory and its subdirectories, such as the directory tree of a large software project. This can be accomplished with ~directory-local~ variables. File local variables override directory local variables.

The usual way to define directory-local variables is to put a file named ~.dir-locals.el~ in a directory.

You can also use ~.dir-locals-2.el~; if found, Emacs loads it in addition to ~.dir-locals.el~. This is useful when ~.dir-locals.el~ is under version control in a shared repository and canât be used for personal customizations.

#+begin_src emacs-lisp

  ;; Hereâs an example of a .dir-locals.el file:
  ((nil . ((indent-tabs-mode . t)
           (fill-column . 80)
           (mode . auto-fill)))
   (c-mode . ((c-file-style . "BSD")
              (subdirs . nil)))
   ("src/imported"
    . ((nil . ((change-log-default-name
                . "ChangeLog.local"))))))
  ;; This sets the variables âindent-tabs-modeâ and fill-column for any
  ;; file in the directory tree, and the indentation style for any C source
  ;; file. The special mode element specifies the minor mode to be
  ;; enabled. So (mode . auto-fill) specifies that the minor mode
  ;; auto-fill-mode needs to be enabled. The special subdirs element is not
  ;; a variable, but a special keyword which indicates that the C mode
  ;; settings are only to be applied in the current directory, not in any
  ;; subdirectories. Finally, it specifies a different ChangeLog file name
  ;; for any file in the src/imported subdirectory.

#+end_src

** Mode
*** Brief
A /mode/ is a set of definitions that customize the behavior of Emacs in useful ways. It is basically a collection of features that can be applied to a single buffer or to the entire editor.

There are two varieties of modes:
-  major modes :: provide specialized facilities for working on a particular file type, such as a C source file, or a particular type of non-file buffer, such as a shell buffer. Major modes are mutually exclusive; each buffer has one and only one major mode at any time.
- minor modes :: are optional features which you can turn on or off while editing, not necessarily specific to a type of file or buffer. For example, Auto Fill mode is a minor mode in which ~SPC~ breaks lines between words as you type. Minor modes are independent of one another, and of the selected major mode.

*** Major mode
Major modes specialize Emacs for editing or interacting with particular kinds of text. Each buffer has exactly one major mode at a time. Every major mode is associated with a /major mode command/, whose name should end in ~-mode~. This command takes care of switching to that mode in the current buffer, by setting various buffer-local variables such as a local keymap. Note that unlike minor modes there is no way to âturn offâ a major mode, instead the buffer must be switched to a different one. However, you can temporarily /suspend/ a major mode and later /restore/ the suspended mode.

The least specialized major mode is called /Fundamental mode/, which has no mode-specific definitions or variable settings, and it does not run any mode hooks, since you are not supposed to customize this mode.

Most modes are divided into three main groups, the first group contains modes for plain text, either plain or markup (/Text mode/. HTML mode, SGML mode, TeX mode and Outline mode). The second contains modes for specific programming languages (/Prog mode/. Lisp (which has several variants), C mode, ...). The third consists of main modes that are not directly associated with files; they are used in buffers created for specific purposes by Emacs (/Special mode/. Dired mode, Message to Mail mode, Shell mode).

Every major mode, apart from Fundamental mode, defines a [[Hooks][mode hook]].

Mode hooks are commonly used to enable [[Minor mode][minor modes]].

#+begin_src emacs-lisp

  ;; Enable Flyspell minor mode in all text-based major modes:
  (add-hook 'text-mode-hook 'flyspell-mode)
  ;; Enable ElDoc minor mode in Emacs Lisp mode:
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)


  ;; Turn on Auto Fill mode automatically in Text mode and related modes.
  (add-hook 'text-mode-hook 'auto-fill-mode)
  ;; You donât want Auto Fill mode turned on in LaTeX mode,
  ;; which is one of the modes based on Text mode:
  (add-hook 'latex-mode-hook (lambda () (auto-fill-mode -1)))


  ;; Remove a hook:
  (remove-hook 'html-mode-hook 'linum-mode)


  ;; To show paren mode only in programming modes
  (add-hook 'prog-mode-hook #'show-paren-local-mode)

#+end_src

*** Minor mode
A /minor mode/ provides optional features that users may enable or disable independently of the choice of major mode. Minor modes can be enabled individually or in combination.

Most minor modes implement features that are independent of the major mode, and can thus be used with most major modes. For example, Auto Fill mode works with any major mode that permits text insertion. A few minor modes, however, are specific to a particular major mode. For example, Diff Auto Refine mode is a minor mode that is intended to be used only with Diff mode.

Ideally, a minor mode should have its desired effect regardless of the other minor modes in effect. It should be possible to activate and deactivate minor modes in any order.

Some minor modes are /buffer-local/, and can be turned on (enabled) in certain buffers and off (disabled) in others. Other minor modes are /global/: while enabled, they affect everything you do in the Emacs session, in all buffers.

Each minor mode can have its own keymap, which is active when the mode is enabled. To set up a keymap for a minor mode, add an element to the alist ~minor-mode-map-alist~.

Like major modes, each minor mode is associated with a /mode command/, whose name consists of the mode name followed by ~-mode~. But unlike a major mode command, which simply enables the mode, the mode command for a minor mode can either enable or disable it:

- If you invoke the mode command directly with no prefix argument (either via M-x, or by binding it to a key and typing that key), that /toggles/ the minor mode.
- If you invoke the mode command with a prefix argument, the minor mode is unconditionally turned off if that argument is zero or negative; otherwise, it is unconditionally turned on.
- If the mode command is called via Lisp, the minor mode is unconditionally turned on if the argument is omitted or nil. This makes it easy to turn on a minor mode from a major modeâs mode hook A non-~nil~ argument is handled like an interactive prefix argument.

Most minor modes also have a /mode variable/, with the same name as the mode command. Its value is non-~nil~ if the mode is enabled, and ~nil~ if it is disabled.

#+begin_src emacs-lisp

  ;; Enable Flyspell minor mode in all text-based major modes:
  (add-hook 'text-mode-hook 'flyspell-mode)
  ;; Enable ElDoc minor mode in Emacs Lisp mode:
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)

#+end_src

** Hooks
*** Brief
Hooks are an important mechanism for customizing Emacs. A hook is a *Lisp variable which holds a list of functions, to be called on some well-defined occasion*. (This is called /running the hook/.) The individual functions in the list are called the /hook functions/ of the hook. For example, the hook ~kill-emacs-hook~ runs just before exiting Emacs.

A hook is *similar to the concept of events in other systems*. Adding function to a hook is similar to adding event handlers. (note: emacs lisp manual also uses the term âeventâ, but that is lower level events to emacs, not events by emacs.)

Most major modes run one or more /mode hooks/ as the last step of initialization. This makes it easy for a user to customize the behavior of the mode, by overriding the buffer-local variable assignments already made by the mode. Most minor mode functions also run a mode hook at the end. But hooks are used in other contexts too. For example, the hook ~suspend-hook~ runs just before Emacs suspends itself.

Each mode hook is named after its major mode, e.g., Fortran mode has ~fortran-mode-hook~. Furthermore, all text-based major modes run ~text-mode-hook~, and many programming language modes run ~prog-mode-hook~, prior to running their own mode hooks. Hook functions can look at the value of the variable ~major-mode~ to see which mode is actually being entered.

Major mode hooks also apply to other major modes /derived/ from the original mode. For instance, HTML mode is derived from Text mode; when HTML mode is enabled, it runs ~text-mode-hook~ before running ~html-mode-hook~. In particular, if you want to apply a hook function to any programming language mode, add it to ~prog-mode-hook~; Prog mode is a major mode that does little else than to let other major modes inherit from it, exactly for this purpose.

*** Types of hooks
Most hooks are /normal hooks/. This means that when Emacs runs the hook, it calls each hook function in turn, with no arguments. We have made an effort to keep most hooks normal, so that you can use them in a uniform way. Every variable whose name ends in ~-hook~ is a normal hook. For example, when ~html-mode~ is loaded, ~html-mode-hook~'s functions are run.

A few hooks are /abnormal hooks/. Their names end in ~-functions~, instead of ~-hook~ (some old code may also use the deprecated suffix ~-hooks~). What makes these hooks abnormal is the way its functions are calledâperhaps they are given arguments, or perhaps the values they return are used in some way. For example, ~find-file-not-found-functions~ is abnormal because as soon as one hook function returns a non-~nil~ value, the rest are not called at all.

If the name of the variable ends in ~-predicate~ or ~-function~ (singular) then its value must be a function, not a list of functions.

*** Setting a hook
You can set a hook variable with [[setq]] like any other Lisp variable or temporarily with [[let]], but the recommended way to add a function to a hook (either normal or abnormal) is to use ~add-hook~ or remove with ~remove-hook~.

If you play with adding various different versions of a hook function by calling ~add-hook~ over and over, remember that all the versions you added will remain in the hook variable together. You can clear out individual functions by calling ~remove-hook~, or do ~(setq hook-variable nil)~ to remove everything.

If the hook variable is buffer-local, the buffer-local variable will be used instead of the global variable. However, if the buffer-local variable contains the element ~t~, the global hook variable will be run as well.

#+begin_src emacs-lisp

  ;; Set up a hook to turn on Auto Fill mode in Text mode
  ;; and other modes based on Text mode
  (add-hook 'text-mode-hook 'auto-fill-mode)

  ;; Next, suppose you donât want Auto Fill mode turned on in LaTeX mode,
  ;; which is one of the modes based on Text mode.
  (add-hook 'latex-mode-hook (lambda () (auto-fill-mode -1)))
  ;; The -1 argument disables the minor mode. Because LaTeX mode runs
  ;; latex-mode-hook after running text-mode-hook, the result leaves
  ;; Auto Fill mode disabled.

#+end_src

** Keymaps
*** Brief
The command bindings (map keys to commands) of input events are recorded in data structures called /keymaps/ (record key bindings). Each entry in a keymap associates (or /binds/) an individual event type, either to another keymap or to a command. When an event type is bound to a keymap, that keymap is used to look up the next input event; this continues until a command is found. The whole process is called key /lookup/.

A key /sequence/, or key for short, is a sequence of one or more input events that form a unit. Input events include characters, function keys, mouse actions, or system events external to Emacs, âall the inputs that you can send to the computer. The Emacs Lisp representation for a key sequence is a string ( =a= -> ~"a"~ , =control= -> ~"\C-"~ , =TAB= -> ~"\t"~ ...) or vector for function keys, mouse button events, system events, or non-ASCII characters ( ~[?\C-x ?l]~ -> ~C-x l~ ).

*Function*: ~kbd keyseq-text~
This function converts the text /keyseq-text/ (a string constant) into a key sequence (a string or vector constant).

#+begin_src emacs-lisp

  (kbd "C-x") â "\C-x"
  (kbd "C-x C-f") â "\C-x\C-f"
  (kbd "C-x 4 C-f") â "\C-x4\C-f"
  (kbd "X") â "X"
  (kbd "RET") â "^M"
  (kbd "C-c SPC") â "\C-c "
  (kbd "<f1> SPC") â [f1 32]
  (kbd "C-M-<down>") â [C-M-down]

#+end_src

*Note*: Key sequences that consist of ~C-c~ followed by a letter (upper or lower case; ASCII or non-ASCII) are reserved for users. Emacs itself will never bind those key sequences, and Emacs extensions should avoid binding them. In other words, users can bind key sequences like ~C-c a~ or ~C-c Ã§~ and rely on these never being shadowed by other Emacs bindings.

*** Keymap basics
A keymap is a Lisp data structure that specifies /key bindings/ for various key sequences (bindings between key sequences and command functions).

A /prefix key/ (usually the keymap to use for looking up the following event) is a key sequence whose binding is a keymap. The keymap defines what to do with key sequences that extend the prefix key. For example, ~C-x~ is a prefix key, and it uses a keymap that is also stored in the variable ~ctl-x-map~. This keymap defines bindings for key sequences starting with ~C-x~.

If the binding of a key sequence is a keymap, we call the key sequence a /prefix key/. Otherwise, we call it a /complete key/ (because no more events can be added to it). If the binding is ~nil~, we call the key /undefined/. Examples of prefix keys are ~C-c~ , ~C-x~ , and ~C-x 4~. Examples of defined complete keys are ~X~ , ~RET~ , and ~C-x 4 C-f~. Examples of undefined complete keys are ~C-x C-g~ , and ~C-c 3~.

At any time, several primary keymaps are /active/ âthat is, in use for finding key bindings. These are the /global map/ (the most important keymap because it is always in effect), which is shared by *all buffers*; the /local keymap/, which is usually associated with a specific *major mode*; and zero or more /minor mode keymaps/, which belong to currently enabled *minor modes*. (Not all minor modes have keymaps.) The local keymap bindings shadow (i.e., take precedence over) the corresponding global bindings. The minor mode keymaps shadow both local and global keymaps.

For example, a self-inserting character such as ~g~ is self-inserting because the global keymap binds it to the command ~self-insert-command~.

Each keymap is a list whose CAR is the symbol ~keymap~. The remaining elements of the list define the key bindings of the keymap. A symbol whose function definition is a keymap is also a keymap.

Some prefix keymaps are stored in variables with names:

- ~ctl-x-map~ is the variable name for the map used for characters that follow ~C-x~.
- ~help-map~ is for characters that follow ~C-h~.
- ~esc-map~ is for characters that follow ~ESC~. Thus, all Meta characters are actually defined by this map.
- ~ctl-x-4-map~ is for characters that follow ~C-x 4~.
- ~mode-specific-map~ is for characters that follow ~C-c~.
- ~project-prefix-map~ is for characters that follow ~C-x p~, used for project-related commands.

*** Changing key bindings
**** Brief
The way to rebind a key is to change its entry in a keymap. If you change a binding in the global keymap, the change is effective in all buffers. If you change the current bufferâs local map, that usually affects all buffers using the same major mode. The [[Global keymap][keymap-global-set]] and [[Local keymap][keymap-local-set]] functions are convenient interfaces for these operations. You can also use ~keymap-set~, a more general function; then you must explicitly specify the map to change.

/key/ is a string representing a single key or a series of key strokes, and must satisfy ~key-valid-p~. Key strokes are separated by a single space character.

Each key stroke is either a single character, or the name of an event, surrounded by angle brackets. In addition, any key stroke may be preceded by one or more modifier keys. Finally, a limited number of characters have a special shorthand syntax.  Hereâs some example key sequences:

- f :: the key ~f~.
- S o m :: three key sequence of the keys ~S~, ~o~ and ~m~.
- C-c o :: two key sequence of the keys ~c~ with the control modifier and then the key ~o~
- H-<left> :: the key named ~left~ with the hyper modifier.
- M-RET :: the ~return~ key with a meta modifier.
- C-M-<space> :: the ~space~ key with both the control and meta modifiers.

The only keys that have a special shorthand syntax are ~NUL~, ~RET~, ~TAB~, ~LFD~, ~ESC~, ~SPC~ and ~DEL~.

The modifiers have to be specified in alphabetical order: ~A-C-H-M-S-s~, which is ~Alt-Control-Hyper-Meta-Shift-super~.

**** Global keymap
The first argument to ~keymap-global-set~ describes the key sequence. It is a string made of a series of characters separated by spaces, with each character corresponding to a key.

Alternatively, to write a key binding you can use the low level functions ~define-key~ and ~global-set-key~.

#+begin_src emacs-lisp

  ;; This function sets the binding of key in the current global map to binding
  (keymap-global-set key binding)
  ;; or an older equivalent
  (global-set-key (kbd key) binding)
  ;; or another way
  (keymap-set (current-global-map) key binding)
  ;; or an older equivalent
  (define-key global-map (kbd key) binding)

  ;; Redefines C-x C-\ to move down a line:
  (keymap-global-set "C-x C-\\" 'next-line)
  ;; Redefines the first (leftmost) mouse button, entered
  ;; with the Meta key, to set point where you click:
  (keymap-global-set "M-<mouse-1>" 'mouse-set-point)
  ;; or an older equivalent
  (global-set-key (kbd "M-<mouse-1>") 'mouse-set-point)

#+end_src

This function *removes the binding of key* from the current global map.  One use of this function is in preparation for defining a longer key that uses key as a prefixâwhich would not be allowed if key has a non-prefix binding.

#+begin_src emacs-lisp

  (keymap-global-unset "C-l") ;; â nil
  ;; or an older equivalent
  (global-unset-key "C-l")

  (keymap-global-set "C-l C-l" 'redraw-display) ;; â nil
  ;; or an older equivalent
  (global-set-key (kbd "C-l") nil)

#+end_src

Additional examples:

#+begin_src emacs-lisp

  (keymap-global-set "C-M-q" 'query-replace)
  (keymap-global-set "<f5>" 'flyspell-mode)
  (keymap-global-set "C-<f5>" 'display-line-numbers-mode)
  (keymap-global-set "C-<right>" 'forward-sentence)
  (keymap-global-set "<mouse-2>" 'mouse-save-then-kill)

  (keymap-global-set (kbd "H-b") 'backward-word) ; H is for hyper
  (keymap-global-set (kbd "s-b") 'backward-word) ; lower case âsâ is for super
  (keymap-global-set (kbd "M-H-b") 'backward-word) ; Meta+Hyper+b


  ;; Key sequence:
  (progn
    ;; define a prefix keymap
    (define-prefix-command 'my-modes-key-map)
    (define-key my-modes-key-map (kbd "<f6>") 'visual-line-mode)
    (define-key my-modes-key-map (kbd "<f7>") 'linum-mode)
    (define-key my-modes-key-map (kbd "<f8>") 'whitespace-mode))

  (global-set-key (kbd "<f9>") my-modes-key-map)
  ;; Now:
  ;; F9 F6 will call visual-line-mode
  ;; F9 F7 will call linum-mode
  ;; F9 f8 will call whitespace-mode

#+end_src

**** Local keymap
Major modes and minor modes can define local keymaps. These keymaps are constructed when the mode is loaded for the first time in a session. The functions ~keymap-local-set~ and ~keymap-set~ can be used to make changes in a specific keymap. To remove a key binding, use ~keymap-unset~.

#+begin_src emacs-lisp

  ;; Sets the binding of key in the current-local-map keymap.
  (keymap-set (current-local-map) key binding)

  ;; Sets the binding of key in the current local keymap to binding.
  (keymap-local-set key binding)


  ;; This function removes the binding of key from the current local map.
  (keymap-local-unset key)

  ;; Example of unbind key:
  (keymap-set dired-mode-map "I" nil)

#+end_src

Since a modeâs keymaps are not constructed until it has been loaded, you must delay running code which modifies them, e.g., by putting it on a [[Hook][mode hook]]. For example, Texinfo mode runs the hook ~texinfo-mode-hook~. Hereâs how you can use the hook to add local bindings for ~C-c n~ and ~C-c p~, and remove the one for ~C-c C-x x~ in Texinfo mode:

#+begin_src emacs-lisp

  (add-hook 'texinfo-mode-hook
            (lambda ()
              (keymap-set texinfo-mode-map "C-c p"
                          'backward-paragraph)
              (keymap-set texinfo-mode-map "C-c n"
                          'forward-paragraph)
              (keymap-set texinfo-mode-map "C-c C-x x" nil)))


  ;; To change minor mode keys, you need to change of the mode's keymap:
  (progn
    ;; change isearch's keys to arrows
    (define-key isearch-mode-map (kbd "<left>") 'isearch-repeat-backward)
    (define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward))

  ;; For some minor modes, you need to load it first:
  (progn
    (require 'dired )
    (define-key dired-mode-map (kbd "o") 'other-window)
    (define-key dired-mode-map (kbd "C-o") 'find-file))


  ;; Here's a example of how to redefine keybinding in minibuffer
  (define-key minibuffer-local-map (kbd "M-r") 'kill-word)
  (define-key minibuffer-local-map (kbd "M-s") 'other-window)

#+end_src

*** Remapping commands
A special kind of key binding can be used to /remap/ one command to another, without having to refer to the key sequence(s) bound to the original command. To use this feature, make a key binding for a key sequence that starts with the dummy event ~remap~, followed by the command name you want to remap; for the binding, specify the new definition (usually a command name, but possibly any other valid definition for a key binding).

For example, suppose My mode provides a special command ~my-kill-line~, which should be invoked instead of ~kill-line~. To establish this, its mode keymap should contain the following remapping:

#+begin_src emacs-lisp

  (keymap-set my-mode-map "<remap> <kill-line>" 'my-kill-line)


  ;; Redefine all keys which now run next-line in Fundamental mode
  ;; so that they run forward-line instead (another old way).
  (keymap-substitute global-map 'next-line 'forward-line)
  ;; or an older equivalent
  (substitute-key-definition 'next-line 'forward-line global-map)

#+end_src

Then, whenever ~my-mode-map~ is active, if the user types ~C-k~ (the default global key sequence for ~kill-line~) Emacs will instead run ~my-kill-line~.

Note that remapping only takes place through active keymaps; for example, putting a remapping in a prefix keymap like ~ctl-x-map~ typically has no effect, as such keymaps are not themselves active. In addition, remapping only works through a single level; in the following example,

#+begin_src emacs-lisp

  (keymap-set my-mode-map "<remap> <kill-line>" 'my-kill-line)
  (keymap-set my-mode-map "<remap> <my-kill-line>" 'my-other-kill-line)

#+end_src

~kill-line~ is *not* remapped to ~my-other-kill-line~. Instead, if an ordinary key binding specifies ~kill-line~, it is remapped to ~my-kill-line~; if an ordinary binding specifies ~my-kill-line~, it is remapped to ~my-other-kill-line~.

To undo the remapping of a command, remap it to ~nil~; e.g.,

#+begin_src emacs-lisp

  (keymap-set my-mode-map "<remap> <kill-line>" nil)

#+end_src

** Packages
*** Brief
Emacs is extended by implementing additional features in /packages/, which are Emacs Lisp libraries. These could be written by you or provided by someone else. If you want to install such a package so it is available in your future Emacs session, you need to compile it and put it in a directory where Emacs looks for Lisp libraries.

Packages can also be provided by package /archives/, which are large collections of Emacs Lisp packages. Each package is a separate Emacs Lisp program, sometimes including other components such as an Info manual.

To list the packages available for installation from package archives, type [[Package installation][M-x list-packages RET]].

By default, Emacs downloads packages from a package archive maintained by the Emacs developers and hosted by the GNU project. Optionally, you can also download packages from archives maintained by third parties.

*Package vs library*
Note that a âpackageâ is (sometimes) different from an Emacs Lisp âlibraryâ. The ~(use-package foo)~ declaration tells use-package to load the /library/ ~foo.el~, which in the overwhelming majority of cases also resides in a /package/ named ~foo~. But the package ~foo~ might also contain a library named ~foo-extra.el~. If that library is not loaded automatically, you will need a separate ~use-package~ declaration to make sure that it is loaded when needed.

*** package.el
**** Brief
The idea behind ~package.el~ is to be able to download packages and install them.  Packages are versioned and have versioned dependencies. Furthermore, this supports built-in packages which may or may not be newer than user-specified packages. This makes it possible to upgrade Emacs and automatically disable packages which have moved from external to core.

A package is described by its name and version. The distribution format is either a tar file or a single ~.el~ file.

A tar file should be named ~NAME-VERSION.tar~. The tar file must unpack into a directory named after the package and version: ~NAME-VERSION~. It must contain a file named ~PACKAGE-pkg.el~ which consists of a call to define-package. It may also contain a "dir" file and the info files it references.

A ~.el~ file is named ~NAME-VERSION.el~ in the remote archive, but is installed as simply ~NAME.el~ in a directory named ~NAME-VERSION~.

The downloader downloads all dependent packages. By default, packages come from the official GNU sources, but others may be added by customizing the ~package-archives~ alist. Packages get byte-compiled at install time.

At activation time we will set up the [[Load path][load-path]] and the info path, and we will load the package's [[Autoload][autoloads]]. If a package's dependencies are not available, we will not activate that package.

/ELPA/ (or Emacs Lisp Package Archive) is the official GNU Emacs ~package.el~ repository (None is required. ELPA is preconfigured in Emacs 24).

**** Package states
Conceptually a package has multiple state transitions:
- download :: fetching the package from ELPA.
- install :: untar the package, or write the ~.el~ file, into ~~/.emacs.d/elpa/~ directory.
- autoload generation ::
- byte compile :: currently this phase is done during install, but we may change this.
- activate :: evaluate the autoloads for the package to make it available to the user.
- load :: actually [[Load][load]] the package and run some code from it.

**** Install packages automatically on startup
Using the ~package.el~ UI is ok if youâre a casual Emacs user, but what if you have a custom Emacs configuration, stored under version control, that youâd like to instantly deploy on any OS/machine. Here in play comes ~package.el~ âs programmer interface.

The following code check if all of the packages in the list are installed and if any of them are not installed if refreshes the local package database (in the case a required package for recently added to the remote repo) and installs them.

But the [[Use package]] also helps in doing that, and more. It allows to declare packages, install and load them asynchronously and declare their configuration.

#+begin_src emacs-lisp

  (require 'cl-lib)

  (defvar my-packages
    '(ack-and-a-half auctex clojure-mode coffee-mode deft expand-region
                     gist groovy-mode haml-mode haskell-mode inf-ruby
                     magit magithub markdown-mode paredit projectile python
                     sass-mode rainbow-mode scss-mode solarized-theme
                     volatile-highlights yaml-mode yari zenburn-theme)
    "A list of packages to ensure are installed at launch.")

  (defun my-packages-installed-p ()
    (cl-loop for p in my-packages
             when (not (package-installed-p p)) do (cl-return nil)
             finally (cl-return t)))

  (unless (my-packages-installed-p)
    ;; check for new packages (package versions)
    (package-refresh-contents)
    ;; install the missing packages
    (dolist (p my-packages)
      (when (not (package-installed-p p))
        (package-install p))))

#+end_src

**** Straight.el, other alternative
~straight.el~ is a "Next-generation, purely functional package manager for the Emacs hacker".

The primary differences are that:
- ~straight.el~ clones Git repos and builds packages from source, instead of downloading tarballs from a central server
- ~straight.el~ uses the init-file as a sole source of truth, whereas ~package.el~ stores mutable state outside the init-file
- ~straight.el~ focuses on reproducibility and local modification, neither of which are supported in any way by ~package.el~

*** Package installation
Packages are most conveniently installed using the package menu ~M-x list-packages~, but you can also use the command ~M-x package-install~. This prompts for the name of a package with the ~available~ status, then downloads and installs it. Similarly, if you want to upgrade a package, you can use the ~M-x package-upgrade~ command, and if you want to upgrade all the packages, you can use the ~M-x package-upgrade-all~ command.

Once a package is downloaded, byte-compiled and installed, it is made available to the current Emacs session. *Making a package available adds its directory to [[Load path][load-path]] and loads its autoloads*. The effect of a packageâs autoloads varies from package to package. Most packages just make some new commands available, while others have more wide-ranging effects on the Emacs session.

*Note* that installing a package using ~package-install~ takes care of placing the packageâs Lisp files in a directory where Emacs will find it, and also writes the necessary initialization code into your init files, making the manual customizations unnecessary.

#+begin_src emacs-lisp

  ;; Enable installation of packages from MELPA:
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  ;; Note that you'll need to run M-x package-refresh-contents or M-x
  ;; package-list-packages to ensure Emacs has fetched the MELPA package
  ;; list before you can install packages with M-x package-install or similar

#+end_src

*** Package files and directory layout
Each package is downloaded from the package archive in the form of a single /package file/ âeither an Emacs Lisp source file, or a tar file containing multiple Emacs Lisp source and other files. Package files are automatically retrieved, processed, and disposed of by the Emacs commands that [[Package installation][install packages]]. Should you ever need to install a package directly from a package file, use the command ~M-x package-install-file~.

Once installed, the contents of a package are placed in a subdirectory of ~~/.emacs.d/elpa/~ (you can change the name of that directory by changing the variable[[ package-user-dir]]). The package subdirectory is named ~name-version~, where name is the package /name/ and /version/ is its version string.

In addition to ~package-user-dir~, Emacs looks for installed packages in the directories listed in [[package-directory-list]]. These directories are meant for system administrators to make Emacs packages available system-wide; Emacs itself never installs packages there.

*Deleting* a package involves deleting the corresponding package subdirectory. This only works for packages installed in ~package-user-dir~; if told to act on a package in a system-wide package directory, the deletion command signals an error.

** Use package
*** Brief
To install a desired package without using use-package, one may have to manually install it from GitHub and put it under a load path where Emacs can find it, for instance with [[path][(add-to-list 'load-path "/path/to/installed-package-repo")]]. Alternatively, you could open up the package list in Emacs with [[Package installation][M-x list-packages]]. Either way, youâd have to explicitly call [[require feature][(require 'package-name)]] in your ~init.el~ before you could do any configuration. Lastly, any configuration of the package may need to be wrapped in a [[Hooks for loading][(with-eval-after-load 'package-name ...)]] block, to avoid running into undefined variables and functions before your package is fully loaded. Well, the good news is that use-package abstracts all of this away from you.

The [[use-package]] macro allows you to *isolate and set up package customization in your init file in a declarative way*. It can help with common customization, such as binding keys, setting up [[Hooks][hooks]], [[Defining customization variables (defcustom)][customizing]] user options and faces, [[Autoload][autoloading]], and more. It also helps you keep Emacs startup fast.

Note that use-package is not a package manager. Although use-package does have the useful capability to interface with the Emacs package manager, *its primary purpose is help with the configuration and loading of packages*, not with managing their download, upgrades, and installation.

*Note* that each call to the ~use-package~ macro in your init file is a *declaration*.

The ~use-package~ macro provides the [[:ensure]] and ~:pin~ (pin a package to a specific archive, for example, from GNU ELPA or NonGNU ELPA) keywords that interface with standard Emacs [[Package installation][package manager]] to automatically install packages.

By default, ~use-package~ assumes that you are using the Emacs built-in [[package.el]] package manager.

*** Loanding Packages
Before use-package can load an Emacs Lisp package, it must be available in a directory on your [[Load path][load-path]]. When you install packages using the built-in ~install-package~ command, it will do this automatically for you. Packages shipped with Emacs (built-in packages) are always available.

use-package can interface with ~package.el~ to install packages on Emacs start.

*Forcing package to load immediately*
The presence of autoloading [[Deferring package loading][trigger keywords]] can be overridden using [[:demand t]], which forces the package to load immediately. Thus, even if you use an autoloading keyword such as [[:bind]], adding ~:demand~ will force loading to occur immediately. It will also avoid creating an autoload for the bound key, as it would be redundant.

If you specify both ~:demand t~ and ~:defer t~, the [[:defer]] keyword will take precedence.

*Note*: when enabled the 'package-install-upgrade-built-in' (nil by default) variable, 'package-install' will include in the list of upgradeable packages those built-in packages (like Eglot and use-package) for which a newer version is available in package archives, and will allow installing those newer versions.

*** Deferring package loading
use-package allows setting things up in such a way that packages are only loaded when some of the packageâs commands is first used (either with ~M-x~ or via some key binding). This is based on [[Autoload][autoloading]].

Some ~use-package~ keywords provide autoload /triggers/ that cause a package to be loaded when certain events occur. For example, the [[:hook]] keyword sets up a trigger that fires when the specified hook is run, and then loads the package automatically. The other *trigger keywords* are [[:commands]] , [[:bind]] , [[:bind*]] , [[:bind-keymap]] , [[:bind-keymap*]] , [[:mode , :interpreter][:mode]] , and [[:mode , :interpreter][:interpreter]].

If you did not specify any autoloading keyword, use-package will fall back to loading the package immediately.

[[:defer]] works to postpone loading the package.

Using ~:defer t~ by itself like this is rarely useful. Typically, you would only use it together with a keyword like [[:config]], or [[:ensure]].

*Making ~:defer t~ the default*
If you customize the user option ~use-package-always-defer~ to non-~nil~, the ~use-package~ macro will behave as if ~:defer t~ is always specified. This can be overridden for individual declarations using either ~:defer nil~ or [[:demand][:demand t]].

*Defer loading until idle for N seconds*
You can also give a numeric argument /n/ to ~:defer~ to specify that a package should be loaded (if it hasnât already) after Emacs has been idle for /n/ seconds.

#+begin_src emacs-lisp

  (use-package foo
    :defer 30)
  ;; make use-package load foo after 30 seconds of idle time

#+end_src

*** use-package
The call to the ~use-package~ macro will *load a package either immediately, or when the package is first used* (via [[Autoload][autoloading]]). In the simplest case, a ~use-package~ declaration loads a package when it is evaluated. If the declaration is in your init file, this happens automatically each time Emacs is started.

If you did not specify any [[Deferring package loading][autoloading keyword]], use-package will fall back to loading the package immediately.

The declaration below immediately loads the library ~foo~, this declaration is equivalent to using [[require feature][require]], with some use-package specific error handling added in. Just like ~require~, it needs the package ~foo~ to be installed and available via your [[Load path][load-path]].

#+begin_src emacs-lisp

  (use-package foo)

#+end_src

If the library ~foo~ is not available in your ~load-path~, the declaration logs a warning to the ~*Messages*~ buffer. The [[:ensure]] keyword takes care of *installing the package if it's not already on the system*, you can use ~:ensure t~ or set the ~use-package-always-ensure~ variable to non-~nil~ to set this behavior globally for all packages.

*Note*: If the above declaration loads the /library/ ~foo.el~, but the package ~foo~ might also contain a library named ~foo-extra.el~, which is not loaded automatically, you will need a separate ~use-package~ declaration to make sure that it is loaded when needed.

*** Order to evaluate keywords
**** :preface
The ~:preface~ section *is evaluated before anything else* (evaluated first), except [[:disabled]] and [[:ensure]]. It can be used to establish function and variable definitions that will:

1. Make the byte-compiler happy: it will not complain about functions whose definitions are unknown.
2. Define functions and variables that will be used in an [[:if , :when , :unless][:if]] test.

Note that whatever is specified within ~:preface~ *is evaluated both at load time and at byte-compilation time*, in order to ensure that definitions are seen by both the Lisp evaluator and the byte-compiler. Therefore, you should avoid having any side-effects in your ~:preface~ forms, and restrict them to symbol declarations and definitions.

Where possible, it is better to avoid ~:preface~, [[:config]] and [[:init]]. Instead, prefer autoloading keywords such as [[:bind]], [[:hook]], and [[:mode , :interpreter][:mode]], as they will take care of setting up autoloads for you without any need for boilerplate code.

**** :init
The ~:init~ section is *evaluated just before the package is loaded* (always executed (Not lazy)). Note that the ~:init~ form is run unconditionally â even if the package happens to not exist on your system. You must therefore remember to restrict ~:init~ code to what would succeed either way; put the rest in the [[:config]] section. ~:init~ also always happens before package load, whether ~:config~ has been deferred or not.

In general, you should keep ~:init~ forms as simple and quick as possible, and put as much as you can get away with into the ~:config~ section. That way, deferred loading can help your Emacs start as quickly as possible.

Where possible, it is better to avoid [[:preface]], ~:config~ and ~:init~. Instead, prefer autoloading keywords such as [[:bind]], [[:hook]], and [[:mode , :interpreter][:mode]], as they will take care of setting up autoloads for you without any need for boilerplate code.

#+begin_src emacs-lisp

  ;; Evaluate some Lisp before the foo package is loaded:
  (use-package foo
    :init
    (setq foo-variable t))


  ;; As you might expect, you can use :init and :config together:
  (use-package foo
    :init
    (setq foo-variable t)
    :config
    (foo-mode 1))


  ;; What :bind does behind the scenes (useful to understand the keywords):
  (use-package ace-jump-mode
    :bind ("C-." . ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :commands ace-jump-mode
    :init
    (bind-key "C-." 'ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :defer t
    :init
    (autoload 'ace-jump-mode "ace-jump-mode" nil t)
    (bind-key "C-." 'ace-jump-mode))

#+end_src

**** :config
The ~:config~ section *is evaluated after the package has been loaded* (after lazily loading the package). If the package is loaded immediately, this happens immediately after that, but if loading is done lazily, this is deferred until after the package has been loaded.

In general, you should keep [[:init]] forms as simple and quick as possible, and put as much as you can get away with into the ~:config~ section. That way, deferred loading can help your Emacs start as quickly as possible.

Where possible, it is better to avoid [[:preface]], ~:config~ and ~:init~. Instead, prefer autoloading keywords such as [[:bind]], [[:hook]], and [[:mode , :interpreter][:mode]], as they will take care of setting up autoloads for you without any need for boilerplate code.

As you might expect, you can use ~:init~ and ~:config~ together:

#+begin_src emacs-lisp

  (use-package foo
    :init
    (setq foo-variable t)
    :config
    (foo-mode 1))


  (use-package hi-lock
    :defer t
    :init (add-hook 'some-hook 'hi-lock-mode)
    :config (use-package my-hi-lock)
    :bind (("M-o l" . highlight-lines-matching-regexp)
           ("M-o r" . highlight-regexp)
           ("M-o w" . highlight-phrase)))
  ;; This will load hi-lock when some of its commands or variables are
  ;; first used, bind 3 keys to its commands, and additionally load the
  ;; my-hi-lock package (presumably further customizing hi-lock) after
  ;; loading hi-lock.

#+end_src

*** Loading keywords
**** :ensure
The ~:ensure~ keyword makes ~use-package~ *ask* the Emacs package manager to *install a package if it is not already present on your system*.

This is particularly useful if you use your init file on more than one system.

To avoid using ~:ensure t~ on all packages that have not been previously installed, you can set the ~use-package-always-ensure~ variable to no-~nil~ to get this behavior globally for all packages.

*Note*: ~:ensure nil~ avoid ~use-package~ from asking the Emacs package manager for the package (avoid fetching it in online archives like melpa). ~:ensure~ does not automatically keep packages up to date. It just ensures that the package is installed.

#+begin_src emacs-lisp

  (use-package magit
    :ensure t)

  ;; You can customize the user option use-package-always-ensure to a
  ;; non-nil value if you want this behavior to be global for all packages:
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
  ;; Override the above setting for a single package:
  (use-package foo
    :ensure nil)


  ;; Install a different package from the one named by use-package:
  (use-package tex
    :ensure auctex)

#+end_src

**** :defer
If you did not specify any [[Deferring package loading][autoloading keyword]], use-package will fall back to loading the package immediately (typically when Emacs is starting up). This can be overridden using the ~:defer~ keyword. It takes one boolean argument: a non-~nil~ value means to stop this package from being immediately loaded (*deferring package loading*). Using ~:defer~ postpones loading the package.

#+begin_src emacs-lisp

  ;; If you have installed a package from GNU ELPA that provides itâs own
  ;; autoloads, it is often enough to say:
  (use-package foo
    :defer t)
  ;; Now, when run any autoloaded command, the package is loaded automatically


  ;; What :bind does behind the scenes (useful to understand the keywords):
  (use-package ace-jump-mode
    :bind ("C-." . ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :commands ace-jump-mode
    :init
    (bind-key "C-." 'ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :defer t
    :init
    (autoload 'ace-jump-mode "ace-jump-mode" nil t)
    (bind-key "C-." 'ace-jump-mode))

#+end_src

Using ~:defer t~ by itself like this is rarely useful. Typically, you would only use it together with a keyword like [[:config]], or [[:ensure]].

*Defer loading until idle for N seconds*
You can also give a numeric argument /n/ to ~:defer~ to specify that a package should be loaded (if it hasnât already) after Emacs has been idle for /n/ seconds.

#+begin_src emacs-lisp

  (use-package foo
    :defer 30)
  ;; make use-package load foo after 30 seconds of idle time

#+end_src

**** :demand
The presence of autoloading [[Deferring package loading][trigger keywords]] can be overridden using ~:demand~ *forces the package to load immediately*. Thus, even if you use an autoloading keyword such as [[:bind]], adding ~:demand~ will force loading to occur immediately. It will also avoid creating an autoload for the bound key, as it would be redundant.

If you specify both ~:demand t~ and ~:defer t~, the [[:defer]] keyword will take precedence.

**** :after
Allows a fairly rich description of the exact *conditions when loading should occur* (*loading packages in sequence*). The ~:after~ keyword takes as argument either a symbol indicating the package name, a list of such symbols, or a list of selectors.

Here is an example of using the GNU ELPA packages ~hydra~, ~ivy~, and ~ivy-hydra~. Note that ~ivy-hydra~ will always be loaded last:

#+begin_src emacs-lisp

  (use-package hydra)

  (use-package ivy)

  (use-package ivy-hydra
    :after (ivy hydra))
  ;; Because the declarations are evaluated in the order they occur, the
  ;; use of :after is not strictly necessary. However, if hydra and ivy
  ;; were to be autoloaded, using :after guarantees that ivy-hydra is not
  ;; loaded until it is actually needed. By using :after, the above code
  ;; will also work even if the order of the declaration changes.

#+end_src

*Note*: when setting ~use-package-always-defer~ to a non-~nil~ value, and also using the ~:after~ keyword. In that case, you will need to specify how the declared package is to be loaded: for example, by some [[:bind]]. If you are not using one of the keywords that registers autoloads, such as ~:bind~ or [[:hook]], and your package manager does not provide autoloads, it is possible that your package will never be loaded if you do not add [[:demand t]] to those declarations.

*Using ~:after~ selectors*
The ~:after~ keyword also accepts a list of selectors. By default, ~:after (foo bar)~ is the same as ~:after (:all foo bar)~, meaning that loading of the given package will not happen until both ~foo~ and ~bar~ have been loaded.

#+begin_src emacs-lisp

  :after (foo bar)
  :after (:all foo bar)
  :after (:any foo bar)
  :after (:all (:any foo bar) (:any baz quux))
  :after (:any (:all foo bar) (:all baz quux))

#+end_src

When you nest selectors, such as in ~(:any (:all foo bar) (:all baz quux))~, it means that the package will be loaded when either both ~foo~ and ~bar~ have been loaded, or when both ~baz~ and ~quux~ have been loaded.

**** :requires
While the [[:after]] keyword delays loading until the dependencies are loaded, the somewhat simpler ~:requires~ keyword *never loads the package if the dependencies are not available when* the [[use-package]] declaration is evaluated. In this context, âavailableâ means that ~foo~ is available if [[Features][(featurep 'foo)]] evaluates to a non-~nil~ value.

#+begin_src emacs-lisp

  (use-package abbrev
    :requires foo)
  ;; This is the same as:
  (use-package abbrev
    :if (featurep 'foo))

  ;; As a convenience, a list of such packages may be specified:
  (use-package abbrev
    :requires (foo bar baz))

#+end_src

**** :if , :when , :unless
The ~:if~ , ~:when~ , and ~:unless~ keywords predicates the loading and initialization of packages (*loading packages conditionally*). They all accept one argument, an Emacs Lisp form that is evaluated at run-time.

If the argument of the ~:if~ keyword evaluates to non-~nil~, the package will be loaded and initialized. The ~:when~ keyword is provided as an alias for ~:if~. Finally, the ~:unless~ keyword is the inverse of ~:if~, such that ~:unless~ foo means the same thing as ~:if (not foo)~.

#+begin_src emacs-lisp

  ;; If you only want to load foo in graphical Emacs sessions, you could use:
  (use-package foo
    :if (display-graphic-p))

  ;; Some common use cases:
  ;; Loads a package only on GNU/Linux.
  :if (eq system-type 'gnu/linux)

  ;; Loads a package only when the foo package is installed.
  :if (package-installed-p 'foo)

  ;; Loads a package only when foo.el is available in your load-path
  ;; (for example, if you installed that file manually):
  :if (locate-library "foo.el")

#+end_src

If you need to make a use-package form conditional so that the condition occurs before even [[:ensure]] or [[:preface]], use ~when~ around the ~use-package~ form itself. For example:

#+begin_src emacs-lisp

  (when (memq window-system '(mac ns))
    (use-package foo
      :ensure t))

#+end_src

**** :commands
In some cases, you might need or want to *provide your own autoloads*. The ~:commands~ keyword autoload an interactive command, takes either a symbol or a list of symbols as its argument. It creates autoloads for those commands (which defers loading of the module until those commands are used).

*Note*: To autoload non-interactive functions use [[:autoload]].

The example below autoloads the commands ~isearch-moccur~ and ~isearch-all~ from the package ~color-moccur.el~. When one of these two commands are used, the package will be loaded. At that point, ~moccur-edit~ is also loaded, to allow editing of the ~moccur~ buffer.

#+begin_src emacs-lisp

  (use-package color-moccur
    :commands (isearch-moccur isearch-all)
    :bind (("M-s O" . moccur)
           :map isearch-mode-map
           ("M-o" . isearch-moccur)
           ("M-O" . isearch-moccur-all))
    :init
    (setq isearch-lazy-highlight t)
    :config
    (use-package moccur-edit))


  ;; What :bind does behind the scenes (useful to understand the keywords):
  (use-package ace-jump-mode
    :bind ("C-." . ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :commands ace-jump-mode
    :init
    (bind-key "C-." 'ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :defer t
    :init
    (autoload 'ace-jump-mode "ace-jump-mode" nil t)
    (bind-key "C-." 'ace-jump-mode))

#+end_src

**** :autoload
Takes the same arguments as [[:commands]], but is used to *autoload non-interactive functions*.

#+begin_src emacs-lisp

  (use-package org-crypt
    :autoload org-crypt-use-before-save-magic)

#+end_src

*** Configurations keywords
**** :hook
*Allows adding functions to hooks*. It takes one argument of the form /hooks/, specifying one or more functions to add to one or more hooks.

For the purposes of ~:hook~, the name of hook variables should always exclude the ~-hook~ suffix. It is appended automatically.

The use of ~:hook~, as with [[:bind]], [[:mode , :interpreter][:mode]], [[:mode , :interpreter][:interpreter]], etc., causes the functions being hooked to implicitly be read as [[:commands]]. This means that they will establish interactive ~autoload~ definitions for that module, if not already defined as functions, and so [[:defer][:defer t]] is also implied by ~:hook~.

#+begin_src emacs-lisp

  ;; Sets up autoloads for company-mode from the company package,
  ;; and adds company-mode to prog-mode-hook
  (use-package company
    :commands company-mode
    :init
    (add-hook 'prog-mode-hook #'company-mode))
  ;; Using :hook keyword:
  (use-package company
    :hook (prog-mode . company-mode))
  ;; :hook will automatically set up autoloads for the company-mode
  ;; command, so there is no need to use :commands.
  ;; You can simplify the above to the equivalent:
  (use-package company
    :hook prog-mode)


  ;; You can also provide a list of hooks:
  (use-package company
    :hook ((prog-mode text-mode) . company-mode))
  ;; or
  (use-package company
    :hook ((prog-mode . company-mode)
           (text-mode . company-mode)))
  ;; or
  (use-package company
    :hook (prog-mode text-mode))


  ;; DOES NOT WORK
  (use-package ace-jump-mode
    :hook (prog-mode-hook . ace-jump-mode))
  ;; It attempts to add a function to non-existent prog-mode-hook-hook.

#+end_src

**** :bind
***** Brief
*To bind keys globally*, the ~:bind~ autoloading keyword takes as its argument either a single cons or a list of conses. Each cons has the form ~(key . command)~, where /key/ is a string indicating the key to bind, and /command/ is the name of a command (a symbol).

~:bind~ creates an autoload for the command and defers loading of the package until you actually use it, and bind the key to that command.

The ~:bind~ keyword uses the ~bind-keys~ macro from the ~bind-key.el~ library to set up keybindings. It keeps track of all keybindings you make, so that you can display them separately from the default keybindings.

Use ~M-x describe-personal-keybindings~ to see all keybindings youâve set using either the ~:bind~ keyword or the ~bind-keys~ macro.

#+begin_src emacs-lisp

  ;; Here is an example of using a single cons:
  (use-package ace-jump-mode
    :bind ("C-." . ace-jump-mode))


  ;; Here is an example of using :bind with a list of conses:
  (use-package hi-lock
    :bind (("M-o l" . highlight-lines-matching-regexp)
           ("M-o r" . highlight-regexp)
           ("M-o w" . highlight-phrase)))


  ;; What :bind does behind the scenes (useful to understand the keywords):
  (use-package ace-jump-mode
    :bind ("C-." . ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :commands ace-jump-mode
    :init
    (bind-key "C-." 'ace-jump-mode))
  ;; This is the same as:
  (use-package ace-jump-mode
    :defer t
    :init
    (autoload 'ace-jump-mode "ace-jump-mode" nil t)
    (bind-key "C-." 'ace-jump-mode))

#+end_src

***** Key bindings in local keymaps
Slightly different from binding a key to a keymap, is *binding a key within a local keymap* that only exists after the package is loaded. ~use-package~ supports this with a ~:map~ modifier, taking the local keymap to bind to:

#+begin_src emacs-lisp

  (use-package helm
    :bind (:map helm-command-map
                ("C-c h" . helm-execute-persistent-action)))
  ;; The effect of this is to wait until helm has loaded, and then
  ;; to bind the key sequence C-c h to helm-execute-persistent-action
  ;; within Helmâs local keymap, helm-command-map.


  ;; Multiple uses of :map may be specified. Any binding occurring
  ;; before the first use of :map are applied to the global keymap:
  (use-package term
    :bind (("C-c t" . term)
           :map term-mode-map
           ("M-p" . term-send-up)
           ("M-n" . term-send-down)
           :map term-raw-map
           ("M-o" . other-window)
           ("M-p" . term-send-up)
           ("M-n" . term-send-down)))

#+end_src

***** Binding to keymaps
Normally ~:bind~ expects that commands are functions that will be autoloaded from the given package. However, this does not work if one of those commands is actually a [[Keymap basics][keymap]], since keymaps are not functions, and cannot be autoloaded using the built-in ~autoload~ function.

To handle this case, ~use-package~ offers a special, limited variant of ~:bind~ called ~:bind-keymap~. The only difference is that the âcommandsâ bound to by ~:bind-keymap~ must be *keymaps defined in the package, rather than interactive functions*.

#+begin_src emacs-lisp

  (use-package foo
    :bind-keymap ("C-c p" . foo-command-map))

#+end_src

***** Remapping
[[Remapping commands][Remapping of commands]] with ~:bind~ and ~bind-key~ works as expected, because when the binding is a vector, it is passed straight to define-key.

#+begin_src emacs-lisp

  ;; Will rebind fill-paragraph (bound to M-q by default) to unfill-toggle:
  (use-package unfill
    :bind ([remap fill-paragraph] . unfill-toggle))

#+end_src

***** Using special keys
Inside key strings, special keys like ~TAB~ or ~F1âF12~ have to be written inside angle brackets, e.g., ~"C-<up>"~ . Standalone special keys (and some combinations) can be written in square brackets, e.g. ~[tab]~ instead of ~"<tab>"~.

#+begin_src emacs-lisp

  (use-package helm
    :bind (("M-x" . helm-M-x)
           ("M-<f5>" . helm-find-files)
           ([f10] . helm-buffers-list)
           ([S-f10] . helm-recentf)))

#+end_src

**** :mode , :interpreter
You can use ~:mode~ and ~:interpreter~ to establish a *deferred binding within the* [[auto-mode-alist]] and [[interpreter-mode-alist]] variables. The specifier to either keyword can be a cons cell, a list of cons cells, or a string or regexp.

#+begin_src emacs-lisp

  ;; The package is "python", and the mode is "python-mode":
  (use-package python
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("python" . python-mode))


  ;; Both the :mode and :interpreter keywords also accept a list of regexps:
  (use-package foo
    ;; Equivalent to "\\(ba[rz]\\)\\'":
    :mode ("\\.bar\\'" "\\.baz\\'")
    ;; Equivalent to "\\(foo[ab]\\)":
    :interpreter ("fooa" "foob"))


  ;; That mode is enabled automatically when a file whose name matches the
  ;; regexp "\\.rb\\'", or when the first line of the file (known as the
  ;; âshebangâ) matches the string "ruby":
  (use-package ruby-mode
    :mode "\\.rb\\'"
    :interpreter "ruby")
  ;; It can be simplified since the package is "ruby-mode", and the
  ;; mode is the same "ruby-mode":


  ;; All :mode does is that internally expands to the normal Emacs syntax:
  (add-to-list 'auto-mode-alist '("\\.tsx?\\'" . typescript-mode))

#+end_src

**** :magic
Similar to [[:mode , :interpreter][:mode]] and ~:interpreter~, you can also use ~:magic~ and ~:magic-fallback~ to cause *certain function to be run if the beginning of a file matches a given regular expression*, as if these regular expressions were added to ~magic-mode-alist~ and ~magic-fallback-mode-alist~. The difference between ~:magic~ and ~:magic-fallback~, is that the latter has a lower priority than ~:mode~.

#+begin_src emacs-lisp

  ;; This registers an autoloaded command for pdf-view-mode, defers loading
  ;; of pdf-tools, and runs pdf-view-mode if the beginning of a buffer
  ;; matches the string "%PDF".
  (use-package pdf-tools
    :magic ("%PDF" . pdf-view-mode)
    :config
    (pdf-tools-install :no-query))

#+end_src

**** :custom
You normally *set customizable variables* using the ~M-x customize~ interface. However, it is also possible to set them in your ~use-package~ declarations by using the ~:custom~ keyword.

This is better than using setq in a [[:config]] block, as customizable variables might have some code associated with it that Emacs will execute when you assign values to them. (In Emacs 29 and later, there is also the new [[setopt]] macro that does this for you.)

Note that the values customized using ~:custom~ are not saved in the standard Emacs ~custom-file~. You should therefore set each user option using either the ~:custom~ keyword or ~M-x customize-option~ command; the latter will save customized values in the Emacs ~custom-file~. Do not use both for the same variable, as this risks having conflicting values.

#+begin_src emacs-lisp

  (use-package comint
    :defer t
    :custom
    (comint-buffer-maximum-size 20000 "Increase comint buffer size.")
    (comint-prompt-read-only t "Make the prompt read only."))

#+end_src

**** :custom-face
Allows *customization* of packageâs *faces*.

#+begin_src emacs-lisp

  (use-package eruby-mode
    :custom-face
    (eruby-standard-face ((t (:slant italic)))))


  (use-package example
    :custom-face
    (example-1-face ((t (:foreground "LightPink"))))
    (example-2-face ((t (:foreground "LightGreen"))) face-defspec-spec))


  (use-package zenburn-theme
    :preface
    (setq my/zenburn-colors-alist
          '((fg . "#DCDCCC") (bg . "#1C1C1C") (cyan . "#93E0E3")))
    :custom-face
    (region ((t (:background ,(alist-get my/zenburn-colors-alist 'cyan)))))
    :config
    (load-theme 'zenburn t))


  (use-package markdown-mode
    :hook (markdown-mode . auto-fill-mode)
    :custom-face (markdown-code-face ((t (:inherit org-block)))))
  ;; same as
  (use-package markdown-mode
    :config
    (add-hook 'markdown-mode-hook #'auto-fill-mode)
    (set-face-attribute 'markdown-code-face nil :inherit 'org-block))

#+end_src

**** :load-path
Provides a convenient way to *add directories to your [[Load path][load path]]*. It takes as argument a symbol, a function, a string or a list of strings. If a directory is specified as a relative file name, it is expanded relative to ~user-emacs-directory~.

#+begin_src emacs-lisp

  (use-package org
    :load-path "site-lisp/org/lisp/"
    :commands org-mode)

#+end_src

When using a symbol or a function to provide a dynamically generated list of directories, you must inform the byte-compiler of this definition, so that the value is available at byte-compilation time. This is done by using the special form ~eval-and-compile~ (as opposed to ~eval-when-compile~). Furthermore, this value is fixed to the value it had during compilation. If the operation is costly, you do not have to repeat it again on each startup.

#+begin_src emacs-lisp

  (eval-and-compile
    (defun ess-site-load-path ()
      (shell-command-to-string "find ~ -path ess/lisp")))


  (use-package ess-site
    :load-path (lambda () (list (ess-site-load-path)))
    :commands R)

#+end_src

**** :diminish , :delight
~use-package~ supports the ~diminish~ and ~delight~ packages, both of which make it possible to *remove or change minor mode strings in your mode-line*. Which one to use is up to you, but you should normally only use one or the other â never both. To use either of them, you must first install the corresponding package from GNU ELPA.

The ~:diminish~ keyword takes as its argument either a minor mode symbol, a cons of the symbol and its replacement string, or just a replacement string, in which case the minor mode symbol is guessed to be the package name with ~-mode~ appended at the end.

#+begin_src emacs-lisp

  ;; First, add the following declaration to the beginning of your init file.
  (use-package diminish :ensure t)

  (use-package abbrev
    :diminish abbrev-mode
    :config
    (if (file-exists-p abbrev-file-name)
        (quietly-read-abbrev-file)))

#+end_src

The ~:delight~ keyword takes as its argument a minor mode symbol, a replacement string, or quoted mode line data (in which case the minor mode symbol is assumed to be the package name with ~-mode~ appended at the end), both of these, or several lists of both. If no arguments are provided, the default mode name is hidden completely.

#+begin_src emacs-lisp

  ;; Hides everything for the foo-mode minor mode in the foo package:
  (use-package foo
    :delight)

  ;; Don't show auto-revert-mode, which doesn't match its package name.
  (use-package autorevert
    :delight auto-revert-mode)


  ;; Here is an example of hiding several built-in minor modes.
  ;; Completely hide visual-line-mode and change auto-fill-mode to " AF".
  (use-package emacs
    :delight
    (auto-fill-function " AF")
    (visual-line-mode))


  ;; You can also use arbitrary Lisp code as argument of :delight. For
  ;; example, to replace foo-mode with the value of the current buffer:
  (use-package foo
    :delight '(:eval buffer-file-name))

#+end_src

**** :pin
use-package can /pin/ a package to a specific archive using the ~:pin~ keyword. This allows you to mix and match packages from different archives. The primary use-case for this is preferring to install packages from GNU ELPA or NonGNU ELPA (indicated by ~gnu~ and ~nongnu~), while installing specific packages from third-party archives.

#+begin_src emacs-lisp

  (use-package company
    :ensure t
    :pin gnu)   ; GNU ELPA

#+end_src

Unfortunately, the third-party archive MELPA uses a versioning scheme based on dates, which means that packages from that archive are always preferred. If you are using that archive, we strongly encourage you to customize ~use-package-always-pin~ to ~nongnu~. This guarantees that you are using a version of that package that has been specifically marked for release by its developer, and not a development snapshot.

If you want to manually keep a package updated and ignore upstream updates, you can pin it to ~manual~. This will work as long as you have not customized a repository to use that name in the ~package-archives~ variable.

#+begin_src emacs-lisp

  (use-package org
    :ensure t
    ;; ignore org-mode from upstream and use a manually installed version
    :pin manual)

#+end_src

~use-package~ signals an error if you try to pin a package to an archive that is not configured using ~package-archives~ (except from the special ~manual~ archive).

** Commands-
*** Lines-
**** list-matching-lines (occur)
Show all lines in the current buffer containing a match for REGEXP.

**** delete-matching-lines (flush-lines)
Delete lines containing matches for REGEXP.

~delete-matching-lines~ starts at the line your cursor is on.

*Note*: the ~kill-matching-lines~ command add the matching lines to the kill ring as a single string, including the newlines that separate the lines.

**** delete-non-matching-lines (keep-lines)
Delete all lines except those containing matches for REGEXP.

~delete-non-matching-lines~ starts at the line your cursor is on.

*Note*: the ~copy-matching-lines~ command add the matching lines to the kill ring as a single string, including the newlines that separate the lines.

**** delete-duplicate-lines
Delete all but one copy of any identical lines in the region.

**** count-matches (how-many)
Print and return number of matches for REGEXP following point.

**** sort-lines
Sort lines in region alphabetically; REVERSE non-nil means descending order

**** reverse-region
Reverse the order of lines in a region.

**** highlight-lines-matching-regexp
Highlight all lines that match REGEXP using FACE.

**** unhighlight-regexp
Remove highlighting of each match to REGEXP set by hi-lock.

**** occur
Show all lines in the current buffer containing a match for REGEXP.

**** xah-fill-or-unfill
This command automatically toggle âfillâ or âunfillâ on the current paragraph. If there is a text selection, then the command automatically works on the region.

#+begin_src emacs-lisp

  ;; Automatically toggle âfillâ or âunfillâ on the current paragraph.
  (defun xah-fill-or-unfill ()
    "Reformat current paragraph or region to `fill-column'.
  When there is a text selection, act on the selection, else, act on a
  text block separated by blank lines. URL
  `http://xahlee.info/emacs/emacs/modernization_fill-paragraph.html'
  Version 2017-01-08"
    (interactive)
    ;; This command symbol has a property â'compact-pâ, the possible values
    ;; are t and nil. This property is used to easily determine whether to
    ;; compact or uncompact, when this command is called again
    (let ( ($compact-p
            (if (eq last-command this-command)
                (get this-command 'compact-p)
              (> (- (line-end-position) (line-beginning-position))
                 fill-column)))
           (deactivate-mark nil)
           ($blanks-regex "\n[ \t]*\n")
           $p1 $p2
           )
      (if (use-region-p)
          (progn (setq $p1 (region-beginning))
                 (setq $p2 (region-end)))
        (save-excursion
          (if (re-search-backward $blanks-regex nil "NOERROR")
              (progn (re-search-forward $blanks-regex)
                     (setq $p1 (point)))
            (setq $p1 (point)))
          (if (re-search-forward $blanks-regex nil "NOERROR")
              (progn (re-search-backward $blanks-regex)
                     (setq $p2 (point)))
            (setq $p2 (point)))))
      (if $compact-p
          (fill-region $p1 $p2)
        (let ((fill-column most-positive-fixnum ))
          (fill-region $p1 $p2)))
      (put this-command 'compact-p (not $compact-p)))
    (deactivate-mark))

#+end_src

**** duplicate-dwim
Duplicates the region if it is active.  If not, it works like 'duplicate-line'.  An active rectangular region is duplicate on its right-hand side.  The new user option 'duplicate-line-final-position' specifies where to move point after duplicating a line.

*** Regex-
**** isearch-forward
Do incremental search forward.

**** isearch-backward
Do incremental search backward.

**** highlight-regexp
Set face of each match of REGEXP to FACE.

**** find-dired
Run find and go into Dired mode on a buffer of the output.

**** dired-do-search
Search through all marked files for a match for REGEXP.

While in dired, you can *step thru all files that matches a text pattern*. In dired, call ~dired-do-search A~. It will prompt you for a search string, then open the first file of the match, with your cursor placed at the matching location.

To go to next occurrence, press ~M-,~ (~tags-loop-continue~).

**** dired-do-query-replace-regexp
Do query-replace-regexp of FROM with TO, on all marked files.

**** dired-do-rename-regexp
Rename selected files whose names match REGEXP to NEWNAME.

**** grep
Call ~grep~ to list all matching text of all files in the current directory.

For example, if you give this input ~grep -nH -e "Cheshire" *html~, which will list all files ending in âhtmlâ that contains the word âCheshireâ.

If you want case insensitive search, add a ~-i~ in the grep option.

**** rgrep
Search all files in current directory and sub-directory.

**** lgrep
Search only some files of current dir by using a text pattern (regex) on file names first.

**** grep-find
Use a combination of unix's ~grep~ and ~find~ commands..

**** replace-regexp-function

*** String-
**** string-rectangle
Replace rectangle contents with STRING on each line.

*Note*: The command string-rectangle can be used to insert a vertical column of string across mulitple lines at any column position, not just at the beginning of lines.

**** kill-rectangle
Delete the region-rectangle and save it as the last killed one.

~kill-rectangle~ can be used to delete any rectangular block of text, not just at the beginning of lines.

There are others useful command like ~replace-rectangle~, ~yank-rectangle~,...

#+begin_example

try to delete the middle column
3c21 646f 6374
6874 6d6c 3e3c
2063 6861 7273
202f 3e0a 3c6d
6965 7770 6f72
2277 6964 7468

1. Put your cursor before â646fâ.
2. Call set-mark-command =C-SPC=.
3. Move cursor to end of â6964â.
4. Call =kill-rectangle=.

#+end_example

**** align-regexp
Align the current region using an ad-hoc rule read from the minibuffer.Align the current region using an ad-hoc rule read from the minibuffer.

There are others useful command like ~align-regexp~, ~sort-regexp-fields~, ~sort-columns~.

Example pressing ~align-regexp~ with "=" align the text.

#+begin_example

align them by the equal sign
tom = 5
jenny = 8
mary = 7

align
California 423,970 kmÂ²
Taiwan 36,008 kmÂ²
Japan 377,944 kmÂ²
Germany 357,021 kmÂ²
Iraq 438,317 kmÂ²
Iran 1,648,195 kmÂ²
Korea (North+South) 219,140 kmÂ²
Mexico 1,964,375 kmÂ²

Select the text first, then press C-u then call align-regexp, with the regexp .* \([0-9,]+\).* then choose -1 for group, 1 for spacing, and n for repeat.

#+end_example

*** Comparing-
**** ediff
Alternative to [[diff]] much more sophisticated.

Provides a convenient way of simultaneous browsing through the differences between a pair (or a triple) of files or buffers. The files being compared, file-A, file-B, and file-C (if applicable) are shown in separate windows (side by side, one above the other or in separate frames) and the differences are highlighted as you step through them. You can also copy difference regions from one buffer to another (and recover old differences if you change your mind).

Ediff also supports merging operations on files and buffers, including merging using ancestor versions. Both comparison and merging operations can be performed on directories, i.e. by pairwise comparison of files in those directories.

You can ignore whitespace or case sensitivity interactively, on the fly:
- Whitespace sensitivity :: toggle with ` ~##~ â (~âediff-toggle-skip-similarâ~).
- Case sensitivity :: toggle with ` ~#c~ â (~âediff-toggle-ignore-caseâ~). This assumes that youâve loaded library Lisp:ediff+.el and that you are using ` ~diff(1)~ â as ~âediff-diff-programâ~. (Toggling case-sensitivity is available in vanilla GNU Emacs 22, so Lisp:ediff+.el is mainly useful for older Emacs versions.)

**** ediff3
Run Ediff on three files, FILE-A, FILE-B, and FILE-C.

**** ediff-buffers
Run Ediff on a pair of buffers, BUFFER-A and BUFFER-B.

**** compare-windows
Compare text in *current window with text in another window*.

Comparison starts at point in each window, after pushing each initial point value on the mark ring in its respective buffer. Then it moves point forward in each window, one character at a time, until it reaches characters that don't match. Then the command exits.

If point in the two windows is followed by non-matching text when the command starts, it tries heuristically to advance up to matching text in the two windows, and then exits. So if you use ~M-x compare-windows~ repeatedly, each time it either skips one matching range or finds the start of another.

With a numeric argument, ~compare-windows~ ignores changes in whitespace. If the variable ~compare-ignore-case~ is non-~nil~, the comparison ignores differences in case as well. If the variable ~compare-ignore-whitespace~ is non-~nil~, ~compare-windows~ normally ignores changes in whitespace, and a prefix argument turns that off.

**** smerge-makeup-conflict
See the differences between two *blocks of text in the same buffer*.

Uses point and mark for two of the relevant positions and previous marks
for the other ones. By default, makes up a 2-way conflict, with a ~C-u~ prefix, makes up a 3-way conflict.

- go to the beginning of the first bloc, ~C-SPC~
- go the beginning of the second bloc, ~C-SPC~
- go to the end of the second bloc, ~M-x smerge-makeup-conflict RET~
- then you can use ~C-c ^ R~ or ~C-c ^ =~ to view the differences.

Note that this works better if the two blocs are pretty much consecutive.

**** diff
Prompts for two file names, using the minibuffer, and displays the differences between the two files in a buffer named â*diff*â. This works by running the ~diff~ program, using options taken from the variable ~diff-switches~.

After running ~M-x diff~, you can use ~C-x `~ to visit successive changed locations in the two source files, as in Compilation mode. (see Compilation Mode.) In the â*diff*â buffer, you can move to a particular hunk of changes and type C-c C-c (diff-goto-source) to visit the corresponding source location.

**** diff-backup
Compares a specified file with its most recent backup.

*** Info-
**** describe-personal-keybindings
Display all keybindings youâve set using either the [[:bind]] keyword or the ~bind-keys~ macro.
**** apropos
This command is like the ~C-h a~ (command-apropos) command, except that the latter finds only those functions that are commands. The ~M-x apropos~ command lists all symbols that match a regular expression, including functions that are not interactive.

#+begin_src emacs-lisp

  ;; Example: we want to look for is some command that prints or inserts
  ;; columns. Very likely, the name of the function will contain either the
  ;; word âprintâ or the word âinsertâ or the word âcolumnâ. Therefore, we
  ;; can simply type:

  M-x apropos RET print\|insert\|column RET

#+end_src

**** pwd
Show the current default directory.

**** command-history
Examine commands from command-history in a buffer.

**** help-quick
Displays an overview of common commands. The command pops up a buffer at the bottom of the screen with a few helpful commands for various tasks.  You can toggle the display using 'C-h C-q'.

*** Files-
**** load-file
Load the Lisp file named FILE.

**** load-library
Load the Emacs Lisp library named LIBRARY.

**** locate-library
Show the precise file name of Emacs library LIBRARY.

**** unload-feature
Unloads the library that provided [[Features][feature]]. It undefines all functions, macros, and variables defined in that library with ~defun~ , ~defalias~ , ~defsubst~ , ~defmacro~ , ~defconst~ , ~defvar~ , and ~defcustom~. It then restores any autoloads formerly associated with those symbols.

Before restoring the previous definitions, ~unload-feature~ runs ~remove-hook~ to remove functions defined by the library from certain hooks. This is to prevent Emacs from ceasing to function because important hooks refer to functions that are no longer defined.

This function discard the functions and variables loaded by a library. It can be used to free up some memory, or occasionally to undo some add-on behaviour.

Ordinarily, ~unload-feature~ refuses to unload a library on which other loaded libraries depend (a library ~a~ depends on library ~b~ if ~a~ contains a ~require~ for ~b~). If the optional argument force is non-~nil~, dependencies are ignored and you can unload any library.

**** do-auto-save
Auto-save all buffers that need it. This is all buffers that have auto-saving enabled and are changed since last auto-saved.

**** recover-file
Visit file FILE, but get contents from its last auto-save file.

**** recover-session
Recover auto save files from a previous Emacs session.

*** Cursor-
**** mc/mark-all-dwim
Tries even harder to guess what you want to mark all of.

**** mc/mark-all-in-region
Find and mark all the parts in the region matching the given search

**** mc/mark-all-in-region-regexp
Find and mark all the parts in the region matching the given regexp.

**** mc/mark-next-word-like-this
Find and mark the next word of the buffer matching the currently active region

**** mc/mark-previous-word-like-this
Find and mark the previous part of the buffer matching the currently active region.

**** mc/mark-sgml-tag-pair
Mark the tag we're in and its pair for renaming.

*** Buffer-
**** revert-buffer
Replace current buffer text with the text of the visited file on disk.

**** revert-buffer-with-fine-grain

**** scratch-buffer
This command switches to the "*scratch*" buffer.  If "*scratch*" doesn't exist, the command creates it first.  You can use this command if you inadvertently delete the "*scratch*" buffer.

*** Mark-
**** transient-mark-mode
Toggle Transient Mark mode.

**** counsel-mark-ring
Browse mark-ring interactively.

*** Packages-
**** package-refresh-contents
Download descriptions of all configured ELPA packages.

For each archive configured in the variable package-archives, inform Emacs about the latest versions of all packages it offers, and make them available for download.

*Note*: when you try to install something appear an error like says "a package is not found using use package" just run the ~package-refresh-contents~ command and that will get everything fixed up for you.

**** package-initialize
This function initializes Emacsâ *internal record* (elpa packages) of which packages are installed, and then calls [[package-activate-all]].

The optional argument no-activate, if non-nil, causes Emacs to update its record of installed packages without actually making them available.

**** package-activate-all
This function makes the packages available to the current session. The user option ~package-load-list~ specifies which packages to make available; by default, *all installed packages are made available*.

In most cases, you should not need to call ~package-activate-all~, as this *is done automatically during startup*. Simply make sure to put any code that should run before ~package-activate-all~ in the [[The early init file][early init file]], and any code that should run after it in the primary init file.

**** package-delete
Delete package PKG-DESC.

**** package-autoremove
Remove packages that are no longer needed.

Packages that are no more needed by other packages in package-selected-packages and their *dependencies* will be deleted.

**** list-packages
Display a list of packages.

This first fetches the updated list of packages before displaying, unless a prefix argument NO-FETCH is specified.

**** package-upgrade
This command allows you to upgrade packages without using 'list-packages'. A package that comes with the Emacs distribution can only be upgraded after you install, once, a newer version from ELPA via the package-menu displayed by 'list-packages'.

*Note*: when enabled the 'package-install-upgrade-built-in' (nil by default) variable, 'package-install' will include in the list of upgradeable packages those built-in packages (like Eglot and use-package) for which a newer version is available in package archives, and will allow installing those newer versions.

**** package-upgrade-all
This command allows upgrading all packages without any queries.

**** package-recompile
This command and 'package-recompile-all' can be useful if the ".elc" files are out of date (invalid byte code and macros).

*** Desktop-
**** desktop-change-dir
Change to desktop saved in DIRNAME.

**** desktop-revert
Revert to the last loaded desktop.

**** desktop-save
Save the state of Emacs in a desktop file in directory DIRNAME.

**** desktop-read
Read and process the desktop file in directory DIRNAME.

*** Orderless-
**** orderless-regexp
The component is treated as a regexp that must match somewhere in the candidate.

If the component is not a valid regexp, it is ignored.

**** orderless-literal
The component is treated as a literal string that must occur in the candidate.

**** orderless-literal-prefix
The component is treated as a literal string that must occur as a prefix of a candidate.

**** orderless-prefixes
The component is split at word endings and each piece must match at a word boundary in the candidate, occurring in that order.

This is similar to the built-in ~partial-completion~ completion-style. For example, ~re-re~ matches ~query-replace-regexp~, ~recode-region~ and ~magit-remote-list-refs~; ~f-d.t~ matches ~final-draft.txt~.

**** orderless-initialism
Each character of the component should appear as the beginning of a word in the candidate, in order.

This maps ~abc~ to ~\<a.*\<b.*\c~.

**** orderless-flex
The characters of the component should appear in that order in the candidate, but not necessarily consecutively.

This maps ~abc~ to ~a.*b.*c~.

**** orderless-without-literal
The component is a treated as a literal string that must not occur in the candidate.

Nothing is highlighted by this style. This style should not be used directly in ~orderless-matching-styles~ but with a style dispatcher instead. See also the more general style modifier ~orderless-not~.

**** orderless-annotation
This style modifier matches the pattern against the annotation string of the candidate, instead of against the candidate string.

**** orderless-not
This style modifier inverts the pattern, such that candidates pass which do not match the pattern.

*** Misc-
**** custom-reevaluate-setting
Reset the value of SYMBOL by re-evaluating its saved or standard value.

*Note*: "saved or standard value". In that order of precedence. If the user has customized and saved a value for the variable, this function resets it to its saved-value, not its standard-value.

#+begin_src emacs-lisp

  (custom-reevaluate-setting 'emms-player-next-function)

#+end_src

**** delete-trailing-whitespace
Delete trailing whitespace between START and END.

**** describe-keymap
Describe key bindings in KEYMAP. When called interactively, prompt for a variable that has a keymap value.

If the symbol at point is a keymap, 'describe-keymap' suggests it as the default candidate.

**** set-fringe-style
Set the default appearance of fringes (arrows) on the selected frame.
When called interactively, query the user for MODE; valid values
are âno-fringesâ, âdefaultâ, âleft-onlyâ, âright-onlyâ, âminimalâ
and âhalf-widthâ.

When used in a Lisp program, MODE should be one of these:
- nil, which means the default width (8 pixels).
- a cons cell (LEFT . RIGHT), where LEFT and RIGHT are
  respectively the left and right fringe widths in pixels, or
  nil (meaning the default width).
- a single integer, which specifies the pixel widths of both
  fringes.

**** whitespace-cleanup
Cleanup some blank problems in all buffer or at region.

**** set-register
Set contents of Emacs register named REGISTER to VALUE.  Returns VALUE.

**** toggle-case-fold-search
Toggle whether to ignore letter-case in search commands.

**** global-set-key
Give KEY a global binding as COMMAND.

Global/local set key commands have the added advantage of being able to temporarily bind commands to keys.

**** proced
Generate a listing of UNIX system processes.

This command is like ~top~ or ~ps~.

**** zone
Zone out, completely.

Emacsâs screensaver.

** Variables-
*** Library-
**** load-path
[[Load path][load-path]] is a list of directories to *search* for files to load.

#+begin_src emacs-lisp

  (
   "/home/richard/.emacs.d/elpa/aggressive-indent-20230112.1300"
   "/home/richard/.emacs.d/elpa/all-the-icons-dired-20231207.1324"
   "/home/richard/.emacs.d/elpa/company-box-20240320.921"
   ...
   "/etc/emacs"
   "/usr/local/share/emacs/27.1/site-lisp"
   "/usr/share/emacs/site-lisp/git"
   ...
   "/usr/share/emacs/site-lisp/autoconf"
   "/usr/share/emacs/site-lisp/elpa"
   "/usr/share/emacs/site-lisp/git"
   ...
   "/usr/share/emacs/27.1/lisp/eshell"
   "/usr/share/emacs/27.1/lisp/calendar"
   "/usr/share/emacs/27.1/lisp/calc"
   ...)

#+end_src

**** load-history
Alist mapping *loaded* file names to symbols and features.

Variable ~load-history~ records lots of information about what *libraries have been loaded in your session so far*, what *functions and variables they each *define* (features provided), and what other libraries they *require* (features required).

Standard library [[loadhist.el]] uses the information in ~load-history~ to let you [[unload-feature][unload feature]] things that were added in a library.

In other words, *itâs a gold mine of information about the files, features, functions, and variables that have been loaded* â in particular, about their interrelations.

#+begin_src emacs-lisp

  ;; Example:
  (("/usr/share/emacs/27.1/lisp/thingatpt.elc"
    (provide . thingatpt)
    (t . forward-thing)
    (defun . forward-thing)
    ...)
   ("/usr/share/emacs/27.1/lisp/help-fns.elc"
    (require . cl-lib)
    (require . radix-tree)
    help-fns-describe-function-functions help-fns-describe-variable-functions help-fns-describe-face-functions help-definition-prefixes
    (defun . help--load-prefixes)
    ...)
   ...
   ("/etc/emacs/site-start.d/50cmake-data.el"
    (autoload . cmake-mode))
   ("/etc/emacs/site-start.d/50autoconf.el"
    (autoload . autotest-mode))
   ("/etc/emacs/site-start.d/00debian.el")
   ("/usr/share/emacs/site-lisp/debian-startup.elc"
    (defun . debian-pkg-add-load-path-item)
    (defun . debian-unique-strings)
    ("/usr/share/emacs/27.1/lisp/subdirs.el")
    ...)

#+end_src

**** loadhist.el
Standard library that uses the information in ~load-history~ to let you [[unload-feature][unload feature]] things that were added in a library.

It also provides functions that let you know which library loaded a given function ~feature-symbols~, the features required by a given library ~file-requires~, the (loaded) libraries that require a given library ~file-dependents~, and the features provided by a given library ~file-provides~.

#+begin_src emacs-lisp

  ;; Which library load dired function:
  (feature-symbols 'dired)
  ;; ("/usr/share/emacs/27.1/lisp/dired.elc"
  ;; (require . dired-loaddefs) dired-listing-switches dired-chown-program ...)

  ;; The (loaded) libraries that require a given library:
  ;; (archivos dependientes de dired (INS))
  (file-dependents "dired")
  ;; ("/home/richard/.emacs.d/elpa/counsel-20240520.1323/counsel.elc"
  ;; "/usr/share/emacs/27.1/lisp/doc-view.elc"
  ;; "/usr/share/emacs/27.1/lisp/gnus/message.elc")

  ;; Features required by a given library:
  ;; (archivos requeridos por dired (INS)) (dependencias)
  (file-requires "dired")
  ;; (dired-loaddefs)

  ;;Features provided by a given library:
  (file-provides "dired")
  ;; (dired)


  ;; Which library load counsel function:
  (feature-symbols 'counsel)
  ;; ("/home/richard/.emacs.d/elpa/counsel-20240520.1323/counsel.elc"
  ;; (require . ivy)(require . swiper)(require . compile)(require . dired) ...)

  ;; The (loaded) libraries that require a given library:
  (file-dependents "counsel")
  ;; ("/home/richard/.emacs.d/init.el")

  ;; Features required by a given library:
  (file-requires "counsel")
  ;; (xdg xref dired compile swiper ivy)

  ;;Features provided by a given library:
  (file-provides "counsel")
  ;; (counsel)

#+end_src

**** features
A list of symbols which are the [[Features (provide, require)][features]] of the *executing* Emacs.

*Note* if you run the [[Autoload][autoload]] command ~doctor~ (which was not previously loaded) the new list would look something like this ~(doctor abbrev ace window ... ivy ivy-faces ...)~.

**** package-activated-list
List of the names of *currently* activated packages (packages in [[package-user-dir]]).

**** package-selected-packages
Store here packages installed *explicitly* (via [[Use package][use-package]] or [[Package installation][M-x list-package]]) by user (not dependencies).

*Note*: Useful if you move to a different system and you would like to quickly install all of your previously installed packages.

**** package-user-dir
Directory containing the user's Emacs Lisp packages.

**** package-directory-list
List of additional directories containing Emacs Lisp packages.

**** user-emacs-directory
Directory beneath which additional per-user Emacs-specific files are placed.

*** Files-
**** auto-save-list-file-prefix
Emacs records information about interrupted sessions in files named ~.saves-pid-hostname~~ in the directory ~~/.emacs.d/auto-save-list/~. This directory is determined by the variable ~auto-save-list-file-prefix~. If you set ~auto-save-list-file-prefix~ to ~nil~, sessions are not recorded for recovery.

**** buffer-auto-save-file-name
This buffer-local variable is the name of the file used for auto-saving the current buffer. It is ~nil~ if the buffer should not be auto-saved.

**** backup-directory-alist
Alist of filename patterns and backup directory names.

**** desktop-path
If you turn on ~desktop-save-mode~ in your init file, then when Emacs starts, it looks for a saved desktop in ~desktop-path~ (which defaults to ~user-emacs-directory~ and then your home directory) and uses the first desktop it finds. While Emacs runs with ~desktop-save-mode~ turned on, it by default auto-saves the desktop whenever any of the desktop configuration changes. The variable ~desktop-auto-save-timeout~ determines how frequently Emacs checks for modifications to your desktop. The desktop is also saved when you exit Emacs.

Specify the option ~--no-desktop~ on the Emacs command line when you don't want it to reload any saved desktop configurations. This turns off ~desktop-save-mode~ for the current session. Starting Emacs with the ~--no-init-file~ option also disables desktop reloading, since it bypasses the init file, where ~desktop-save-mode~ is usually turned on.

You can have separate saved desktop configurations in different directories; starting Emacs from a directory where you have a saved desktop configuration will restore that configuration, provided that you customize ~desktop-path~ to prepend ( ~.~ ) (the current directory) to the other directories there. You can save the current desktop and reload the one saved in another directory by typing ~M-x desktop-change-dir~. Typing ~M-x desktop-revert~ reverts to the previously reloaded desktop.

**** desktop-globals-to-save
List of global variables saved by desktop-save.

**** create-lockfiles
When you make the first modification in an Emacs buffer that is visiting a file, Emacs records that the file is /locked/ by you. (It does this by creating a specially-named symbolic link (~.#*~) with special contents in the same directory). Emacs removes the lock when you save the changes. The idea is that the file is locked whenever an Emacs buffer visiting it has unsaved changes.

You can prevent the creation of lock files by setting the variable ~create-lockfiles~ to ~nil~.

*Caution*: by doing so you will lose the benefits that this feature provides. You can also control where lock files are written by using the ~lock-file-name-transforms~ variable.

**** interpreter-mode-alist
Alist mapping interpreter names to major modes.

#+begin_src emacs-lisp

  ("emacs" . emacs-lisp-mode)

#+end_src

**** auto-mode-alist
Alist of filename patterns vs corresponding major mode functions.

When Emacs visits a file, it automatically selects a major mode for the buffer based on information in the file name or in the file itself. It also processes local variables specified in the file text.

#+begin_src emacs-lisp

  ("\\.el\\'" . emacs-lisp-mode)
  ("\\.js[mx]?\\'" . javascript-mode)

#+end_src

*** Lsp-
**** lsp-ui-sideline-enable
Whether or not to enable âlsp-ui-sidelineâ.

The info line at the end.

**** lsp mode toggle
Whenever you have a buffer width that's kind of narrow things get jammed up together with the code and it starts to get a little bit distracting so i tend to allow only minimal information there if at all. You can toggle this on and off using =C-c l T= and then some toggle code action.

*** Org-
**** org-structure-template-alist
An alist of keys and block types.

~org-insert-structure-template~ will display a menu with this list of templates to choose from.  The block type is inserted, with ~#+BEGIN_~ and ~#+END_~ added automatically.

**** org-hide-emphasis-markers
Non-nil mean font-lock should hide the emphasis marker characters.

*** Text-
**** repeat-exit-timeout
To break the repetition chain in repeat-mode automatically after some amount of idle time: customize the user option ~repeat-exit-timeout~ to specify the idle time in seconds after which this transient repetition mode will be turned off automatically.

**** describe-repeat-maps
It's not a variable is a function that show the commands that support repetition in ~repeat-mode~.

**** repeat-exit-key
Typing any key other than those defined to repeat the previous command exits the transient repeating mode, and then the key you typed is executed normally. You can also define a key which will exit the transient repeating mode /without/ executing the key which caused the exit. To this end, customize the user option ~repeat-exit-key~ to name a key; one natural value is ~RET~.

*** Misc
**** global-minor-modes
This variable holds a list of currently enabled global minor modes (as a list of symbols). A list of the currently enabled global minor modes.

**** local-minor-modes
This permanently buffer-local variable holds a list of currently enabled non-global minor modes in the current buffer (as a list of symbols).

**** major-mode-remap-alist
Specifies the favorite major modes

This user option lets you remap the default modes (e.g. 'perl-mode' or 'latex-mode') to your favorite ones (e.g. 'cperl-mode' or 'LaTeX-mode') instead of having to use 'defalias', which can have undesirable side effects. This applies to all modes specified via 'auto-mode-alist', file-local variables, etc.

** Modes-
*** multiple-cursors-
**** mc/mark-next-like-this
Find and mark the next part of the buffer matching the currently active region
If no region is active add a cursor on the next line.

**** mc/mark-previous-like-this
Find and mark the previous part of the buffer matching the currently active region. If no region is active ,add a cursor on the previous line.

**** mc/mark-all-like-this
Find and mark all parts of the buffer matching the currently active region, while also keeping the current region.

**** mc/edit-lines
When you have an active region that spans multiple lines, the following will add a cursor to each line.

**** mc/mark-next-like-this-word
Adds a cursor and region at the next part of the buffer forwards that matches the current region, if no region is selected it selects the word at the point. (words in the same or following lines)

**** mc/mark-next-word-like-this
Like mc/mark-next-like-this but only for whole words. (just the words in the following lines)

**** mc/mark-all-in-region
Prompts for a string to match in the region, adding cursors to all of them.

**** mc/mark-all-dwim
Tries to be smart about marking everything you want. Can be pressed multiple times.

**** mc/add-cursor-on-click
Add a cursor where you click, or remove a fake cursor that is already there (~C-S-<mouse-1>~).

**** mc/mark-more-like-this-extended
Use arrow keys to quickly mark/skip next/previous occurrences.

**** mc/insert-numbers
Insert increasing numbers for each cursor, top to bottom.

**** mc/insert-letters
Insert increasing letters for each cursor, top to bottom.

**** set-rectangular-region-anchor
Think of this one as `set-mark` except you're marking a rectangular region. It is an exceedingly quick way of adding multiple cursors to multiple lines.

**** Notes
- To get out of ~multiple-cursors-mode~, press ~<return>~ or ~C-g~. The latter will first *disable multiple regions before disabling multiple cursors*. If you want to insert a newline in ~multiple-cursors-mode~, use ~C-j~.

- Sometimes you end up with cursors outside of your view. You can scroll the screen to center on each cursor with ~C-v~ and ~M-v~ or you can press ~C-'~ to hide all lines without a cursor, press ~C-'~ again to unhide.

- If you get out of ~multiple-cursors-mode~ and yank - it will yank only from the ~kill-ring~ of main cursor. To yank from the ~kill-rings~ of every cursor use ~yank-rectangle~, normally found at ~C-x r y~.

- It is possible to set multiple-cursors to "run-for-all" for every command except for those that are listed in ~mc/cmds-to-run-once~. To enable this set ~mc/always-run-for-all~ to non-nil. Add commands to be run once to ~mc/cmds-to-run-once~ in ".mc-lists.el".

  Multiple-cursors uses two lists of commands to know what to do: the run-once list and the run-for-all list. It comes with a set of defaults, but it would be beyond silly to try and include all the known Emacs commands.

  So that's why multiple-cursors occasionally asks what to do about a command. It will then remember your choice by saving it in ~~/.emacs.d/.mc-lists.el~. You can change the location with:

  ~(setq mc/list-file "/my/preferred/file")~

  NB! Make sure to do so before requiring multiple-cursors.

- Redo might screw with your cursors. Undo works very well.

*** yas-global-
**** M-x yas-expand
Try to expand snippets before point.  In `yas-minor-mode', this is normally bound to TAB, but you can customize it in `yas-minor-mode-map'.

**** M-x yas-insert-snippet
Prompts you for possible snippet expansion if that is possible according to buffer-local and snippet-local expansion conditions.  With prefix argument, ignore these conditions.

**** M-x yas-visit-snippet-file
Prompts you for possible snippet expansions like `yas-insert-snippet', but instead of expanding it, takes you directly to the snippet definition's file, if it exists.

**** M-x yas-load-directory
Prompts you for a directory hierarchy of snippets to load.

**** M-x yas-load-snippet-buffer
When editing a snippet, this loads the snippet.  This is bound to "C-c C-c" while in the `snippet-mode' editing mode.

**** M-x yas-tryout-snippet
When editing a snippet, this opens a new empty buffer, sets it to the appropriate major mode and inserts the snippet there, so you can see what it looks like.  This is bound to "C-c C-t" while in `snippet-mode'.

**** M-x yas-describe-tables
Lists known snippets in a separate buffer.  User is prompted as to whether only the currently active tables are to be displayed, or all the tables for all major modes.

**** M-x yas-activate-extra-mode
Prompts you for an extra mode to add snippets for in the current buffer.

**** M-x yas-new-snippet
Lets you create a new snippet file in the correct subdirectory of `yas-snippet-dirs', according to the active major mode.

*** misc-
**** xref-etags-mode
Minor mode to make xref use etags again.

Some major modes install ~xref~ support facilities that might sometimes fail to find certain identifiers. For example, in Emacs Lisp mode =M-.= will by default find only functions and variables from Lisp packages which are loaded into the current Emacs session or are [[Autoload][auto-loaded]]. If =M-.= fails to find some identifiers, you can try forcing ~xref~ to use the ~etags~ backend. To this end, turn on the Xref Etags minor mode with ~M-x xref-etags-mode~, then invoke =M-.= again. (For this to work, be sure to run etags to create the tags table in the directory tree of the source files.)

The ~etags~ program is used to create a tags table file. It knows the syntax of several languages. Here is how to run etags:

#+begin_src sh

  etags inputfilesâ¦

#+end_src

The ~etags~ program reads the specified files, and writes a tags table named ~TAGS~ in the current working directory.
**** hl-line-mode
Toggle highlighting of the current line (Hl-Line mode).

* Subjects
** LSP
*** Background
To implement support for language features in a code editor, for example VS Code, we found three common problems:

First, Language Servers are usually implemented in their native programming languages, and that presents a challenge in integrating them with VS Code, which has a Node.js runtime.

Additionally, language features can be resource intensive. For example, to correctly validate a file, Language Server needs to parse a large amount of files, build up Abstract Syntax Trees for them and perform static program analysis. Those operations could incur significant CPU and memory usage and we need to ensure that VS Code's performance remains unaffected.

Finally, integrating multiple language toolings with multiple code editors could involve significant effort. From language toolings' perspective, they need to adapt to code editors with different APIs. From code editors' perspective, they cannot expect any uniform API from language toolings. This makes implementing language support for M languages in N code editors the work of M * N.

To solve those problems, Microsoft specified Language Server Protocol, which standardizes the communication between language tooling and code editor. This way, Language Servers can be implemented in any language and run in their own process to avoid performance cost, as they communicate with the code editor through the Language Server Protocol. Furthermore, any LSP-compliant language toolings can integrate with multiple LSP-compliant code editors, and any LSP-compliant code editors can easily pick up multiple LSP-compliant language toolings. LSP is a win for both language tooling providers and code editor vendors!

*** Technical overview
Programmatic Language Features is a set of smart-editing features powered by the ~vscode.languages.*~ API.

Let's take Hover as an example:

#+begin_src javascript

  vscode.languages.registerHoverProvider('javascript', {
      provideHover(document, position, token) {
          return {
              contents: ['Hover Content']
          };
      }
  });

#+end_src

The ~vscode.languages.registerHoverProvider~ API provides an easy way to provide hover contents to JavaScript files. After this extension gets activated, whenever you hover over some JavaScript code, VS Code queries all ~HoverProvider~ for JavaScript and shows the result in a Hover widget.

An alternative approach is to implement a Language Server that speaks Language Server Protocol. The way it works is:

1. An extension provides a Language Client and a Language Server for JavaScript.
2. The Language Client is like any other VS Code extension, running in the Node.js Extension Host context. When it gets activated, it spawns the Language Server in another process and communicates with it through Language Server Protocol.
3. You hover over JavaScript code in VS Code
4. VS Code informs the Language Client of the hover
5. The Language Client queries the Language Server for a hover result and sends it back to VS Code
6. VS Code displays the hover result in a Hover widget

The process seems more complicated, but it provides two major benefits:

- The Language Server can be written in any language
- The Language Server can be reused to provide smart editing features for multiple editors

*Libraries for the client and server*
The actual integration of a language server into a particular tool is not defined by the language server protocol and is left to the tool implementors. Some tools integrate language servers generically by having an extension that can start and talk to any kind of language server. Others, like VS Code, create a custom extension per language server, so that an extension is still able to provide some custom language features.

*To simplify the implementation of language servers and clients, there are libraries or SDKs for the client and server parts*. These libraries are provided for different languages. For example, there is a *language client npm module* (npm i vscode-languageclient) to ease the integration of a language server into a VS Code extension and another *language server npm module* (npm i vscode-languageserver) to write a language server using Node.js.

*Note*: *Eglot* relays the diagnostics information received from the LSP server to Emacs's *Flymake*, which annotates/underlines the problematic parts of the buffer. The information is shared with the *ElDoc* system, meaning that the commands ~eldoc~ and ~eldoc-doc-buffer~ show diagnostics along with other documentation under point.

*** Emacs role as a client
As of 2020, Emacs is at least 35 years old; it had coding features way before LSP was a thing, through elisp packages. Keeping only currently popular implementations:

- *completion* is brought by ~company~
- *syntax/error* checking is brought by ~flycheck~ or ~flymake~
- *jumping to definitions* is brought by ~xref~
- displaying symbol *documentation* on point (under the cursor) is brought by ~eldoc~
- *syntax highlighting* is brought by ~Font Lock~.

All those packages use data sources that are defined on a case by case basis; for example, ~elpy-company-backend~ is a source that uses Jedi to bring python completions to company

As emacs is a âdevelopment toolâ, theoretically emacsâ developers are responsible to handle the client part of the protocol. This means integrating LSP in all the existing packages so that they ask a language server over JSON-RPC for the relevant information as a data source.

Instead of implementing a ~company-lsp~ source, and a ~flycheck-lsp~ source, and a ~xref-lsp~ source etc. that could be out of sync and create a lot of compatibilty issues, complete âLSP clientâ packages exist to act as an abstraction layer between the LSProtocol and the inner emacs packages that need a source.

There are 2 coexisting LSP clients in emacs, *eglot* and *lsp-mode* that provide exactly this :

- convert user intent (âI want completionsâ or âWhat is this symbol ?â) from ~company~, ~xref~ â¦ requests into JSON-RPC messages
- send and receive LSProtocol messages**
- dispatch the received messages to the relevant âsourceâ so that other packages seamlessly use language servers as a source

*** Eglot performance
1. Select and install a language server.
2. Visit the file you want to work on (e.g. ~~/projects/fooey/lib/x.foo~).
3. Turn on Eglot for your project (~M-x eglot~).
4. Eglot uses Emacsâs project management infrastructure to figure out which files and buffers belong to what project. When Eglot starts a server program, it does so in the projectâs root directory, which is usually the top-level directory of the projectâs directory hierarchy. For example, if you visit the file ~~/projects/fooey/lib/x.foo~ and ~x.foo~ belongs to a project rooted at ~~/projects/fooey~ (perhaps because a .git directory exists there), then ~M-x eglot~ causes the language server configured for the programming language of that buffer to start with that root as the current working directory. The server then will analyze not only the file ~lib/x.foo~ you visited, but likely also all the other ~*.foo~ files under the ~~/projects/fooey~ directory.
5. For each buffer in which Eglot is active, it notifies the language server that Eglot is managing the file visited by that buffer. This tells the language server that the fileâs contents on disk may no longer be up-to-date due to unsaved edits. Eglot reports to the server any changes in the text of each managed buffer, to make the server aware of unsaved changes. Killing a buffer relinquishes its management by Eglot and notifies the server that the file on disk is up-to-date.
6. Eglot turns on a special minor mode in each buffer it manages. This minor mode ensures the server is notified about files Eglot manages, and also arranges for other Emacs features supported by Eglot (this activation of the minor mode is what ensures Eglot that it has to follow the buffer changes and not the disk file).
7. Use Eglot. Most Eglot facilities are integrated into Emacs features, such as ElDoc, Flymake, Xref, and Imenu. However, Eglot also provides commands of its own, mainly to perform tasks by the language server, such as ~M-x eglot-rename~ (to rename an identifier across the entire project), ~M-x eglot-format~ (to reformat and reindent code), and some others.

*** Example of lsp-mode server configurations
**** Setting up C++
By default, ~lsp-mode~ will look for the ~clangd~ executable on the path. ~Clangd~ can be downloaded with ~pacman -S clang~ on Arch.

**** Setting up Python
LSP-mode supports 5 different Python language servers. You can install, for example, ~pyright~ globally with ~pip~, ~npm~, or your systemâs package manager. Also you need a thin layer of extra client, ~lsp-pyright~, to sit atop ~lsp-mode~ and leverage ~pyright~ âs features.

#+begin_src emacs-lisp

  ;; Example python configuration:
  (use-package lsp-pyright
    :hook (python-mode . (lambda () (require 'lsp-pyright)))
    :init (when (executable-find "python3")
            (setq lsp-pyright-python-executable-cmd "python3")))

#+end_src

**** Setting up JavaScript
The recommended language server for JavaScript (and TypeScript) is the conveniently-named ~typescript-language-server~ (or ~ts-ls~ for short), which is a wrapper around Visual Studio Codeâs tsserver.

Since ~lsp-mode~ has ~ts-ls~ support integrated by default, *thereâs no need to install an additional thin layer of client on top of ~lsp-mode~. However, we do need to install the language server on our system. We can install it globally with ~npm~:

#+begin_src sh

  npm install -g typescript-language-server

#+end_src

*Note*: the vscode-langservers-extracted is a thin client layer that help to connect/work to language servers, like vscode-css-language-server, vscode-eslint-language-server, vscode-html-language-server,... (IDK)

**** Setting up Java
The go-to language server for Java is Eclipseâs JDT Language Server. We need yet another thin layer of a client called ~lsp-java~ to help leverage ~lsp-mode~ and the ~JDT~ server. The good news is once you have ~lsp-java~ installed in Emacs through ~use-package~, the client will âautomatically detect whether the server is missing and download Eclipse JDT Language Server before the first startupâ!

#+begin_src emacs-lisp

  (use-package lsp-java
    :after lsp)

#+end_src

*** lsp-mode notes
- The highest number is highest priority (20 highest -20 lowest (INS)). Note this is the opposite of Unix priority (niceness). Servers defined in ~lsp-mode~ tend to have lower priority than the external packages (priority 0 if unspecified). If a server is registered with :add-on? flag set to t it will be started in parallel to the other servers that are registered for the current mode. If the server that you want to use is not with the highest priority you may use ~lsp-disabled-clients~ to disable the server with higher priority or use ~lsp-enabled-clients~ to enable only the servers you want to use. In order to find the server ids you may check ~*lsp-log*~ buffer.

- Refer to ~lsp--formatting-indent-alist~ to find out what is the variable that is used for the current major mode.

- Some language servers, e.g. for C++, Java, etc, can format code as you type and the formatting is triggered when the corresponding character is pressed(typically, ~}~ , ~RET~). This behaviour is controlled via ~lsp-enable-on-type-formatting~ and it is enabled by default.

- Look for ~lsp-mode~ variable to customize *server path*. Usually, you may find the variable by doing: ~M-x customize-group~ =RET= ~lsp-LANGUAGE-SERVER-ID~.

- ~lsp-deferred~ will wait until the buffer is visible before invoking lsp.
This avoids overloading the server with many files when starting Emacs. Useful when setting a ~:hook (js-mode . lsp-deferred)~ hook this way when cycling through buffers, and there are ~js~ files, then ~lsp-mode~ will not triggered on every ~js~ file, it will only turn on when the buffer is open.

*** Miscellaneous
**** Flycheck uses local dir variables
https://www.flycheck.org/en/latest/user/syntax-checkers.html

Flycheck uses js-jshint instead of js-eslint.

We recommend to set flycheck-checker via directory local variables to enforce a specific syntax checker for a project. For instance, Flycheck usually prefers javascript-eslint for Javascript buffers, but if your project uses javascript-jshint instead you can tell Flycheck to use javascript-jshint for all Javascript buffers of your project with the following command in the top-level directory of your project: M-x add-dir-local-variable RET js-mode RET flycheck-checker RET javascript-jshint. A new buffer pops up that shows the newly created entry in the directory variables. Save this buffer and kill it. From now on Flycheck will check all Javascript files of this project with JSHint.

**** ts-lit-plugin
https://www.reddit.com/r/neovim/comments/y62tr4/javascript_lit_html_syntax_highlighting_ts/
Javascript Lit HTML syntax highlighting. (TS Injection)

I have been trying to develop web components under neovim.

So far thanks to [[https://github.com/runem/lit-analyzer/tree/master/packages/ts-lit-plugin][ts-lit-plugin]] LSP started working.

I still have one big major problem. Treesitter can not figure out${(x) => x.disabled && disabled}. It should be highlighted with JS.

This correctly works on Vscode via [[https://github.com/runem/lit-analyzer/tree/master/packages/vscode-lit-plugin][vscode-lit-plugin]].

**** Packages about js, eslint, npm, lit, ...
***** add-node-modules-path
This file provides ~add-node-modules-path~, which runs ~npm bin~ and
and adds the path to the buffer local ~exec-path~.
This allows Emacs to find project based installs of e.g. ~eslint~.

***** Eslint-RC
eslint-rc is a function that searches for local rc rules and eslintignore rules per project and use it to format the current buffer using eslint. The package also exports a minor mode that applies ~(eslint-rc)~ on save.

***** code-tag
https://github.com/fregante/code-tag
noop functions to help formatters and syntax highlighters recognize embedded code

When embedding other languages in JavaScript, you can mark those strings with a tag function to help JavaScript tools recognize the string as code:

#+begin_src javascript

  document.body.innerHTML = html`
          <p>This is inline HTML</p>
          <!-- Including comments -->
          <style>.and {css: 'too'}</style>
  `;

#+end_src

**** IDE (Daniel)
I don't used an IDE, but I have Emacs, which does most of the things I want. I can navigate through code (even code outside the project). It warns me of syntax errors. I can navigate to files in the project, and look for text inside (helm-git-grep).
I do the debugging outside Emacs: in Python, through ipdb.

Option 1, the âcheapâ but good enough option:
- helm-git-grep (with helm, of course), and just typing a few letters of where I want to go. For instance, if I want to go to where a function is defined, I type âname defâ (or âdef nameâ or âname dâ or âf.nameâ or âf naâ, â¦ Helm does fuzzy matching and finds it)
- for syntax errors: flymake

Option 2, elegant one:
-  and eglot (already integrated into the latest Emacs).  I have a call like (add-hook 'python-mode-hook 'eglot-ensure)  in .emacs, and it enables many features, like going to definition with M-. (and back, with M-,). You need a lsp server, e.g. pyls for Python, ccls for C, etc.

Projectile:
Is a project interaction library for Emacs. Its goal is to provide a nice set of features operating on a project level without introducing external dependencies (when feasible). This library provides easy project management and navigation.

debugging "console.log" ...
Python has a REPL (look this up) where you can run interactive commands. There are JavaScript REPL tools too, e.g. I used the node.js one.
The interesting trick is that in the middle of a program you can invoke the REPL shell. So it stops there (at any point you want) and you can type commands to inspect the variables or even to change them.
And you get extra commands, like ânextâ to execute the next line, âcontâ to stop debugging, âwhereâ to see the stack, âlistâ to see the code, etc.
And autocompletion etc.
To do that, you just insert this line in a Python program: from ipdb import set_trace; set_trace()

** Debugging
*** User interface
The following diagram shows the main components of the debugging user interface:

- Run and Debug view :: displays all information related to running, debugging, and managing debug configuration settings.
- Debug toolbar :: has buttons for the most common debugging actions.
- Debug console :: enables viewing and interacting with the output of your code running in the debugger.
- Debug sidebar :: during a debug session, lets you interact with the call stack, breakpoints, variables, and watch variables.

*** Start debugging
https://code.visualstudio.com/docs/editor/debugging

*** Launch configurations
Creating a launch configuration file is beneficial because it allows you to configure and save debugging setup details. VS Code keeps debugging configuration information in a ~launch.json~ file located in a ~.vscode~ folder in your workspace (project root folder) or in your user settings or workspace settings.

*** Debug actions

- Continue / Pause :: resume normal program/script execution (up to the next breakpoint) / inspect code executing at the current line and debug line-by-line.

- Step Over :: execute the next method as a single command without inspecting or following its component steps.

- Step Into :: enter the next method to follow its execution line-by-line.

- Step Out :: when inside a method or subroutine, return to the earlier execution context by completing remaining lines of the current method as though it were a single command.

- Restart :: terminate the current program execution and start debugging again using the current run configuration.

- Stop :: terminate the current program execution.

*** Breakpoints
**** Conditional breakpoints
A powerful VS Code debugging feature is the ability to set conditions based on expressions, hit counts, or a combination of both.

- Expression condition :: the breakpoint will be hit whenever the expression evaluates to true
- Hit count :: the hit count controls how many times a breakpoint needs to be hit before it interrupts execution. Whether a hit count is respected, and the exact syntax of the expression, can vary among debugger extensions.

**** Triggered breakpoints
Is a breakpoint that is automatically enabled once another breakpoint is hit. They can be very useful when diagnosing failure cases in code that happen only after a certain precondition.

**** Inline breakpoints
Are only hit when the execution reaches the column associated with the inline breakpoint. This is particularly useful when debugging minified code which contains multiple statements in a single line.

**** Function breakpoints
Instead of placing breakpoints directly in source code, a debugger can support creating breakpoints by specifying a function name. This is useful in situations where source is not available but a function name is known.

**** Data breakpoints
If a debugger supports data breakpoints, they can be set from the context menu in the *VARIABLES* view. The Break on Value Change/Read/Access commands add a data breakpoint that is hit when the value of the underlying variable changes/is read/is accessed.

*** Logpoints
A Logpoint is a variant of a breakpoint that does not "break" into the debugger but instead logs a message to the debug console. Logpoints enable you to inject logging while debugging without modifying the source code. They are especially useful when you're debugging production servers that cannot be paused or stopped. Logpoints can also help you save time by not having to add or remove logging statements in your code.

*** Data inspection
Variables can be inspected in the *VARIABLES* section or by hovering over their source in the editor. Variable values and expression evaluation are relative to the selected stack frame in the *CALL STACK* section.

*** Variable substitution
VS Code makes commonly used paths and other values available as variables and supports variable substitution inside strings in ~launch.json~. For example, ~${workspaceFolder}~ gives the root path of a workspace folder, ~${file}~ the file open in the active editor, and ~${env:Name}~ the environment variable 'Name'.

*** Debug Console REPL
Expressions can be evaluated with the Debug Console REPL (Read-Eval-Print Loop) feature.

Expressions are evaluated after you press =Enter= and the Debug Console REPL shows suggestions as you type. If you need to enter multiple lines, use =Shift+Enter= between the lines and then send all lines for evaluation with =Enter=.

*** dape package
**** Installation
First install ~dape~ package.

Then install the supported debug adapters.

*Javascript - vscode-js-**:
1. Install ~node~
2. Visit https://github.com/microsoft/vscode-js-debug/releases/ and download the asset ~js-debug-dap-<version>.tar.gz~
3. Unpack ~mkdir -p ~/.emacs.d/debug-adapters && tar -xvzf js-debug-dap-<version>.tar.gz -C ~/.emacs.d/debug-adapters~

**** Usage
To begin a debugging session, invoke the ~dape~ command. In the minibuffer prompt, enter a debug adapter configuration name from ~dape-configs~. For example, on ~.js~ files, =Run adapter=: ~js-debug-node~, whrere the path is: ~/home/rich/.emacs.d/var/dap-adapters/js-debug/src/depDeguggerServer.js~.

For complete functionality, make sure to enable ~eldoc-mode~ in your source buffers and ~repeat-mode~ for more pleasant key mappings.

**** Notes
- If the debugger is not running, verify that the path of the file you want to debug matches the one you are entering on the prompt:

#+begin_src emacs-lisp

  :cwd "/home/rich/trials/trial-test/project-name/src" :program "index.js"
  ;; buffer -> /home/rich/trials/trial-test/project-name/src/index.js

#+end_src

- Example ~dape-config~ template for ~debugpy~:

#+begin_src emacs-lisp

  (add-to-list 'dape-configs
               `(debugpy
                 modes (python-ts-mode python-mode)
                 command "python3"
                 command-args ("-m" "debugpy.adapter")
                 :type "executable"
                 :request "launch"
                 :cwd dape-cwd-fn
                 :program dape-find-file-buffer-default))

#+end_src

*** dap-mode package
**** Installation
First install ~dap-mode~ package.

After enabling DAP mode on emacs side follow the language specific settings.

*Installation node debugger*
For easier of setting up vscode extension, you only need call ~dap-node-setup~ (download the vscode extension) after requiring ~dap-node~.

~dap-node~ library is a thin layer between dap-mode (DAP emacs client debugger) and vscode extension (DAP node debugger) (INS).

#+begin_src emacs-lisp

  (require 'dap-node)

#+end_src

~dap-node-setup~
Downloading ms-vscode.node-debug2 to path specified.

~dap-node-debug-program~
The path to the node debugger.

#+begin_src emacs-lisp

  ("node"
   "/home/rich/.emacs.d/var/dap/extensions/vscode
  /ms-vscode.node-debug2/extension/out/src/nodeDebug.js")

#+end_src

**** Configuration
For an auto-configuration enable the ~dap-auto-configure-mode~. You can configure which features from dap-mode do you want with ~dap-auto-configure-features~:

~dap-auto-configure-mode~
Non-nil if Dap-Auto-Configure mode is enabled.

~dap-auto-configure-features~
Windows to auto show on debugging when in dap-ui-auto-configure-mode.

#+begin_src emacs-lisp

  (sessions locals breakpoints expressions controls tooltip)

#+end_src

**** Usage
The main entry points are ~dap-debug~ and ~dap-debug-edit-template~. The first one asks for a registered debug template and starts the configuration using the default values for that particular configuration. The latter creates a debug template which could be customized before running. ~dap-debug-edit-template~ will prepare a template declaration inside a temporary buffer. You should execute this code using =C-M-x= for the changes to apply. You should also copy this code into your Emacs configuration if you wish to make it persistent.

To usage on node, run ~dap-debug~ or ~dap-debug-edit-template~ and select the node template. For additional documentation on the supported template parameters or about different configuration templates refer to Nodejs Debugging.

~dap-debug~
Run debug configuration DEBUG-ARGS.

~dap-debug-edit-template~
Edit registered template DEBUG-ARGS.

~dap-mode~
Global minor mode for DAP mode.

~dap-ui-mode~ ...

**** Notes/errors
- The ~dap-debug~ command throws the following error:

#+begin_src emacs-lisp

  â Warning (emacs): Initialize request failed: Attribute 'program' is not absolute ('{path}'); consider adding '${workspaceFolder}/' as a prefix to make it absolute.

#+end_src

So to fix it, use this command ~dap-debug-edit-template~ and set configure this template, changing only the value of the ~program~ attribute:

#+begin_src emacs-lisp

  ;; Eval Buffer with `M-x eval-buffer' to register the newly created template.
  (dap-register-debug-template
   "Node::Run"
   (list :type "node"
         :cwd nil
         :request "launch"
         :program "${workspaceFolder}/index.js"
         :name "Node::Run"))

#+end_src

-The  ~dap-debug-template-configurations~ variable is a plist Template configurations for DEBUG/RUN.

#+begin_src emacs-lisp

  (("Firefox Run Configuration" :type "firefox" :cwd nil
    :request "launch" :file nil :reAttach t :program nil
    :name "Firefox::Run"))

#+end_src

** Tasks runners
*** Brief
Lots of tools exist to automate tasks like linting, building, packaging, testing, or deploying software systems. Examples include the TypeScript Compiler, linters like ESLint and TSLint as well as build systems like Make, Ant, Gulp, Jake, Rake, and MSBuild.

These tools are mostly run from the command line and automate jobs inside and outside the inner software development loop (edit, compile, test, and debug). Given their importance in the development life cycle, it is helpful to be able to run tools and analyze their results from within VS Code. Tasks in VS Code can be configured to run scripts and start processes so that many of these existing tools can be used from within VS Code without having to enter a command line or write new code. Workspace or folder specific tasks are configured from the ~tasks.json~ file in the ~.vscode~ folder for a workspace.

*** Prodigy
**** Brief
Is a manage external services from within Emacs.

Start prodigy with ~M-x prodigy~. You should see a list of all defined services.

**** Add services
Services can be defined in a few different ways. See ~doc-string~ for information about available properties to specify: ~M-x describe-variable RET prodigy-services~.

Services can be defined using the function ~prodigy-define-service~ or can be defined by setting the variable ~prodigy-services~:

#+begin_src emacs-lisp

  ;; Funciton prodigy-define-service (&rest args):
  (prodigy-define-service :prop value ...)

  ;; Variable prodigy-services:
  (setq prodigy-services
        '((:prop value ...)
          (:prop value ...)))

#+end_src

*Note*: unlike the ~prodigy-define-service~ function, when setting properties to ~prodigy-services~ some values ââmust omit the single quote ( ~'~ ). For example:

#+begin_src emacs-lisp

  ;; In the function it works.:
  (prodigy-define-service :tags '(work) ...)

  ;; In the variable it doesn't work, it should be omitted:
  (setq prodigy-services '((:tags (work) ...)))     ; it work
  ;; (setq prodigy-services '((:tags '(work) ...))) ; it doesn't work

#+end_src

**** Remove services
To remove a service, just delete it from the ~prodigy-services~ variable.

To remove all services, just do ~(setq  prodigy-services nil)~.

**** Notes
- In the prodigy window, you can see a process' output with the ~$~ key.

- Pressing ~c~ in the log buffer of a service (thus using ~prodigy-view-mode~) now gives access to all commands accessible in ~prodigy-mode~. This is, for example, useful to restart the service (with =c r=) or to open ~dired~ (with =c j d=) or ~magit~ (with =c j m=) in the directory of the service

- By default the ~rc/create-prodigy-service~ function will use ~npm~. For using ~pnpm~ specify it as follows:

#+begin_src emacs-lisp

  (rc/create-prodigy-service "pnpm")

#+end_src

**** Examples
Nodemon Server

#+begin_src emacs-lisp

  ;; This service starts a Nodemon server on port 6002. The project is
  ;; using NVM, so before the process starts, NVM is set up.
  (prodigy-define-service
    :name "Node app"
    :command "nodemon"
    :cwd "/path/to/my/project"
    :args '("app.coffee")
    :port 6002
    :tags '(work node)
    :init-async (lambda (done)
                  (nvm-use-for "/path/to/my/project" done)))

#+end_src

Python Simple HTTP Server

#+begin_src emacs-lisp

  ;; This service start a Python Simple HTTP Server on port 6001. When
  ;; stopping the service, the sigkill signal is used.
  (prodigy-define-service
    :name "Python app"
    :command "python"
    :args '("-m" "SimpleHTTPServer" "6001")
    :cwd "/path/to/my/project"
    :tags '(work)
    :stop-signal 'sigkill
    :kill-process-buffer-on-stop t)

#+end_src

**** Creating dynamic task runners
Creating dynamic task runners for ~npm~ scripts (Rajasegar Chandran):

#+begin_src emacs-lisp

  (defun rc/create-prodigy-service (&optional package-manager)
    "Create new prodigy services based on current package.json

  To use it, open the package.json file situated in the project
  root folder, and invoke the function."
    (interactive)
    (let ((pkg (json-parse-string (buffer-substring-no-properties
                                   (point-min) (point-max)))))
      (maphash  (lambda (key value)
                  (let ((args '())
                        (name (gethash "name" pkg)))
                    (add-to-list 'args key)
                    (add-to-list 'args "run")
                    (prodigy-define-service
                      :name (concat name "-" key)
                      :command (or package-manager "npm")
                      :cwd (file-name-directory (buffer-file-name))
                      :path (file-name-directory (buffer-file-name))
                      :args args
                      :tags '(temp)
                      :stop-signal 'sigkill
                      :kill-process-buffer-on-stop t
                      ))) (gethash "scripts" pkg))
      (prodigy)
      (prodigy-refresh)))

#+end_src

** Eshell
*** It's a shell
While eshell may look like a shell, like Bash you should view it as a REPL with parenthesis-less s-expressions.

Like a shell, everything is a string except for the first command. Actually don't have to put strings or quotes around this to make it a string.

As a shell:
- Concept of a current directory
- ~popd~, ~pushd~, and ~dirs~
- Globbing Expressions
- Quotes often optional

#+begin_src sh

  #Doesn't this:
  ls -d /tmp
  # look like this =:
  (ls "-d" "/tmp")

#+end_src

*** It's a REPL
Lisp expressions work within parens.

- Unlike shell, EShell:
  - Commands can be executables or Emacs functions
  - Distinguishes strings, numbers, and lists

- EShell is marriage of two syntax parsers:
  - Lisp Expressions (as soon as type in parentheses it's going into lisp parser)
  - Shell Expressions (if remove parentheses it now types it into shell parser)
  - A single line can mix the two!

Without parens, Eshell is in "shell mode", wich means that words are strings, and variables need to be prefixed with dollar signs.

#+begin_src sh

  (+ 8 8)
  # 16
  # or
  + 8 8
  # 16

  # mix two
  - 3 (+ 1 2)
  # 0


  # Parentheses with $
  echo $answer1:$answer2
  # 41:42
  echo $answer1:(+ $answer2 10)
  # Unknown predicate character â+â
  echo $answer1:$(+ answer2 10)
  # 41:52
  echo $answer1:${+ answer2 10} # with {} going to shell mode
  # 41:52

#+end_src

*** Eshellâs parsers
*Lisp* parser:
- ~( ... )~
- ~$( ... )~ â¦ useful for string evaluation

*Shell* parser:
- no parens â¦ in other words, the default
- ~{ ... }~
- ~${ ... }~ â¦ useful for string evaluation
- reference variables with ~$~

#+begin_src sh

  setq ANSWER 42   # â Normal Emacs variable
  # 42

  numberp ANSWER  # â Use  to get value.
  # t

  setq UNANSWER "41"
  # 41

  stringp UNANSWER
  # t

  mod ANSWER 5    # â Forgot the  with shell parser
  # Wrong type argument: number-or-marker-p, "ANSWER"

  mod ANSWER 5   # â Math without expr
  # 2

  (mod ANSWER 5)  # â Lisp doesn't need  for vars
  # 2

  (mod ANSWER 5)
  # Symbol's value as variable is void: ANSWER

  echo UNANSWER:ANSWER
  # 41:42

  echo UNANSWER:(mod ANSWER 5)
  # Malformed modification time modifier `m'

  echo UNANSWER:(mod ANSWER 5)
  # 41:2

  echo ANSWER:{mod ANSWER 5}
  # 42:2

#+end_src

*** Subshell rules
- with ~(...)~ , eshell treats it as Lisp-expressions.
- with ~{...}~ , eshell follows these shell-like rules:
  - looks like a number, it's a number
  - otherwise, converted to string (quotes, like in shells, grops words)
  - what about functions and executables?
    - first, fuctions start with ~eshell/~
    - next are executables orn your ~$PATH~
    - then matching Lidp functions
    - you can switch this order (see ~eshell-prefer-lisp-funcitons~ variable)

Shells can call subshells which return their outputlike a function call.

#+begin_src sh

  # This bash command, you can have a subshell:
  $(cat files.txt)
  # is the same as:
  { cat files.txt }

#+end_src

*** Wildcard and globbinâ filters
The wildcard actually crates a list.

#+begin_src sh

  touch 'English.org Shell.org init.org'

  ls *.org
  # English.org  Shell.org  init.org

  echo *.org
  # ("English.org" "Shell.org" "init.org")

  length *.org
  # 3

#+end_src

*Globbinâ Filters*:
- The ~*~ glob-thing has filters
- Great if you can remember the syntax:
  - ~.~ for files
  - ~/~ for directories
  - ~r~ if readable
  - ~w~ if writable
  - ~L~ filtering based on file size
  - ~m~ filtering on modification time
- The filters can be stacked, e.g. . ~L~

  ~C-c M-q~ ( ~eshell-display-predicate-help~ )

#+begin_src sh

  ls *(.)
  # README  and go.py  pi.py  pi.rb

  ls *(^/)   # â Inverse of directories are often files
  # README  and go.py  pi.py  pi.rb


#+end_src

Demonstrate combining modifiers by listing all files with more than 50 bytes to them:

#+begin_src sh

  ls *(.L+50)
  # README  pi.py

#+end_src

After creating three files (using the ~touch~ executable), we can list all empty files (that is, those that have less than 1 byte):

#+begin_src sh

  ls *(L-1)
  # and go.py  goo.py  grip.py  swam.py

#+end_src

Or those modified less than 40 seconds ago:

#+begin_src sh

  ls *(.ms-40)
  # README  and go.py  goo.py  grip.py  pi.py  pi.rb  src  swam.py  tests


#+end_src

Modified after we modified ~goo.py~:

#+begin_src sh

  ls *(.m-'goo.py')
  # grip.py  swam.py

#+end_src

And before we modified ~goo.py~:

#+begin_src sh

  ls *(.m+'goo.py')
  # README  and go.py  pi.py  pi.rb

#+end_src

I can get a list of my journal entries larger than 5000 bytes, and open ~dired~ showing only those files:

#+begin_src sh

  dired ~/journal/2017*(L+5000)

#+end_src

*** Set variable eshell
~Setq~ to create variable, those are global Emacs variables available everywhere.
This variable asssignment doesn't work as you might expect, as ~setq~ in Eshell is still ~setq~, and it assigns variables in pairs.

*Note*: dollar sign ~$~ of variable does not work within a list.

#+begin_src sh

  setq file text.org
  # text.org
  echo $file
  # text.org


  # The wildcard actually crates a list.
  setq all-org *.org
  # ("English.org" "Shell.org" "init.org")
  echo $all-org
  # ("English.org" "Shell.org" "init.org")


  # To make a list, use listify
  setq some { listify fileA.org fileB.org }
  # ("fileA.org" "fileB.org")


  # Other examples
  setq ANSWER 50
  + ANSWER 49
  # Wrong type argument: number-or-marker-p, "ANSWER"
  + $ANSWER 49
  # 99


  # Parentheses with $
  echo $answer1:$answer2
  # 41:42
  echo $answer1:(+ $answer2 10)
  # Unknown predicate character â+â
  echo $answer1:$(+ answer2 10)
  # 41:52
  echo $answer1:${+ answer2 10} # with {} going to shell mode
  # 41:52

#+end_src

*** Shell-like Loops
- Syntactic sugar around ~loop~.
- Code following ~in~ is a generate list
- Use trailing ~{ ... }~ for side-effects

#+begin_src sh

  for i in A B C; do echo $i; done
  # do: command not found
  # done: command not found


  for i in A B C { echo "Hello $i" }
  # Hello A
  # Hello B
  # Hello C


  for i in A B C { echo Hello $i }
  # ("Hello" "A")
  # ("Hello" "B")
  # ("Hello" "C")


  # A list can be generated in any way, like with Lisp:
  for N in (number-sequence 1 5) { + 10 $N }
  # 11
  # 12
  # 13
  # 14
  # 15

  # You cannot replace the action with a lisp
  for N in (number-sequence 1 5) ( + 10 $N )
  #
  # but if you put it inside a shell mode then you
  # can run Lisp as the action
  for N in (number-sequence 1 5) {( + 10 $N )}
  # 11
  # 12
  # 13
  # 14
  # 15

#+end_src

*** Write your own functions
Eshell is Emacs: you can write Emacs functions instead shell scripts and other pretty features.

- Functions for Eshell: ~eshell/~
- They do not need to be ~interactive~
- Functions should assume ~&rest~ for arguments:

#+begin_src emacs-lisp

  (defun eshell/do-work (&rest args)
    "Do some work in an optional directory."
    (let ((some-dir (if args
                        (pop args)
                      default-directory)))
      (message "Work in %s" some-dir)))

#+end_src

Using &rest allows your functions to behave more like shell functions:

#+begin_src sh

  do-work
  # Work in /tmp/testing/

  do-work /home/howard/bin
  # Work in /home/howard/bin

#+end_src

*** Function or executable?
What about the executable ~find~ vs. Emacsâ ~find~ function?

*Precedence Order*:
- Eshell aliases
- Emacs functions that being with ~eshell/~ prefix
- Normal Emacs functions (donât need to be ~interactive~)
- Shell executables
- Of course, this is customizable:

~eshell-prefer-lisp-functions~ prefer Lisp functions to external commands
~eshell-prefer-lisp-variables~ prefer Lisp variables to environmentals

To demonstrate the precedence order for eshell commands, I created a script called foobar that simply contains:

#+begin_src sh

  #!/bin/sh
  echo "Called: executable"

#+end_src

Without anything else, this will be called:

#+begin_src sh

  which foobar
  # /home/howard/bin/foobar

  foobar
  # Called: executable

#+end_src

We now create a regular Emacs function in Lisp (notice that it isnât interactive):

#+begin_src emacs-lisp

  (defun foobar ()
    "Called: function")

#+end_src

It now takes precedence over the executable:

#+begin_src sh

  which foobar
  # foobar is a Lisp function

  foobar
  # Called: function

#+end_src

Create another Lisp function, this has the ~eshell/~ prefix. Again, no need to make interactive:

#+begin_src emacs-lisp

  (defun eshell/foobar ()
    "Called: eshell function")

#+end_src

And this new function over-shadows the others:

#+begin_src sh

  which foobar
  # eshell/foobar is a Lisp function

  foobar
  # Called: eshell function

#+end_src

Finally, we define an alias, and demonstrate that it over-shadows all the others:

#+begin_src sh

  alias foobar 'echo "Called: alias"'

  which foobar
  # foobar is an alias, defined as "echo "Called: alias""

  foobar
  # Called: alias

#+end_src

*** Aliases
A common alias for ~ls -l~, and would be defined with the command invocation ~alias ll 'ls -l $*'~ ; with this defined, running ~ll foo~ in Eshell will actually run ~ls -l foo~.

Aliases defined (or deleted) by the alias command are automatically written to the file named by ~eshell-aliases-file~ (this defaults to something like ~~/.emacs.d/eshell/aliases~), which you can also edit directly (although you will have to manually reload it).

Note that unlike aliases in Bash, arguments must be handled explicitly. Typically the alias definition would end in ~$*~ to pass all arguments along. More selective use of arguments via ~$1~, ~$2~, etc., is also possible. For example, alias ~mcd 'mkdir $1 && cd $1'~ would cause ~mcd foo~ to create and switch to a directory called ~foo~.

*Warning*: if this doesn't work and get the error ~command not found~ , remove the quote, e.g. type the command ~alias ll ls -l $*~  instead of ~alias ll 'ls -l $*'~.

*Note*: Example alias from Howard Abrams (Emacs hacker who has a YouTube channel)
~alias ee 'find-file-other-window $1'~

*** Notes
- ~cd =~ list all recent directories, and ~cd -2~ to get to that directory
- ~clear 1~  command that clean eshell
- REPL de Emacs Lisp, permite llamar a las funciones o evaluar comandos de Emacs Lisp directamente desde el shell, incluso puede configurar alias ~alias ffo "find-file-other-window $1"~ y proporciona una manera sencilla de hacer nuestros scripts en elisp en lugar de bash u otros.
- Puede correr comandos en la shell como ~find-file~, ~dired~, ...,  tambiÃ©n correr funciones ~(+ 20 5)~  (presionando /TAB/ se puede completar las funciones).
- Puede usar comandos con pipe para enviar salida a un buffer ~echo "Hello" > #<buffer test-buffer>~ o para adjuntar ~ls >> #<buffer *scratch*>~.
- La sintaxis de la subshell es un poco diferente se utiliza ~${ }~ en vez de ~$( )~.
- Soporta TRAMP (controlar remotamente otra maquina).
- Programas que leen input (como lenguajes REPLs, como por ejemplo "node") y herramientas que dependen de la configuraciÃ³n de los ambientes de shell (nvm, virtualenv) pueden funcionar incorrectamente.
- ~*ls~ (se coloca delante para poderlo usar).
- ~/dev/clip~ and ~/dev/kill~ - you can redirect shell commands to the emacs clipboard and killring
- Eshell pipelines only pipe stdout by default. To pipe both stdout and stderr, use the ~|&~ operator instead of ~|~.

*Warning*:
- Los enlaces duros y simbÃ³licos funcionan diferente a lo esperado. Cuando se modifica el archivo original que tiene un hard link creado con eshell, cambia su valor de ~inode~ .
- Comandos que impliquen opciones que manipulan enlaces simbÃ³licos como ~cp -a dir dirNew~  dan problema.
- No permite crear redirecciones tales como ~cat << Whatever~.

** Mode line
*** Brief
A mode line construct can be either a single string, a single Lisp symbol, or a list. For lists, the first element in the list determines how the list is interpreted. Nesting mode line constructs for recursive processing is very common.

|     | /Input Method and Coding System/                              |
|-----+-------------------------------------------------------------|
| /-/   | No code conversion, except possibly end-of-line translation |
| /'=/  | No code conversion or end-of-line translation               |
| /1/   | ISO Latin 1 code conversion                                 |
| /U/   | Unicode (typically UTF-8)                                   |
|     |                                                             |
|     | /End Of Line/                                                 |
|-----+-------------------------------------------------------------|
| /:/   | (Unix) Line feed - Unix, Linux, MacOS X                     |
| /'//  | (MAC) Carriage return - classic Macintosh (not MacOS X)     |
| /\/   | (DOS) Both - Microsoft, DEC, RFCs                           |
|     |                                                             |
|     | /Buffer Modification/                                         |
|-----+-------------------------------------------------------------|
| /**/  | modified since last save                                    |
| /--/  | not modified since last save                                |
| /%*/  | read-only, but modified                                     |
| /%%/  | read-only, not modified                                     |
|     | /Cursor Position/                                             |
|-----+-------------------------------------------------------------|
| /Top/ | the beginning of the buffer is shown in the window          |
| /Bot/ | the end of the buffer is shown in the window                |
| /All/ | all of the buffer is shown in the window                    |
| /xx%/ | % of the buffer above the top of the window ( visible text) |

*** Single string
A mode line construct can be a single string. When rendered by â ~format-mode-line~ â, this yields the same string, with any ~%-constructs~ replaced with their values. Note that ~%-construct~ replacement in simple strings only happens at the top-level.

#+begin_src emacs-lisp

  (setq example-construct "buffer: %b")
  ;; buffer: *scratch*

#+end_src

*** Single lisp symbol
A mode line construct can be a single Lisp symbol. When rendered, symbols are evaluated for their value. The symbols â ~t~ â and â ~nil~ â are ignored, as are any symbols whose value is void. A symbol whose value is a string is not subject to ~%-construct~ replacement.

#+begin_src emacs-lisp

  (setq example-construct emacs-version)

  (setq mode-line-format nil)
  ;; disable mode line

#+end_src

*** List of constructs
A mode line construct can be a list of mode constructs. Such a list must start with either a string, or another list. When rendered, the list elements(s) are processed recursively as mode line constructs, and the results concatenated into one string. Strings in such a list are subject to ~%-construct~ processing.

#+begin_src emacs-lisp

  (setq example-construct (list "Emacs version: " emacs-version))

#+end_src

*** Field width
A list starting with an integer specifies a field width. The remainder of the list is processed recursively, as above. If the width is positive, the resulting string is space padded on the right to that width as needed. If the width is negative, it is truncated as needed.

#+begin_src emacs-lisp

  ;; FIXME example for positive padded

  ;; limit path display to 70 characters
  (setq example-construct (list -70 "File: %f"))

#+end_src

*** Eval form
A list starting with ~:eval~ causes the rest of the list to be evaluated as a Lisp form, and uses the result as the string to display. If the Lisp evaluation loads any files, it may cause infinite recursion and crash Emacs, so donât do that.

#+begin_src emacs-lisp

  (setq mode-line-format '("%e" "Hello world!"
                           (:eval (format " Buffer: %s" (buffer-name)))))
  ;; Hello world! Buffer: *scratch*

#+end_src

*** Propertize
A list starting with ~:propertize~ will process the second list element as a mode line construct, taking the remaining elements as *text properties to add to the resulting string*.

#+begin_src emacs-lisp

  (setq mode-line-format '("%e" "Hello world!"
                           (:eval (format " Buffer: %s"
                                          (propertize (buffer-name)
                                                      'face 'error)))))
  ;; Hello world! Buffer: *scratch*
  ;; but "*scratch*" in red color

  (setq mode-line-format '("%e" "Hello world!"
                           (:eval (propertize (capitalize
                                               (symbol-name major-mode))
                                              'face 'bold))))
  ;; MODE: Lisp-Interaction-Mode

#+end_src

*** defvar-local
Declares local variables, it is useful to use it in âmode-lineâ to make its construction more comfortable and easier to read.

#+begin_src emacs-lisp

  (defvar-local rf-modeline-buffer '(:eval
                                     (format " Buffer: %s"
                                             (propertize (buffer-name)
                                                         'face 'error)))
    "Mode line construct to display the buffer.")
  (defvar-local rf-modeline-major-mode '(:eval
                                         (propertize
                                          (capitalize
                                           (symbol-name major-mode))
                                          'face 'bold))
    "Mode line construct to display the major mode.")

  (setq-default mode-line-format '("%e" "Hello world!"
                                   (:eval
                                    (format " Buffer: %s"
                                            (propertize (buffer-name)
                                                        'face 'error)))
                                   (:eval
                                    (propertize
                                     (capitalize (symbol-name
                                                  major-mode))
                                     'face 'bold))))
  ;; is equivalent to
  (setq-default mode-line-format '("%e" "Hello world!" rf-modeline-buffer
                                   rf-modeline-major-mode)

#+end_src

*Note* the variable must have a risky local variable property:

#+begin_src emacs-lisp

  (put 'rf-modeline-buffer 'risky-local-variable t)
  ;; or many variable at once in dolist
  (dolist (construct '(rf-modeline-buffer
                       rf-modeline-major-mode))
    (put construct 'risky-local-variable t))

#+end_src

** Draw ASCII
*** artist-mode
Lets you draw ASCII pictures with mouse. Permite dibujar lÃ­neas, cuadrados, rectÃ¡ngulos y polilÃ­neas, elipses y cÃ­rculos con el mouse y/o el teclado en formato AsCii.

- Left mouse button to draw.
- Right mouse button to erase.
- Middle click (mouse-2) to switch to rectangle, ellipse, and other tools.

When *line* is used to create lines, the ~>~ and ~<~ characters can be used to placed arrows.

#+begin_src ditaa :file some_filename.png :cmdline -r -s 0.8

    +-----------+        +---------+
    |    PLC    |        |         |
    |  Network  +<------>+   PLC   +<---=---------+
    |    cRED   |        |  c707   |              |
    +-----------+        +----+----+              |
                              ^                   |
                              |                   |
                              |  +----------------|-----------------+
                              |  |                |                 |
                              v  v                v                 v
      +----------+       +----+--+--+      +-------+---+      +-----+-----+       Windows clients
      |          |       |          |      |           |      |           |      +----+      +----+
      | Database +<----->+  Shared  +<---->+ Executive +<-=-->+ Operator  +<---->|cYEL| . . .|cYEL|
      |   c707   |       |  Memory  |      |   c707    |      | Server    |      |    |      |    |
      +--+----+--+       |{d} cGRE  |      +------+----+      |   c707    |      +----+      +----+
         ^    ^          +----------+             ^           +-------+---+
         |    |                                   |
         |    +--------=--------------------------+
         v
+--------+--------+
|                 |
| Millwide System |            -------- Data ---------
| cBLU            |            --=----- Signals ---=--
+-----------------+

#java -jar ditaaXXX.jar
#java -jar ditaa0_9.jar demo.txt

#+end_src

*** Box drawing unicode

|        | /0/ | /1/ | /2/ | /3/ | /4/ | /5/ | /6/ | /7/ |
|--------+---+---+---+---+---+---+---+---|
| /U+250x/ | â | â | â | â | â | â | â | â |
|--------+---+---+---+---+---+---+---+---|
| /U+251x/ | â | â | â | â | â | â | â | â |
|--------+---+---+---+---+---+---+---+---|
| /U+252x/ | â  | â¡ | â¢ | â£ | â¤ | â¥ | â¦ | â§ |
|--------+---+---+---+---+---+---+---+---|
| /U+253x/ | â° | â± | â² | â³ | â´ | âµ | â¶ | â· |
|--------+---+---+---+---+---+---+---+---|
| /U+254x/ | â | â | â | â | â | â | â | â |
|--------+---+---+---+---+---+---+---+---|
| /U+255x/ | â | â | â | â | â | â | â | â |
|--------+---+---+---+---+---+---+---+---|
| /U+256x/ | â  | â¡ | â¢ | â£ | â¤ | â¥ | â¦ | â§ |
|--------+---+---+---+---+---+---+---+---|
| /U+257x/ | â° | â± | â² | â³ | â´ | âµ | â¶ | â· |

|        | /8/ | /9/ | /A/ | /B/ | /C/ | /D/ | /E/ | /F/ |
|--------+---+---+---+---+---+---+---+---|
| /U+250x/ | â | â | â | â | â | â | â | â |
|--------+---+---+---+---+---+---+---+---|
| /U+251x/ | â | â | â | â | â | â | â | â |
|--------+---+---+---+---+---+---+---+---|
| /U+252x/ | â¨ | â© | âª | â« | â¬ | â­ | â® | â¯ |
|--------+---+---+---+---+---+---+---+---|
| /U+253x/ | â¸ | â¹ | âº | â» | â¼ | â½ | â¾ | â¿ |
|--------+---+---+---+---+---+---+---+---|
| /U+254x/ | â | â | â | â | â | â | â | â |
|--------+---+---+---+---+---+---+---+---|
| /U+255x/ | â | â | â | â | â | â | â | â |
|--------+---+---+---+---+---+---+---+---|
| /U+256x/ | â¨ | â© | âª | â« | â¬ | â­ | â® | â¯ |
|--------+---+---+---+---+---+---+---+---|
| /U+257x/ | â¸ | â¹ | âº | â» | â¼ | â½ | â¾ | â¿ |

*** Geometric shapes

#+begin_src

          0   1   2   3   4   5   6   7
  U+25Ax  â    â¡   â¢   â£   â¤   â¥   â¦   â§
  U+25Bx  â°   â±   â²   â³   â´   âµ   â¶   â·
  U+25Cx  â   â   â   â   â   â   â   â
  U+25Dx  â   â   â   â   â   â   â   â
  U+25Ex  â    â¡   â¢   â£   â¤   â¥   â¦   â§
  U+25Fx  â°   â±   â²   â³   â´   âµ   â¶   â·

          8   9   A   B   C   D   E   F
  U+25Ax  â¨   â©   âª   â«   â¬   â­   â®   â¯
  U+25Bx  â¸   â¹   âº   â»   â¼   â½   â¾   â¿
  U+25Cx  â   â   â   â   â   â   â   â
  U+25Dx  â   â   â   â   â   â   â   â
  U+25Ex  â¨   â©   âª   â«   â¬   â­   â®   â¯
  U+25Fx  â¸   â¹   âº   â»   â¼   â½  â¾  â¿

#+end_src

*** Dingbats

#+begin_src

            0   1   2   3   4   5   6   7
   U+270x   â   â   â   â   â   â  â   â
   U+271x   â   â   â   â   â   â   â   â
   U+272x   â    â¡   â¢   â£   â¤   â¥   â¦   â§
   U+273x   â°   â±   â²   â³   â´   âµ   â¶   â·
   U+274x   â   â   â   â   â   â   â   â
   U+275x   â   â   â   â  â  â  â   â
   U+276x   â    â¡   â¢   â£   â¤   â¥   â¦   â§
   U+277x   â°   â±   â²   â³   â´   âµ   â¶   â·
   U+278x   â   â   â   â   â   â   â   â
   U+279x   â   â   â   â   â   â  â  â
   U+27Ax   â    â¡   â¢   â£   â¤   â¥   â¦   â§
   U+27Bx   â°  â±   â²   â³   â´   âµ   â¶   â·

            8   9   A   B   C   D   E   F
   U+270x   â   â   â  â  â   â   â   â
   U+271x   â   â   â   â   â   â   â   â
   U+272x   â¨  â©   âª   â«   â¬   â­   â®   â¯
   U+273x   â¸   â¹   âº   â»   â¼   â½   â¾   â¿
   U+274x   â   â   â   â   â  â   â  â
   U+275x   â   â   â   â   â   â   â   â
   U+276x   â¨   â©   âª   â«   â¬   â­   â®   â¯
   U+277x   â¸   â¹   âº   â»   â¼   â½   â¾   â¿
   U+278x   â   â   â   â   â   â   â   â
   U+279x   â   â   â   â   â   â   â   â
   U+27Ax   â¨   â©   âª   â«   â¬   â­   â®   â¯
   U+27Bx   â¸   â¹   âº   â»   â¼   â½   â¾   â¿

#+end_src

*** The most common ones
â â â â
â â â â¤
â´ â¬ â¼

* How to
** Init file
*** Initialization
**** Package
Manager for Emacs Lisp packages.

#+begin_src emacs-lisp

  ;; When enabled, 'package-install' will include in the list of
  ;; upgradeable packages those built-in packages (like Eglot and
  ;; use-package) for which a newer version is available in package
  ;; archives, and will allow installing those newer versions:
  (setq package-install-upgrade-built-in t)

#+end_src

**** Startup settings
Emacs start-up settings.

*** Faces
**** Basic faces
The standard faces  for specifying text appearance.
- default :: is used for ordinary text that doesnât specify any face. Its background color is used as the frameâs background color.
- variable-pitch :: forces use of a variable-width (i.e., proportional) font. The font size picked for this face matches the font picked for the default (usually fixed-width) font.
- fixed-pitch :: forces use of a fixed-width font. Itâs reasonable to customize this face to use a different fixed-width font, if you like, but you should not make it a variable-width font.
- shadow :: is used for making the text less noticeable than the surrounding ordinary text. Usually this can be achieved by using shades of gray in contrast with either black or white default foreground color.

#+begin_src emacs-lisp

  ;; Set the default face:
  (set-face-attribute 'default nil :font "Fira Code Retina":height 100)

  ;; Set the variable pitch face:
  (set-face-attribute 'variable-pitch nil :font "Cantarell":height 125)

  ;; Set the fixed pitch face:
  (set-face-attribute 'fixed-pitch nil :font "JetBrains Mono":height 100)

#+end_src

**** Nerd icons faces
Manage how Nerd Font icons are coloured and themed.

#+begin_src emacs-lisp

  ;; Library for easily using Nerd Font icons inside Emacs:
  (use-package nerd-icons)
    ;; :custom
    ;; "Symbols Nerd Font Mono" is the default and is recommended
    ;; (nerd-icons-font-family "JetBrainsMono Nerd Font"))
  ;; This need a Nerd Font installed on your system.
  ;; You can use M-x nerd-icons-install-fonts or install it manually
  ;; to get Symbols Nerd Fonts Mono or another variant of your choice.

#+end_src

**** All the icons faces
Manage how all the icons icons are coloured and themed.

*** Environment
**** Mode line
Contents of the mode line.

#+begin_src emacs-lisp

  ;; Hidden minor modes from the default mode line:
  (defvar hidden-minor-modes
    '(abbrev-mode drag-stuff-mode ivy-mode counsel-mode
                  yas-minor-mode eldoc-mode buffer-face-mode visual-line-mode
                  org-indent-mode which-key-mode help-mode company-mode
                  company-box-mode paredit-mode lsp-lens-mode skewer-css-mode
                  skewer-html-mode skewer-mode projectile-mode))

  (defun se/purge-minor-modes ()
    (interactive)
    (dolist (minor-mode hidden-minor-modes)
      (let ((show-string (cdr (assoc minor-mode minor-mode-alist))))
        (when show-string
          (setcar show-string "")))))

  (add-hook 'after-change-major-mode-hook 'se/purge-minor-modes)


  ;; This is another way to hide the modes in modeline by Mickey
  ;; Petersen, but first need to define the loop function.
  ;; Hiding and replacing modeline strings (Mickey Petersen)
  (defvar mode-line-cleaner-alist
    `((abbrev-mode . " Î±")
      (drag-stuff-mode . " Î´Ï")
      (ivy-mode . " Î¹")
      (counsel-mode . " Ï")
      (yas-minor-mode . " ÏÎ¼")
      (eldoc-mode . " Îµ")
      (buffer-face-mode . " Î²Ï")
      (visual-line-mode . " ÏÎ»")
      (org-indent-mode . " Î¿Î¹")
      (which-key-mode . " ÏÎº")
      (help-mode . " Î·")
      (company-mode . " ÏÎ±")
      (company-box-mode . " ÏÎ±Î²")
      (paredit-mode . " Ï")
      (lsp-lens-mode . " Î»Î»")
      (skewer-css-mode . " ÏÏ")
      (skewer-html-mode . " ÏÎ·")
      (skewer-mode . " Ï")
      (projectile-mode . " ÏÏ"))
    "Alist for `clean-mode-line'.

  When you add a new element to the alist, keep in mind that you
  must pass the correct minor/major mode symbol and a string you
  want to use in the modeline *in lieu of* the original.")

  (defun mp/clean-mode-line ()
    (interactive)
    (loop for cleaner in mode-line-cleaner-alist
          do (let* ((mode (car cleaner))
                    (mode-str (cdr cleaner))
                    (old-mode-str (cdr (assq mode minor-mode-alist))))
               (when old-mode-str
                 (setcar old-mode-str mode-str))
               ;; major mode
               (when (eq mode major-mode)
                 (setq mode-name mode-str)))))

  (add-hook 'after-change-major-mode-hook 'mp/clean-mode-line)


  ;; Only display modes on the visible screen by Protesilaos:
  (defvar-local prot-mode-line-modes-hide
      '(:eval
        (when (mode-line-window-selected-p)
          mode-line-modes))
    "Only display modes on the visible screen.")
  (put 'prot-mode-line-modes-hide 'risky-local-variable t)

  (setq-default mode-line-format
                '("%e"
                  mode-line-front-space
                  mode-line-mule-info
                  mode-line-client
                  mode-line-modified
                  mode-line-remote
                  mode-line-frame-identification
                  mode-line-buffer-identification
                  "   "
                  mode-line-position
                  (vc-mode vc-mode)
                  "  "
                  prot-mode-line-modes-hide
                  mode-line-misc-info
                  mode-line-end-spaces))

#+end_src

**** Theme
Options for doom-themes.

#+begin_src emacs-lisp

  ;; A theme megapack for GNU Emacs:
  (use-package doom-themes
    :config
    (load-theme 'doom-one t)
    ;; Another fancy option:
    ;; (load-theme 'doom-palenight t)
    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config))

#+end_src

**** Frames
Support for Emacs frames and window systems.

#+begin_src emacs-lisp

  ;; Set maximize frame into the current frame:
  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  ;; Set maximize frame by default:
  (add-to-list 'default-frame-alist '(fullscreen . maximized))

  ;; Set specify frame size, and set it by default:
  ;; These functions previously help us know the size of the frame:
  ;; (frame-parameters) -> all parameters
  ;; (frame-width) -> 170
  ;; (frame-height) -> 43
  (set-frame-size (selected-frame) 170 43)
  (add-to-list 'default-frame-alist '(width . 170))
  (add-to-list 'default-frame-alist '(height . 43))

  ;; Set position of the frame:
  ;; Fits on the monitor screen.
  (add-to-list 'default-frame-alist '(left . 1356))
  (add-to-list 'default-frame-alist '(top . 30))
  ;; Fits on the laptop screen.
  (add-to-list 'default-frame-alist '(left + -10))
  (add-to-list 'default-frame-alist '(top . 475))


  ;; Set the default appearance of fringes on the Package Menu frame.
  (add-hook 'package-menu-mode-hook (lambda () (set-fringe-style nil)))
  ;; Note: changes all the windows

#+end_src

**** Windows
***** Ace window
Quickly switch current window.

***** Windmove
Directional selection of windows in a frame.

**** Display
How things are displayed in buffers.

#+begin_src emacs-lisp

  ;; show-paren-mode in all buffers:
  (setopt show-paren-predicate t)

#+end_src

**** Desktop
Save status of Emacs when you exit.

**** Mouse
Input from the mouse.

**** Cursor
Displaying text cursors.

#+begin_src emacs-lisp

  ;; Set the color of the mouse pointer.
  (set-face-attribute 'cursor nil :background "#ff0000")

#+end_src

**** Scrolling
Properties on the scroll cursor.

#+begin_src emacs-lisp

  ;; To scroll one line at a time, enable only one of these two:
  ;; Scroll up to this many lines, to bring point back on screen:
  (setq scroll-conservatively 100)
  ;; The number of lines to try scrolling a window by when point moves out:
  (setq scroll-step 1)

#+end_src

**** Minibuffer
Controlling the behavior of the minibuffer.

**** Imenu
Mode-specific buffer indexes.

*** Editing
**** Editing basics
Most basic editing facilities.

**** Killing
Killing and yanking commands.

**** Indent
Indentation commands.

#+begin_src emacs-lisp

  ;; Enable indentation in all modes except text modes.
  (electric-indent-mode)

  (add-hook 'text-mode-hook
            (lambda ()
              (electric-indent-local-mode -1)))

#+end_src

**** Whitespace
Visualize blanks (TAB, (HARD) SPACE and NEWLINE).

**** Yasnippet
Yet Another Snippet extension.

#+begin_src emacs-lisp

  ;; Allows to type an abbreviation and automatically expand it in templates:
  (use-package yasnippet
    :hook (prog-mode . yas-minor-mode-on)
    :bind (:map yas-minor-mode-map
                ("TAB" . nil)
                ("<tab>" . nil)
                ("C-<tab>" . yas-expand))
    :config
    (yas-reload-all))


  ;; Point yas-snippet-dirs to good snippet collections out there.
  (setq yas-snippet-dirs
      '("~/.emacs.d/snippets"       ; personal snippets
        "/path/to/some/collection/" ; foo and bar-mode snippet collection
        "/path/to/yasnippet/yasmate/snippets" ; the yasmate collection
        ))


  ;; Set here because use-package throws an error for this binding.
  (with-eval-after-load 'yasnippet
    (define-key yas-minor-mode-map (kbd "TAB") yas-maybe-expand))

  ;; Trigger key
  ;; yas-expand tries to expand a snippet abbrev (also known as snippet
  ;; key) before point. YASnippet also provides a conditional binding for
  ;; this command: the variable yas-maybe-expand contains a special value
  ;; which, when bound in a keymap, tells Emacs to call yas-expand if and
  ;; only if there is a snippet abbrev before point. If there is no
  ;; snippet to expand, Emacs will behave as if yas-expand is unbound and
  ;; so will run whatever command is bound to that key normally.

  ;; When yas-minor-mode is enabled, it binds yas-maybe-expand to TAB and
  ;; <tab> by default, however, you can freely remove those bindings:
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)

  ;; And set your own:
  ;; Bind `SPC' to `yas-expand' when snippet expansion available (it
  ;; will still call `self-insert-command' otherwise).
  (define-key yas-minor-mode-map (kbd "SPC") yas-maybe-expand)
  ;; Bind `C-c y' to `yas-expand' ONLY.
  (define-key yas-minor-mode-map (kbd "C-c y") #'yas-expand)

#+end_src

**** Matching
Various sorts of searching and matching.

**** Paren matching
Highlight (un)matching of parens and expressions.

**** Bookmark
Setting, annotation and jumping to bookmarks.

**** Rectangle
Operations on rectangles.

**** Paragraphs
Paragraph and sentence parsing.

**** Undo
Undoing changes in buffers.

**** Region

*** Convenience
**** Convenience basics
Convenience features for faster editing.

#+begin_src emacs-lisp

  ;; It is the opposite of fill-paragraph (emacswiki)
  (defun unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn (barf-if-buffer-read-only) '(t)))
    (let ((fill-column (point-max))
          ;; This would override `fill-column' if it's an integer.
          (emacs-lisp-docstring-fill-column t))
      (fill-paragraph nil region)))

#+end_src

**** Ibuffer
Advanced replacement for âbuffer-menuâ.

#+begin_src emacs-lisp

  ;; Remap the list-buffers mode to ibuffer mode (doesn't work):
  (setq major-mode-remap-alist
        '((list-buffers-mode . ibuffer-mode)))

#+end_src

**** Compare
Compare, view/edit files and tools such as diff and ediff (comprehensive visual interface to âdiffâ and âpatchâ).

#+begin_src emacs-lisp

  ;; Split the window depending on the frame width:
  (setq ediff-split-window-function (if (> (frame-width) 150)
                                        'split-window-horizontally
                                      'split-window-vertically))

#+end_src

**** Company
Extensible inline text completion mechanism.

#+begin_src emacs-lisp

  ;; Better completions:
  (use-package company
    :bind
    (:map company-active-map
          ("<tab>" . company-complete-selection))
    (:map lsp-mode-map
          ("<tab>" . company-indent-or-complete-common))
    :custom
    company-dabbrev-downcase 0))


  ;; A company front-end with icons.
  (use-package company-box
    :hook (company-mode . company-box-mode))


  ;; Show suggestions for YASnippets when using eglot:
  ;; For company:
  (add-hook 'eglot-managed-mode-hook
            (lambda () (add-to-list 'company-backends
                                    '(company-capf :with company-yasnippet))))
  ;; For corfu:
  (straight-use-package 'cape)
  (defun my/eglot-capf ()
    (setq-local completion-at-point-functions
                (list (cape-super-capf
                       #'eglot-completion-at-point
                       (cape-company-to-capf #'company-yasnippet)))))
  (add-hook 'eglot-managed-mode-hook #'my/eglot-capf)

#+end_src

**** Prescient
Simple but effective candidate sorting by usage.

#+begin_src emacs-lisp

  ;; vertico-prescient.el provides an interface for using prescient.el
  ;; to sort and filter candidates in Vertico menus.
  (use-package vertico-prescient
    :demand t
    :config
    (setq prescient-filter-method '(literal initialism prefix regexp)
          prescient-use-char-folding t
          prescient-use-case-folding 'smart
          prescient-sort-full-matches-first t ; Works well with `initialism'.
          prescient-sort-length-enable t)
    (vertico-prescient-mode 1)
    ;; Save recency and frequency rankings to disk, which let them become
    ;; better over time.
    (prescient-persist-mode 1))


  ;; Frameworks that use prescient library to sort and filter candidates lists:
  (use-package ivy-prescient
    :after counsel
    :custom
    ;; Going back to Ivyâs filtering (ivy-prescient doesnlt apply filtering):
    (ivy-prescient-enable-filtering nil)
    :config
    (ivy-prescient-mode 1)
    ;; Sorting remembered across sessions!
    (prescient-persist-mode 1)
    ;; Disable sorting candidates by length.
    (setq prescient-sort-length-enable nil))

#+end_src

**** Vertico
VERTical Interactive COmpletion.

#+begin_src emacs-lisp

  ;; Enable vertico
  (use-package vertico
    :custom
    ;; (vertico-scroll-margin 0) ;; Different scroll margin
    ;; (vertico-count 20) ;; Show more candidates
    ;; (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
    (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
    :init
    (vertico-mode))

#+end_src

**** Consult
Provides search and navigation commands based on the Emacs completion function completing-read.

#+begin_src emacs-lisp

  ;; -*- lexical-binding: t -*-
  ;; Previewing files in find-file
  (setq read-file-name-function #'consult-find-file-with-preview)

  (defun consult-find-file-with-preview (prompt &optional dir default
                                                mustmatch initial pred)
    (interactive)
    (let ((default-directory (or dir default-directory))
          (minibuffer-completing-file-name t))
      (consult--read #'read-file-name-internal :state (consult--file-preview)
                     :prompt prompt
                     :initial initial
                     :require-match mustmatch
                     :predicate pred)))


  ;; -*- lexical-binding: t -*-
  ;; Emacs and web colors list.
  (defvar consult-colors-history nil
    "History for `consult-colors-emacs' and `consult-colors-web'.")

  ;; No longer preloaded in Emacs 28.
  (autoload 'list-colors-duplicates "facemenu")
  ;; No preloaded in consult.el
  (autoload 'consult--read "consult")

  (defun consult-colors-emacs (color)
    "Show a list of all supported colors for a particular frame.\

    You can insert the name (default), or insert or kill the hexadecimal or RGB value of the
    selected color."
    (interactive
     (list (consult--read (list-colors-duplicates (defined-colors))
                          :prompt "Emacs color: "
                          :require-match t
                          :category 'color
                          :history '(:input consult-colors-history)
                          )))
    (insert color))

  ;; Adapted from counsel.el to get web colors.
  (defun counsel-colors--web-list nil
    "Return list of CSS colors for `counsult-colors-web'."
    (require 'shr-color)
    (sort (mapcar #'downcase (mapcar #'car shr-color-html-colors-alist)) #'string-lessp))

  (defun consult-colors-web (color)
    "Show a list of all CSS colors.\

    You can insert the name (default), or insert or kill the hexadecimal or RGB value of the
    selected color."
    (interactive
     (list (consult--read (counsel-colors--web-list)
                          :prompt "Color: "
                          :require-match t
                          :category 'color
                          :history '(:input consult-colors-history)
                          )))
    (insert color))

  ;; A toggle for the `consult-find' command.
  (defun rf/consult-find-toggle ()
    "Toggle to find for any file or all files except hidden ones."
    (interactive)
    (if (string= "find . -not ( -path */.[A-Za-z]* -prune )"
                 consult-find-args)
        (setq consult-find-args "find . ")
      (setq consult-find-args
            "find . -not ( -path */.[A-Za-z]* -prune )")))

#+end_src

**** Bind key
A simple way to manage personal keybindings.

**** Kmacro
Simplified keyboard macro user interface.

**** Hydra
How to use defhydra

#+begin_src emacs-lisp

  ;; Example:
  (global-set-key (kbd "C-c m")
                  (defhydra hydra-transpose (:color red)
                    "Transpose"
                    ("w" transpose-words "words")
                    ("o" org-transpose-words "Org mode words")
                    ("l" transpose-lines "lines")
                    ("q" nil "cancel" :color blue)))

  ;; auto-saves buffers, when certain events happen (e.g. you switch
  ;; between buffers, an Emacs frame loses focus)
  (use-package super-save
    :defer 1
    :diminish super-save-mode
    :config
    (super-save-mode +1))


  ;; Another example:
  (defhydra hydra-buffers (:color blue :hint nil)
    "
                                                                       â­ââââââââââ
     Move to Window         Switch                  Do                 â Buffers â
  â­âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ´ââââââââââ¯
           ^_k_^          [_b_] switch (ido)       [_d_] kill the buffer
           ^^â^^          [_i_] ibuffer            [_r_] toggle read-only mode
       _h_ â   â _l_      [_a_] alternate          [_u_] revert buffer changes
           ^^â^^          [_s_] switch (helm)      [_w_] save buffer
           ^_j_^
  --------------------------------------------------------------------------------
              "
    ("<tab>" hydra-master/body "back")
    ("<ESC>" nil "quit")
    ("a" joe-alternate-buffers)
    ("b" ido-switch-buffer)
    ("d" joe-kill-this-buffer)
    ("i" ibuffer)
    ("h" buf-move-left  :color red)
    ("k" buf-move-up    :color red)
    ("j" buf-move-down  :color red)
    ("l" buf-move-right :color red)
    ("r" read-only-mode)
    ("s" helm-buffers-list)
    ("u" joe-revert-buffer)
    ("w" save-buffer))


  ;; Another example:
  (defhydra hydra-window (:color blue :hint nil)
    "
                                                                       â­ââââââââââ
     Move to      Size    Scroll        Split                    Do    â Windows â
  â­âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ´ââââââââââ¯
        ^_k_^           ^_K_^       ^_p_^    â­ââ¬ââ^ ^        â­ââ¬ââ^ ^         âº [_u_] undo layout
        ^^â^^           ^^â^^       ^^â^^    â â â_v_ertical âââ¼ââ¤_b_alance   â» [_r_] restore layout
    _h_ â   â _l_   _H_ â   â _L_   ^^ ^^    â°ââ´ââ¯^ ^        â°ââ´ââ¯^ ^         â [_d_] close window
        ^^â^^           ^^â^^       ^^â^^    â­ââââ^ ^        â­ââââ^ ^         â [_w_] cycle window
        ^_j_^           ^_J_^       ^_n_^    âââââ¤_s_tack    â   â_z_oom
        ^^ ^^           ^^ ^^       ^^ ^^    â°ââââ¯^ ^        â°ââââ¯^ ^
  --------------------------------------------------------------------------------
            "
    ("<tab>" hydra-master/body "back")
    ("<ESC>" nil "quit")
    ("n" joe-scroll-other-window :color red)
    ("p" joe-scroll-other-window-down :color red)
    ("b" balance-windows)
    ("d" delete-window)
    ("H" shrink-window-horizontally :color red)
    ("h" windmove-left :color red)
    ("J" shrink-window :color red)
    ("j" windmove-down :color red)
    ("K" enlarge-window :color red)
    ("k" windmove-up :color red)
    ("L" enlarge-window-horizontally :color red)
    ("l" windmove-right :color red)
    ("r" winner-redo :color red)
    ("s" split-window-vertically :color red)
    ("u" winner-undo :color red)
    ("v" split-window-horizontally :color red)
    ("w" other-window)
    ("z" delete-other-windows))

#+end_src

**** Completion
Dynamic word-completion code.

**** Abbreviations
Abbreviation handling, typing shortcuts, macros.

**** Ivy
Incremental vertical completion/selection.

Ivy is an interactive interface for listing sorting, filtering, previewing, and applying actions on selection from a list. When Emacs prompts for a string from a list of several possible choices, Ivy springs into action to assist in narrowing and picking the right string from a vast number of choices.

Ivy is installed as part of the ~counsel~ package. Ivy is split into three packages: ~ivy~, ~swiper~ and ~counsel~, by installing ~counsel~, the other two are brought in as dependencies. If you are not interested in the extra functionality provided by ~swiper~ and ~counsel~, you can install only ~ivy~.

Counsel provide versions of common Emacs commands that are customised to make the best use of Ivy. For example, ~counsel-find-file~ has some additional keybindings. Pressing =DEL= will move you to the parent directory.

#+begin_src emacs-lisp

  ;; Ivy (alternative to Ido) a generic completion mechanism for Emacs.
  ;; ivy-mode ensures any cmd using completing-read-fun uses ivy for completion:
  (use-package ivy
    :demand t
    :bind (:map ivy-minibuffer-map
                ("TAB" . ivy-alt-done)
                ("C-<tab>" . ivy-alt-done))
    :config
    (ivy-mode 1)
    ;; Aallow minibuffer commands while in the minibuffer.
    (setq enable-recursive-minibuffers t)
    ;; Delete ./ and .// to the front of the list when completing file names.
    (setq ivy-extra-directories nil)
    ;; Completion Styles: custom regex builder assigned to file name completion:
    (setq ivy-re-builders-alist
          '((read-file-name-internal . ivy--regex-ignore-order)
            (t . ivy--regex-plus))))

  ;; Add recentf-mode and bookmarks to ivy-switch-buffer completion candidates.
  (setq ivy-use-virtual-buffers t)

  ;; Completion Styles: custom regex builder assigned to file name completion:
  (setq ivy-re-builders-alist
        '((read-file-name-internal . ivy--regex-ignore-order)
          ;; '((read-file-name-internal . ivy--regex-fuzzy)
          (t . ivy--regex-plus))))


  ;; A collection of Ivy-enhanced versions of common Emacs commands.
  ;; counsel-mode remaps built-in functions that have counsel replacements.
  (use-package counsel
    :after ivy
    :bind (("C-M-j" . 'counsel-switch-buffer)
           ("C-x j" . 'counsel-recentf))
    :config
    (counsel-mode 1))

  ;; Fuzzy match anywhere within the cmd name (take out the leading ^): (IDK)
  (ivy-configure 'counsel-M-x :initial-input "")


  ;; Display icons for all buffers in ivy:
  ;; Should M-x all-the-icons-install-fonts to install the necessary fonts:
  (use-package all-the-icons-ivy-rich
    :after (ivy all-the-icons)
    :init (all-the-icons-ivy-rich-mode 1))


  ;; Friendly interface for ivy. Transformers for cmds from ivy and counsel:
  (use-package ivy-rich
    :after all-the-icons-ivy-rich
    :init (ivy-rich-mode 1)
    :config
    (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
    ;; Abbreviate paths using abbreviate-file-name:
    (setq ivy-rich-path-style 'abbrev))

#+end_src

*** Text
**** Org
***** Org properties
Options concerning properties in Org mode.

#+begin_src emacs-lisp

  ;; Start an org file with all headers collapsed.
  (setq org-startup-folded 't)

  ;; Start an org file showing only 2-levels headers.
  (setq org-startup-folded 'show2levels)

  ;; Start an org file showing all headers (not content).
  (setq org-startup-folded 'content)

#+end_src

***** Org general
General settings of the org mode.

***** Org modes
Options concerning the minor modes active in org.

***** Org faces
Options concerning the org faces.

***** Org appearance
Settings for Org mode appearance.

***** Org TODO
Options concerning TODO items in Org mode.

***** Org editing
Options concerning the editing in org.

***** Babel
Code block evaluation and management in âorg-modeâ documents

#+begin_src emacs-lisp

  ;; Add lisp and python as execution languages for babel org.
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (python . t)))

    (push '("conf-unix" . conf-unix) org-src-lang-modes))


  ;; Don't ask for confirmation before executing code blocks.
  (setq org-confirm-babel-evaluate nil)

#+end_src

***** Org LaTeX
Options for embedding LaTeX code into Org mode.

#+begin_src emacs-lisp

  ;;Activate LaTeX letters in Org:
  (with-eval-after-load 'ox-latex
    (add-to-list 'org-latex-classes '("letter" "\\documentclass{letter}")))

#+end_src

***** Org agenda
Options concerning agenda views in Org mode.

***** Org export
Options for exporting Org mode files.

***** Org goto
Options concerning Org Goto navigation interface.

***** Org ID
Options concerning global entry identifiers in Org mode.

***** Org indent
Options concerning dynamic virtual outline indentation.

***** Org link
Options concerning links in Org mode.

***** Org mobile
Options concerning support for a viewer/editor on a mobile device.

***** Org structure
Options concerning the general structure of Org files.

***** Org table
Options concerning tables in Org mode.

***** Org tags
Options concerning tags in Org mode.

***** Org time
Options concerning time stamps and deadlines in Org mode.

**** Htmlize
Convert buffer text and faces to HTML.

**** Outlines
Support for hierarchical outlining.

**** Markdown
Major mode for editing text files in Markdown format.

**** Tex
Code related to the TeX formatter.

**** Table
Text based table manipulation utilities.

**** Picture
Editing text-based pictures ("ASCII art").

**** View
Peruse file or buffer without editing.

*** Files
**** Save place
Automatically save place in files.

**** Auto revert
Revert individual buffers when files on disk change.

#+begin_src emacs-lisp

  ;; Revert other buffers like Dired, buffer-menu... (IDK)
  (setq global-auto-revert-non-file-buffers t)

#+end_src

**** Dired
Directory editing.

#+begin_src emacs-lisp

  ;; Dired commands operate only on files in the active region, if any:
  (setq dired-mark-region t)

#+end_src

**** Recentf
Maintain a menu of recently opened files.

**** Persistent scratch
Preserve the state of scratch buffers across Emacs sessions

**** Auto Save
Preventing accidental loss of data.

**** Backup
Backups of edited data files.

#+begin_src emacs-lisp

  ;; Placing all files in one directory (EmacsWiki):
  (setq backup-directory-alist
        `(("." . ,(concat user-emacs-directory "backups"))))

#+end_src

**** Treemacs
Shows the file system outlines of your projects in a simple tree layout allowing quick navigation and exploration.

#+begin_src emacs-lisp

  ;; Provides a theme using all-the-icons.
  (use-package treemacs-all-the-icons
    :after treemacs)

#+end_src

*** Help
**** Helpful
A rich help system with contextual information.

#+begin_src emacs-lisp

  ;; Use helpful with counsel.
  (use-package helpful
    :bind
    ;; Replace the default Emacs help keybindings:
    (([remap describe-key] . helpful-key)
     ([remap describe-command] . helpful-command)
     ([remap describe-variable] . counsel-describe-variable)
     ([remap describe-function] . counsel-describe-function))
    :custom
    ;; Use Helpful with counsel commands:
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable))

#+end_src

**** Which key
Customization options for which-key-mode.

**** Help features
Features for displaying local help.

**** Info
Info subsystem.

*** Communication
**** Simple httpd
A simple web server.

**** Impatient
Serve buffers live over HTTP.

**** Skewer
Live browser JavaScript interaction.

**** Browse url
Use a web browser to look at a URL.

**** Tramp
Edit remote files with a combination of ssh, scp, etc.

**** Server
Emacs running as a server process.

*** Programming
**** Prog mode
Generic programming mode, from which others derive.

#+begin_src emacs-lisp

  ;; To show paren mode only in programming modes
  (add-hook 'prog-mode-hook #'show-paren-local-mode)


  ;; Automatically turn on some tree-sitter based modes for the same
  ;; files for which a "built-in" mode would be turned on:
  (add-to-list 'major-mode-remap-alist '(ruby-mode . ruby-ts-mode))
  ;; or:
  (setq major-mode-remap-alist
        '((yaml-mode . yaml-ts-mode)
          (js2-mode . js-ts-mode)
          (typescript-mode . typescript-ts-mode)
          (json-mode . json-ts-mode)
          (css-mode . css-ts-mode)
          (python-mode . python-ts-mode)))


  ;; Tell Emacs where to find the language grammars. Then call the command
  ;; M-x treesit-install-language-grammar for each language.
  (setq treesit-language-source-alist
        '((css "https://github.com/tree-sitter/tree-sitter-css")
          (html "https://github.com/tree-sitter/tree-sitter-html")
          (javascript "https://github.com/tree-sitter/tree-sitter-javascript"
                      "master" "src")
          (json "https://github.com/tree-sitter/tree-sitter-json")
          (tsx "https://github.com/tree-sitter/tree-sitter-typescript"
               "master" "tsx/src")
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript"
                      "master" "typescript/src")))

#+end_src

**** Tools
***** Eglot
Provides infrastructure and a set of commands for enriching the source code editing capabilities of Emacs via LSP.

#+begin_src emacs-lisp

  ;; Feature that Eglot shouldnât automatically try to manage on
  ;; the userâs behalf. Eglot stay away from flymake Emacs feature.
  (add-to-list 'eglot-stay-out-of 'flymake)
  ;; Disable Eglot's integration with Flymake and rely on linters
  ;; outside of the language servers.
  (use-package eglot
    ;;...
    :init
    (setq eglot-stay-out-of '(flymake)))


  ;; Start an Eglot session for each buffer in which foo-mode is turned on.
  (add-hook 'foo-mode-hook 'eglot-ensure)
  ;; or
  (use-package eglot
    :hook (foo-mode . eglot-ensure))


  ;; Enable `company-mode' after Eglot starts/stops managing a buffer.
  (add-hook 'eglot-managed-mode-hook 'company-mode)
  ;; or
  (use-package company
    :hook (eglot-managed-mode . company-mode))


  ;; Eglot is the Emacs client for the (LSP).
  (use-package eglot
    :bind (:map eglot-mode-map
                ("C-c r" . eglot-rename)
                ("C-c o" . eglot-code-action-organize-imports)
                ("C-c h" . eldoc)
                ("<f6>"  . xref-find-denfinitions))
    :custom
    (eglot-autoshutdown t)
    (eglot-events-buffer-size 0)
    (eglot-extend-to-xref nil)
    (eglot-ignored-server-capabilities
     '(:hoverProvider
       :documentHighlightProvider
       :documentFormattingProvider
       :documentRangeFormattingProvider
       :documentOnTypeFormattingProvider
       :colorProvider
       :foldingRangeProvider))
    (eglot-stay-out-of '(yasnippet)))


  ;; eglot-mode-map is the keymap for binding eglot-related command.
  (define-key eglot-mode-map (kbd "C-c r") 'eglot-rename)
  (define-key eglot-mode-map (kbd "<f6>")  'xref-find-definitions)


  ;; Add server associations to the default list:
  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 '(foo-mode . ("fools" "--stdio"))))
  ;; Multiple servers are acceptable alternatives:
  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 `(foo-mode . ,(eglot-alternatives
                                '(("fools" "--stdio")
                                  ("phewls" "--fast"))))))

#+end_src

***** Language server
Language Server Protocol client.

#+begin_src emacs-lisp

  ;; If you seeing significant problems in responsiveness. Set
  ;; `gc-cons-threshold' to big number like most of the popular starter
  ;; kits (Spacemacs/Doom/Prelude,...).  This is due to the fact that
  ;; client/server communication generates a lot of memory/garbage.
  (setq gc-cons-threshold (* 2 50 1000 1000))

  ;; Lock files will kill `npm start'
  (setq create-lockfiles nil)


  ;; Emacs client/library for the Language Server Protocol.
  (use-package lsp-mode
    :hook((prog-mode . lsp-deferred)
          (lsp-mode . lsp-enable-which-key-integration))
    :config
    ;; Turn off automatically detect and config lsp-ui and company-mode.
    (setq lsp-auto-configure nil))
  ;; This way lsp-mode won't autoload the client packages, and
  ;; other features, so you need either to set it to '(lsp-LANG)
  ;; or to require lsp-LANG manually, and other features manually.


  ;; Defer LSP server startup (and DidOpen notification) until buffer visible.
  (add-hook 'XXX-mode-hook #'lsp-deferred)


  ;; Remap xref-find-{definitions,references}:
  (define-key lsp-ui-mode-map [remap xref-find-definitions]
              #'lsp-ui-peek-find-definitions)
  (define-key lsp-ui-mode-map [remap xref-find-references]
              #'lsp-ui-peek-find-references)


  ;; Project errors on modeline.
  (with-eval-after-load 'lsp-mode
    ;; :global/:workspace/:file
    (setq lsp-modeline-diagnostics-scope :workspace))

#+end_src

***** Eldoc
Show function arglist or variable docstring in echo area.

#+begin_src emacs-lisp

  ;; Truncate if the doc is longer than a single screen line.
  (setq eldoc-echo-area-use-multiline-p 1)


  ;; Displays ElDoc documentations in a childframe.
  (use-package eldoc-box
    :bind ( "C-h ," . eldoc-box-help-at-point))


  ;; Start with M-x eldoc-doc-buffer. It opens a dedicated Eldoc buffer
  ;; for your documentation. The only annoying thing about it is that it
  ;; prefers to pop open in an existing window. The rule forces the
  ;; buffer to appear at the bottom of the frame instead with a fixed
  ;; window height of about 4 lines.
  (add-to-list 'display-buffer-alist
               '("^\\*eldoc for" display-buffer-at-bottom
                 (window-height . 4)))

#+end_src

***** Flymake
Universal on-the-fly syntax checker.

#+begin_src emacs-lisp

  ;; Enable eslint in web-mode:
  (add-hook 'web-mode-hook
            (lambda ()
              (flymake-eslint-enable)))


  ;; Variable to set for use local eslint from node_modules
  (setq-local flymake-eslint-executable-name
              "/home/rich/trials/trial-test/project-name
       /node_modules/eslint/bin/eslint.js")

  ;; Variable to set for use local stylelint from node_modules
  (setq-local flymake-stylelint-executable-name
              "/home/rich/trials/trial-test/project-name
  /node_modules/stylelint/bin/stylelint.mjs")


  ;; Map them to M-n and M-p in flymake-mode.
  (define-key flymake-mode-map (kbd "M-n") 'flymake-goto-next-error)
  (define-key flymake-mode-map (kbd "M-p") 'flymake-goto-prev-error)


  ;; Show flymake errors with sideline.
  ;; (it doesn't work, but sideline-flycheck does)
  (use-package sideline-flymake
    :defer t
    :init
    ;; 'point to show errors only on point - 'line to show errors on line
    (setq sideline-flymake-display-mode 'line)
    (setq sideline-backends-right '(sideline-flymake)))

#+end_src

***** Flycheck
Modern on-the-fly syntax checking for GNU Emacs.

#+begin_src emacs-lisp

  ;; Flycheck is a modern on-the-fly syntax checking extension.
  (use-package flycheck
    :hook (prog-mode . flycheck-mode)
    ;; Show indicators in the right margin (looks too small on the right)
    :custom
    (flycheck-indication-mode 'right-fringe))


  ;; This Flycheck extension shows errors under point in pos-tip popups.
  (use-package flycheck-pos-tip-mode
    :after flycheck
    :config
    (flycheck-pos-tip-mode))


  ;; Variable to set for use local eslint from node_modules
  (setq-local flycheck-javascript-eslint-executable
              "/home/rich/trials/trial-test/project-name
  /node_modules/eslint/bin/eslint.js")


  ;; Adjust margins and fringe widths (to be able to see the indicators >>).
  (defun my/set-flycheck-margins ()
    (setq left-fringe-width 8 right-fringe-width 8  ; 2 minimum
          left-margin-width 1 right-margin-width 0) ; 0 minimum
    (flycheck-refresh-fringes-and-margins))
  ;; â¦every time Flycheck is activated in a new buffer
  (add-hook 'flycheck-mode-hook #'my/set-flycheck-margins)


  ;; Make the error list display like similar lists in
  ;; contemporary IDEs like VisualStudio, Eclipse, etc.
  (add-to-list 'display-buffer-alist
               `(,(rx bos "*Flycheck errors*" eos)
                 (display-buffer-reuse-window
                  display-buffer-in-side-window)
                 (side            . bottom)
                 (reusable-frames . visible)
                 (window-height   . 0.33)))

#+end_src

***** ESlint
Linting for JavaScript.

#+begin_src emacs-lisp

  ;; Use local eslint from node_modules before global (Jeff Barczewski).
  (defun jb/use-eslint-from-node-modules ()
    "Use local eslint from node_modules before global.

  This code looks for a node_modules directory in any parent of
  the buffer's directory and configures Flycheck to use an eslint
  executable from that directory if any exists."
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "node_modules"))
           (eslint (and root
                        (expand-file-name "node_modules/eslint/bin/eslint.js"
                                          root))))
      (when (and eslint (file-executable-p eslint))
        (setq-local flycheck-javascript-eslint-executable eslint))))
  (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)
  ;; or
  ;; Grab eslint executable from node_modules instead of global (zdx.cat).
  (defun lunaryorn-use-js-executables-from-node-modules ()
    "Set executables of JS and TS checkers from local node modules."
    (-when-let* ((file-name (buffer-file-name))
                 (root (locate-dominating-file file-name "node_modules"))
                 (module-directory (expand-file-name "node_modules" root)))
      (pcase-dolist (`(,checker . ,module) '((javascript-jshint . "jshint")
                                             (javascript-eslint . "eslint")
                                             (typescript-tslint . "tslint")
                                             (javascript-jscs   . "jscs")))
        (let ((package-directory (expand-file-name module module-directory))
              (executable-var (flycheck-checker-executable-variable checker)))
          (when (file-directory-p package-directory)
            (set (make-local-variable executable-var)
                 (expand-file-name (if (string= module "tslint")
                                       (concat "bin/" module)
                                     (concat "bin/" module ".js"))
                                   package-directory)))))))

#+end_src

***** Xref
Cross-referencing commands.

#+begin_src emacs-lisp

  ;; Adding a consult function for visualizing xref. (INS)
  (defvar consult--xref-history nil
    "History for the `jf/consult-recent-xref' results.")

  (defun jf/consult-recent-xref (&optional markers)
    "Jump to a marker in MARKERS list (defaults to `xref--history'.

  The command supports preview of the currently selected marker position.
  The symbol at point is added to the future history."
    (interactive)
    (consult--read
     (consult--global-mark-candidates
      (or markers (flatten-list xref--history)))
     :prompt "Go to Xref: "
     :annotate (consult--line-prefix)
     :category 'consult-location
     :sort nil
     :require-match t
     :lookup #'consult--lookup-location
     :history '(:input consult--xref-history)
     :add-history (thing-at-point 'symbol)
     :state (consult--jump-state)))

#+end_src

***** Combobulate
Combobulate group: Structured Editing and Movement with Combobulate.

#+begin_src emacs-lisp

  ;; Complete installation with tree-sitter grammar installation.
  (use-package treesit
    :mode (("\\.tsx\\'" . tsx-ts-mode))
    :preface
    (defun mp-setup-install-grammars ()
      "Install Tree-sitter grammars if they are absent."
      (interactive)
      (dolist (grammar
               ;; Note the version numbers. These are the versions that
               ;; are known to work with Combobulate *and* Emacs.
               '((css . ("https://github.com/tree-sitter/tree-sitter-css" "v0.20.0"))
                 (go . ("https://github.com/tree-sitter/tree-sitter-go" "v0.20.0"))
                 (html . ("https://github.com/tree-sitter/tree-sitter-html" "v0.20.1"))
                 (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript" "v0.20.1" "src"))
                 (json . ("https://github.com/tree-sitter/tree-sitter-json" "v0.20.2"))
                 (markdown . ("https://github.com/ikatyang/tree-sitter-markdown" "v0.7.1"))
                 (python . ("https://github.com/tree-sitter/tree-sitter-python" "v0.20.4"))
                 (rust . ("https://github.com/tree-sitter/tree-sitter-rust" "v0.21.2"))
                 (toml . ("https://github.com/tree-sitter/tree-sitter-toml" "v0.5.1"))
                 (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" "v0.20.3" "tsx/src"))
                 (typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" "v0.20.3" "typescript/src"))
                 (yaml . ("https://github.com/ikatyang/tree-sitter-yaml" "v0.5.0"))))
        (add-to-list 'treesit-language-source-alist grammar)
        ;; Only install `grammar' if we don't already have it
        ;; installed. However, if you want to *update* a grammar then
        ;; this obviously prevents that from happening.
        (unless (treesit-language-available-p (car grammar))
          (treesit-install-language-grammar (car grammar)))))

    ;; Optional. Combobulate works in both xxxx-ts-modes and
    ;; non-ts-modes.

    ;; You can remap major modes with `major-mode-remap-alist'. Note
    ;; that this does *not* extend to hooks! Make sure you migrate them
    ;; also
    (dolist (mapping
             '((python-mode . python-ts-mode)
               (css-mode . css-ts-mode)
               (typescript-mode . typescript-ts-mode)
               (js2-mode . js-ts-mode)
               (bash-mode . bash-ts-mode)
               (conf-toml-mode . toml-ts-mode)
               (go-mode . go-ts-mode)
               (css-mode . css-ts-mode)
               (json-mode . json-ts-mode)
               (js-json-mode . json-ts-mode)))
      (add-to-list 'major-mode-remap-alist mapping))
    :config
    (mp-setup-install-grammars)
    ;; Do not forget to customize Combobulate to your liking:
    ;;
    ;;  M-x customize-group RET combobulate RET
    ;;
    (use-package combobulate
      :custom
      ;; You can customize Combobulate's key prefix here.
      ;; Note that you may have to restart Emacs for this to take effect!
      (combobulate-key-prefix "C-c o")
      :hook ((prog-mode . combobulate-mode))
      ;; Amend this to the directory where you keep Combobulate's source
      ;; code.
      :load-path ("path-to-git-checkout-of-combobulate")))

  ;; Don't display s tree outline of nodes.
  (setq combobulate-flash-node nil)))

  ;; Remove highlighting in js console functions.
  :custom
  (combobulate-query-highlight-serene-shade-face ((t nil)))


  ;; Adds structured editing and movement to a range of programming languages.
  (use-package combobulate
    :vc (combobulate :url "https://github.com/mickeynp/combobulate"
                     :lisp-dir "extensions/"))

#+end_src

***** Debug
Bringing rich debugging capabilities to Emacs via the Debug Adapter Protocol.

#+begin_src emacs-lisp

  ;; Debug adapter client for Emacs that has no dependencies outside Emacs.
  (use-package dape
    :hook
    ;; Save breakpoints on quit
    ((kill-emacs . dape-breakpoint-save)
     ;; Load breakpoints on startup
     (after-init . dape-breakpoint-load))
    :config
    ;; Turn on global bindings for setting breakpoints with mouse
    (dape-breakpoint-global-mode)
    ;; Info buffers like gud (gdb-mi)
    (setq dape-buffer-window-arrangement 'gud)
    (setq dape-info-hide-mode-line nil)
    ;; Showing inlay hints
    (setq dape-inlay-hints t)
    ;; Pulse source line (performance hit)
    (add-hook 'dape-display-source-hook
              'pulse-momentary-highlight-one-line)))


  ;; DAP mode configuration:
  ;; Enabling only some features
  (setq dap-auto-configure-features '(sessions locals controls tooltip))

  ;; Enable only specific modes:
  (dap-ui-mode 1)
  ;; enables mouse hover support
  (dap-tooltip-mode 1)
  ;; use tooltips for mouse hover
  ;; if it is not enabled `dap-mode' will use the minibuffer.
  (tooltip-mode 1)
  ;; displays floating panel with debug buttons
  (dap-ui-controls-mode 1)

  ;; Automatically trigger the hydra when the program hits a breakpoint.
  (add-hook 'dap-stopped-hook
            (lambda (arg) (call-interactively #'dap-hydra)))

#+end_src

***** Magit
Controlling Git from Emacs.

***** Projectile
Manage and navigate projects easily.

**** Languages
***** Html
Hypertext Markup Language editing mode.

#+begin_src emacs-lisp

  ;; Remap one of the keymaps used by default in html and derived
  ;; modes, so it doesn't interfere with the global keymap.
  (add-hook 'html-mode-hook
            (lambda ()
              (keymap-set html-mode-map "M-o" nil)
              (keymap-set html-mode-map "M-i"
                          'facemenu-keymap)))


  ;; Defines the key binding in mhtl-mode and its derivatives. (INS)
  (with-eval-after-load 'mhtml-mode
    (define-key mhtml-mode-map (kbd "C-c d") 'html-div))


  ;; A simple tree-sitter major mode for HTML and Emacs 29.
  (use-package html-ts-mode
    :vc
    (html-ts-mode :url "https://github.com/mickeynp/html-ts-mode"))

#+end_src

***** JavaScript
Customization variables for JavaScript mode.

#+begin_src emacs-lisp

  ;; Use M-. xref-find-definition in js buffers (disable js-find-symbol).
  (with-eval-after-load 'js
    (define-key js-mode-map (kbd "M-.") nil))


  ;; Indent js-mode at level 2.
  (use-package js
    :config
    (setq js-indent-level 2))

#+end_src

***** Css
Cascading Style Sheets (CSS) editing mode.

***** TypeScript
Customization variables for TypeScript mode.

***** Lisp
Lisp support, including Emacs Lisp.

*** Applications
**** Eshell
Command shell implemented entirely in Emacs Lisp.

#+begin_src emacs-lisp

  (setq eshell-history-size 1000)
  (setq eshell-buffer-maximum-lines 10000)

  ;; It's an error for a glob pattern not to match.
  ;; Note: when used, aliases do not work perfectly.
  (setq eshell-error-if-no-glob t)

#+end_src

**** Calc
Advanced desk calculator and mathematical tool.

**** Mail
Modes for electronic-mail handling.

**** Gnus
The coffee-brewing, all singing, all dancing, kitchen sink newsreader.

**** Calendar
Calendar and time management support.

*** External
**** Vterm
Emacs-libvterm (vterm) is fully-fledged terminal emulator inside GNU Emacs based on libvterm, a C library.
**** Google translate
Emacs core UI script for the Google Translate package.
**** Proced
Proced mode.

**** Term
General command interpreter in a window.

**** Shell
Running shell from within Emacs buffers.

**** EasyPG
Interface to the GNU Privacy Guard (GnuPG).

**** Sql
Running a SQL interpreter from within Emacs buffers.

**** Executable
Base functionality for executable interpreter scripts.

**** FlySpell
Spell checking on the fly.

*** Multimedia
**** Image
Image support.

**** Doc view
In-buffer viewer for PDF, PostScript, DVI, and DJVU files.

*** Local
Code local to your site.

*** Miscellaneous
**** Test configuration
Start a bare bone Emacs instance with ~emacs -Q~ on the command line. Execute the following minimal code snippets in the scratch buffer. This way we can exclude side effects due to configuration settings. If other packages are relevant to reproduce the issue, include them in the minimal configuration snippet.

You can also put some configurations  in a file called ~init-test.el~ and then run ~emacs -Q -l init-test.el~.

#+begin_src emacs-lisp

  ;; Minimal setup with Vertico and the default completion system (emacs -Q):
  (package-initialize)
  (require 'consult)
  (require 'vertico)
  (vertico-mode)
  (setq completion-styles '(substring basic))

  ;; Minimal setup for general testing (emacs -Q):
  (package-initialize)
  (vertico-mode)
  (marginalia-mode)
  (setq completion-styles '(orderless basic))
  (keymap-global-set "C-." 'embark-act)
  (keymap-global-set "M-o" 'other-window)
  (repeat-mode)
  ;; (find-file "" t)

#+end_src

** Edit column text, rectangle commands
This page shows you how to edit text in a rectangular region.

- Add a prefix to every line (such as # or //)
  1- Move to the beginning of first line you want.
  2- Press ~C-SPC~ (~set-mark-command~) to mark cursor position.
  3- Move cursor to the beginning of the last line.
  4- Then ~M-x string-rectangle~ ( ~C-x r t~ )
  5- Then type what you want to insert, then Enter.
The command ~string-rectangle~ can be used to insert a vertical column of string across mulitple lines at any column position, not just at the beginning of lines.

- Delete the first few n chars of every line ( ~kill-rectangle~ )
- Delete a column of text ( ~kill-rectangle~ )
- replace-rectangle
- Paste Rectangle ( ~yank-rectangle~ )
- Insert a Column of Numbers ( ~rectangle-number-lines~ )

http://xahlee.info/emacs/emacs/emacs_string-rectangle_ascii-art.html


Insert A to Z Vertically:
1- Move cursor to before specific start word.
2- ~set-mark-command~ ( ~C-SPC~ ).
3- Move cursor to before specific end word.
4- ~universal-argument~ ( ~C-u~ ).
5- Now, ~M-x rectangle-number-lines~. It will prompt you to enter arguments.
6- Type ~65~ (Letter ~A~ has Unicode codepoint ~65~. ~a~ is ~97~).
7- Remove the default ~%2d~ , type ~%c~. (the ~%c~ is for character format)

** Batch rename a bunch of  files in dired directory
1. ~M-x dired~ to go to the directory.
2. ~M-x dired-toggle-read-only~ ( =C-x C-q= ).
3. Then, just edit the file names. (You can use ~M- query-replace~ or ~M- query-replace-regexp~ or rectangle commands).
4. When done, wdired-finish-edit ( =C-c C-c= ) to commit the changes.

To abort, ~M- wdired-abort-changes~ ( =C-c C-k= ).

** Interactively find/replace a bunch of files in dired directory
Suppose you need to do find/replace of a string pattern, for the hundreds of files in a directory. However, you do not want to replace all of them. You need to look at it in a case-by-case basis. What can you do?

1. Call dired to list files in dir, or call ~find-dired~ if you need all subdirectories.
2. Mark the files you want. You can mark by regex by typing ~% m~.
3. Type Q to call ~dired-do-query-replace-regexp~.
4. Type your find regex and replace string.
5. For each occurrence, type y to replace, ~n~ to skip.
6. Type ~!~ to replace all occurrences in current file without asking, ~N~ to skip all possible replacement for rest of the current file. (N is emacs 23 only)
7. To do the replacement on all files without further asking, type ~Y~. (Emacs 23 only)
8. Call ~ibuffer~ to list all opened files.
9. Type ~* u~ to mark all unsaved files, type ~S~ to save all marked files, type ~D~ to close them all.

https://wilkesley.org/~ian/xah/emacs/find_replace_inter.html

** Abbrev mode by commands
*** Turn on abbrev mode
~M-x abbrev-mode~ to turn it on. Call again to turn off.

To turn on globally when emacs starts, put this in your Emacs Init File:
~(setq-default abbrev-mode t)~

*** Define abbrev
Suppose you want to define âbgâ â âbackgroundâ.

1.  Type âbackgroundâ.
2. ~M-x add-global-abbrev~, in the prompt, type âbgâ.

Now, when you type âbgâ followed by a space or return, it'll expand to âbackgroundâ.

If you want the abbrev only for the current major mode,

~M-x add-mode-abbrev~

If the expanded text is more than one word, for example, suppose you want to define âfaqâ â âfrequently asked questionsâ.

1. Type âfrequently asked questionsâ.
2. Select the text.
3. ~C-u 0~
4. ~M-x add-global-abbrev~, in the prompt, type âfaqâ.

*NOTE*:
I put âzâ in the beginning of my abbrevs. This way, i don't have to worry about clash with short words that i don't want to expand.

#+begin_src emacs-lisp

  ;; signature
  "zxl"   â   "Xah Lee"

  ;; url
  "zuxl"   â   "http://xahlee.info/"

  ;; emacs regex
  "zd"   â   "\\([0-9]+?\\)"
  "zstr"   â   "\\([^\"]+?\\)\""

  ;; shell commands
  "zditto"   â   "ditto -ck --sequesterRsrc --keepParent src dest"
  "zim"   â   "convert -quality z5% "

  ;; math/unicode symbols
  "zin"   â   "â"
  "znin"   â   "â"
  "zinf"   â   "â"
  "zluv"   â   "â¥"
  "zsmly"   â   "âº"

  ;; email
  "zme"   â   "someone@example.com"

  ;; computing tech
  "zwp"   â   "Wikipedia"
  "zg"   â   "Google"

  ;; normal english words
  "zalt"   â   "alternative"
  "zchar"   â   "character"
  "zdef"   â   "definition"

#+end_src

*** Remove abbrev
To remove a definition, give a negative argument to add-global-abbrev or add-mode-abbrev.

For example, to undefine the abbrev âbgâ.

1. ~C-u -1~.
2. ~M-x add-global-abbrev~, in the prompt, type âbgâ.

*** Save abbrev
When you quit, emacs will ask you if you want to save.

To auto save, put this in your Emacs Init File:

~(setq save-abbrevs 'silently)~

The abbrevs is saved in a file at a path specified by the variable

~abbrev-file-name~

By default, it's at ~~/.emacs.d/abbrev_defs~

*** List and edit
Display a list of defined abbrevs.
~M-x list-abbrevs~

Edit Abbrevs
~M-x edit-abbrevs~

*** Abbrev file location
The abbrevs is saved in a file at a path specified by the variable ~abbrev-file-name~

By default, it's at  ~(~/.emacs.d/abbrev_defs)~

You can change it, for example, put this in emacs init:

~(setq abbrev-file-name "~/emacs_abbre.el")~

*** Edit abbrevs
Call ~edit-abbrevs~ to edit abbrev.

To remove a abbrev, just delete the line.
To add a abbrev, just add a line.

When done, to load and or save, call any of:

~edit-abbrevs-redefine~  â Redefine abbrevs according to current buffer contents.
~abbrev-edit-save-buffer~  â Redefine and save to abbrev file.
~abbrev-edit-save-to-file~ â Redefine and save to abbrev file, but ask for a location.

*** Reference

[[http://xahlee.info/emacs/emacs/emacs_abbrev_mode_tutorial.html]]

https://wilkesley.org/~ian/xah/emacs/emacs_abbrev_mode.html

*** Abbrev mode by lisp code
Emacs's abbrev feature lets you type a short word and expand into a full word or code template.

[[http://xahlee.info/emacs/emacs/emacs_abbrev_mode.html]]

** Use a live web server
*** impatien-mode
Works perfectly well with HTML and CSS, with JS it might cause problems due to browser cache. One way to be able to sometimes use JS is to include the meta tag ~<meta http-equiv="refresh" content="1" >~ (refresh the page every sec) at the beginning and comment it out and uncomment it to update the JS.

*Activate the impatien-mode*:
1. Enable the web server provided by simple-httpd: ~M-x httpd-start~ or ~M-x httpd-serve-directory~
2. Publish each buffers that you want to edit by enabling the minor mode impatient-mode on it: ~M-x impatient-mode~
3. Point your browser to http://localhost:8080/imp/, and watch your changes appear as you type!

If you are editing HTML that references resources in other files (like CSS) you can enable impatient-mode on those buffers as well. This will cause your browser to live refresh the page when you edit a referenced resource.

*Note*: I think the problem happens when variables are declared with "let", when the program reloads the code it see the variable "let" assigned again. I think that when the package was created it didn't give problem because at that time JS used "var" in the variables, and nothing happens when it's declared again.

*** skewer-mode
**** To skewer your own document
Works perfectly well in JS, HTML and CSS, following the steps below, but it only updates values (I really don't know if it can create new values), that is, it doesn't create new values, for example, in HTML it doesn't render new tags it only updates existing ones, in JS depending on what you want to do, it may create new things.

1. Start the HTTP server (~httpd-start~ or ~httpd-serve-directory~)
2. Add this tag at the end (~<script src="http://localhost:8080/skewer"></script>~) of the ~index.html~ file (check your httpd-port)
3. ~M-x run-skewer~ to attach a browser to Emacs
4. Visit the document from your browser. Can be through:
   - http://localhost:8080/index.html (~http-server-directory~ => ~~/Downloads/Project-folder~)
   - http://localhost:8000/Project-folder/ (server directory => ~~/Downloads~)
   - file:///home/richard/Downloads/Project-folder/index.html
   - http://127.0.0.1:8080/skewer/demo (totally empty but renders new tags)
5. Enabled respective mode (.html -> ~skewer-mode~ and ~skewer-html-mode~ , .js -> ~skewer-mode~ and ~js2-mode~ (optional enable ~lsp~ ) or .css ->  ~skewer-mode~ and ~skewer-css-mode~)
6. From a ~js2-mode~ buffer with ~skewer-mode~ minor mode enabled, send forms to the browser to evaluate
7. Evaluate each statement (~C-x C-e~) or the entire buffer (~C-c C-k~). The results should be displayed on the server opened by skewer or the one you open yourself, and also is echoed in the minibuffer.

Note: to simple test (provided blank document), enable ~httpd-start~ run ~run-skewer~ to open skewer demo, create a empty ~js~ file, type some comands, enable ~js2-mode~ and ~skewer-mode~, and evaluate the statements. Skewer demo URL http://127.0.0.1:8080/skewer/demo.

#+begin_src html

  <!-- Original document -->
  <p>This is a paragraph</p>

  <!-- After use skewer -->
  <p>This is a paragraph inside the document</p> <!-- update tag (works) -->
  <p>This is a new tag</p> <!-- create new tag (doesn't work) -->

#+end_src

**** How to evalutationg expressions
https://github.com/skeeto/skewer-mode
The keybindings for evaluating expressions in the browser are just like the Lisp modes. These are provided by the minor mode ~skewer-mode~.

- C-x C-e :: Evaluate the form before the point and display the result in the minibuffer. If given a prefix argument, insert the result into the current buffer.
- C-M-x :: Evaluate the top-level form around the point.
- C-c C-k :: Load the current buffer.
- C-c C-z :: Select the REPL buffer.

The result of the expression is *echoed in the minibuffer*.

Additionally, ~css-mode~ and ~html-mode~ get similar sets of bindings for modifying the CSS rules and HTML on the current page.

*CSS*:
- C-x C-e :: Load the declaration at the point.
- C-M-x :: Load the entire rule around the point (point must be inside the tag).
- C-c C-k :: Load the current buffer as a stylesheet.

*HTML*:
- C-M-x :: Load the HTML tag immediately around the point (point must be inside the tag).

*Note*: ~run-skewer~ uses ~browse-url~ to launch the browser. This may require further setup depending on your operating system and personal preferences.

Multiple browsers and browser tabs can be attached to Emacs at once. JavaScript forms are sent to all attached clients simultaneously, and each will echo back the result individually. Use ~list-skewer-clients~ to see a list of all currently attached clients.

Sometimes Skewer's long polls from the browser will timeout after a number of hours of inactivity. If you find the browser disconnected from Emacs for any reason, use the browser's console to call ~skewer()~ to reconnect. This avoids a page reload, which would lose any fragile browser state you might care about.

**** Format document example
The format should be like this

#+begin_src html

  <!DOCTYPE html>
  <html>
    <head>
      <title>Something</title>
      <link rel="stylesheet" href="./syle.css">
    </head>
    <body>
      <h1>Here</h1>
      <p>START</p>
      <img src="img/cat.png" id="cat" style="position: absolute">
      <img src="img/hat.png" id="hat" style="position: absolute">
      <script src="./javascript.js"></script>
      <p>LAST</p>
      <script src="http://localhost:8080/skewer"></script>
      <p>REALLY LAST</p>
    </body>
  </html>

#+end_src

and not like this (can also be done by just opening a js file and typing but will only see the js not the html or css)

#+begin_src javascript

  <!doctype html>

  <style>body { min-height: 200px }</style>
  <img src="img/cat.png" id="cat" style="position: absolute">
  <img src="img/hat.png" id="hat" style="position: absolute">

  <script>
    let cat = document.querySelector("#cat");
    let hat = document.querySelector("#hat");

    let angle = 0;
    let lastTime = null;
    function animate(time) {
        if (lastTime != null) angle += (time - lastTime) * 0.001;
        lastTime = time;
        cat.style.top = (Math.sin(angle) * 40 + 40) + "px";
        cat.style.left = (Math.cos(angle) * 220 + 230) + "px";

        // Your extensions here.

        requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>

#+end_src

**** REPL
A REPL into the browser can be created with ~M-x skewer-repl~ , or ~C-c C-z~. This should work like a console within the browser. Messages can be logged to this REPL with ~skewer.log()~ (like ~console.log()~).

Results of expressions evaluated in the REPL are printed more verbosely than in the minibuffer, when possible. This may help in debugging.

** YASnippet template
Special Characters

1. ~$0~ â the position the cursor (after the snippte is inserted). You don't need to put a ~$0~ if you don't need to.
2. ~$â¹nâº~ â a field, where the ~â¹nâº~ is a integer starting with 1. (Example: ~$1~, ~$2~, â¦). Pressing tab will move cursor to these stops for user to fill in. Multiple occurrence of the same ~$â¹nâº~ means typing in one field will automatically fill the other.
3. ~${â¹nâº:â¹default textâº}~ â same as ~$â¹nâº~, but provides a default text.
4. ~$&~ â means indent the line according to the mode's indentation rule.
5. ~`â¦`~ â (backtick) is used to enclose elisp code. The lisp code will be evaluated in the same buffer the snippet is being expanded.

Once you create a template file, you have to load it. Call ~yas-reload-all~.

#+begin_example

Examples of defining HTML tags with field stop points:

<h1>$1</h1>

<img src="$1" class="$2" alt="$3">

You can also include lisp code in your template. For example,
you might want to have a date stamp. Here's a example that
insert user's email address and datestamp.

`user-mail-address`

`(current-time-string)`

#+end_example

** Build website on org
*** Creating project folders
Create a folder called ~my-org-site~ with a subfolder called ~content~ which contains a single ~index.org~ file. This will create a file called ~index.html~.

*** Creating the build script
Create a script that will generate the HTML files for the Org documents.

#+begin_src emacs-lisp

  ;; ~/my-org-site/build-site.el

  ;; Load the publishing system
  (require 'ox-publish)

  (message "Build complete!")

#+end_src

We also need a shell script that can run our Emacs Lisp script (no es necesario pero garantiza que el emac se levante desde cero sin configuraciones o dependencias que puedan causar problemas al generar los archivos)

#+begin_src sh

  # ~/my-org-site/build.sh

  #!/bin/sh
  emacs -Q --script build-site.el

  # Dont forget to use chmod +x build.sh to make the script executable!
  # The -Q parameter prevents Emacs from loading your own Emacs configuration

#+end_src

Now in the shell, change directory to ~my-org-site~ and run the script ~./build.sh~ to launch emacs with ~build-site.el~

*** Setting up the publish project

#+begin_src emacs-lisp

  (require 'ox-publish)

  ;; set up a Org publishing configuration for our website
  ;; Define the publishing project
  (setq org-publish-project-alist
        (list
         (list "my-org-site"
               :recursive t
               :base-directory "./content"
               :publishing-directory "./public"
               :publishing-function 'org-html-publish-to-html)))
  ;;publishing-funtion -> we want to publish the files as HTML
  ;;first list -> list of all project configuration
  ;;second list -> list configuration one

  ;; Generate the site output
  ;;publish every project configured in org-publish-project-alist
  (org-publish-all t)
  ;;t -> don't use any cached files just regenerate everything from scratch

  (message "Build complete!")

#+end_src

*** Creating the index.org example to test
Create ~~/my-org-site/content/index.org~ file to test

#+begin_src org

  #+title: Org Mode Example Site

  * Overview

  This is an *example* of a _website_ written with Org Mode.

  * Links

  - [[https://www.google.com][External link]]
  - [[file:///home/richard/Test/index.html][Internal pc link]]
  - [[./other-page.org][Link to another file in same public folder]]

#+end_src

Run the script ~./build.sh~ to generate the output of our site that are put in ~~/my-org-site/public~ folder. (se debe ejecutar cada vez que se quiera transformar nuevos archivos .org -> .html)

*** Install simple-httpd local server
Host the files as a website on the local machine. Run ~M-x httpd-serve-directory~. It will prompt you for a directory to serve from within Emacs.

Default http://localhost:8080 . Set ~httpd-port~ to change the default port if necessary.

#+begin_src emacs-lisp

  (use-package simple-httpd
    :ensure t)

#+end_src

*** Settings customizations
Note: ~C-h v org-publish-project-alist~ da una descripciÃ³n sobre las variables de personalizaciÃ³n y que otras estan disponibles.

#+begin_src emacs-lisp

  ;;set a different variable to get rid of the validate link at the bottom
  (setq org-html-validation-link nil)

  (setq org-publish-project-alist
        (list
         (list "org-site:main"
               :recursive t
               :base-directory "./content"
               :publishing-directory "./public"
               :publishing-function 'org-html-publish-to-html
               :with-author nil        ;; Don't include author name
               :with-creator t   ;; Include Emacs and Org versions in footer
               :with-toc t             ;; Include a table of contents
               :section-numbers nil    ;; Don't include section numbers
               :time-stamp-file nil))) ;; Don't include time stamp in file

#+end_src

*** Aditional customizations
We can use a nice stylesheet to give our site a more polished look:

#+begin_src emacs-lisp

  ;; Customize the HTML output
  (setq org-html-validation-link nil            ;; Don't show validation link
        org-html-head-include-scripts nil       ;; Use our own scripts
        org-html-head-include-default-style nil ;; Use our own styles
        org-html-head "<link rel=\"stylesheet\"
  href=\"https://cdn.simplecss.org/simple.min.css\" />")
  ;;Place before (setq org-publish-project-alist...

#+end_src

This will remove the default JavaScript and CSS code that gets injected into the HTML output by default and replace it with the link to a nice stylesheet.

Nota: It can use a own css file by adding it in the public folder.

*** Generating pages with code blocks
Enhance the code and avoid the error "Cannot fontify source block (htmlize.el >= 1.34 required)"

#+begin_src emacs-lisp

  ;; Set the package installation directory so that packages aren't
  ;; stored in ~/.emacs.d/elpa path.
  (require 'package)
  (setq package-user-dir (expand-file-name "./.packages"))
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))

  ;; Initialize the package system
  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))

  ;; Install dependencies
  (package-install 'htmlize)

#+end_src

*** Linking between pages
One last thing I want to show you is how you can create links between pages on your site. Let's open up ~index.org~ and create a link to the ~Emacs.org~ file.

Inside ~index.org~, we can press /C-c C-l/ (~org-insert-link~), enter the path of the Org file we want to link to (~./Emacs.org~), press Enter, then enter the text for the link ("My Emacs configuration").

*** The final build script

#+begin_src emacs-lisp

  ;; Set the package installation directory so that packages aren't
  ;; stored in the ~/.emacs.d/elpa path.
  (require 'package)
  (setq package-user-dir (expand-file-name "./.packages"))
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))

  ;; Initialize the package system
  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))

  ;; Install dependencies
  ;;(package-install 'htmlize) ;;Enhanced block code

  ;; Load the publishing system
  (require 'ox-publish)

  ;; Customize the HTML output
  (setq org-html-validation-link nil            ;; Don't show validation link
        org-html-head-include-scripts nil       ;; Use our own scripts
        org-html-head-include-default-style nil ;; Use our own styles
        org-html-head "<link rel=\"stylesheet\"
  href=\"https://cdn.simplecss.org/simple.min.css\" />")

  ;; set up a Org publishing configuration for our website
  ;; Define the publishing project
  (setq org-publish-project-alist
        (list
         (list "my-org-site"
               :recursive t
               :base-directory "./content"
               :publishing-directory "./public"
               :publishing-function 'org-html-publish-to-html
               :with-author nil ;; Don't include author name
               :with-creator t ;; Include Emacs and Org versions in footer
               :with-toc t     ;; Include a table of contents
               :section-numbers nil    ;; Don't include section numbers
               :time-stamp-file nil))) ;; Don't include time stamp in file
  ;;publishing-funtion -> we want to publish the files as HTML
  ;;first list -> list of all project configuration
  ;;second list -> list configuration one

  ;; Generate the site output
  ;;publish every project configured in org-publish-project-alist
  (org-publish-all t) ;; t -> don't use any cached files just
                      ;; regenerate everything from scratch

  (message "Build complete!")

#+end_src

** Define org links

#+begin_src org

  # WEB
  [[http://orgmode.org/][Org-mode]]
  # or
  [[http://orgmode.org/]]


  # FILE
  [[file:Emacs-guide.org][Emacs-Guide]]
  # or
  [[file:Emacs-guide.org]]
  # path
  [[file:~/path/Emacs-guide.org::Outline][Outline]]
  # line 255
  [[file:~/code/main.c::255]]
  # <<Mi objetive>>
  [[file:~/xx.org::Mi objective]]
  # my-personal-id
  [[file:~/xx.org::#my-personal-id]]


  # ANCHOR
  [[Heading name][whatever]]
  # or
  [[Heading name]]
  # CUSTOM_ID property (name different from outline)
  # * Source Code
  :PROPERTIES:
  :CUSTOM_ID: source-code-layout-organization
  :END:
  [[#source-code-layout-organization][Source Code Layout & Organization]]

#+end_src

** Letter on org latex
https://www.miskatonic.org/2022/01/28/latex-letters-in-org/

First, need to turn on the  LaTeX letters in Org in the Emacs init file.

#+begin_src emacs-lisp

  ;;Activate LaTeX letters in Org
  (with-eval-after-load 'ox-latex
    (add-to-list 'org-latex-classes '("letter" "\\documentclass{letter}"))
    )

#+end_src

#+begin_src org

  # #+title: Comment out, or do not use
  #+date: Wednesday

  #+options: toc:nil

  #+latex_header: \usepackage[osf]{Baskervaldx}

  #+latex_class: letter

  #+latex_header: \signature{Lucy}
  #+latex_header: \address{17, Chatham Street}

  #+latex: \begin{letter}{[s.l.]}
  #+latex: \opening{My dearest Mina,---}

  I must say you tax me very unfairly with being a bad correspondent.
  I wrote to you /twice/ since we parted, and your last letter was only
  your /second/.
  Besides, I have nothing to tell you.  There is really nothing to interest you.
  Town is very pleasant just now, and we go a good deal to picture-galleries
  and for walks and rides in the park.  As to the tall, curly-haired man,
  I suppose it was the one who was with me at the last Pop.  Some one
  has evidently
  been telling tales.  That was Mr. Holmwood.  He often comes to see us,
  and he and
  mamma get on very well together; they have so many things to talk about
  in common.
  We met some time ago a man that would just /do for you/, if you were
  not already
  engaged to Jonathan.  He is an excellent /parti/, being handsome,
  well off, and
  of good birth.  He is a doctor and really clever.  Just fancy!
  He is only nine-and-twenty, and he has an immense lunatic asylum all
  under his own care.

  #+latex: \closing{Sincerely,}
  #+latex: \ps{P.S.  I need not tell you this is a secret.  Good-night again.}
  #+latex: \end{letter}

#+end_src

** Estructure of Org code blocks
Org offers two ways to structure source code in Org documents: in a 'src' code block, and directly inline. Both specifications are shown below.

A source code block conforms to this structure:

#+NAME: <name>
#+BEGIN_SRC <language> <switches> <header arguments>
  <body>
#+END_SRC

Org also works with other completion systems in Emacs, some of which predate Org and have custom domain-specific languages for defining templates.

An inline code block conforms to this structure:

src_<language>{<body>}

or

src_<language>[<header arguments>]{<body>}

Examples:

src_sh{ echo "hola" }

src_js{ function foo () { return 'exit';} }

** Basic emacs installation
*** Building Emacs from Source with pgtk
https://batsov.com/articles/2021/12/19/building-emacs-from-source-with-pgtk/

*** emacs-mirror
https://github.com/emacs-mirror/emacs/blob/master/INSTALL
On most Unix systems, you build Emacs by first running the 'configure'
shell script.  This attempts to deduce the correct values for
various system-dependent variables and features, and find the
directories where certain system headers and libraries are kept.
In a few cases, you may need to explicitly tell configure where to
find some things, or what options to use.

'configure' creates a 'Makefile' in several subdirectories, and a
'src/config.h' file containing system-dependent definitions.
Running the 'make' utility then builds the package for your system.

Building Emacs requires GNU make, <https://www.gnu.org/software/make/>.
On most systems that Emacs supports, this is the default 'make' program.

Here's the procedure to build Emacs using 'configure' on systems which
are supported by it.  In some cases, if the simplified procedure fails,
you might need to use various non-default options, and maybe perform
some of the steps manually.  The more detailed description in the other
sections of this guide will help you do that, so please refer to those
sections if you need to.

  1.  Obtain and unpack the Emacs release, with commands like this:

       wget https://ftp.gnu.org/gnu/emacs/emacs-VERSION.tar.xz
       tar -xf emacs-VERSION.tar.xz

       where VERSION is the Emacs version number.

  2a. 'cd' to the directory where you unpacked Emacs and invoke the
        'configure' script:

        ./configure

  2b. Alternatively, create a separate directory, outside the source
        directory, where you want to build Emacs, and invoke 'configure'
        from there:

        SOURCE-DIR/configure

        where SOURCE-DIR is the top-level Emacs source directory.

  2c. If you don't have write access to the default directory where
        Emacs and its data files will be installed, specify an alternative
        installation directory:

        ./configure --prefix=/SOME/OTHER/DIRECTORY

        where /SOME/OTHER/DIRECTORY is a directory writable by your user,
        for example, a subdirectory of your home directory.

  3. When 'configure' finishes, it prints several lines of details
       about the system configuration.  Read those details carefully
       looking for anything suspicious, such as wrong CPU and operating
       system names, wrong places for headers or libraries, missing
       libraries that you know are installed on your system, etc.

       If you find anything wrong, you may have to pass to 'configure'
       one or more options specifying the explicit machine configuration
       name, where to find various headers and libraries, etc.
       Refer to the section DETAILED BUILDING AND INSTALLATION below.

       If 'configure' didn't find some image support libraries, such as
       Xpm and jpeg, refer to "Image support libraries" below.

       If the details printed by 'configure' don't make any sense to
       you, but there are no obvious errors, assume that 'configure' did
       its job and proceed.

  4. Invoke the 'make' program:

       make

  5. If 'make' succeeds, it will build an executable program 'emacs'
       in the 'src' directory.  You can try this program, to make sure
       it works:

       src/emacs -Q

       To test Emacs further (intended mostly to help developers):

       make check

  6. Assuming that the program 'src/emacs' starts and displays its
       opening screen, you can install the program and its auxiliary
       files into their installation directories:

       make install

    You are now ready to use Emacs.  If you wish to conserve space,
    you may remove the program binaries and object files from the
    directory where you built Emacs:

    make clean

    You can delete the entire build directory if you do not plan to
    build Emacs again, but it can be useful to keep for debugging.
    If you want to build Emacs again with different configure options,
    first clean the source directories:

    make distclean

    Note that the install automatically saves space by compressing
    (provided you have the 'gzip' program) those installed Lisp source (.el)
    files that have corresponding .elc versions, as well as the Info files.

    You can read a brief summary about common make targets:

    make help

*** Xah
http://xahlee.info/emacs/emacs/building_emacs_on_linux.html

*** Install with tree-sitter support
https://www.masteringemacs.org/article/how-to-get-started-tree-sitter

** Define an alias
Define an alias to be use with the ~query-replace-regexp~ function by typing ~like M-x qrr~.

#+begin_src emacs-lisp

  (defalias 'qrr 'query-replace-regexp)

  ;; Always use ibuffer
  (defalias 'list-buffers 'ibuffer)

  ;; Answer the questions "yes" or "no" with "y" or "n".
  (defalias 'yes-or-no-p 'y-or-n-p)

#+end_src

** Keyboard macro
*** Define keyboard macros
*To save a macro (Xah)*
1. ~M-x name-last-kbd-macro~ and give it a name.
2. ~M-x insert-kbd-macro~ this will insert the lisp code for a named kmacro at the cursor position.
3. Copy & Paste the code into your emacs init file.
4. In any future emacs session, you can call your kmacro by name just like any emacs command.

Once you've saved your macro with a name, you can also give it a keyboard shortcut, such as ~F8~.

#+begin_src emacs-lisp

  ;; macro for bold region, add two *
  (fset 'bold
        (kmacro-lambda-form [?\C-c ?\C-x ?\C-f kp-multiply] 0 "%d"))
  (global-set-key (kbd "<f7>") 'bold)

  ;; macro for code region, add tow =
  (fset 'code
        (kmacro-lambda-form [?\C-c ?\C-x ?\C-f ?=] 0 "%d"))
  (global-set-key (kbd "<f8>") 'code)

#+end_src

*** Interactive keyboard macros
One neat, little feature is the ability to insert a /macro query/ flag when you are recording a macro. A macro query is only triggered when you play it back. Emacs detects the query and pauses execution and cedes control back to you. To use it, type ~C-x q~ when youâre recording. There is no visual indicator when you type it, though.

| /Opts/ | /Specify how to proceed with keyboardmacro execution/ |
|------+-----------------------------------------------------|
| /Y/    | Finish this iteration and continue with the next    |
| /N/    | Skip the rest of this iteration, and start the next |
| /RET/  | Stop the macro entirely right now                   |
| /C-l/  | Redisplay the screen, then ask again                |
| /C-r/  | Enter recursive edit; (press /SCP/) to ask again      |
|      | when you exit from that                             |

That makes it excellent for what I call *interactive* macros that require user input. You can place the /macro query/ anywhere you like â even in a prompt, like query replace regexp with ~C-M-%~. You can even prefill the prompt; Emacs will remember that also.

*** Repeat keyboard macros
You can optionally give a prefix argument to ~C-x e~ or ~F4~ to make it repeat the macro that many times. Use ~0~ to tell Emacs to *run the macro until it gets an error signal*. A macro plays back until it encounters an error (end of buffer, end of matches in ~*Grep*~ if you advance with ~M-g M-n~, and so on.) Watch out if youâre waving ~C-g~ around in a macro â it terminates the recording!

*** Insert counter in keyboard macros
If you call ~F3~ when youâre recording, itâll insert a number from a counter and increment it. Use a universal arg ~C-u~ and itâll repeat the last number without incrementing it. You can pass a numeric arg to ~F3~ to start the recording with a different number. This featureâs obviously great for numerating lists.

*** Notes
*Mickey Petersen*
- To modifying window layout, just make sure you start with a call to ~C-x 1~ to reset the windows back to one when you start the recording.
- To call up a Shell, make it run ~C-u M-x shell~ (or Eshell, or Vterm, orâ¦) and run some commands that you frequently need to do.

*Xah*
- To move to the next logical line (line with a line return at the end), move to end of line first, then right cursor moves it to beginning of next line. Because if you have Emacs: Visual Line Mode on, down arrow may move to the next visual line.

*Emacswiki*
- You want to add the text ââ foobar was hereâ at the end of each of the lines in a file. Whatâs important here is to stop defining the macro at a *similar position to where you started it* â so that you are in a position to execute it again, after it executes. This is a general rule that you will often follow when defining keyboard macros: try to make them executable N times in a row.

** Writing scripts
1. Create ~some.el~ file
2. Change modes (~chmod a+x some.el~)
3. Write the code with the shebang line

#+begin_src emacs-lisp

  #!emacs --script

  (defun main ()
    (print (version))
    (print (format "I did it. you passed in %s" command-line-args-left)))

  (main)

#+end_src

4. Run with or without arguments (~./some.el arg1 arg2~)
5. Or run with ~-Q~ to disabled initial messages (~./some.el -Q arg1 arg2~)

** Markup for Rich Contents
Org is primarily about organizing and searching through your plain-text notes. However, it also provides a lightweight yet robust markup language for rich text formatting and more. For instance, you may want to center or emphasize text. Or you may need to insert a formula or image in your writing. Org offers syntax for all of this and more. Used in conjunction with the export framework, you can author beautiful documents in Orgâlike the fine manual you are currently reading.

*Paragraphs*
Paragraphs are separated by at least one empty line. If you need to enforce a line break within a paragraph, use â\\â at the end of a line.

#+BEGIN_VERSE
 Great clouds overhead
 Tiny black birds rise and fall
 Snow covers Emacs

    ---AlexSchroeder
#+END_VERSE

#+BEGIN_QUOTE
Everything should be made as simple as possible,
but not any simpler ---Albert Einstein
#+END_QUOTE

*Literal Examples*
You can include literal examples that should not be subjected to markup. Such examples are typeset in monospace, so this is well suited for source code and similar examples.

#+BEGIN_EXAMPLE
  Some example from a text file.
#+END_EXAMPLE

* References
- [[https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html][An Introduction to Programming in Emacs Lisp]]
- [[https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html][GNU Emacs Manual]]
- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/][The GNU Emacs Lisp Reference Manual]]
- [[https://orgmode.org/orgguide.html][Org Mode Compact Guide]]
- [[https://wilkesley.org/~ian/xah/][âXAH]]
- [[https://www.youtube.com/watch?v=48JlgiBpw_I][System Crafters Youtube]]
