#+title: JavaScript
#+date: 2023-11-05

* Values and operators
** Values
*** Brief
Imagine a sea of bits‚Äîan ocean of them. A typical modern computer has more than 100 billion bits in its volatile data storage (working memory). Nonvolatile storage (the hard disk or equivalent) tends to have yet a few orders of magnitude more.

To be able to work with such quantities of bits without getting lost, we separate them into chunks that represent pieces of information. In a JavaScript environment, those chunks are called /values/. Though all values are made of bits, they play different roles. Every value has a type that determines its role. Some values are numbers, some values are pieces of text, some values are functions, and so on.

Standard defines nine types, and only six are directly accessible in an ECMAScript program (other three types are accessible only at implementation level):

- Undefined
- Null
- Boolean
- String
- Number
- Object

These values are represented in implementations directly on a low level. They are *not objects*, they do not have neither prototypes, nor constructors.

#+begin_src javascript

  let a = undefined;
  let b = null;
  let c = true;
  let d = 'test';
  let e = 10;


  // The typeof operator can be unintuitive if not properly
  // understood. And one such example of that is with the value null.
  console.log(typeof null); // "object"

#+end_src

*** Primitive values
**** Brief
In JavaScript, there are 7 primitive data types: [[Strings][string]], number, bigint, [[Boolean values][boolean]], [[Symbols][symbol]], [[Empty values][undefined]], and [[Empty values][null]]. Their values are considered immutable. These are not objects and have no methods or properties; however, all primitives except ~undefined~ and ~null~ have object wrappers.

**** Empty values
There are two special values, written ~null~ and ~undefined~, that are used to denote the absence of a *meaningful* value. They are themselves values, but they carry no information.

Many operations in the language that don‚Äôt produce a meaningful value yield ~undefined~ simply because they have to yield some value.

The difference in meaning between ~undefined~ and ~null~ is an accident of JavaScript‚Äôs design, and it doesn‚Äôt matter most of the time. In cases where you actually have to concern yourself with these values, I recommend treating them as mostly interchangeable.
**** Boolean values
JavaScript has a Boolean type, which has just two values, ~true~ and ~false~.

*Note*: the rules for converting strings and numbers to Boolean values state that ~0~, ~NaN~, and the empty string ( ~""~ ) count as *false*, while all the other values count as *true*.

#+begin_src javascript

  console.log(Boolean(5))         // true
  console.log(Boolean("string"))  // true

  console.log(Boolean(0))         // false
  console.log(Boolean(""))        // false
  console.log(Boolean(NaN))       // false
  console.log(Boolean(null))      // false
  console.log(Boolean(undefined)) // false

#+end_src

**** Strings
***** Single quotes, double quoutes, backticks
Strings are used to represent text. They are written by enclosing their content in quotes. You can use *single quotes*, *double quotes*, or *backticks* to mark strings, as long as the quotes at the start and the end of the string match.

#+begin_src javascript

  `Down on the sea`
  "Lie on the ocean"
  'Float on the ocean'

#+end_src

Strings written with single or double quotes behave very much the same‚Äîthe only difference is in which type of quote you need to escape inside of them. Backtick-quoted strings, usually called *template literals*, can do a few more tricks. Apart from being able to span lines, they can also embed other values.

When you write something inside ~${}~ in a template literal, its result will be computed, converted to a string, and included at that position.

#+begin_src javascript

  `half of 100 is ${100 / 2}`
  // ‚Äúhalf of 100 is 50‚Äù.

#+end_src

***** Scape character
Whenever a backslash ( ~\~ ) is found inside quoted text, it indicates that the character after it has a special meaning. This is called *escaping* the character. A quote that is preceded by a backslash will not end the string but be part of it. When an ~n~ character occurs after a backslash, it is interpreted as a newline. Similarly, a ~t~ after a backslash means a tab character.

*Newlines* can be included without escaping only when the string is quoted with backticks ( ~`~ ).

#+begin_src javascript

  "This is the first line\nAnd this is the second"
  // This is the first line
  // And this is the second


  "A newline character is written like \"\\n\"."
  // ‚ÄúA newline character is written like "\n".‚Äù

#+end_src

***** Concatenate of strings
Strings cannot be divided, multiplied, or subtracted, but the ~+~ operator can be used on them. It does not add, but it *concatenates* ‚Äî it glues two strings together.

#+begin_src javascript

  "con" + "cat" + "e" + "nate"
  // "concatenate"

#+end_src

***** Comparison of strings
Strings can be compared. The way strings are ordered is roughly alphabetic but not really what you‚Äôd expect to see in a dictionary: uppercase letters are always ‚Äúless‚Äù than lowercase ones, so "Z" < "a", and nonalphabetic characters (!, -, and so on) are also included in the ordering. When comparing strings, JavaScript goes over the characters from left to right, comparing the Unicode codes one by one.

#+begin_src javascript

  console.log("Aardvark" < "Zoroaster")
  // ‚Üí true

#+end_src

***** Strings and character codes
JavaScript strings are encoded as a sequence of 16-bit numbers. These are called *code units*. A Unicode character code was initially supposed to fit within such a unit (which gives you a little over 65,000 characters). When it became clear that wasn‚Äôt going to be enough, many people balked at the need to use more memory per character. To address these concerns, UTF-16, the format used by JavaScript strings, was invented. It describes most common characters using a single 16-bit code unit but uses a pair of two such units for others.

UTF-16 is generally considered a bad idea today. It seems almost intentionally designed to invite mistakes. It‚Äôs easy to write programs that pretend code units and characters are the same thing. And if your language doesn‚Äôt use two-unit characters, that will appear to work just fine. But as soon as someone tries to use such a program with some less common Chinese characters, it breaks. Fortunately, with the advent of emoji, everybody has started using two-unit characters, and the burden of dealing with such problems is more fairly distributed.

Unfortunately, obvious operations on JavaScript strings, such as getting their length through the ~length~ property and accessing their content using square brackets, deal only with code units.

#+begin_src javascript

  // Two emoji characters, horse and shoe
  // üê¥ -> Unicode U+1F434  / CodePoint DECimal 128052
  let horseShoe = "üê¥üëü";
  console.log(horseShoe.length);
  // ‚Üí 4
  console.log(horseShoe[0]);
  // ‚Üí ÔøΩ (Invalid half-character)
  console.log(horseShoe.charCodeAt(0));
  // ‚Üí 55357 (Code of the half-character)
  console.log(horseShoe.codePointAt(0));
  // ‚Üí 128052 (Actual code for horse emoji) (Code Point DECimal)
  console.log(horseShoe.codePointAt(1));
  // ‚Üí 56372

  console.log(horseShoe.codePointAt(2));
  // ‚Üí 128095 (Actual code for shoe emoji) (Code Point DECimal)
  console.log(horseShoe.codePointAt(3));
  // ‚Üí 56372
  console.log(horseShoe.codePointAt(4));
  // ‚Üí undefined

  // Two normal characters, a and b
  // a -> Unicode U+0061 / Code Point DECimal 97
  let normalChar = "ab";
  console.log(normalChar.length);
  // ‚Üí 2
  console.log(normalChar[0]);
  // ‚Üí a
  console.log(normalChar.charCodeAt(0));
  // ‚Üí 97
  console.log(normalChar.codePointAt(0));
  // ‚Üí 97

#+end_src

JavaScript‚Äôs ~charCodeAt~ method gives you a code unit, not a full character code. The ~codePointAt~ method, added later, does give a full Unicode character. So we could use that to get characters from a string. But the argument passed to ~codePointAt~ is still an index into the sequence of code units. So to run over all characters in a string, we‚Äôd still need to deal with the question of whether a character takes up one or two code units.

Like ~codePointAt~, the ~for/of~ loop was introduced at a time where people were acutely aware of the problems with UTF-16. When you use it to loop over a string, it gives you real characters, not code units.

#+begin_src javascript

  let roseDragon = "üåπüêâ";
  for (let char of roseDragon) {
      console.log(char);
  }
  // ‚Üí üåπ
  // ‚Üí üêâ

#+end_src

If you have a character (which will be a string of one or two code units), you can use ~codePointAt(0)~ to get its code.

**** Special numbers
***** Infinity
There are three special values in JavaScript that are considered numbers but don‚Äôt behave like normal numbers.

The first two are ~Infinity~ and ~-Infinity~, which represent the positive and negative infinities. Don‚Äôt put too much trust in infinity-based computation, though. It isn‚Äôt mathematically sound, and it will quickly lead to the next special number: ~NaN~.

#+begin_src javascript

  console.log(Infinity - 1)
  // Infinity

#+end_src

***** NaN
~NaN~ stands for ‚Äúnot a number‚Äù, even though it is a value of the number type. You‚Äôll get this result when you, for example, try to calculate ~0 / 0~ (zero divided by zero), ~Infinity - Infinity~, or any number of other numeric operations that don‚Äôt yield a meaningful result.

This is the only one value in JavaScript that is not equal to itself. ~NaN~ is supposed to denote the result of a nonsensical computation, and as such, it isn‚Äôt equal to the result of any other nonsensical computations.

#+begin_src javascript

  console.log(NaN == NaN)
  // ‚Üí false

#+end_src

** Arithmetic
When operators appear together without parentheses, the order in which they are applied is determined by the *precedence* of the operators. The ~/~ operator has the same precedence as ~*~ . Likewise for ~+~ and ~-~ . When multiple operators with the same precedence appear next to each other, as in ~1 - 2 + 1~ , they are applied left to right: ~(1 - 2) + 1~ . The remainder operator‚Äôs (modulo) precedence is the same as that of multiplication and division.

These rules of precedence are not something you should worry about. When in doubt, just add parentheses.

** Comparison
*** > , <
The ~>~ and ~<~ signs are the traditional symbols for ‚Äúis greater than‚Äù and ‚Äúis less than‚Äù, respectively. They are binary operators. Applying them results in a Boolean value that indicates whether they hold true in this case.

#+begin_src javascript

  console.log(3 > 2)
  // ‚Üí true
  console.log(3 < 2)
  // ‚Üí false

#+end_src

*** Strings comparison
[[Strings]] can be compared in the same way. The way strings are ordered is roughly alphabetic but not really what you‚Äôd expect to see in a dictionary: uppercase letters are always ‚Äúless‚Äù than lowercase ones, so "Z" < "a", and nonalphabetic characters (!, -, and so on) are also included in the ordering. When comparing strings, JavaScript goes over the characters from left to right, comparing the Unicode codes one by one.

#+begin_src javascript

  console.log("Aardvark" < "Zoroaster")
  // ‚Üí true

#+end_src

*** >= , <= , = = , !=
Other operators are ~>=~ (greater than or equal to), ~<=~ (less than or equal to), ~==~ (equal to), and ~!=~ (not equal to).

#+begin_src javascript

  console.log("Itchy" != "Scratchy") // ‚Üí true
  console.log("Apple" == "Orange")   // ‚Üí false

#+end_src

There is only one value in JavaScript that is not equal to itself, and that is [[NaN]] (‚Äúnot a number‚Äù). ~NaN~ is supposed to denote the result of a nonsensical computation, and as such, it isn‚Äôt equal to the result of any other nonsensical computations.

#+begin_src javascript

  console.log(NaN == NaN)
  // ‚Üí false

#+end_src

[[Mutability][Note]]: when you compare objects with JavaScript‚Äôs ~==~ operator, it compares by identity: it will produce ~true~ only if both objects are precisely the same value. Comparing different objects will return ~false~, even if they have identical properties.

*** = = = , != =
When you do not want any type conversions to happen, there are two additional operators: ~===~ and ~!==~ . The first tests whether a value is precisely equal to the other, and the second tests whether it is not *precisely* equal.

I recommend using the three-character comparison operators defensively to prevent unexpected type conversions from tripping you up. But when you‚Äôre certain the types on both sides will be the same, there is no problem with using the shorter operators.

#+begin_src javascript

  console.log("" === false) // false

#+end_src

*** Same type comparison
When comparing values of the same type using ~==~ , the outcome is easy to predict: you should get true when both values are the same, except in the case of ~NaN~. But when the types differ, JavaScript uses a complicated and confusing set of rules to determine what to do. In most cases, it just tries to convert one of the values to the other value‚Äôs type. However, when ~null~ or ~undefined~ occurs on either side of the operator, it produces true only if both sides are one of ~null~ or ~undefined~.

That behavior is often useful. When you want to test whether a value has a real value instead of ~null~ or ~undefined~, you can compare it to ~null~ with the ~==~ (or ~!=~ ) operator.

#+begin_src javascript

  console.log(null == undefined); // ‚Üí true
  console.log(null == 0);         // ‚Üí false

#+end_src

But what if you want to test whether something refers to the precise value false? Expressions like ~0 = = false~ and ~"" = = false~ are also true because of automatic type conversion.

** Coercion
JavaScript goes out of its way to accept almost any program you give it, even programs that do odd things.

When an operator is applied to the ‚Äúwrong‚Äù type of value, JavaScript will quietly convert that value to the type it needs, using a set of rules that often aren‚Äôt what you want or expect. This is called type *coercion*.

#+begin_src javascript

  console.log(8 * null) // null becomes 0
  // ‚Üí 0
  console.log("5" - 1)  // "5" becomes 5 (from string to number)
  // ‚Üí 4
  console.log("5" + 1)  // + tries string concatenation before numeric addition
  // ‚Üí 51               // 1 is converted to "1" (from number to string)

#+end_src

When something that doesn‚Äôt map to a number in an obvious way (such as ~"five"~ or ~undefined~) is converted to a number, you get the value ~NaN~. Further arithmetic operations on ~NaN~ keep producing ~NaN~, so if you find yourself getting one of those in an unexpected place, look for accidental type conversions.

#+begin_src javascript

  console.log("five" * 2) // ‚Üí NaN
  console.log(false == 0) // ‚Üí true

#+end_src

*Manual type coercion*
Additionally, you may use manual type conversion to compare exactly e.g. strings, numbers or booleans:

#+begin_src javascript

  "" + a == "" + b  // comparing strings
  +a == +b          // comparing numbers
  !a == !b          // comparing booleans

  // the same, but more human-read versions
  String(a) == String(b)
  Number(a) == Number(b)
  Boolean(a) == Boolean(b)

#+end_src

** Logical operators
*** &&
The ~&&~ operator represents logical *and*. It is a binary operator, and its result is true only if both the values given to it are true.

#+begin_src javascript

  console.log(true && false) // ‚Üí false
  console.log(true && true)  // ‚Üí true

#+end_src

*** ||
The ~||~ operator denotes logical *or*. It produces true if either of the values given to it is true.

#+begin_src javascript

  console.log(false || true)  // ‚Üí true
  console.log(false || false) // ‚Üí false

#+end_src

*** !
*Not* is written as an exclamation mark ( ~!~ ). It is a unary operator that flips the value given to it.

#+begin_src javascript

  console.log(!true)  // ‚Üí false
  console.log(!false) // ‚Üí true

#+end_src

*** Mixing
When *mixing* these Boolean operators with arithmetic and other operators, it is not always obvious when parentheses are needed. In practice, you can usually get by with knowing that of the operators we have seen so far, ~||~ has the lowest precedence, then comes ~&&~, then the comparison operators ( ~>~ , ~==~ , and so on), and then the rest. This order has been chosen such that, in typical expressions like the following one, as few parentheses as possible are necessary:

#+begin_src javascript

  1 + 1 == 2 && 10 * 10 > 50

#+end_src

*** Conditional operator ( ?: )
This logical operator is not unary, not binary, but *ternary*, operating on three values. The value on the left of the question mark ‚Äúpicks‚Äù which of the other two values will come out. When it is true, it chooses the middle value, and when it is false, it chooses the value on the right. An important property of this operator is that the part to their right is evaluated only when necessary.

#+begin_src javascript

  console.log(true ? 1 : 2);
  // ‚Üí 1
  console.log(false ? 1 : 2);
  // ‚Üí 2


  // Conditional chains
  // The ternary operator is right-associative, which means it can be
  // "chained" in the following way, similar to an if ‚Ä¶ else if ‚Ä¶ else if ‚Ä¶
  // else chain:
  function example() {
      return condition1 ? value1
          : condition2 ? value2
          : condition3 ? value3
          : value4;
  }
  // This is equivalent to the following if...else chain.
  function example() {
      if (condition1) {
          return value1;
      } else if (condition2) {
          return value2;
      } else if (condition3) {
          return value3;
      } else {
          return value4;
      }
  }

#+end_src

*Example of good use of the ternary operator*:
Tabbed panels are widely used in user interfaces. They allow you to select an interface panel by choosing from a number of tabs ‚Äústicking out‚Äù above an element.

In this exercise you must implement a simple tabbed interface. Write a function, ~asTabs~, that takes a DOM node and creates a tabbed interface showing the child elements of that node. It should insert a list of ~<button>~ elements at the top of the node, one for each child element, containing text retrieved from the ~data-tabname~ attribute of the child. All but one of the original children should be hidden (given a ~display~ style of ~none~). The currently visible node can be selected by clicking the buttons.

When that works, extend it to style the button for the currently selected tab differently so that it is obvious which tab is selected.

#+begin_src javascript

  <!doctype html>

  <tab-panel>
    <div data-tabname="one">Tab one</div>
    <div data-tabname="two">Tab two</div>
    <div data-tabname="three">Tab three</div>
  </tab-panel>
  <script>
  function asTabs(node) {

    let tabs = Array.from(node.children).map(node => {
        let button = document.createElement("button");
        button.textContent = node.getAttribute("data-tabname");
        let tab = {node, button};
        button.addEventListener("click", () => selectTab(tab));
        return tab;
    });

    let tabList = document.createElement("div");
    for (let {button} of tabs) tabList.appendChild(button);
    node.insertBefore(tabList, node.firstChild);

        // Use of the ternary operator:
        function selectTab(selectedTab) {
            for (let tab of tabs) {
                let selected = tab == selectedTab;
                tab.node.style.display = selected ? "" : "none";
                tab.button.style.color = selected ? "red" : "";
            }
        }
        selectTab(tabs[0]);
    }

  asTabs(document.querySelector("tab-panel"));
  </script>

#+end_src

*** Nullish coalescing operator (??)
Is a logical operator that returns its right-hand side operand when its left-hand side operand is ~null~ or ~undefined~, and otherwise returns its left-hand side operand.

#+begin_src javascript

  const foo = null ?? 'default string';
  console.log(foo);  // "default string"

  const baz = 0 ?? 42;
  console.log(baz); // 0

#+end_src

*** Short-circuiting of logical operators
The logical operators ~&&~ and ~||~ handle values of different types in a peculiar way. They will convert the value on their left side to Boolean type in order to decide what to do, but depending on the operator and the result of that conversion, they will return either the original left-hand value or the right-hand value.

The ~||~ operator, will return the value to its left when that can be converted to true and will return the value on its right otherwise. This has the expected effect when the values are Boolean and does something analogous for values of other types.

#+begin_src javascript

  console.log(null || "user")    // ‚Üí user
  console.log("Agnes" || "user") // ‚Üí Agnes

#+end_src

The rules for converting strings and numbers to Boolean values state that ~0~, ~NaN~, and the empty string ( ~""~ ) count as *false*, while all the other values count as *true*.

The ~&&~ operator works similarly but the other way around. When the value to its left is something that converts to false, it returns that value, and otherwise it returns the value on its right.

Another important property of these two operators is that the part to their right is evaluated only when necessary. In the case of ~true || X~, no matter what ~X~ is‚Äîeven if it‚Äôs a piece of program that does something terrible‚Äîthe result will be true, and ~X~ is never evaluated. The same goes for ~false && X~, which is false and will ignore ~X~.

The [[Conditional operator ( ?: )][conditional operator]] works in a similar way. Of the second and third values, only the one that is selected is evaluated.

** Assignment operators
JavaScript provides a shortcut for updating bindings.

#+begin_src javascript

  x++
  // the increment operator increments and returns the value before incrementing
  ++x
  // the increment operator increments and returns the value after incrementing

  counter = counter + 1;
  counter += 1;
  counter++

  result = result * 2;
  result *= 2;

  x = x / y
  x /= y


  let counter = 0;
  console.log(counter);   // 0
  console.log(counter++); // 0
  console.log(counter);   // 1

  let counter2 = 0;
  console.log(counter2);   // 0
  console.log(++counter2); // 1
  console.log(counter2);   // 1

#+end_src

** Comma operator (,)
Evaluates each of its operands (from left to right) and returns the value of the last operand.

You can use the comma operator when you want to include multiple expressions in a location that requires a single expression. The most common usage of this operator is to supply multiple updaters in a ~for~ loop. For an idiom allowing multiple statements in a location that requires a single expression, you may use an [[IIFE]].

Because all expressions except the last are evaluated and then discarded, these expressions must have side effects to be useful. Common expressions that have side effects are assignments, function calls, and ~++~ and ~--~ operators.

The comma operator has the lowest precedence of all operators. If you want to incorporate a comma-joined expression into a bigger expression, you must parenthesize it.

#+begin_src javascript

  // Syntax:
  expr1, expr2, expr3/* , ‚Ä¶ */


  let x = 1;

  x = (x++, x);
  console.log(x); // 2

  x = (2, 3);
  console.log(x); // 3


  // The comma operator increments i and decrements j at once.
  for (let i = 0, j = 9; i <= 9; i++, j--) { ... }


  // Processing and then returning
  function myFunc() {
    let x = 0;

    return (x += 1, x); // the same as return ++x;
  }


  // The following example uses a single map() to get both the sum of an
  // array and the squares of its elements, which would otherwise require
  // two iterations, one with reduce() and one with map():
  let sum = 0;
  const squares = [1, 2, 3, 4, 5].map((x) => ((sum += x), x * x));
  console.log(squares); // [1, 4, 9, 16, 25]
  console.log(sum); // 15

#+end_src

*Discarding reference binding*
The comma operator always returns the last expression as a /value/ instead of a /reference/. This causes some contextual information such as the ~this~ binding to be lost. For example, a property access returns a reference to the function, which also remembers the *object that it's accessed on*, so that calling the property works properly. If the method is returned from a comma expression, then the function is called as if it's a *new function value*, and ~this~ is ~undefined~.

#+begin_src javascript

  const obj = {
    value: "obj",
    method() {
      console.log(this.value);
    },
  };

  obj.method(); // "obj"
  (obj.method)(); // "obj" (the grouping operator still returns the reference)
  (0, obj.method)(); // undefined (the comma operator returns a new value)

  #+end_src

** Strict mode
*** Brief
JavaScript's strict mode is a way to opt in to a restricted variant of JavaScript, thereby implicitly opting-out of "sloppy mode" (non-strict mode).

A /Use Strict Directive/ is a directive in a Directive Prologue whose string literal is either the exact character sequences ~"use strict"~ or ~'use strict'~. A Use Strict Directive may not contain an escape sequence or line continuation. This directive is used for *specifying a strict mode* of a code unit.

So, to define a strict mode of some code unit we use simply:

#+begin_src javascript

  "use strict";
  // implementation of a module

#+end_src

*Warning*: remember to put ( ~;~ ) at the end of the ~"use strict";~ directive, this avoids some syntax error like when calling the IIFE function.

#+begin_src javascript

  "use strict"
  (function () { })(); // TypeError: "use strict" is not a function

#+end_src

Strict mode makes several changes to normal JavaScript semantics:

1. *Eliminates* some JavaScript *silent errors* by changing them to throw errors.
2. *Fixes mistakes* that make it difficult for JavaScript engines to perform *optimizations*: strict mode code can sometimes be made to run faster than identical code that's not strict mode.
3. *Prohibits* some *syntax* likely to be defined in future versions of ECMAScript.

*** Strictness scope
Strict mode applies to *entire scripts* or to *individual functions*. It doesn't apply to block statements enclosed in ~{}~ braces; attempting to apply it to such contexts does nothing. ~eval~ code, ~Function~ code, event handler attributes, strings passed to ~setTimeout()~, and related functions are either function bodies or entire scripts, and invoking strict mode in them works as expected.

#+begin_src javascript

  // Use strict mode only for the foo function:
  var eval = 10;   // OK

  function foo() {
      "use strict";
      alert(eval); // 10
      eval = 20;   // SyntaxError (eval not allowed for assignment)
  }

  foo();

#+end_src

The affecting of a strict mode *prolongs to all inner contexts*. I.e. the context code is a strict code if either its context or any surrounding context contains a Use Strict Directive.

#+begin_src javascript

  // define strict mode in the global context, i.e. for the whole program
  "use strict";

  (function foo() {
      // strictness is "inherited" from the global context
      eval = 10; // SyntaxError
      (function bar() {
          // the same - from the global context
          arguments = 10; // SyntaxError
      })();
  })();

#+end_src

At the same time a strict mode *is specified lexically* (statically) for a context ‚Äî just as a closure ‚Äî *where this context is created, but not executed*. I.e. the strictness of the context being called is not dependent on the strictness of a caller:

#+begin_src javascript

  // globally use a non-strict mode

  var foo = (function () {
      "use strict";
      return function () {
          alert(this);
      };
  })();

  function bar() {
      alert(this);
  }

  // for both functions, a caller is the global context

  // but "foo" is evaluated in the strict mode
  foo(); // undefined

  // meanwhile "bar" is not
  bar(); // object

#+end_src

The entire contents of *JavaScript modules* are automatically in strict mode, with no statement needed to initiate it.

All parts of a [[Class body][class's body]] are strict mode code, including both class declarations and class expressions.

Functions created via the ~Function~ constructor do not inherit the strictness from the surrounding context.

The ~"use strict"~ directive can only be applied to the body of functions with simple parameters. Using ~"use strict"~ in functions with rest, default, or destructured parameters is a syntax error.

#+begin_src javascript

  function sum(a = 1, b = 2) {
    // SyntaxError: "use strict" not allowed in function with default parameter
    "use strict";
    return a + b;
  }

#+end_src

*** Strict mode restrictions
**** Future reserved keywords
The following set of identifiers is classified as future reserved keywords and cannot be used as variable or function names: ~implements~, ~interface~, ~let~, ~package~, ~private~, ~protected~, ~public~, ~static~, and ~yield~.

#+begin_src javascript

  // non-strict mode
  var l–µt = 10; // OK
  console.log(l–µt); // 10


  "use strict";
  var let = 10; // SyntaxError

#+end_src

*Restrictions names and identifiers*
In strict mode these names ‚Äî ~eval~ and ~arguments~ are treated as kind of ‚Äúkeywords‚Äù (while they are not) and not allowed in several cases.

~callee~ and ~caller~ identifiers because of some security reasons have been restricted.

**** Assignment to an undeclared identifier
As we know, in ES3 assignment to an undeclared identifier creates a new property of the global object (which are often confused with global variables). This causes also well-known issue related with unintentional polluting of the global scope:

#+begin_src javascript

  // non-strict mode

  (function foo() {
      // local vars
      var x = y = 20;
  })();

  // unfortunately, "y" wasn't local
  // for "foo" function
  console.log(y); // 20
  console.log(x); // "x" is not defined

#+end_src

In strict mode this feature has been removed:

#+begin_src javascript

  "use strict";
  a = 10; // ReferenceError

  var x = y = 20; // also a ReferenceError

#+end_src

**** Duplications
Duplications of formal parameters of functions are restricted.

#+begin_src javascript

  "use strict";
  function foo(x, x) {} // SyntaxError


  function sum(a, a, c) {
      // syntax error
      "use strict";
      return a + a + c; // wrong if this code ran
  }

#+end_src

**** ~this~ value restrictions
In the strict mode, a ~this~ value *is not automatically coerced to an object*. A ~this~ value of ~null~ or ~undefined~ is not converted to the global object and primitive values are not converted to wrapper objects. The ~this~ value passed via a function call (including calls made using ~Function.prototype.apply~ and ~Function.prototype.call~) do not coerce the passed ~this~ value to an object:

#+begin_src javascript

  "use strict";
  // undefined "this" value, but not the global object
  function foo() {
      console.log(this);
  }

  foo();                // undefined  // global in non-strict mode

  // "this" is a primitive
  Number.prototype.test = function () {
      console.log(this);
  };

  1..test();            // 1          // [Number: 1] in non-strict mode

  foo.call(null);       // null       // global in non-strict mode
  foo.apply(undefined); // undefined  // global in non-strict mode

  foo.apply({});        // {}         // {} in non-strict mode

#+end_src

~undefined~ value for ~this~ can help to avoid cases with using constructors, forgetting ~new~ keyword:

#+begin_src javascript

  // non-strict
  function A(x) {
      this.x = x;
  }

  var a = A(10); // forget "new" keyword
  console.log(a); // undefined
  // "a" is undefined, because exactly this value
  // is returned implicitly from the A function

  console.log(x); // 10
  // created "x" property of the global object, because "this"
  // is coerced to global object in the non-strict in such case


  // In strict mode, an exception is thrown.
  "use strict";
  var a = A(10); // error
  var b = new A(10); // OK

#+end_src

**** Strict with properties attributes
***** Assignment to read-only properties
If a property being either a data property with ~[[Writable]]~ attribute set to ~false~ or an accessor property without a ~[[Set]]~ method. In the following example a ~TypeError~ should be thrown:

#+begin_src javascript

  "use strict";

  var foo = Object.defineProperties({}, {
      bar: {
          value: 10,
          writable: false // by default
      },
      baz: {
          get: function () {
              return "baz is read-only";
          }
      }
  });

  foo.bar = 20; // TypeError
  foo.baz = 30; // TypeError

#+end_src

However, if a property is configurable, then we can change it via [[Object.defineProperty]]:

#+begin_src javascript

  "use strict";

  var foo = Object.defineProperty({}, "bar", {
      value: 10,
      writable: false, // read-only
      configurable: true // but still configurable
  });

  // change the value
  Object.defineProperty(foo, "bar", {
      value: 20
  });

  console.log(foo.bar); // OK, 20

  // but still can't via assignment

  foo.bar = 30; // TypeError

#+end_src

***** Shadowing inherited read-only properties
If we try to shadow some read-only inherited property via assignment we also get ~TypeError~. And again, if we shadow the property via [[Object.defineProperty]] it‚Äôs made normally ‚Äî thus, a ~configurable~ attribute of the inherited property doesn‚Äôt matter in this case:

In ES3 and non-strict ES5 such assignments to read-only properties failure silently.

#+begin_src javascript

  "use strict";

  var foo = Object.defineProperty({}, "x", {
      value: 10,
      writable: false
  });

  // "bar" inherits from "foo"

  var bar = Object.create(foo);

  console.log(bar.x); // 10, inherited

  // try to shadow "x" via assignment

  bar.x = 20; // TypeError
  console.log(bar.x); // still 10, if non-strict mode

  // however shadowing works if we use "Object.defineProperty"
  Object.defineProperty(bar, "x", { // OK
      value: 20
  });

  console.log(bar.x); // 20

#+end_src

***** Creating a new property of non-extensible objects
Restricted assignment also relates to augmenting non-extensible objects, i.e. objects having ~[[Extensible]]~ property as false:

#+begin_src javascript

  "use strict";

  var foo = {};
  foo.bar = 20; // OK

  Object.preventExtensions(foo);
  foo.baz = 30; // TypeError

#+end_src

*****  ~delete~ operator restrictions
Applied in a strict code, ~delete~ operator cannot remove non-configurable properties (i.e. properties having ~[[Configurable]]~ attribute as ~false~) and provides ~SyntaxError~ or ~TypeError~ depending on the case.

Actually, a variable, function argument, or function couldn‚Äôt be deleted also in ES3 (except the ~eval~ context). Here, in strict mode, ~delete~ additionally provides errors (including deleting in the ~eval~ context):

#+begin_src javascript

  "use strict";

  var foo = {};

  function bar(x) {
      delete x; // SyntaxError
  }

  bar(10);  // SyntaxError

  delete foo; // SyntaxError
  delete bar; // SyntaxError

  Object.defineProperty(foo, "baz", {
      value: 10,
      configurable: false
  });

  // but when delete a property, then TypeError

  delete foo.baz; // TypeError

  // SyntaxError
  eval("var x = 10; delete x;"); // in non-strict is OK

#+end_src

There is another subtle case related with the delete operator in strict mode. According to 11.4.1 The ~delete~ Operator, it‚Äôs not possible in the strict mode to delete a binding of an environment record regardless the state of its ~[[Configurable]]~ attribute. Bindings of environment records are variables, function declarations, formal parameters or simple properties of e.g. global object. Thus, we have:

#+begin_src javascript

  "use strict";

  var foo = 10;
  delete foo; // SyntaxError, [[Configurable]] == false

  this.bar = 20; // OK
  delete this.bar; // OK, [[Configurable]] == true

  // However, if we try to delete it without specifying the base,
  // we have again a SynaxError according to step 5-a of the 11.4.1

  this.baz = 30; // OK
  delete baz; // SyntaxError
  delete this.baz; // OK

#+end_src

*** Strict mode execution context
**** Syntax errors (entering the execution context)
When adding ~'use strict';~, the following cases will throw a ~SyntaxError~ before the script is executing:

- Octal syntax ~const n = 023;~
- ~with~ statement
- Using ~delete~ on a variable name ~delete myVariable;~
- Using ~eval~ or ~arguments~ as variable or function argument name
- Using one of the newly reserved keywords (in prevision for future language features): ~implements~, ~interface~, ~let~, ~package~, ~private~, ~protected~, ~public~, ~static~, and ~yield~
- Declaring two function parameters with the same name ~function f(a, b, b) {}~
- Declaring the same property name twice in an object literal ~{a: 1, b: 3, a: 7}~. This constraint was later removed (bug 1041128).

These errors are good, because they reveal plain errors or bad practices. They occur before the code is running, so they are easily discoverable as long as the code gets parsed by the runtime.

**** New runtime errors (code execution)
- Assigning to an undeclared variable throws a ~ReferenceError~. This used to set a property on the global object, which is rarely the expected effect. If you really want to set a value to the global object, explicitly assign it as a property on ~globalThis~.
- Failing to assign to an object's property (e.g. it's read-only) throws a ~TypeError~. In sloppy mode (non-strict mode), this would silently fail.
- Deleting a non-deletable property throws a ~TypeError~. In sloppy mode, this would silently fail.
- Accessing ~arguments.callee~, ~strictFunction.caller~, or ~strictFunction.arguments~ throws a ~TypeError~ if the function is in strict mode. If you are using ~arguments.callee~ to call the function recursively, you can use a named function expression instead.

* Program structure
** Expressions
*A fragment of code that produces a value is called an expression*. Every value that is written literally (such as ~22~ or ~"psychoanalysis"~) is an expression. An expression between parentheses is also an expression, as is a binary operator applied to two expressions or a unary operator applied to one.

*Note*: When a function produces a value, it is said to return that value. *Anything that produces a value is an expression in JavaScript*, which means function calls can be used within larger expressions. Here ~Math.max~, is used as part of a plus expression:

#+begin_src javascript

  console.log(Math.min(2, 4) + 100); // ‚Üí 102

#+end_src

*Wikipedia*
Expressions are often contrasted with statements‚Äîsyntactic entities that have no value (an instruction).

A distinction is often made between statements, which are executed, and expressions, which are evaluated. Expressions always evaluate to a value, which statements do not. However, expressions are often used as part of a larger statement.

*MDN*
At a high level, an expression is a *valid unit of code that resolves to a value*. There are two types of expressions: those that have side effects (such as assigning values) and those that purely evaluate.

The expression ~x = 7~ is an example of the first type. This expression uses the ~=~ operator to assign the value seven to the variable ~x~. The expression itself evaluates to ~7~.

The expression ~3 + 4~ is an example of the second type. This expression uses the ~+~ operator to add ~3~ and ~4~ together and produces a value, ~7~. However, if it's not eventually part of a bigger construct (for example, a variable declaration like ~const z = 3 + 4~), its result will be immediately discarded ‚Äî this is usually a programmer mistake because the evaluation doesn't produce any effects.

#+begin_src javascript

  let x = 0;

  function foo(exp) {
      return exp + 3 + x;
  }

  console.log(foo(x = 7)); // 17

#+end_src

** Statement
*** Brief
If an expression corresponds to a sentence fragment, a JavaScript statement corresponds to a full sentence. A program is a list of statements.

The simplest kind of statement is an expression with a semicolon after it.

*Control flow*
When your program contains more than one statement, the statements are executed as if they are a story, from top to bottom.

Here is the rather trivial schematic representation of straight-line control flow:

-------------------->

*Wikipedia*
Is a *syntactic unit of* an imperative programming language that *expresses some action to be carried out*. A program written in such a language is formed by a sequence of one or more statements. A statement may have internal components (e.g. expressions).

Many programming languages (e.g. Ada, Algol 60, C, Java, Pascal) make a distinction between statements and definitions/declarations. A /definition or declaration/ specifies the data on which a program is to operate, while a /statement/ specifies the actions to be taken with that data.

The appearance of a statement (and indeed a program) is determined by its /syntax/ or grammar. The meaning of a statement is determined by its /semantics/.

In most programming languages, a statement can consist of little more than an expression, usually by following the expression with a statement terminator (semicolon). In such a case, while the expression evaluates to a value, the complete statement does not (the expression's value is discarded). For instance, in C, C++, C#, and many similar languages, ~x = y + 1~ is an expression that will set ~x~ to the value of ~y~ plus one, and the whole expression itself will evaluate to the same value that ~x~ is set to. However, ~x = y + 1;~ (note the semicolon at the end) is a statement that will still set ~x~ to the value of ~y~ plus one because the expression within the statement is still evaluated, but the result of the expression is discarded, and the statement itself does not evaluate to any value.

Expressions can also be contained within other expressions. For instance, the expression ~x = y + 1~ contains the expression ~y + 1~, which in turn contains the values ~y~ and ~1~, which are also technically expressions.

Although the previous examples show assignment expressions, some languages do not implement assignment as an expression, but rather as a statement. A notable example of this is Python, where ~=~ is not an operator, but rather just a separator in the assignment statement. Although Python allows multiple assignments as each assignment were an expression, this is simply a special case of the assignment statement built into the language grammar rather than a true expression.

*** Statements and declarations
Statements and declarations. They are two disjoint sets of grammars. The following are *declarations*:

- ~let~
- ~const~
- ~function~
- ~function*~
- ~async function~
- ~async function*~
- ~class~
- ~export~ (Note: it can only appear at the top-level of a module)
- ~import~ (Note: it can only appear at the top-level of a module)

Everything else is a *statement*.

The terms "statement" and "declaration" have a precise meaning in the formal syntax of JavaScript that affects where they may be placed in code. For example, in most control-flow structures, the body only accepts statements ‚Äî such as the two arms of an ~if...else~:

#+begin_src javascript

  if (condition)
      statement1;
  else
      statement2;

  // let declaration is not a statement.
  if (condition)
      let i = 0;  // SyntaxError: Lexical declaration cannot
                  // appear in a single-statement context.

  // It can be inside a block
  if (condition) {
      let i = 0;
  }

  // var is a statement, so you can use it on its own as the if body.
  if (condition)
      var i = 0;

#+end_src

You can see /declarations/ as "*binding identifiers to values*", and /statements/ as "*carrying out actions*".

The fact that ~var~ is a statement instead of a declaration is a special case, because it doesn't follow normal lexical scoping rules and may create side effects ‚Äî in the form of creating global variables, mutating existing ~var~-defined variables, and defining variables that are visible outside of its block (because ~var~-defined variables aren't block-scoped).

*** Block statement
Is used to group zero or more statements. The block is delimited by a pair of braces ("curly braces") and contains a list of zero or more statements and declarations.

Block statement allows you to use multiple statements where JavaScript expects *only one* statement. The opposite behavior is possible using an [[Empty statement][empty statement]], where you provide no statement, although one is required.

In addition, combined with block-scoped declarations like ~let~, ~const~, and ~class~, blocks can *prevent temporary variables from polluting the global namespace*, just like [[IIFE][IIFEs]] do.

#+begin_src javascript

  // Syntax:
  {
      StatementList
  }


  var x = 1;
  let y = 1;

  if (true) {
      var x = 2;
      let y = 2;
  }
  console.log(x); // 2
  console.log(y); // 1

  let z = 1;

  {
      z = 3;
  }
  console.log(z); // 3


  // The same is true of const:
  const c = 1;
  {
      const c = 2;
  }
  console.log(c); // 1; does not throw SyntaxError

  // Note that the block-scoped const c = 2 does not throw a SyntaxError:
  // Identifier 'c' has already been declared because it can be declared
  // uniquely within the block.

#+end_src

*Note*: in non-strict code, function declarations inside blocks behave strangely. Do not use them.

*Using a block statement to encapsulate data*
~let~ and ~const~ declarations are scoped to the containing block. This allows you to hide data from the global scope without wrapping it in a function.

#+begin_src javascript

  let sector;
  {
    // These variables are scoped to this block and are not
    // accessible after the block
    const angle = Math.PI / 3;
    const radius = 10;
    sector = {
      radius,
      angle,
      area: (angle / 2) * radius ** 2,
      perimeter: 2 * radius + angle * radius,
    };
  }
  console.log(sector);
  // {
  //   radius: 10,
  //   angle: 1.0471975511965976,
  //   area: 52.35987755982988,
  //   perimeter: 30.471975511965976
  // }
  console.log(typeof radius); // "undefined"

#+end_src

*** Empty statement
An empty statement is used to provide no statement, although the JavaScript syntax would expect one.

The empty statement is a semicolon ( ~;~ ) indicating that no statement will be executed, even if JavaScript syntax requires one.

The opposite behavior, where you want multiple statements, but JavaScript only allows a single one, is possible using a [[Block statement][block statement]], which combines several statements into a single one.

#+begin_src javascript

  // Syntax:
  ;

  // Empty Statement:
  const array1 = [1, 2, 3];
  // Assign all array values to 0
  for (let i = 0; i < array1.length; array1[i++] = 0) /* empty statement */ ;
  console.log(array1); // Array [0, 0, 0]

  // Single statement:
  for (let i = 0; i < 10; i++) console.log(i);

  // Multiple statement:
  for (let i = 0; i < 10; i++) {
    console.log(i);
    console.log(i ** 2);
  }

#+end_src

** Control flow
*** throw
The ~throw~ statement throws a user-defined exception. Execution of the current function will stop (the statements after ~throw~ won't be executed), and control will be passed to the first ~catch~ block in the call stack. If no ~catch~ block exists among caller functions, the program will terminate.

*Eloquent*: the ~throw~ keyword is used to raise an exception. Catching one is done by wrapping a piece of code in a ~try~ block, followed by the keyword ~catch~. When the code in the ~try~ block causes an exception to be raised, the ~catch~ block is evaluated, with the name in parentheses bound to the exception value. After the ~catch~ block finishes‚Äîor if the ~try~ block finishes without problems‚Äîthe program proceeds beneath the entire ~try/catch~ statement.

The ~Error~ constructor is used to create an exception value. This is a standard JavaScript constructor that creates an object with a ~message~ property. In most JavaScript environments, instances of this constructor also gather information about the call stack that existed when the exception was created, a so-called *stack trace*. This information is stored in the ~stack~ property and can be helpful when trying to debug a problem: it tells us the function where the problem occurred and which functions made the failing call.

*Note*: exceptions are a mechanism that makes it possible for code that runs into a problem to raise (or ~throw~) an exception. An exception can be any value. Raising one somewhat resembles a super-charged return from a function: it jumps out of not just the current function but also its callers, all the way down to the first call that started the current execution. This is called *unwinding the stack*.

*Note*: using ~throw~ with ~try~ and ~catch~, lets you control program flow and generate custom error messages.

*Note*: JavaScript (in a rather glaring omission) doesn‚Äôt provide direct support for selectively catching exceptions: either you catch them all or you don‚Äôt catch any. This makes it tempting to assume that the exception you get is the one you were thinking about when you wrote the ~catch~ block.

The ~try...catch...finally~ statements combo handles errors without stopping JavaScript.
The ~try~ statement defines the code block to run (to try).
The ~catch~ statement defines a code block to handle any error.
The ~finally~ statement defines a code block to run regardless of the result.
The ~throw~ statement defines a custom error.
Both ~catch~ and ~finally~ are optional, but you must use one of them.

#+begin_src javascript

  // Syntax:
  throw expression;


  function getRectArea(width, height) {
      if (isNaN(width) || isNaN(height)) {
          throw new Error('Parameter is not a number!');
      }
  }

  try {
      getRectArea(3, 'A');
  } catch (e) {
      console.error(e);
      // Expected output: Error: Parameter is not a number!
  }


  // Eloquent example:
  function promptDirection(question) {
      let result = prompt(question);
      if (result.toLowerCase() == "left") return "L";
      if (result.toLowerCase() == "right") return "R";
      throw new Error("Invalid direction: " + result);
  }

  function look() {
      if (promptDirection("Which way?") == "L") {
          return "a house";
      } else {
          return "two angry bears";
      }
  }

  try {
      console.log("You see", look());
  } catch (error) {
      console.log("Something went wrong: " + error);
  }
  // Note that the look function completely ignores the possibility that
  // promptDirection might go wrong. This is the big advantage of
  // exceptions: error-handling code is necessary only at the point where
  // the error occurs and at the point where it is handled. The functions
  // in between can forget all about it.

#+end_src

Throwing an exception causes the call stack to be unwound until the next enclosing ~try/catch~ block or until the bottom of the stack. The exception value will be given to the ~catch~ block that catches it, which should verify that it is actually the expected kind of exception and then do something with it. To help address the unpredictable control flow caused by exceptions, [[finally]] blocks can be used to ensure that a piece of code always runs when a block finishes.

*** throw (selective catching)
As a general rule, don‚Äôt blanket-catch exceptions unless it is for the purpose of ‚Äúrouting‚Äù them somewhere‚Äîfor example, over the network to tell another system that our program crashed. And even then, think carefully about how you might be hiding information.

The below ~for (;;)~ construct is a way to intentionally create a loop that doesn‚Äôt terminate on its own. We break out of the loop only when a valid direction is given. But we misspelled ~promptDirection~ ([[throw][example]]) which will result in an ‚Äúundefined variable‚Äù error. Because the ~catch~ block completely ignores its exception value (~e~), assuming it knows what the problem is, it wrongly treats the binding error as indicating bad input. Not only does this cause an infinite loop, it ‚Äúburies‚Äù the useful error message about the misspelled binding.

#+begin_src javascript

  for (;;) {
      try {
          let dir = promtDirection("Where?"); // ‚Üê typo!
          console.log("You chose ", dir);
          break;
      } catch (e) {
          console.log("Not a valid direction. Try again.");
      }
  }

#+end_src

So we want to catch a *specific* kind of exception. We can do this by checking in the ~catch~ block whether the exception we got is the one we are interested in and rethrowing it otherwise. But how do we recognize an exception?

We could compare its ~message~ property against the error message we happen to expect. But that‚Äôs a shaky way to write code‚Äîwe‚Äôd be using information that‚Äôs intended for human consumption (the message) to make a programmatic decision. As soon as someone changes (or translates) the message, the code will stop working.

Rather, let‚Äôs define a new type of error and use ~instanceof~ to identify it.

#+begin_src javascript

  class InputError extends Error {}

  function promptDirection(question) {
      let result = prompt(question);
      if (result.toLowerCase() == "left") return "L";
      if (result.toLowerCase() == "right") return "R";
      throw new InputError("Invalid direction: " + result);
  }

#+end_src

The new error class extends ~Error~. It doesn‚Äôt define its own constructor, which means that it inherits the ~Error~ constructor, which expects a string message as argument. In fact, it doesn‚Äôt define anything at all‚Äîthe class is empty. ~InputError~ objects behave like ~Error~ objects, except that they have a different class by which we can recognize them.

Now the loop can catch these more carefully.

#+begin_src javascript

  for (;;) {
      try {
          let dir = promptDirection("Where?");
          console.log("You chose ", dir);
          break;
      } catch (e) {
          if (e instanceof InputError) {
              console.log("Not a valid direction. Try again.");
          } else {
              throw e;
          }
      }
  }

#+end_src

This will catch only instances of ~InputError~ and let unrelated exceptions through. If you reintroduce the typo, the undefined binding error will be properly reported.

*** try...catch
Is comprised of a ~try~ block and either a ~catch~ block, a ~finally~ block, or both. The code in the ~try~ block is executed first, and if it throws an exception, the code in the ~catch~ block will be executed. The code in the ~finally~ block will always be executed before control flow exits the entire construct.

#+begin_src javascript

  // Syntax
  try {
      // The statements to be executed.
      tryStatements
  } catch (exceptionVar) {
      // Is executed if an exception is thrown in the try block.
      catchStatements
  } finally {
      // Execute regardless of whether an exception was thrown or caught.
      finallyStatements
  }


  // Example:
  try {
    nonExistentFunction();
  } catch (error) {
    console.error(error);
    // Expected output: ReferenceError: nonExistentFunction is not defined
    // (Note: the exact output may be browser-dependent)
  }


  // Can use a destructuring pattern to assign multiple identifiers at once.
  try {
    throw new TypeError("oops");
  } catch ({ name, message }) {
    console.log(name); // "TypeError"
    console.log(message); // "oops"
  }

#+end_src

*Note*: if a ~return~ statement is executed within a ~try~ block, its ~finally~ block, if present, is first executed, before the value is actually returned.

Another feature is returning from closures. In ECMAScript, a ~return~ statement from a closure returns the control flow to a calling context (a caller).

*Dmitry S√≥shnikov*
A ~catch~ clause in order to have access to the parameter-exception creates an *intermediate* scope (like [[Scope for parameters][parameters]]) object with the only property ‚Äî exception parameter name, and places this object in front of the scope chain. Schematically it looks so:

After the work of catch clause is finished, scope chain is also restored to the previous state.

#+begin_src javascript

  try {
      ...
  } catch (ex) {
      alert(ex);
  }

  //Scope chain modification:
  var catchObject = {
      ex: <exception object>
  };

  Scope = catchObject + AO|VO + [[Scope]]

#+end_src

ECMAScript standard return behavior:

#+begin_src javascript

  function getElement() {

      [1, 2, 3].forEach(element => {

          if (element % 2 == 0) {
              // return to "forEach" function,
              // but not return from the getElement
              console.log('found: ' + element); // found: 2
              return element;
          }

      });

      return null;
  }

  console.log(getElement()); // null, but not 2

#+end_src

Though, in ECMAScript in such case throwing and catching of some special ‚Äúbreak‚Äù-exception may help:

#+begin_src javascript

  const $break = {};

  function getElement() {

      try {

          [1, 2, 3].forEach(element => {

              if (element % 2 == 0) {
                  // "return" from the getElement
                  console.log('found: ' + element); // found: 2
                  $break.data = element;
                  throw $break;
              }

          });

      } catch (e) {
          if (e == $break) {
              return $break.data;
          }
      }

      return null;
  }

  console.log(getElement()); // 2

#+end_src

*Note*: ~catch~ clause replaces the running context‚Äôs lexical environment with the newly created one. ~catch~ clause uses declarative record but not the object:

#+begin_src javascript

  var e = 10;

  try {
      throw 20;
  } catch (e) { // replace the environment
      console.log(e); // 20
  }

  // and now it's restored back
  console.log(e); // 10

#+end_src

*** finally
The ~try...catch~ statement is comprised of a ~try~ block and either a ~catch~ block, a ~finally~ block, or both. The code in the ~try~ block is executed first, and if it throws an exception, the code in the ~catch~ block will be executed. The code in the ~finally~ block will always be executed before control flow exits the entire construct.

*Note*: if a ~return~ statement is executed within a ~try~ block, its ~finally~ block, if present, is first executed, before the value is actually returned.

*Eloquent*: a ~finally~ block says ‚Äúno matter *what* happens, run this code after trying to run the code in the ~try~ block.‚Äù

#+begin_src javascript

  // Syntax:
  try {
      tryStatements
  } catch (exceptionVar) {
      catchStatements
  } finally {
      finallyStatements
  }


  // Here is some really bad banking code.
  const accounts = {
      a: 100,
      b: 0,
      c: 20
  };

  function getAccount() {
      let accountName = prompt("Enter an account name");
      if (!accounts.hasOwnProperty(accountName)) {
          throw new Error(`No such account: ${accountName}`);
      }
      return accountName;
  }

  function transfer(from, amount) {
      if (accounts[from] < amount) return;
      accounts[from] -= amount;
      accounts[getAccount()] += amount;
  }
  // transfer first removes the money from the account and then calls
  // getAccount before it adds it to another account. If it is broken off
  // by an exception at that point, it‚Äôll just make the money disappear.

  function transfer(from, amount) {
      if (accounts[from] < amount) return;
      let progress = 0;
      try {
          accounts[from] -= amount;
          progress = 1;
          accounts[getAccount()] += amount;
          progress = 2;
      } finally {
          if (progress == 1) {
              accounts[from] += amount;
          }
      }
  }
  // This version of the function tracks its progress, and if, when
  // leaving, it notices that it was aborted at a point where it had
  // created an inconsistent program state, it repairs the damage it did.

  // Note that even though the finally code is run when an exception is
  // thrown in the try block, it does not interfere with the
  // exception. After the finally block runs, the stack continues
  // unwinding.

#+end_src

*** return
Ends function execution and specifies a value to be returned to the function caller.

The ~return~ statement can only be used within function bodies. When a ~return~ statement is used in a function body, the execution of the function is stopped.

The ~return~ statement has different effects when placed in different functions:

If a ~return~ statement is executed within a ~try~ block, its ~finally~ block, if present, is first executed, before the value is actually returned.

#+begin_src javascript

  // Syntax
  return;
  return expression;


  function getRectArea(width, height) {
      if (width > 0 && height > 0) {
          return width * height;
      }
      return 0;
  }
  console.log(getRectArea(3, 4));  // 12
  console.log(getRectArea(-3, 4)); //  0


  // Returning a function (closures)
  function magic() {
      return function calc(x) {
          return x * 42;
      };
  }

  const answer = magic();
  answer(1337); // 56154

#+end_src

*** break
The ~break~ statement "jumps out" of a loop.

#+begin_src javascript

  // It finds the first number that is both greater
  // than or equal to 20 and divisible by 7.
  for (let current = 20; ; current = current + 1) {
      if (current % 7 == 0) {
          console.log(current);
          break;
      }
  }
  // ‚Üí 21

#+end_src

*** continue
The ~continue~ statement "jumps over" one iteration in the loop.

#+begin_src javascript

  // This example skips the value of 2:
  for (let i = 0; i < 4; i++) {
      if (i === 2) { continue; }
      console.log("The number is " + i);
  }
  // The number is 0
  // The number is 1
  // The number is 3

#+end_src

** Bindings
*** Binding
How does a program keep an internal state? How does it remember things? We have seen how to produce new values from old values, but this does not change the old values, and the new value has to be immediately used or it will dissipate again. To catch and hold values, JavaScript provides a thing called a binding, or variable.

*After a binding has been defined, its name can be used as an expression*. The value of such an expression is the value the binding currently holds.

#+begin_src javascript

  let caught = 5 * 5;
  // Creates a binding called caught and uses it to grab hold of the number
  // that is produced by multiplying 5 by 5.

  console.log(caught * caught);
  // ‚Üí 100

#+end_src

When a binding points at a value, that does not mean it is tied to that value forever. The ~=~ operator can be used at any time on existing bindings to disconnect them from their current value and have them point to a new one.

*You should imagine bindings as tentacles, rather than boxes*. They do not contain values; they grasp them‚Äîtwo bindings can refer to the same value. A program can access only the values that it still has a reference to. When you need to remember something, you grow a tentacle to hold on to it or you reattach one of your existing tentacles to it.

When you define a binding without giving it a value, the tentacle has nothing to grasp, so it ends in thin air. If you ask for the value of an empty binding, you‚Äôll get the value ~undefined~.

*** Rebinding
*Dmitry S√≥shnikov*
A rebinding relates to an identifier. This operation unbinds the identifier (if it was previously bound) from an old object and binds it to another one (to another block of memory). Often (and in ECMAScript in particular) rebinding is implemented via a simple operation of assignment.

Think about bindings not as by-reference, but (from C viewpoint) as by-pointer (or sometimes ‚Äî by-sharing) operation. Often it‚Äôs also called as a special case of by-value where value is an address. Assignment just changes (rebinds) the pointer‚Äôs value (the address) from one memory block to another. And when we assign one variable to another we just copy the address of the same object to the second variable. Now two identifiers are said to share the one object. From here the name ‚Äî [[Call by sharing][by-sharing]].

#+begin_src javascript

  // bind "foo" to {x: 10} object
  var foo = {x: 10};

  console.log(foo.x); // 10

  // bind "bar" to the *same* object as "foo" identifier is bound
  var bar = foo;

  console.log(foo === bar); // true
  console.log(bar.x); // OK, also 10

  // and now rebind "foo" to the new object
  foo = {x: 20};

  console.log(foo.x); // 20

  // and "bar" still points to the old object
  console.log(bar.x); // 10
  console.log(foo === bar); // false

  +-------------------------+    +-----------------------------------+
  |  bar = foo              |    |  foo = {x: 20}                    |
  |      +-----------+      |    |  +-----------+  +-----------+     |
  |      |  {x: 10}  |      |    |  |  {x: 20}  |  |  {x: 10}  |     |
  |      +-----------+      |    |  +-----------+  +-----------+     |
  |         ^      ^        |    |           ^      ^       ^        |
  |        /        \       |    |            \    ‚ï≥         \       |
  |       /          \      |    |             \  ‚ï≥           \      |
  |  +-----+       +-----+  |    |           +-----+        +-----+  |
  |  | foo |       | bar |  |    |           | foo |        | bar |  |
  |  +-----+       +-----+  |    |           +-----+        +-----+  |
  +-------------------------+    +-----------------------------------+

#+end_src

*** Mutation
In contrast with rebinding, the operation of mutation *already affects the content of the object*.

#+begin_src javascript

  // bind an array to the "foo" identifier
  var foo = [1, 2, 3];

  // and here is a *mutation* of the array object contents
  foo.push(4);
  console.log(foo); // 1,2,3,4

  // also mutations
  foo[4] = 5;
  foo[0] = 0;
  console.log(foo); // 0,2,3,4,5

  +---------------+     +-----------------+     +--------------------+
  | foo = [1,2,3] |     | foo.push(4)     |     | foo[4]=5; foo[0]=0 |
  |  +---------+  |     |  +-----------+  |     |  +-------------+   |
  |  | [1,2,3] |  |     |  | [1,2,3,4] |  |     |  | [0,2,3,4,5] |   |
  |  +---------+  |     |  +-----------+  |     |  +-------------+   |
  |       ^       |     |        ^        |     |         ^          |
  |       |       |     |        |        |     |         |          |
  |    +-----+    |     |     +-----+     |     |      +-----+       |
  |    | foo |    |     |     | foo |     |     |      | foo |       |
  |    +-----+    |     |     +-----+     |     |      +-----+       |
  +---------------+     +-----------------+     +--------------------+

#+end_src

*** Hoisting
JavaScript /Hoisting/ refers to the process whereby the interpreter appears to move the declaration of functions, variables, classes, or imports to the top of their scope, prior to execution of the code.

Hoisting is not a term normatively defined in the ECMAScript specification. The spec does define a group of declarations as /HoistableDeclaration/, but this only includes ~function~, ~function*~, ~async function~, and ~async function*~ declarations. Hoisting is often considered a feature of ~var~ declarations as well, although in a different way. In colloquial terms, any of the following behaviors may be regarded as hoisting:

1. Being able to use a variable's value in its scope before the line it is declared. ("Value hoisting")
2. Being able to reference a variable in its scope before the line it is declared, without throwing a ~ReferenceError~, but the value is always ~undefined~. ("Declaration hoisting")
3. The declaration of the variable causes behavior changes in its scope before the line in which it is declared.
4. The side effects of a declaration are produced before evaluating the rest of the code that contains it.

The four function (~function~, ~function*~, ...) declarations above are hoisted with type 1 behavior; ~var~ declaration is hoisted with type 2 behavior; ~let~, ~const~, and ~class~ declarations (also collectively called /lexical declarations/) are hoisted with type 3 behavior; ~import~ declarations are hoisted with type 1 and type 4 behavior.

Some prefer to see ~let~, ~const~, and ~class~ as non-hoisting, because the [[Temporal dead zone (TDZ)][temporal dead zone]] strictly *forbids any use of the variable before its declaration*. This dissent is fine, since hoisting is not a universally-agreed term. However, the temporal dead zone can cause other observable changes in its scope, which suggests there's some form of hoisting:

#+begin_src javascript

  const x = 1;
  {
    console.log(x); // ReferenceError
    const x = 2;
  }

#+end_src

If the ~const x = 2~ declaration is not hoisted at all (as in, it only comes into effect when it's executed), then the ~console.log(x)~ statement should be able to read the ~x~ value from the upper scope. However, because the ~const~ declaration still "taints" the entire scope it's defined in, the ~console.log(x)~ statement reads the ~x~ from the ~const x = 2~ declaration instead, which is not yet initialized, and throws a ~ReferenceError~. Still, it may be more useful to characterize lexical declarations as non-hoisting, because from a utilitarian perspective, the hoisting of these declarations doesn't bring any meaningful features.

*Dmitry S√≥shnikov*
In order not to repeat each time this long ‚Äúthere are two stages of the code handling: (1) [[Entering the execution context][entering the context]], where all the data are created, and (2) the [[Code execution][code execution stage]]‚Äù, often the term ‚Äúhoisting‚Äù is used to describe this behavior (though, it‚Äôs not a standard term). The fact that a function is already available at the moment of the code execution brings the picture, where the function looks like it was hoisted to the top of the context‚Äôs code.

Two main reasons of why this technique can be needed are *mutual recursion* and *optimization*.

So the main rule that a function (or a variable) *should be defined before its usage* ‚Äî in the system with hoisting is done implicitly and in the system without hoisting ‚Äî should be done explicitly by the programmer.

*** Temporal dead zone (TDZ)
A variable declared with ~let~, ~const~, or ~class~ is said to be in a "temporal dead zone" (TDZ) from the start of the block until code execution reaches the place where the variable is declared and initialized.

While inside the TDZ, the variable has not been initialized with a value, and any attempt to access it will result in a ~ReferenceError~. The variable is initialized with a value when execution reaches the place in the code where it was declared. If no initial value was specified with the variable declaration, it will be initialized with a value of ~undefined~.

This differs from ~var~ variables, which will return a value of ~undefined~ if they are accessed before they are declared. The code below demonstrates the different result when ~let~ and ~var~ are accessed in code before the place where they are declared.

*Dmitry S√≥shnikov*: ES6 mentions so called TDZ (stands for Temporal Dead Zone) ‚Äî this is the region of a program, where a variable or a parameter *cannot be accessed until it‚Äôs initialized* (i.e. received a value).

#+begin_src javascript

  {
    // TDZ starts at beginning of scope
    console.log(bar); // "undefined"
    console.log(foo); // ReferenceError: Cannot
                      // access 'foo' before initialization
    var bar = 1;
    let foo = 2; // End of TDZ (for foo)
  }

#+end_src

The term "temporal" is used because the zone *depends on the order of execution (time)* rather than the order in which the code is written (position). For example, the code below works because, even though the function that uses the ~let~ variable appears before the variable is declared, the function is called outside the TDZ.

#+begin_src javascript

  {
    // TDZ starts at beginning of scope
    const func = () => console.log(letVar); // OK

    // Within the TDZ letVar access throws `ReferenceError`

    let letVar = 3; // End of TDZ (for letVar)
    func(); // Called outside TDZ!
  }

#+end_src

Using the ~typeof~ operator for a variable in its TDZ will throw a ~ReferenceError~:

#+begin_src javascript

  {
    typeof i; // ReferenceError: Cannot access 'i' before initialization
    let i = 10;
  }

#+end_src

This differs from using ~typeof~ for undeclared variables, and variables that hold a value of ~undefined~:

#+begin_src javascript

  console.log(typeof undeclaredVariable); // "undefined"

#+end_src

*Note*: ~let~ and ~const~ declarations are only processed when the current script gets processed. If you have two ~<script>~ elements running in script mode within one HTML, the first script is not subject to the TDZ restrictions for top-level ~let~ or ~const~ variables declared in the second script, although if you declare a ~let~ or ~const~ variable in the first script, declaring it again in the second script will cause a redeclaration error.

** Declaring variables
*** var
Bindings declared with ~var~ behave differently‚Äîthey end up in the nearest function scope or the global scope. For example, when is ~var~ declared in the [[for]] loop, it's visible throughout the global scope or inside the function that declares it.

*Note*: variables declared with ~var~ are only *function-scoped*, but not *lexically scoped* (i.e. they can't be scoped to the *loop body*).

*** let
Bindings declared with ~let~ and ~const~ are in fact *local to the block* that they are declared in, so if you create one of those inside of a loop, the code before and after the loop cannot ‚Äúsee‚Äù it. In pre-2015 JavaScript, only functions created new scopes, so old-style bindings, created with the ~var~ keyword, are visible throughout the whole function that they appear in‚Äîor throughout the global scope, if they are not in a function. For example, when is ~var~ declared in the [[for]] loop, it's visible throughout the global scope or inside the function that declares it.

#+begin_src javascript

  // Differences when using scopes, variable declarations and properties:
  let a = 0; // declare variable
  {
      console.log(a); // 0
      a = 5; // overwrites the value declared in a upper scope
      console.log(a); // 5
  }
  console.log(a);     // 5


  let a = 0;
  {
      // console.log(a); // Cannot access 'a' before initialization
                         // a = undefined
      let a = 5; // 'let' creates another variable within the block scope
      console.log(a); // 5
  }
  console.log(a);     // 0


  a = 0; // create property in the global object
  {
      console.log(a); // 0
      a = 5; // overwrites the property in the global object
      console.log(a); // 5
  }
  console.log(a);     // 5

#+end_src


*Note*: ‚Äúit is possible to declare global variables using ~var~ keyword (in the global context) and without using ~var~ keyword (in any place)‚Äù.

It is not so. [[Note about variables, properties, and global object][Remember]]: variables are declared *only* with using ~var~ keyword.

*** const
The word ~const~ stands for constant. It defines a constant binding, which points at the same value for as long as it lives. This is useful for bindings that give a name to a value so that you can easily refer to it later.

** Conditionals
*** if
The ~if~ keyword executes or skips a statement depending on the value of a Boolean expression. The deciding expression is written after the keyword, between parentheses, followed by the statement to execute.

#+begin_src javascript

  // Syntax:
  if (condition) {
      //  block of code to be executed if the condition is true
  }


  // Make a "Good day" greeting if the hour is less than 18:00:
  if (hour < 18) {
      greeting = "Good day";
  }


  // You could have omitted braces, since they hold only a single statement
  if (1 + 1 == 2) console.log("It's true");
  // ‚Üí It's true

#+end_src

*** if...else
The ~if...else~ statement executes a statement if a specified condition is *truthy*. If the condition is *falsy*, another statement in the optional ~else~ clause will be executed.

#+begin_src javascript

  // Syntax:
  if (condition) {
      //  block of code to be executed if the condition is true
  } else {
      //  block of code to be executed if the condition is false
  }

  // When code hold only a single statement:
  if (condition) //code;
      else //code;


          if (hour < 18) {
              greeting = "Good day";
          } else {
              greeting = "Good evening";
          }


  function checkValue(a, b) {
      if (a === 1) {
          if (b === 2) {
              console.log("a is 1 and b is 2");
          }
      } else {
          console.log("a is not 1");
      }
  }

#+end_src

*** else if
Use the ~else if~ statement to specify a new condition if the first condition is false.

#+begin_src javascript

  // Syntax:
  if (condition1) {
      //  block of code to be executed if condition1 is true
  } else if (condition2) {
      // executed if the condition1 is false and condition2 is true
  } else {
      //  executed if the condition1 is false and condition2 is false
  }


  if (num < 10) {
      console.log("Small");
  } else if (num < 100) {
      console.log("Medium");
  } else {
      console.log("Large");
  }

#+end_src

*** switch
The ~switch~ statement evaluates an expression, matching the expression's value against a series of ~case~ clauses, and executes statements after the first ~case~ clause with a matching value, until a ~break~ statement is encountered. The ~default~ clause of a ~switch~ statement will be jumped to if no ~case~ matches the expression's value.

A ~switch~ statement first evaluates its expression. It then looks for the first ~case~ clause whose expression evaluates to the same value as the result of the input expression (using the strict equalityEOF comparison) and transfers control to that clause, *executing all statements following that clause* (at least a ~break~ statement is encountered).

The clause expressions are only evaluated when necessary ‚Äî if a match is already found, subsequent ~case~ clause expressions will not be evaluated, even when they will be visited by fall-through.

It is not necessary to break the last case in a switch block. The block breaks (ends) there anyway.

*Note*: If you omit the break statement, the next case will be executed even if the evaluation does not match the case.

#+begin_src javascript

  // Syntax:
  switch(expression) {
  case caseExpression1:
      // code block
      break;
  case caseExpression2:
      // code block
      break;
  default:
      // code block
  }


  // If today is neither Saturday (6) nor Sunday (0), write a default message:
  switch (new Date().getDay()) {
  case 6:
      text = "Today is Saturday";
      break;
  case 0:
      text = "Today is Sunday";
      break;
  default:
      text = "Looking forward to the Weekend";
  }
  // Looking forward to the Weekend


  switch (prompt("What is the weather like?")) {
  case "rainy":
      console.log("Remember to bring an umbrella.");
      break;
  case "sunny":
      console.log("Dress lightly.");
  case "cloudy":
      console.log("Go outside.");
      break;
  default:
      console.log("Unknown weather type!");
  }
  // In the "sunny" case, this can be used to share some code between cases
  // (it recommends going outside for both sunny and cloudy weather)

#+end_src

*Note*: the next error in ~switch~ statements occurs, because there is only one block.

#+begin_src javascript

  let x = 1;

  switch (x) {
  case 0:
      let foo;
      break;
  case 1:
      let foo; // SyntaxError: Identifier 'foo' has already been declared
      break;
  }

  // To avoid the error, wrap each case in a new block statement.

  let x = 1;

  switch (x) {
  case 0: {
      let foo;
      break;
  }
  case 1: {
      let foo;
      break;
  }
  }

#+end_src

** Iterations
*** while
A statement starting with the keyword ~while~ creates a loop. The word ~while~ is followed by an expression in parentheses and then a statement. The loop keeps entering that statement as long as the expression produces a value that gives true when converted to Boolean.

#+begin_src javascript

  // Syntax:
  while (condition) {
      // code block to be executed
  }


  let number = 0;
  while (number <= 12) {
      console.log(number);
      number = number + 2;
  }
  // ‚Üí 0
  // ‚Üí 2
  //   ‚Ä¶ etcetera

#+end_src

*** do...while
A do loop is a control structure similar to a [[while]] loop. It differs only on one point: a do loop always executes its body at least once, and it starts testing whether it should stop only after that first execution. To reflect this, the test appears after the body of the loop.

#+begin_src javascript

  // Execute a code block once, an then continue if condition is true:
  do {
      code block to be executed
  }
  while (condition);


  let yourName;
  do {
      yourName = prompt("Who are you?");
  } while (!yourName);
  console.log(yourName);
  // This program will force you to enter a name. It will ask again and
  // again until it gets something that is not an empty string. Applying
  // the ! operator will convert a value to Boolean type before negating
  // it, and all strings except "" convert to true. This means the loop
  // continues going round until you provide a non-empty name.

#+end_src

*** for
**** Description
The ~for~ statement creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement (usually a [[Block statement][block statement]]) to be executed in the loop.

The parentheses after a ~for~ keyword must contain two semicolons. The part before the first semicolon *initializes* the loop, usually by defining a binding. The second part is the expression that *checks* whether the loop must continue. The final part *updates* the state of the loop after every iteration. In most cases, this is shorter and clearer than a ~while~ construct.

- initialization (optional) :: an expression (including assignment expressions) or variable declaration *evaluated once before the loop begins*. This expression may optionally declare new variables with ~var~ or ~let~ keywords. Variables declared with ~var~ are not local to the loop, i.e. they are in the same scope the ~for~ loop is in. Variables declared with ~let~ are *local to the statement*. The result of this expression is discarded.

- condition (optional) :: an expression to be *evaluated before each loop iteration*. If this expression evaluates to true, ~statement~ is executed. If the expression evaluates to false, execution exits the loop and goes to the first statement after the ~for~ construct. This conditional test is optional. If omitted, the condition always evaluates to true.

- afterthought (optional) :: an expression to be *evaluated at the end of each loop iteration*. This occurs before the next evaluation of ~condition~.

#+begin_src javascript

  for (initialization; condition; afterthought) {
      statement;
  }

  // Equivalent command when it has only one statement.
  for (initialization; condition; afterthought) statement;

  // The general loop algorithm works like this:
  for (initialization; condition; afterthought) statement;
  // run begin
  let i = ...
  if (condition) { body; afterthought }
  if (condition) { body; afterthought }
  if (condition) { body; afterthought }


  // This code calculates 2 to 10.
  let result = 1;
  for (let counter = 0; counter < 10; counter = counter + 1) {
      result = result * 2;
  }
  console.log(result);
  // ‚Üí 1024


  for (;;) {
      // The for (;;) construct is a way to intentionally create a loop that
      // doesn‚Äôt terminate on its own (need a break keyword).
  }


  // Empty Statement:
  const array1 = [1, 2, 3];
  // Assign all array values to 0
  for (let i = 0; i < array1.length; array1[i++] = 0) /* empty statement */ ;
  console.log(array1); // Array [0, 0, 0]


  // The comma operator increments i and decrements j at once.
  for (let i = 0, j = 9; i <= 9; i++, j--) { ... }

#+end_src

Like other looping statements, you can use control flow statements inside ~statement~:

- [[break]] stops ~statement~ execution and goes to the first statement after the loop.
- [[continue]] stops ~statement~ execution and re-evaluates ~afterthought~ then ~condition~.

**** Lexical declarations in the initialization block
Declaring a variable within the initialization block has important differences from declaring it in the upper scope, especially when creating a closure within the loop body.

#+begin_src javascript

  for (let i = 0; i < 3; i++) {
    setTimeout(() => {
      console.log(i);
    }, 1000);
  }

#+end_src

It logs ~0~, ~1~, and ~2~, as expected. However, if the variable is defined in the upper scope:

#+begin_src javascript

  let i = 0;
  for (; i < 3; i++) {
    setTimeout(() => {
      console.log(i);
    }, 1000);
  }

#+end_src

It logs ~3~, ~3~, and ~3~. The reason is that each ~setTimeout~ creates a *new closure that closes over* the ~i~ variable, but if the ~i~ is *not scoped to the loop body*, all closures will reference the same variable when they eventually get called ‚Äî and due to the *asynchronous* nature of [[window.setTimeout()][setTimeout()]], it will happen *after the loop has already exited*, causing the value of ~i~ in all queued callbacks' bodies to have the value of ~3~.

This also happens if you use a ~var~ statement as the initialization, because variables declared with ~var~ are *only function-scoped*, but *not lexically scoped* (i.e. they *can't* be scoped to the *loop body*).

#+begin_src javascript

  for (var i = 0; i < 3; i++) {
    setTimeout(() => {
      console.log(i);
    }, 1000);
  }
  // Logs 3, 3, 3

#+end_src

The scoping effect of the initialization block can be understood as if the *declaration happens within the loop body*, but just happens to be accessible within the ~condition~ and ~afterthought~ parts. More precisely, ~let~ declarations are special-cased by ~for~ loops ‚Äî if ~initialization~ is a ~let~ declaration, then *every time*, *after the loop body is evaluated*, the following happens:

1. A *new lexical scope* is created with new ~let~-declared variables.
2. The *binding values from the last iteration* are used to re-initialize the new variables.
3. ~afterthought~ is *evaluated in the new scope*.

So re-assigning the new variables within ~afterthought~ does *not affect* the bindings from the *previous iteration*.

A new lexical scope is also created *after* ~initialization~, *just before* ~condition~ is evaluated for the *first time*. These details can be observed by creating closures, which allow to get hold of a binding at any particular point.

*Note*: the parameters also use an *intermediate scope* type. The [[Scope for parameters][parameters]] header has a more precise explanation of this behavior.

Here are detailed [[Scope behaviors in the for loop][examples]] of the ~for~ loop with ~let~ (shows scopes and order tracking).

For example, in this code a closure created within the ~initialization~ section does not get updated by re-assignments of ~i~ in the ~afterthought~:

#+begin_src javascript

  for (let i = 0, getI = () => i; i < 3; i++) {
    console.log(i, getI());
  }

                             Block(script)
  +----------------------------------------------------------------+
  |                                                                |
  +----------------------------------------------------------------+
       Block(loop)
     initialization
  +------------------+
  | let i    = una/0 |<‚îê
  | let getI = una/f |‚îÄ‚îò
  +----------------‚îÇ-+
               ‚îå‚îÄ‚îÄ‚îÄ‚îò
  +------------v-----+   +------------------+   +------------------+
  | let getI = f   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> let getI = f   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> let getI = f     |
  | let i    = 0     |   | let i    = 0 | 1 |   | let i    = 1 | 2 |
  +------------------+   +------------------+   +------------------+
     condition body        after cond body         after cond body

       Block(body)            Block(body)            Block(body)
  +------------------+   +------------------+   +------------------+
  |                  |   |                  |   |                  |
  +------------------+   +------------------+   +------------------+

  // i => 0     getI() => 0
  // i => 1     getI() => 0
  // i => 2     getI() => 0

#+end_src

This does not log "~0~, ~1~, ~2~", like what would happen if ~getI~ is declared in the loop body. This is because ~getI~ is *not re-evaluated on each iteration* ‚Äî rather, the function is *created once and closes over the* ~i~ variable, which refers to the variable declared when the loop was first initialized. Subsequent updates to the value of ~i~ actually create *new variables called* ~i~, which ~getI~ does *not see*. A way to fix this is to re-compute ~getI~ every time ~i~ updates:

#+begin_src javascript

  for (let i = 0, getI = () => i; i < 3; i++, getI = () => i) {
    console.log(i, getI());
  }

                             Block(script)
  +----------------------------------------------------------------+
  |                                                                |
  +----------------------------------------------------------------+
       Block(loop)
     initialization
  +------------------+
  | let i    = una/0 |<‚îê
  | let getI = una/f |‚îÄ‚îò
  +----------------‚îÇ-+
               ‚îå‚îÄ‚îÄ‚îÄ‚îò
  +------------v-----+   +------------------+   +------------------+
  | let getI = f   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> let getI = f | f‚Äô‚îÄ‚îÄ‚î¨‚îÄ> let getI = f‚Äô|f‚Äô‚Äô|‚îÄ‚îê
  | let i    = 0     |   | let i    = 0 | 1 |<‚îò | let i    = 1 | 2 |<‚îò
  +------------------+   +------------------+   +------------------+
     condition body         after cond body        after cond body

       Block(body)            Block(body)            Block(body)
  +------------------+   +------------------+   +------------------+
  |                  |   |                  |   |                  |
  +------------------+   +------------------+   +------------------+

  // i => 0     getI() => 0
  // i => 1     getI() => 1
  // i => 2     getI() => 2

#+end_src

The ~i~ variable *inside* the ~initialization~ is distinct from the ~i~ variable *inside every iteration*, including the *first*. So, in this example, ~getI~ returns ~0~, even though the value of ~i~ inside the iteration is incremented beforehand:

#+begin_src javascript

  for (let i = 0, getI = () => i; i < 3; ) {
    i++;
      console.log(i, getI());
  }

                             Block(script)
  +----------------------------------------------------------------+
  |                                                                |
  +----------------------------------------------------------------+
       Block(loop)
     initialization
  +------------------+
  | let i    = una/0 |<‚îê
  | let getI = una/f |‚îÄ‚îò
  +----------------‚îÇ-+
               ‚îå‚îÄ‚îÄ‚îÄ‚îò
  +------------v-----+   +------------------+   +------------------+
  | let getI = f   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> let getI = f   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> let getI = f     |
  | let i    = 0 | 1 |   | let i    = 1 | 2 |   | let i    = 2 | 3 |
  +------------------+   +------------------+   +------------------+
     condition body         after cond body        after cond body

       Block(body)            Block(body)            Block(body)
  +------------------+   +------------------+   +------------------+
  |                  |   |                  |   |                  |
  +------------------+   +------------------+   +------------------+

  // i => 1     getI() => 0
  // i => 2     getI() => 0
  // i => 3     getI() => 0

#+end_src

In fact, you can *capture* this *initial binding* of the ~i~ variable and re-assign it later, and this *updated* value *will not be visible* to the *loop body*, which sees the next new binding of ~i~.

#+begin_src javascript

  for (
    let i = 0, getI = () => i, incrementI = () => i++;
    getI() < 3;
    incrementI()
  ) {
    console.log(i,getI());
  }

                             Block(script)
  +----------------------------------------------------------------+
  |                                                                |
  +----------------------------------------------------------------+
       Block(loop)
     initialization
  +----------------------------------------------------------------+
  | let i    = una/0 |<‚îê                  1  <‚îê                  2 |<‚îê
  | let incI = una/g |‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ|‚îÄ‚î§
  | let getI = una/f |‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ|‚îÄ‚îò
  +----------------‚îÇ-----------------------------------------------+
               ‚îå‚îÄ‚îÄ‚îÄ‚îò
  +------------v-----+   +------------------+   +------------------+
  | let getI = f   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> let getI = f   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> let getI = f     |
  | let incI = g   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> let incI = g   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> let incI = g     |
  | let i    = 0     |   | let i    = 0     |   | let i    = 0     |
  +------------------+   +------------------+   +------------------+
     condition body         after cond body        after cond body

       Block(body)            Block(body)            Block(body)
  +------------------+   +------------------+   +------------------+
  |                  |   |                  |   |                  |
  +------------------+   +------------------+   +------------------+

  // i => 0     getI() => 0
  // i => 0     getI() => 1
  // i => 0     getI() => 2

#+end_src

This logs "~0~, ~0~, ~0~", because the ~i~ variable in each loop evaluation is actually a *separate variable*, but ~getI~ and ~incrementI~ both read and write the initial *binding* of ~i~, ~not~ what was *subsequently declared*.

Another good example, but this time declaring functions inside the body. One declaring it with ~let~, and the other as a global property.

#+begin_src javascript

  let arr = [];  // declare variable in the Variable Object
  let arr2 = [];
  let j = 0;

  for (let i = 0,k = 0; j++, i < 7; i++,k++,j++) {
    let foo = () => { // declare variable in the block/body scope
        console.log(i,k,j);
    };
      arr.push(foo);
      i++,j++;

    bar = () => {   // property of the global object
        console.log(i,k,j);
    };
      arr2.push(bar);
      i++,j++;
  }
  j++;

  console.log("foo:")
  arr[0](); // 2 0 14
  arr[1](); // 5 1 14
  arr[2](); // 8 2 14

  console.log("bar:")
  arr2[0](); // 2 0 14
  arr2[1](); // 5 1 14
  arr2[2](); // 8 2 14

#+end_src

**** Scope behaviors in the for loop
A simple example of the behavior of the *intermediate scope* in the for loop, and another one a little more complex.

*Note*: there are other [[Lexical declarations in the initialization block][examples]] focused on different types of closures.

*Note*: the parameters also use an *intermediate scope* type. The [[Scope for parameters][parameters]] header has a more precise explanation of this behavior.

#+begin_src javascript

  let a = 0;

  for (let i = 0, j = 0; i < 3; i++) {
      let b = 0;
      a++, b++; j++;
      console.log(a, b, i, j)
  }

                             Block(script)
  +----------------------------------------------------------------+
  |let a = una/0 | 1                      2                      3 |
  +----------------------------------------------------------------+
       Block(loop)
     initialization
  +------------------+
  | let i    = una/0 |
  | let j    = una/0 |
  +------------------+
     condition body        after cond body         after cond body
  +------------------+   +------------------+   +------------------+
  | let i    = 0     |   | let i    = 0 | 1 |   | let i    = 1 | 2 |
  | let j    = 0 | 1 |   | let j    = 1 | 2 |   | let j    = 2 | 3 |
  +------------------+   +------------------+   +------------------+
       Block(body)            Block(body)            Block(body)
  +------------------+   +------------------+   +------------------+
  | let b = una/0| 1 |   | let b    = 1 | 2 |   | let b    = 2 | 3 |
  +------------------+   +------------------+   +------------------+

  // a => 1   b => 1   i => 0   j => 1
  // a => 2   b => 1   i => 1   j => 2
  // a => 3   b => 1   i => 2   j => 3

#+end_src

*Notes*:
- in the ~initialization~ part, and in the body, variables can be declared with ~let~ or ~const~. In the ~condition~, and ~after~ parts you can only define properties of the global object (in the body too)
- variables declared in the body are only accessible in the body

#+begin_src javascript

  // Declares variables i and j with let.
  for ( let i = 0, j = 0; i < 3; i++) { // like let i = 0
      console.log(i,j);                 //      let j = 0
  }

  // Creates the property i = 0 in the global/window object.
  for ( i = 0; i < 3; i++) {
      console.log(i);
  }

#+end_src

Another slightly more complex example with more variables.

#+begin_src javascript

a1 = 0;     // property of the global object, same as (var a1 = 0)
let b = 0;  // declare variable in the Variable Object

for (let i=0, j=0, k=0; a2=0,i<3; a4=0,k=10,i++,a1++,afoo(),b++,k++,a3++) {
    a3 = 0;    // property of the global object
    let c = 0; // declare variable in the block/body scope
    let d = 0; // to compare it with 'c' when creating the next new scopes
    afoo = () => c++; // test if this function keep 'c' closure (property)
    let foo = () => c++; // test if this function keep 'c' closure (variable)
    j = 10;    // property of the global object
    a1++, b++, j++, k++, a2++, c++, d++, a3++;
    console.log(a1, b, i, j, k, a2, a3, c, d);
}

  script(variable object)
  +-----------------------------------------------------------------+
  |let b = una/0 |  1                     3                      5  | scope
  +-----------------------------------------------------------------+
    Block(loop)
   initialization
  +---------------+
  | let i = una/0 |
  | let j = una/0 |
  | let k = una/0 |
  +---------------+
     condition body     afterthought cond body afterthought cond body
  +-------------------+  +-------------------+  +-------------------+
  | let i = 0     | 0 |  | let i =  0 |   1  |  | let i =  1 |   2  | new
  | let j = 0     |11 |  | let j = 11 |  11  |  | let j = 11 |  11  | lexical
  | let k = 0     | 1 |  | let k =  1 |  12  |  | let k = 12 |  12  | scopes
  +-------------------+  +-------------------+  +-------------------+
       Block(body)            Block(body)            Block(body)
  +-------------------+  +-------------------+  +-------------------+
  | let c  = una/0| 1 |  | let c = una| 0->1 |  | let c   = 1| 0->1 |
  | let d  = una/0| 1 |  | let d   = 1| 0->1 |  | let d   = 1| 0->1 |
  | let foo= una/f| f |  | let foo = f| f->f |  | let foo = f| f->f |
  +-------------------+  +-------------------+  +-------------------+

  global = {a1: 1, a2: 1, a3: 1, afoo: f, ... }        // body
         = {a1: 2, a2: 1, a3: 2, afoo: f, a4: 0, ... } // afterthought part
         = ...

  // In the second body block, 'c' starts out unavailable, since the
  // closure in the 'afterthought' part changes it to '2'

  //  1  1  0  11   1  1  1  1  1
  //  3  3  1  11  12  1  1  1  1
  //  5  5  2  11  12  1  1  1  1

#+end_src

*** for...of
Executes a loop that operates on a sequence of *values sourced* from an *iterable object*. Iterable objects include instances of built-ins such as ~Array~, ~String~, ~TypedArray~, ~Map~, ~Set~, [[NodeList]] (and other DOM collections), as well as the ~arguments~ object, generators produced by generator functions, and user-defined iterables.

#+begin_src javascript

  // Syntax:
  for (variable of iterable) {
      statement
  }
  // variable can be declared with const, let, or var
  // Variables declared with var are not local to the loop, i.e.
  // they are in the same scope the for...of loop is in.


  // Example:
  const array1 = ['a', 'b', 'c'];

  for (const element of array1) {
      console.log(element);
  }
  // "a"
  // "b"
  // "c"


  let biggest = null;
  for (let script of SCRIPTS) {
      if (biggest == null ||
          biggest < script.number) {
          biggest = script.number;
      }
  }
  let SCRIPTS = [{name: "A",number: 23},{name: "B",number: 33},
                 {name: "C",number: 53},]
  console.log(biggest);  // 53

#+end_src

*** for...in
The ~for...in~ statement iterates over all *enumerable string properties* of an *object* (ignoring properties keyed by symbols), including inherited enumerable properties.

#+begin_src javascript

  const object = { a: 1, b: 2, c: 3 };

  for (const property in object) {
      console.log(`${property}: ${object[property]}`);
  }
  // "a: 1"
  // "b: 2"
  // "c: 3"

  let child = Object.create(object);
  child.y = 20;

  for (const property in child) {
      console.log(`${property}: ${child[property]}`);
  }
  // "y: 20"
  // "a: 1"
  // "b: 2"
  // "c: 3"

#+end_src

* Function
** Brief
A function is a *piece of program wrapped in a value*. Such values can be applied in order to run the wrapped program. For example, in a browser environment, the binding prompt holds a function that shows a little dialog box asking for user input.

Functions are special values that encapsulate a piece of program. You can invoke them by writing ~functionName(argument1, argument2)~. Such a function call is an expression and may produce a value.

The ~function~ keyword, when used as an *expression*, can create a function value. When used as a *statement*, it can be used to declare a binding and give it a function as its value.

Functions are the bread and butter of JavaScript programming. The concept of wrapping a piece of program in a value has many uses. It gives us a way to structure larger programs, to reduce repetition, to associate names with subprograms, and to isolate these subprograms from each other.

A ~return~ statement determines the value the function returns. When control comes across such a statement, it immediately jumps out of the current function and gives the returned value to the code that called the function. A ~return~ keyword without an expression after it will cause the function to return ~undefined~. Functions that don‚Äôt have a ~return~ statement at all, similarly return ~undefined~.

Parameters to a function behave like regular bindings, but their initial values are given by the caller of the function, not the code in the function itself.

*Note*: all functions in ECMAScript are first-class and closures.

#+begin_src javascript

  // Define f to hold a function value
  const f = function(a) {
      console.log(a + 2);
  };

  // Declare g to be a function
  function g(a, b) {
      return a * b * 3.5;
  }

  // A less verbose function value
  let h = a => a % 3;

#+end_src

** Bindings and scopes
JavaScript has the following kinds of scopes:

- Global scope :: the default scope for all code running in script mode
- Module scope :: the scope for code running in module mode
- Function scope :: the scope created with a function

In addition, identifiers declared with certain syntaxes, including ~let~, ~const~, ~class~, or (in strict mode) function, can belong to an additional scope:

- Block scope :: the scope created with a pair of curly braces (a block).

Each binding has a scope, which is the *part of the program in which the binding is visible*. For bindings defined outside of any function or block, the scope is the whole program‚Äîyou can refer to such bindings wherever you want. These are called *global*.

But bindings created for function *parameters* or *declared inside* a function can be referenced only in that function, so they are known as *local* bindings. Every time the function is called, new instances of these bindings are created. This provides some isolation between functions.

Bindings declared with ~let~ and ~const~ are in fact *local to the block* that they are declared in, so if you create one of those inside of a loop, the code before and after the loop cannot ‚Äúsee‚Äù it. In pre-2015 JavaScript, only functions created new scopes, so old-style bindings, created with the ~var~ keyword, are visible throughout the whole function that they appear in‚Äîor throughout the global scope, if they are not in a function. For example, when is ~var~ declared in the [[for]] loop, it's visible throughout the global scope or inside the function that declares it.

A key aspect in understanding functions is understanding scopes. Each block creates a new scope. Parameters and bindings declared in a given scope are local and not visible from the outside. Bindings declared with ~var~ behave differently‚Äîthey end up in the nearest function scope or the global scope.

*Nested scope*
JavaScript distinguishes not just global and local bindings. Blocks and functions can be created inside other blocks and functions, producing multiple degrees of locality.

The set of bindings visible inside a block is determined by the place of that block in the program text. Each local scope can also see all the local scopes that contain it, and all scopes can see the global scope. This approach to binding visibility is called *lexical scoping*.

*Note*: be careful with /scopes/, and [[Closure][closures]] (closures are by reference (INS)).

A similar example with diagram is given under the heading [[Functions having the same parent scope]].

#+begin_src javascript

  let x = 7;
  let y = 3;

  function outer() {
      let x = 0;
      let y = 0;

      let obj = {
          foo: function () { x++; console.log(x,y) },
          bar: function () { x--; console.log(x,y) }
      }
      x++;
      return obj;
  }

  x++
  let returnObj = outer()

  console.log(x,y) // 8 3
  returnObj.foo()  // 2 0
  returnObj.bar()  // 1 0

  // The same example, but without the declaration of the 'returnObj'
  let x = 7;
  let y = 3;

  function outer() {
      let x = 0;
      let y = 0;

      let obj = {
          foo: function () { x++; console.log(x,y) },
          bar: function () { x--; console.log(x,y) }
      }
      x++;
      return obj;
  }
  x++

  console.log(x,y) // 8 3
  outer().foo()    // 2 0
  outer().bar()    // 0 0

#+end_src

*Note*: be careful with ~let~, ~var~ declarations, and reassignments.

#+begin_src javascript

  let x = 7;
  let y = 3;

  function outer() {
      x = 0;
      y = 0;

      let obj = {
          foo: function () { x++; console.log(x,y) },
          bar: function () { x--; console.log(x,y) }
      }
      x++;
      return obj;
  }

  x++                     // ; console.log(x,y) //  8 3
  let returnObj = outer() // ; console.log(x,y) //  1 0

  console.log(x,y) // 1 0
  returnObj.foo()  // 2 0
  returnObj.bar()  // 1 0

  // The same example, but without the declaration of the 'returnObj'
  let x = 7;
  let y = 3;

  function outer() {
      x = 0;
      y = 0;

      let obj = {
          foo: function () { x++; console.log(x,y) },
          bar: function () { x--; console.log(x,y) }
      }
      x++;
      return obj;
  }

  x++

  console.log(x,y) // 8 3
  outer().foo()    // 2 0
  outer().bar()    // 0 0

#+end_src

** Functions as values
A function binding usually simply acts as a name for a specific piece of the program. Such a binding is defined once and never changed. This makes it easy to confuse the function and its name.

But the two are different. A /function value/ *can do all the things that other values can do* ‚Äîyou can use it in arbitrary expressions, not just call it. It is possible to store a function value in a new binding, pass it as an argument to a function, and so on. Similarly, a /binding that holds a function/ is still just a *regular binding* and can, if not constant, be assigned a new value, like so:

#+begin_src javascript

  let launchMissiles = function() { // anonymous function
    missileSystem.launch("now");
  };
  // launchMissiles: binding that holds the anonymous function
  if (safeMode) {
    launchMissiles = function() {/* do nothing */};
  }

#+end_src

*Note*:  A good mental model is to think of function values *as containing both the code in their body and the environment in which they are created*. When called, the function body sees the environment in which it was created, not the environment in which it is called.

The ~function~ *keyword*, when used as an expression, can create a function value. When used as a statement, it can be used to *declare a binding* and give it a function *as its value*.

#+begin_src javascript

  // Define f to hold a function value
  const f = function(a) {
    console.log(a + 2);
  };

  // Declare g to be a function
  function g(a, b) {
    return a * b * 3.5;
  }

#+end_src

** Defining functions
*** Function declarations
**** Brief
There is a slightly shorter way to create a function binding. When the ~function~ keyword is used at the start of a statement, it works differently.

#+begin_src javascript

  function square(x) {
      return x * x;
  }

#+end_src

This is a function *declaration*. The statement defines the binding ~square~ and points it at the given function.

Function declarations are not part of the regular top-to-bottom flow of control. They are conceptually *moved to the top of their scope* and can be used by all the code in that scope. This is sometimes useful because it offers the freedom to order code in a way that seems meaningful, without worrying about having to define all functions before they are used.

*Note*: Semicolons are used to separate executable JavaScript statements.
Since a function declaration is not an executable statement, it is not common to end it with a semicolon.

Parameters are essentially passed to functions *by value* ‚Äî so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, *the change is not reflected globally or in the code which called that function*.

*Note*: arguments are always /passed by value/ and never passed by reference. This means that if a function *reassigns a parameter*, the value *won't change outside* the function. More precisely, *object arguments* are /passed by sharing/, which means if the *object's properties are mutated*, the change *will impact the outside* of the function.

#+begin_src javascript

  function foo(theValue) {
      theValue = 30;
  }

  const value = 45;

  console.log(value); // 45
  myFunc(value);
  console.log(value); // 45


  function assignNew(obj) {
      obj = {};
  };

  const mycar = {
      make: "Honda",
      model: "Accord",
      year: 1998,
  };

  console.log(mycar);
  // { make: 'Honda', model: 'Accord', year: 1998 }
  assignNew(mycar);
  console.log(mycar);
  // { make: 'Honda', model: 'Accord', year: 1998 }

#+end_src

When you pass an object as a parameter, if the function changes the *object's properties*, that change is *visible outside* the function.

#+begin_src javascript

  function myFunc(theObject) {
      theObject.make = "Toyota";
  }

  const mycar = {
      make: "Honda",
      model: "Accord",
      year: 1998,
  };

  console.log(mycar.make); // "Honda"
  myFunc(mycar);
  console.log(mycar.make); // "Toyota"

#+end_src

When you pass an array as a parameter, if the function changes any of the *array's values*, that change is *visible outside* the function.

#+begin_src javascript

  function myFunc(theArr) {
      theArr[0] = 30;
  }

  const arr = [45];

  console.log(arr[0]); // 45
  myFunc(arr);
  console.log(arr[0]); // 30

#+end_src

~function~ declarations behave like a mix of ~var~ and ~let~:

- Like ~let~, in strict mode, function declarations are scoped to the most closely containing block.
- Like ~let~, function declarations at the top level of a module or within blocks in strict mode cannot be redeclared by any other declaration.
- Like ~var~, function declarations at the top level of a script (strict or non-strict) become properties on ~globalThis~. Function declarations at the top level of a script or function body (strict or non-strict) can be redeclared by another ~function~ or ~var~.
- Like both, function declarations can be re-assigned, but you should avoid doing so.
- Unlike either, function declarations are hoisted together with its value and can be called anywhere in its scope.

*Block-level function declaration*
*Warning*: In non-strict mode, function declarations inside blocks behave strangely. Only declare functions in blocks if you are in strict mode.

Functions can be conditionally declared ‚Äî that is, a function statement can be nested within an ~if~ statement. However, in non-strict mode, the results are inconsistent across implementations.

#+begin_src javascript

  console.log(
    `'foo' name ${
      "foo" in globalThis ? "is" : "is not"
    } global. typeof foo is ${typeof foo}`,
  );
  if (false) {
    function foo() {
      return 1;
    }
  }

  // In Chrome:
  // 'foo' name is global. typeof foo is undefined

  // In Firefox:
  // 'foo' name is global. typeof foo is undefined

  // In Safari:
  // 'foo' name is global. typeof foo is function

#+end_src

**** Dmitry S√≥shnikov
A *Function Declaration* (abbreviated form is FD) is a function which:
- has a *required name*;
- in the source code position it is positioned: either at the *Program level* (global code) or directly in the *body of another function* (FunctionBody);
- is *created on* [[Entering the execution context][entering the context]] stage;
- *influences* [[Variable object][variable object]];

The main feature of this type of functions is that *only they influence variable object* (they are stored in the VO of the context). This feature defines the second important point (which is a consequence of a variable object nature) ‚Äî *at the code execution stage they are already available* (since FD are stored in the VO on entering the context stage ‚Äî before the execution begins).

These are the *only two positions in code where a function may be declared* (i.e. it is impossible to declare it in an expression position or inside a code block).

#+begin_src javascript

  // function can be declared:
  // 1) directly in the global context
  function globalFD() {
      // 2) or inside the body
      // of another function
      function innerFD() {}
  }

#+end_src

*** Function expressions
**** Brief
A JavaScript function can also be defined using an *expression*.

A function expression can be stored in a variable:

#+begin_src javascript

  const times = function (a, b) {return a * b};
  // After a function expression has been stored in a
  // variable, the variable can be used as a function:

  let z = times(4, 3);
  // The function above ends with a semicolon because
  // it is a part of an executable statement.

#+end_src

Function expressions are convenient when passing a function as an argument to another function. In the following code, the function receives a function defined by a function expression and executes it for every element of the array received as a second argument:

#+begin_src javascript

  function map(f, a) {
      const result = new Array(a.length);
      for (let i = 0; i < a.length; i++) {
          result[i] = f(a[i]);
      }
      return result;
  }

  const cube = function (x) {
      return x * x * x;
  };

  const numbers = [0, 1, 2, 5, 10];
  console.log(map(cube, numbers)); // [0, 1, 8, 125, 1000]

#+end_src

A name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:

#+begin_src javascript

  const factorial = function fac(n) {
      return n < 2 ? 1 : n * fac(n - 1);
  };

  console.log(factorial(3)); // 6

#+end_src

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines ~myFunc~ only if ~num~ equals ~0~:

#+begin_src javascript

  let myFunc;
  if (num === 0) {
      myFunc = function (theObject) {
          theObject.make = "Toyota";
      };
  }

#+end_src

*Note*: anonymous functions are not identical even if defined using the same unchanging source-code called repeatedly, *even if in a loop*.

**** Dmitry S√≥shnikov
A Function Expression (abbreviated form is FE) is a function which:
- in the source code can *only be defined at the expression position*;
- can have an optional name;
- it‚Äôs definition *has no effect on variable object*;
- and is *created at the* [[Code execution][code execution stage]] (in other words, functions are not ‚Äú[[Hoisting][hoisted]]‚Äù).

The main feature of this type of functions is that in the source code *they are always in the expression position*.

FEs nevertheless ideologically are for exactly *using functions as expressions*, e.g. passing as an anonymous ‚Äúfunarg‚Äù to another higher-order function, not polluting the outer scope with the named declaration and creating these functions literally at runtime.

*Note*: function expression will be created during the execution stage, then executed, and then removed (if there are no references to it).

*Note*: grouping parentheses are needed when a function *is not at the expression position and if we want to call it immediately right after its creation* ‚Äî in this case we just manually transform the function to FE.

When a FE is assigned a name it can be difficult to distinguish it from a FD. However, if you know the definition, it is easy to tell them apart: *FE is always in the expression position*. In the following example we can see various ECMAScript expressions in which all the functions are FE:

#+begin_src javascript

  // in parentheses (grouping operator) can be only an expression
  (function foo() {});

  // in the array initialiser ‚Äì also only expressions
  [function bar() {}];

  // comma also operates with expressions
  1, function baz() {};

#+end_src

The definition also states that FE is created at the code execution stage and is not stored in the [[Variable object][variable object]]. Let‚Äôs see an example of this behavior:

#+begin_src javascript

  // FE is not available neither before the definition
  // (because it is created at code execution phase),

  console.log(foo); // "foo" is not defined

  (function foo() {});

  // nor after, because it is not in the VO

  console.log(foo);  // "foo" is not defined

#+end_src

The logical question now is why do we need this type of functions at all? The answer is obvious ‚Äî *to use them in expressions and ‚Äúnot pollute‚Äù the variables object*.

In case a FE is assigned to a variable, the function remains stored in memory and can later be accessed via this variable name (because *variables* as we know influence VO):

#+begin_src javascript

  var foo = function () {
      console.log('foo');
  };

  foo();

#+end_src

Here‚Äôs an example of FE which are created conditionally at runtime and do not pollute VO:

#+begin_src javascript

  var x = 10;

  var bar = (x % 2 == 0
             ? function () { console.log(0); }
             : function () { console.log(1); }
            );

  bar(); // 0

#+end_src

*Notice*, ES5 standardized [[Function.prototype.bind][bound functions]]. This type of functions correctly binds the value of ~this~, making it locked in any function invocation.

#+begin_src javascript

  var boundFn = function () {
      return this.x;
  }.bind({x: 10});

  boundFn(); // 10
  boundFn.call({x: 20}); // still 10

#+end_src

**** IIFE
An IIFE (Immediately Invoked Function Expression) is an idiom in which a JavaScript function runs as soon as it is defined.

#+begin_src javascript

  // standard IIFE
  (function () {
    // statements‚Ä¶
  })();

  // arrow function variant
  (() => {
    // statements‚Ä¶
  })();

  // async IIFE
  (async () => {
    // statements‚Ä¶
  })();

#+end_src

It contains two major parts:

1. A [[Function expressions][function expression]]. This usually needs to be enclosed in parentheses in order to be parsed correctly.
2. Immediately /calling/ the function expression. Arguments may be provided, though IIFEs without arguments are more common.

IIFEs are a common pattern used to execute arbitrarily many statements in their own scope (and possibly return a value), in a location that requires a single expression. They are similar to, but much more powerful than, the [[Comma operator (,)][comma operator]], which can only execute multiple expressions and, therefore, does not provide a way to use local variables or control flow statements.

Use cases of IIFEs include:

- Avoiding polluting the global namespace by creating a new scope.
- Creating a new async context to use ~await~ in a non-async context.
- Computing values with complex logic, such as using multiple statements as a single expression.

*Dmitry S√≥shnikov*
Another example is *creation of encapsulated scope to hide auxiliary helper data from external context* (in the following example we use FE which is called right after creation):

#+begin_src javascript

  var foo = {};

  // FE since it's inside parentheses.
  // It's not an FD since FDs are only declared directly in
  // the global context or inside the body of another function.
  (function initialize() {

      var x = 10;

      // Because the fuction is created here, it stores this context.
      foo.bar = function () {
          console.log(x);
      };

  })();

  foo.bar(); // 10;

  console.log(x); // "x" is not defined


  // Often in this pattern the name of initializing FE is omitted:
  (function () {

      // initializing scope

  })();

#+end_src

We see that function ~foo.bar~ (via its ~[[Scope]]~ property) has access to the internal variable ~x~ of function ~initialize~. And at the same time ~x~ is not accessible directly from the outside. This strategy is used in many libraries to create ‚Äúprivate‚Äù data and hide auxiliary entities.

*** Arrow functions
The arrow comes *after* the list of parameters and is followed by the function‚Äôs body. It expresses something like ‚Äúthis input (the parameters) produces this result (the body)‚Äù.

#+begin_src javascript

  // ES5
  var x = function(x, y) {
      return x * y;
  }

  // ES6
  const x = (x, y) => { return x * y };
  // Can have an implicit return:
  const x = (x, y) => x * y;


  // When there is only one parameter name:
  const square1 = (x) => { return x * x; };
  const square2 = x => x * x;


  // When an arrow function has no parameters at all, its
  // parameter list is just an empty set of parentheses.
  const horn = () => {
      console.log("Toot");
  };


  // Practical example:
  const power = (base, exponent) => {
      let result = 1;
      for (let count = 0; count < exponent; count++) {
          result *= base;
      }
      return result;
  };

#+end_src

There‚Äôs no deep reason to have both arrow functions and function expressions in the language. Apart from a minor detail, (shorter functions and non-binding of ~this~), they do the same thing. Arrow functions were added in 2015, mostly to make it possible to write small function expressions in a less verbose way.

*Note*: arrow functions are not hoisted. They must be defined *before* they are used.

*Note*: using ~const~ is safer than using ~var~, because a function expression is always constant value.

*Cannot be used as methods*
Arrow function expressions should only be used for non-method functions because they do not have their own ~this~. Let's see what happens when we try to use them as methods:

#+begin_src javascript

  "use strict";

  const obj = {
    i: 10,
    b: () => console.log(this.i, this),
    c() {
      console.log(this.i, this);
    },
  };

  obj.b(); // logs undefined, Window { /* ‚Ä¶ */ } (or the global object)
  obj.c(); // logs 10, Object { /* ‚Ä¶ */ }

#+end_src

*Line break before arrow*
An arrow function cannot contain a line break between its parameters and its arrow.

#+begin_src javascript

  // SyntaxError: Unexpected token '=>'
  const func = (a, b, c)
        => 1;
  // SyntaxError: Unexpected token '=>'


  const func = (a, b, c) =>
        1;

  const func2 = (a, b, c) => (
      1
  );

  const func3 = (a, b, c) => {
      return 1;
  };

  const func4 = (
      a,
      b,
      c,
  ) => 1;

#+end_src

*** Function creation and application
A function is *created* relatively to a given [[Environment (scope chain)][environment]]. The resulting function object is a pair consisting of the code (function body) and a pointer to the environment in which the function was created.

#+begin_src javascript

  // global "x"
  var x = 10;

  // function "foo" is created relatively to the global environment
  function foo(y) {
      var z = 30;
      console.log(x + y + z);
  }


  //Corresponds in the pseudo-code to:

  // create "foo" function
  foo = functionObject {
      code: "console.log(x + y + z);"
      environment: {x: 10, outer: null}
  };

                              +-------------------------+
                          --->| console.log(x + y + z); |
                          |   +-------------------------+
   +-----------------+    |
   | foo function    |    |
   | +-------------+ |    |      +--------------------+
   | |     code    |------|      | Global frame (GE)  |
   | +-------------+ |           |   +------------+   |
   | +-------------+ |           |   |    x: 10   |   |
   | | environment |------------>|   +------------+   |
   | +-------------+ |           |   +------------+   |
   +-----------------+           |   | foo: <fun> |   |
           ^                     |   +------------+   |
           |                     +---------|----------+
           |                               |
           ---------------------------------

  // Note, the function refers to its environment, and one of the
  // environment bindings ‚Äî the function ‚Äî refers back to the
  // function object.

#+end_src

A function is called with (or applied to) a set of arguments by constructing a *new frame*, binding the formal parameters of the function to the arguments of the call, creating bindings for local variables in this frame, and then executing the body of the function in the context of the *new environment constructed*. The new frame has as its enclosing environment the environment part of the function object being applied.

#+begin_src javascript

  // The application (call):

  // function "foo" is applied to the argument 20
  foo(20);


  // Corresponds to the following pseudo-code:

  // create a new frame with formal parameters and local variables
  fooFrame = {
      y: 20,
      z: 30,
      outer: foo.environment
  };

  // and evaluate the code of the "foo" function
  execute(foo.code, fooFrame); // 60

                                              +------------------------+
                                              | Foo activation env     |
                                              | +--------------------+ |
                                              | | Global frame (GE)  | |
                                              | |   +------------+   | |
                                              | |   |    x: 10   |   | |
                                              | |   +------------+   | |
                                              | |   +------------+   | |
                                              | |   | foo: <fun> |   | |
+---------------------------+                 | |   +------------+   | |
| foo function code         |                 | +--------------------+ |
| +-----------------------+ |--Execute code-->|           ^            |
| |console.log(x + y + z);| |    using env    |           |            |
| +-----------------------+ |                 |         outer          |
+---------------------------+                 |           |            |
                                              | +--------------------+ |
                                              | | foo frame          | |
                                              | |   +------------+   | |
                                              | |   |    y: 20   |   | |
                                              | |   +------------+   | |
                                              | |   +------------+   | |
                                              | |   |    z: 30   |   | |
                                              | |   +------------+   | |
                                              | +--------------------+ |
                                              +------------------------+

#+end_src

** Arguments
*** Evaluation strategy
**** Eager evaluation
From the initial evaluation perspective, there are two main strategies: strict (sometimes it‚Äôs called eager), meaning the *arguments are evaluated before their application*, and non-strict, meaning the evaluation happens on-demand, when the arguments are actually used (so-called ‚Äúlazy‚Äù evaluation).

*ECMAScript, uses eager evaluation for the arguments*:

#+begin_src javascript

  function eager(x) {
      console.log(x);
  }

  eager(y);
        ^
  // ReferenceError: y is not defined
  //     at Object.<anonymous> (/home/rich/trials/dape.js:5:9)
  //     at Module._compile (node:internal/modules/cjs/loader:1469:14)
  //     ...

#+end_src

In the example above the error is thrown right and before the function call, that is, all arguments should be eagerly evaluated before passing.

The lazy evaluation can be achieved in JavaScript via callbacks:

#+begin_src javascript

  function lazy(onDemandGetter) {
      console.log(onDemandGetter()); // ReferenceError: "y" is not defined
  }

  lazy(() => y); // OK
               ^
  // ReferenceError: y is not defined
  //     at /home/rich/trials/dape.js:5:14
  //     at lazy (/home/rich/trials/dape.js:2:19)
  //     at Object.<anonymous> (/home/rich/trials/dape.js:5:3)
  //     at Module._compile (node:internal/modules/cjs/loader:1469:14)
  //     ...


  function foo(arg) {
      return console.log('Passed!');
  }
  // lazy
  foo(()=>[2+1, 3*2, 1/0, x]); // Passed!
  // eager
  foo([2+1, 3*2, 1/0, x]);    // ReferenceError: x is not defined

#+end_src

**** Evaluation orders
In addition, the order in which the arguments are evaluated and passed, is also standardized ‚Äî *it‚Äôs left-to-right*.

JavaScript uses [[Eager evaluation][eager]] evaluation of arguments, in left-to-right order.

#+begin_src javascript

  function foo(...args) {
      console.log(args); // [1, 2, 3]
  }

  foo(
      (() => { console.log(1); return 1; })(), // 1
      (() => { console.log(2); return 2; })(), // 2
      (() => { console.log(3); return 3; })(), // 3
  );

  // Here we pass three arguments, and using the side-effect of logging
  // each argument, we see that the left-to-right order is correctly
  // maintained.

#+end_src

**** Passing arguments
- By value :: this type of strategy is well-known by many developers. The value of an argument here *is a copy of the passed object*. The changes made inside the function do not affect the passed object outside. Technically, a runtime allocates a new memory block, copies the full contents of the passing object into it, and then the function can use this new object from the new location.

- By reference :: in contrast with /call by value/, the by reference strategy receives not a copy, but the *implicit reference to an object* instead. And this reference is directly mapped (like an alias) to the object from the outside. Any changes to the parameter inside the function ‚Äî either just the property modifications, or the full rewrite are immediately reflected on the original object.

- By sharing :: alternative names of this strategy are ‚Äúcall by object‚Äù or ‚Äúcall by object-sharing‚Äù. *This strategy plays the key role in passing ECMAScript arguments*.

The main difference of this strategy is that function receives the *copy of the reference to object*. This reference copy is associated with the formal parameter and is its value.

Despite using the word ‚Äúreference‚Äù in this description, this strategy should not be confused with the /call by reference/. The value of the argument is not a direct alias, but the *copy of the address*.

In this case a *re-assignment* to a new value does *not replace the original object* (as would by reference strategy do). *However*, since the formal parameter still received an address, it can access the contents (the properties) of the original object, and *mutate* them.

This strategy assumes that language in general operates with objects instead of the primitive values.

| /Strategy/     | /Value/              | /Can modify/ | /Can replace/ |
|              |                    | /contents?/  | /contents?/   |
|--------------+--------------------+------------+-------------|
| By value     | Full contents copy | No         | No          |
| By reference | Address copy       | Yes        | Yes         |
| By sharing   | Address copy       | Yes        | No          |

#+begin_src

            By value
             A3D10          +---+
  foo ------------------->  |   |
                            +---+

             PP11K          +---+
  bar ------------------->  |   |
                            +---+

          By reference
             A3D10          +---+
  foo ------------------->  |   |
   ^                        +---+
   | AL1A5
   |
  bar

          By sharing
             A3D10          +---+
  foo --------------------> |   |
                   -------> +---+
           A3D10 /
               /
  bar -------

#+end_src

**** Call by sharing
The evaluation strategy used in ECMAScript is call by sharing. That is, we can *change the properties of the object, but cannot fully re-assignment it*. Assignment only [[Rebinding][rebinds]] the parameter name to a new memory, keeping the original object untouched.

However, the generic ‚Äúby value‚Äù terminology for this strategy can be used among JS programmers ‚Äî again, meaning the value of a pointer. JavaScript inventor Brendan Eich also notices that the copy of a reference is passed.

This behavior can also be seen on a simple assignment. In this case we can see that we have two different variables, but which share the same value ‚Äî *the address of the object*.

Assignment of one variable to another *just copies its address*, making both variables pointing to the same memory location. The following assignment of a new value unbinds a name from the old address and rebinds it to the new one. This is an important difference from the by reference strategy, and this is exactly how objects are also passed as arguments to functions.

And once we have an address of an object, we can mutate its contents (updated properties) ‚Äî and this is operation of [[Mutation]].

#+begin_src javascript

  // Bind `foo` to {x: 10} object:
  let foo = {x: 10};

  console.log(foo.x); // 10

  // Bind `bar` to the *same* object as `foo` identifier is bound to:
  let bar = foo;

  console.log(foo === bar); // true
  console.log(bar.x); // OK, also 10

  // And now rebind `foo` to the new object:
  foo = {x: 20};

  console.log(foo.x); // 20

  // And `bar` still points to the old object:

  console.log(bar.x); // 10
  console.log(foo === bar); // false

  // This is (Re)binding operation (that is, setting
  // the variable value to an object address).

  +-------------------------+      +-----------------------------------+
  |  bar = foo              |      |  foo = {x: 20}                    |
  |      +-----------+      |      |  +-----------+  +-----------+     |
  |      |  {x: 10}  |      |      |  |  {x: 20}  |  |  {x: 10}  |     |
  |      +-----------+      |      |  +-----------+  +-----------+     |
  |         ^      ^        |      |           ^      ^       ^        |
  |        /        \       |      |            \    ‚ï≥         \       |
  |       /          \      |      |             \  ‚ï≥           \      |
  |  +-----+       +-----+  |      |           +-----+        +-----+  |
  |  | foo |       | bar |  |      |           | foo |        | bar |  |
  |  +-----+       +-----+  |      |           +-----+        +-----+  |
  +-------------------------+      +-----------------------------------+

#+end_src

*Terminology versions*
Let‚Äôs define the versions of correct terminology related to ECMAScript in this case.

It can be either ‚Äúcall by value‚Äù, with specifying that the special case of call by value is meant ‚Äî when the value is the address copy. From this position it is possible to say that everything in ECMAScript is passed by value.

Or, ‚Äúcall by sharing‚Äù, which makes this distinction from ‚Äúby reference‚Äù, and ‚Äúby value‚Äù. In this case it is possible to separate passing types: primitive values are passed by value and objects ‚Äî by sharing.

The statement ‚Äúobjects are passed by reference‚Äù formally is not related to ECMAScript and is incorrect.

*** Optional arguments
JavaScript is extremely broad-minded about the number of arguments you pass to a function. If you pass too many, the extra ones are ignored. If you pass too few, the missing parameters get assigned the value ~undefined~.

The downside of this is that it is possible‚Äîlikely, even‚Äîthat you‚Äôll accidentally pass the wrong number of arguments to functions. And no one will tell you about it.

The upside is that this behavior can be used to allow a function to be called with different numbers of arguments. For example, this ~minus~ function tries to imitate the ( ~-~ ) operator by acting on either one or two arguments:

#+begin_src javascript

  function minus(a, b) {
      if (b === undefined) return -a;
      else return a - b;
  }

  console.log(minus(10));
  // ‚Üí -10
  console.log(minus(10, 5));
  // ‚Üí 5

#+end_src

*** Default argument
If you write an ( ~=~ ) operator after a parameter, followed by an expression, the value of that expression will replace the argument when it is not given.

#+begin_src javascript

  function power(base, exponent = 2) {
      let result = 1;
      for (let count = 0; count < exponent; count++) {
          result *= base;
      }
      return result;
  }

  console.log(power(4));
  // ‚Üí 16
  console.log(power(2, 6));
  // ‚Üí 64

#+end_src

*** Parameters
**** Parameter evaluation time and shadowing
In contrast with some other languages (e.g. Python), that may calculate default parameters once, at definition time, ECMAScript evaluates *default parameter values at execution time ‚Äî on every single function call*. This design choice was made to avoid confusions with complex objects used as default values.

*Shadowing of the outer scope*

#+begin_src javascript

  var x = 1;

  function foo(x, y = x) {
      console.log(y);
  }

  foo(2); // 2, not 1!

#+end_src

The example above outputs ~2~ for ~y~, not ~1~, as visually may look like. The reason for this is that ~x~ from the parameters is not the same as the global ~x~. And since evaluation of the defaults happens at call time, then when assignment, ~= x~, happens, the ~x~ is already resolved in the inner scope, and refers to the ~x~ parameter itself. That is parameter ~x~ shadowed global variable with the same name, and every access to ~x~ from the default values refers to the parameter.

**** TDZ (Temporal Dead Zone) for parameters
ES6 mentions so called [[Temporal dead zone (TDZ)][TDZ]] (stands for Temporal Dead Zone) ‚Äî this is the region of a program, where a variable or a parameter *cannot be accessed until it‚Äôs initialized* (i.e. received a value).

Regarding parameters, a parameter cannot have default value of itself:

#+begin_src javascript

  var x = 1;

  function foo(x = x) { // throws!
      ...
  }

#+end_src

The assignment ~= x~, resolves ~x~ in the parameters scope, that shadowed the global ~x~. However, the parameter ~x~ is under the TDZ, and cannot be accessed until it‚Äôs initialized. Obviously, it cannot be initialized to itself.

**** Scope for parameters
***** Intermediate scope
*Conditional intermediate scope*
The parameters are related already with the ‚Äúinner scope‚Äù, which from ES5 we could assume it‚Äôs the scope of the function body. However, it‚Äôs a bit more complicated: it may be a scope of a function, or, an *intermediate scope, created specially to store parameters bindings*.

In fact, in case if some (at least one) of the parameters have default values, ES6 defines an intermediate scope to store the parameters, and this scope is not shared with the scope of the function body. This is a major difference from ES5 in this respect.

*Note*: the [[Lexical declarations in the initialization block][for]] iterator also uses a kind of intermediate scope.

#+begin_src javascript

  var x = 1;

  function foo(x, y = function() { x = 2; }) {
      var x = 3;
      y(); // is `x` shared?
      console.log(x); // no, still 3, not 2
  }

  foo();

  // and the outer `x` is also left untouched
  console.log(x); // 1

#+end_src

In this case, we have three scopes: the global environment, the parameters environment, and the environment of the function:

Now we see that when function ~y~ is executed, it resolves ~x~ in the nearest environment (i.e. in the same environment), and doesn‚Äôt even see the scope of the function.

#+begin_src javascript

  :  {x: 3} // inner
  -> {x: undefined, y: function() { x = 2; }} // params
  -> {x: 1} // global

#+end_src

*Transpiling to ES5*
If we‚Äôre about to compile ES6 code to ES5, and see how this intermediate scope looks like, we would get something like this:

#+begin_src javascript

  // ES6
  function foo(x, y = function() { x = 2; }) {
      var x = 3;
      y(); // is `x` shared?
      console.log(x); // no, still 3, not 2
  }

  // Compiled to ES5
  function foo(x, y) {
      // Setup defaults.
      if (typeof y == 'undefined') {
          y = function() { x = 2; }; // now clearly see that it
                                     // updates `x` from params
      }

      return function() {
          var x = 3; // now clearly see that this `x` is from inner scope
          y();
          console.log(x);
      }.apply(this, arguments);
  }

#+end_src

***** The reason for the params scope
However, what is the exact purpose of this params scope? Why can‚Äôt we still do ES5-way and share params with the function body? The reason is: the variables in the body with the same name should not affect captured in closures bindings with the same name.

#+begin_src javascript

  var x = 1;

  function foo(y = function() { return x; }) { // capture `x`
      var x = 2;
      return y();
  }

  foo(); // correctly 1, not 2

#+end_src

If we create the function ~y~ in the scope of the body, it would capture inner ~x~, that is, ~2~. However, it‚Äôs clearly observable, that it should capture the outer ~x~, i.e. ~1~ (unless it‚Äôs shadowed by the parameter with the same name).

At the same time we cannot create the function in the outer scope, since this would mean we won‚Äôt be able to access the parameters from such function, and we should be able to do this:

#+begin_src javascript

  var x = 1;

  function foo(y, z = function() { return x + y; }) { // can see `x` and `y`
      var x = 3;
      return z();
  }

  foo(1); // 2, not 4

#+end_src

***** When the params scope is not created
The described [[The reason for the params scope][above]] semantics completely different than what we have in manual implementation of defaults:

#+begin_src javascript

  var x = 1;

  function foo(x, y) {
      if (typeof y == 'undefined') {
          y = function() { x = 2; };
      }
      var x = 3;
      y(); // is `x` shared?
      console.log(x); // yes! 2
  }

  foo();

  // and the outer `x` is again untouched
  console.log(x); // 1

#+end_src

Now that‚Äôs an interesting fact: if a function doesn‚Äôt have defaults, it doesn‚Äôt create this intermediate scope, and share the parameters binding in the environment of a function, i.e. works in the ES5-mode.

Why these complications? Why not always create the parameters scope? Is it just about optimizations? Not really. The reason for this is exactly legacy backward compatibilities with ES5: the code from above with manual implementation of defaults should update ~x~ from the function body (which is the parameter itself, and is in the same scope).

** Closure
*** Brief
**** Eloquent
The ability to treat functions as values, combined with the fact that local bindings are re-created every time a function is called, brings up an interesting question: What happens to local bindings when the function call that created them is no longer active?

The following code shows an example of this. It defines a function, ~wrapValue~, that creates a local binding. It then returns a function that accesses and returns this local binding.

#+begin_src javascript

  function wrapValue(n) {
    let local = n;
    return () => local;
  }

  let wrap1 = wrapValue(1);
  let wrap2 = wrapValue(2);
  console.log(wrap1());  // ‚Üí 1
  console.log(wrap2());  // ‚Üí 2

#+end_src

This is allowed and works as you‚Äôd hope‚Äîboth instances of the binding can still be accessed. This situation is a good demonstration of the fact that local bindings are created anew for every call, and different calls don‚Äôt affect each other‚Äôs local bindings.

This feature‚Äî *being able to reference a specific instance of a local binding in an enclosing scope* ‚Äîis called /closure/. A function that references bindings from local scopes around it is called *a* closure. This behavior not only frees you from having to worry about the lifetimes of bindings but also makes it possible to use function values in some creative ways.

With a slight change, we can turn the previous example into a way to create functions that multiply by an arbitrary amount.

#+begin_src javascript

  function multiplier(factor) {
    return number => number * factor;
  }

  let twice = multiplier(2);
  console.log(twice(5));
  // ‚Üí 10

#+end_src

The explicit ~local~ binding from the ~wrapValue~ example isn‚Äôt really needed since a parameter is itself a local binding.

Thinking about programs like this takes some practice. A good mental model is to think of [[Functions as values][function values]] *as containing both the code in their body and the environment in which they are created*. When called, the function body sees the environment in which it was created, not the environment in which it is called.

In the previous example, ~multiplier~ is called and creates an environment in which its ~factor~ parameter is bound to ~2~. The function value it returns, which is stored in ~twice~, remembers this environment so that when that is called, it multiplies its argument by ~2~.

*Note*: closures allow to get hold of a binding at any particular point.

*Note (techsith youtube channel)*: "Closures are nothing but FUNCTIONS WITH PRESERVED DATA".

**** Dmitry S√≥shnikov
As is [[Scope chain][known]], ~[[Scope]]~ is *saved at function creation* and exists until the function object is destroyed.

A /closure/ is exactly a *combination of a function code* and *its* ~[[Scope]]~ (statically/lexically saved all parent scopes) *property*. Thus, via these saved scopes a function may easily refer free variables.

~[[Scope]]~ contains that [[Lexical environment][lexical environment]] in which function is *created*. Variables from higher contexts at the further function activation will be searched in this lexical chain of variable objects.

*Notice*, that since every (normal) function (anonymous, named, function expression or function declaration) saves ~[[Scope]]~ at creation, theoretically, all functions in ECMAScript are closures.

An exception to this rule can be functions created via Function constructor which ~[[Scope]]~ contains only global object.

Static scope is when function knows the resolution environment for free variables at time of creation. Closures is a natural continuation of the static scope. One can say: ‚Äúclosure == static scope‚Äù.

#+begin_src javascript

  var x = 10;

  function foo() {
      alert(x);
  }

  (function () {
      var x = 20;
      foo(); // 10, but not 20
  })();

#+end_src

We see that ~x~ variable is found in the ~[[Scope]]~ of ~foo~ function, i.e. for variables lookup the *lexical (closured) chain defined at the moment of function creation*, but not the dynamic chain of the call (at which value of ~x~ variable would be resolved to ~20~) is used.

Since in ECMAScript only a static scope is used, so ECMAScript has complete support of closures, which technically are implemented using ~[[Scope]]~ property of functions.

Closures in ECMAScript are:
- from the theoretical viewpoint :: all functions, since all they save at creation variables of a parent context. Even a simple global function, referencing a global variable refers a free variable and therefore, the general scope chain mechanism is used;

- from the practical viewpoint :: those functions are interesting which:
  - continue to exist after their parent context is finished, e.g. inner functions returned from a parent function;
  - use free variables.

*** Funarg problem
First subtype of the ‚Äúfunarg problem‚Äù is an ‚Äúupward funarg problem‚Äù. It appears when a function is returned ‚Äúup‚Äù (to the outside) from another function and uses free variables. To be able access variables of the parent context even after the parent context ends, the inner function at creation moment saves in it‚Äôs ~[[Scope]]~ property parent‚Äôs scope chain. Then when the function is activated, the scope chain of its context is formed as combination of the activation object and this ~[[Scope]]~ property:

#+begin_src javascript

  Scope chain = Activation object + [[Scope]]

#+end_src

Notice again the main thing ‚Äî *exactly at creation moment* ‚Äî a function saves parent‚Äôs scope chain, because exactly this saved scope chain will be used for variables lookup then in further calls of the function.

*Upward funarg problem*
It corresponds to the complexity of returning an inner function to the outside (upward) ‚Äî i.e. how can we implement the returning of the function if this function uses free variables of the parent environment in which it‚Äôs created?

As we already know, the lexical scope with saving enclosing frame on the heap ‚Äî is the key and the answer. And the strategy of storing bindings on the stack (used in C) does not fit anymore. Let‚Äôs repeat again, this *saved code block and the environment* ‚Äî is a /closure/.

#+begin_src javascript

  function foo() {
      var x = 10;
      return function bar() {
          console.log(x);
      };
  }

  // "foo" returns also a function
  // and this returned function uses
  // free variable "x"

  var returnedFunction = foo();

  // global variable "x"
  var x = 20;

  // execution of the returned function
  returnedFunction(); // 10, but not 20

  // This style of scope is called the static (or lexical) scope. We see
  // that the variable x is found in the saved [[Scope]] of returned bar
  // function.

#+end_src

*Downward funarg problem*
Downward funarg problem corresponds to the ambiguity of the variable name resolution when we pass a function which uses free variables as an argument to another function. In which scope these free variables should be resolved ‚Äî in the scope of the function definition or in the scope of the function execution?

I.e. downward funarg problem relates to the choice of the static (lexical) and dynamic scopes. As we already know and said above ‚Äî again, the lexical (static) scope ‚Äî is the answer. We should save exactly the lexical variables to avoid such ambiguities. And again ‚Äî this *saved lexical variables and the code* of our function ‚Äî is what is called a /closure/.

#+begin_src javascript

  // global "x"
  var x = 10;

  // global function
  function foo() {
      console.log(x);
  }

  (function (funArg) {

      // local "x"
      var x = 20;

      // there is no ambiguity,
      // because we use global "x",
      // which was statically saved in
      // [[Scope]] of the "foo" function,
      // but not the "x" of the caller's scope,
      // which activates the "funArg"

      funArg(); // 10, but not 20

  })(foo); // pass "down" foo as a "funarg"

#+end_src

*** Functions having the same parent scope
Several functions may have the same parent scope (it‚Äôs quite a normal situation when e.g. we have two inner/global functions). In this case variables stored in the ~[[Scope]]~ [[Scope chain][property]] are shared between all functions having the same parent scope chain. Changes of variables made by one closure are reflected on reading these variables in another closure:

#+begin_src javascript

  function baz() {
      var x = 1;
      return {
          foo: function foo() { return ++x; },
          bar: function bar() { return --x; }
      };
  }

  var closures = baz();

  console.log(
      closures.foo(), // 2
      closures.bar()  // 1
  );

                                  +--------------------------+
                                  | foo and bar [[Scope]]    |
                                  |                          |
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          |  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  |
  ‚îÇ        foo AO      ‚îÇ    ‚îå------->‚îÇ       baz AO       ‚îÇ  |
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    |     |  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  |
  | <other properties> |    |     |  |      x     |   1   |  |
  |--------------------|    |     |  |--------------------|  |
  | __parent__ |   |   |    |     |  | __parent__ |   |   |  |
  +----------------|---+    |     |  +----------------|---+  |
                   |        |     |              ‚îå----‚îò      |
                   ‚îî--------‚î§     |              v           |
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    |     |  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  |
  ‚îÇ        bar AO      ‚îÇ    |     |  ‚îÇ      Global VO     ‚îÇ  |
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    |     |  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  |
  | <other properties> |    |     |  |  closures  | {...} |  |
  |--------------------|    |     |  |--------------------|  |
  | __parent__ |   |   |    |     |  | <other properties> |  |
  +----------------|---+    |     |  |--------------------|  |
                   |        |     |  | __parent__ |  null |  |
                   ‚îî--------‚îò     |  +--------------------+  |
                                  +--------------------------+

#+end_src

Exactly with this feature confusion with creating several functions in a loop is related. Using a loop counter inside created functions, some programmers often get unexpected results when all functions have the same value of a counter inside a function. Now it should be clear why it is so ‚Äî because all these functions have the same ~[[Scope]]~ where the loop counter has the last assigned value.

*Note*: the [[Lexical declarations in the initialization block][for]] header contains further examples with illustrative diagrams of closure behavior.

#+begin_src javascript

  var data = [];

  for (var k = 0; k < 3; k++) {
      data[k] = function () {
          console.log(k);
      };
  }

  data[0](); // 3, but not 0
  data[1](); // 3, but not 1
  data[2](); // 3, but not 2

  //Schematically:
  activeContext.Scope = [
      ... // higher variable objects
          {data: [...], k: 3} // activation object
  ];

  data[0].[[Scope]] === Scope;
  data[1].[[Scope]] === Scope;
  data[2].[[Scope]] === Scope;


  // There are several techniques which may solve this issue. One of the
  // techniques is to provide an additional object in the scope chain ‚Äî
  // e.g. using additional function:

  var data = [];

  for (var k = 0; k < 3; k++) {
        data[k] = (function (x) {
                       return function () {
                                  console.log(x);
                              };
                   })(k);
   }               // pass "k" value

  // now it is correct
  data[0](); // 0
  data[1](); // 1
  data[2](); // 2

#+end_src

Let‚Äôs see what has happened in this case. First, the function ~_helper~ is created and *immediately activated* with the argument ~k~.

Then, returned value of the ~_helper~ function *is also a function*, and exactly it is saved to the corresponding element of the ~data~ array.

This technique provides the following effect: being activated, the ~_helper~ *every time creates a new activation object* which has argument ~x~, and the value of this argument is the passed value of ~k~ variable.

Thus, the ~[[Scope]]~ of returned functions is the following:

#+begin_src javascript

  data[0].[[Scope]] === [
      ... // higher variable objects
      AO of the parent context: {data: [...], k: 3},
      AO of the _helper context: {x: 0}
  ];

  data[1].[[Scope]] === [
      ... // higher variable objects
      AO of the parent context: {data: [...], k: 3},
      AO of the _helper context: {x: 1}
  ];

  data[2].[[Scope]] === [
      ... // higher variable objects
      AO of the parent context: {data: [...], k: 3},
      AO of the _helper context: {x: 2}
  ];

  // We see that now the [[Scope]] property of functions have the reference
  // to the needed value ‚Äî via the x variable which is captured by the
  // additionally created scope.

#+end_src

*Note*: ES6 introduced *block-scope bindings*. This is done via ~let~ or ~const~ keywords. Example from above can now easily and conveniently rewritten as:

*Note*: for a better understanding of the following example you can review the behavior of the [[Scope behaviors in the for loop][for]] loop.

#+begin_src javascript

  let data = [];

  for (let k = 0; k < 3; k++) {
      data[k] = function () {
          console.log(k);
      };
  }

  data[0](); // 0
  data[1](); // 1
  data[2](); // 2

#+end_src

** this
*** Brief
**** MDN
The ~this~ keyword refers to the *context where* a piece of code, such as a function's body, is supposed to run.

The value of ~this~ in JavaScript depends on *how a function is invoked* (runtime binding), not how it is defined. When a regular function is invoked as a method of an object (~obj.method()~), ~this~ points to that object. When invoked as a standalone function (not attached to an object: ~func()~), ~this~ typically refers to the global object (in non-strict mode) or ~undefined~ (in strict mode).

The value of ~this~ depends on in which context it appears: function, class, or global.

**** Eloquent
You can think of ~this~ as an *extra parameter that is passed in a different way*. If you want to pass it explicitly, you can use a function‚Äôs [[Function.prototype.call][call]] method, which takes the ~this~ value as its first argument and treats further arguments as normal parameters.

#+begin_src javascript

  function Product(name, price) {
      this.name = name;
      this.price = price;
  }

  function Food(name, price) {
      Product.call(this, name, price);
      this.category = 'food';
  }

  function Food2(name, price) {
      Product(name, price);
      this.category = 'food';
  }

  console.log(new Food('cheese', 5));
  // Food { name: 'cheese', price: 5, category: 'food' }

  console.log(new Food2('CHEESE', 15));
  // Food2 { category: 'food' }

  console.log(global.name,global.price); // CHEESE 15

  // Since each function has its own this binding, whose value depends on
  // the way it is called, you cannot refer to the this of the wrapping
  // scope in a regular function defined with the function keyword.

#+end_src

**** Dmitry S√≥shnikov
A ~this~ value is a special object in *which context, a code is executed*. It's related with the [[Execution context][execution context]] (~this~ is a property of the execution context). Therefore, it may be named as a context object (i.e. an object in which context the execution context is activated).

The value of ~this~ in a function context is *provided by the caller* and *determined* by the current *form of a call expression* (how the function call is written *syntactically*).

#+begin_src javascript

  activeExecutionContext = {
      VO: {...},  // variable object
      this: thisValue
  };

#+end_src

In the global context, ~this~ binding is still the *global object itself*, and inside a function context ~this~ value is still determined by the form of *how the function is called*. If it‚Äôs called with a reference, then the *base value* of the reference is used as ~this~ value, in all other cases ‚Äî either global object or ~undefined~ in strict mode is used for ~this~.

#+begin_src javascript

  var foo = {
      bar: function () {
          console.log(this);
      }
  };

  // --- Reference cases ---

  // with a reference
  foo.bar(); // `this` is foo - the base

  var bar = foo.bar;

  // with the reference
  bar(); // `this` is the global or undefined, implicit base
  this.bar(); // the same, explicit base, the global
  (foo.bar)(); // Reference, OK => foo

  // with also but another reference
  bar.prototype.constructor(); // `this` is bar.prototype

  // --- non-Reference cases ---
  (foo.bar = foo.bar)(); // `this` is global or undefined
  (foo.bar || foo.bar)(); // `this` is global or undefined
  (function () { console.log(this); })(); // `this` is global or undefined

#+end_src

~this~ is directly related to the type of executable code (global code, function code, ) of the context. The value is determined on entering the context and is *immutable* while the code is running in the context.

Any object can be used as ~this~ value of the context. One important note is that the this value is a property of the execution context, but not a property of the variable object.

This feature is very important, because in contrast with variables, ~this~ value never participates in identifier resolution process. I.e. *when accessing this in a code, its value is taken directly from the execution context and without any scope chain lookup*. The value of ~this~ is determined only once, on entering the context.

*Note*: In ES6 ~this~ actually became a property of a lexical environment, i.e. property of the variable object in ES3 terminology. This is done to support arrow functions, which have lexical ~this~, which they inherit from parent contexts.

In case of a function context, ~this~ value in every single function call may be different. Here ~this~ value is provided by the caller via the form of a call expression (i.e. *the way of how a function is activated*). For example, the function ~foo~ below is a callee, being called from the global context, which is a caller.

#+begin_src javascript

  // the code of the "foo" function never changes, but the
  //  "this" value differs in every activation

  function foo() {
      console.log(this);
  }

  // caller activates "foo" (callee) and
  // provides "this" for the callee

  foo();
  // global

  console.log(foo === foo.prototype.constructor); // true

  // but with another form of the call expression
  // of the same function, this value is different
  foo.prototype.constructor();
  // foo.prototype

#+end_src

[[Function call and non-Reference type][Case]] where the *base object of Reference type* value is the [[Activation object][activation object]].

We can see this situation on an example with the inner function called from the parent. As we know, local variables, inner functions and formal parameters are stored in the activation object of the given function:

The activation object always returns as ~this~ value ‚Äî ~null~ (i.e. pseudo-code ~AO.bar()~ is equivalent to ~null.bar()~).

#+begin_src javascript

  function foo() {
      console.log(this);
      function bar() {
          console.log(this);
      }
      bar(); // the same as AO.bar()
  }

  foo();     // global     // global

  const obj = { foo }
  obj.foo()  // obj        // global


  // The situation with a recursive call of the named function expression
  (function foo(bar) {

      console.log(this);

      // "should" be special object, but always (correct) global
      !bar && foo(1);

  })(); // global
  // At the first call of function, base object is the parent activation
  // object (or the global object), at the recursive call ‚Äî base object
  // should be special object storing the optional name of a function
  // expression. However, in this case this value is also always set to global

#+end_src

*** this in global context
In the global context  (outside of any functions or classes; may be inside blocks or arrow functions defined in the global scope), a ~this~ value is always the *global object itself* (that means, ~this~ value here equals to variable object).

At the top level of a script, ~this~ refers to ~globalThis~ whether in strict mode or not.

#+begin_src javascript

  // In web browsers, the window object is also the global object:
  console.log(this === window); // true

  var x = 10;

  console.log(
      x,       // 10
      this.x,  // 10
      window.x // 10
  );

  // explicit property definition of the global object
  this.a = 10;           // 10
  console.log(a);        // 10
  console.log(window.a); // 10

  // implicit definition via assigning to unqualified identifier
  b = 20;
  console.log(this.b);   // 20

  // also implicit via variable declaration
  var c = 30;
  console.log(this.c);   // 30

#+end_src

If the source is loaded as a module (for HTML, this means adding ~type="module"~ to the ~<script>~ tag), ~this~ is always ~undefined~ at the top level.

#+begin_src javascript

  // Browser:
  'use strict'

  console.log(this);                  // global    // global in non-strict
  (() => console.log(this))();        // global    // global in non-strict
  (function() {console.log(this)})(); // undefined // global in non-strict


  // Node:
  'use strict'

  console.log(this);                  // {}        // {} in non-strict
  (() => console.log(this))();        // {}        // {} in non-strict
  (function() {console.log(this)})(); // undefined // globalThis in non-strict

#+end_src

*** this in function contexts
The first (and, probably, the main) feature of ~this~ value in this type of code is that here it is *not statically bound* to a function.

In a usual function call, ~this~ *is provided by the caller* which *activates* the code of the context, i.e. the *parent context which calls the function*. And the value of ~this~ is determined by the form of a call expression (in other words by the form how *syntactically* the function is called).

~this~ value is determined on entering the context, and in case with a function code the value can be absolutely different every time.

However, at runtime of the code ~this~ value is immutable, i.e. it is not possible to assign a new value to it since this is not a variable.

#+begin_src javascript

  function foo() {
      console.log(this);
  }

  foo();
  // global

  console.log(foo === foo.prototype.constructor); // true

  // but with another form of the call expression
  // of the same function, this value is different
  foo.prototype.constructor();
  // foo.prototype

  // Why the same function activated with different forms of a call
  // expression, has also different this values ‚Äî the answer is in
  // different intermediate values of typeReference (pseudo-code):
  var fooReference = {
      base: global,
      propertyName: 'foo'
  };

  var fooPrototypeConstructorReference = {
      base: foo.prototype,
      propertyName: 'constructor'
  };

#+end_src

It is similarly possible to call the function defined as a method of some object, but ~this~ value will not be set to this object:

#+begin_src javascript

  var foo = {
      bar: function () {
          console.log(this);
          console.log(this === foo);
      }
  };

  foo.bar();
  // foo, true

  var exampleFunc = foo.bar;

  console.log(exampleFunc === foo.bar); // true

  // again with another form of the call expression
  // of the same function, we have different this value
  exampleFunc();
  // global, false

#+end_src

If the value that the method is accessed on is a primitive, ~this~ will be a primitive value as well ‚Äî but only if the function is in strict mode.

In non-strict mode, a special process called ~this~ substitution ensures that the value of ~this~ is always an object. This means:

- If a function is called with ~this~ set to ~undefined~ or ~null~, ~this~ gets substituted with ~globalThis~.
- If the function is called with ~this~ set to a primitive value, ~this~ gets substituted with the primitive value's wrapper object.

#+begin_src javascript

  function getThisStrict() {
    "use strict"; // Enter strict mode
    return this;
  }

  // Only for demonstration ‚Äî you should not mutate built-in prototypes
  Number.prototype.getThisStrict = getThisStrict;
  console.log((1).getThisStrict());
  // 1           // [Number: 1]   in non-strict mode

  // called without being accessed on anything
  console.log(getThisStrict()); // "undefined"
  // undefined   // global        in non-strict mode

#+end_src

*** Function call and non-Reference type
In case when on the left hand side of call parentheses *there is a value not of* ~Reference~ *type*  (it is not the identifier and not the property accessor), but any another type, this value is automatically set to ~null~ and, as consequence, to the global object.

#+begin_src javascript

  function foo() {
      console.log(this);
  }

  var bar = {
      baz: foo
  };

  bar.baz();             // Reference, OK => bar
  (bar.baz)();           // Reference, OK => bar

  (bar.baz = bar.baz)(); // Value (function), OK => global object
  (bar.baz, bar.baz)();  // Value (function), OK => global object
  (false || bar.baz)();  // Value (function), OK => global object
  // After applying the operations, we already have on the left
  // side of call parenthesis the value that's not of type Reference

  var otherFoo = bar.baz;
  otherFoo();            // Reference, OK => global object


  // Why the same function activated with different forms of a call
  // expression, has also different this values ‚Äî the answer is in
  // different intermediate values of typeReference (pseudo-code):
  var fooReference = {
      base: global,
      propertyName: 'foo'
  };

  var fooPrototypeConstructorReference = {
      base: foo.prototype,
      propertyName: 'constructor'
  };

#+end_src

In the second case there *is a grouping operator* which does not apply. Accordingly, at return from evaluation of the grouping operator ‚Äî we still have a value of ~Reference~ type and that is *why* this value is again set to the base object.

In the third case, *assignment operator*. As a result at return there is already function object (but not a value of ~Reference~ type) which means that ~this~ value set to ~null~ and, as consequence, to global.

Similarly with the fourth and fifth cases ‚Äî the *comma operator* and *logical OR expression* call the ~GetValue~ method and accordingly we lose value of type ~Reference~ and get value of type function; and again ~this~ value is set to global.

There is a case when call expression determines on the left hand side of call parentheses the value of ~Reference~ type, however ~this~ value is set to ~null~ and, as consequence, to global. It is related to the case *when the base object of Reference type value is* the [[Activation object][activation object]].

We can see this situation on an example with the inner function called from the parent. As we know, local variables, inner functions and formal parameters are stored in the activation object of the given function:

The activation object always returns as ~this~ value ‚Äî ~null~ (i.e. pseudo-code ~AO.bar()~ is equivalent to ~null.bar()~). Here again we come back to the described above case, and again, ~this~ value is set to global object.

#+begin_src javascript

  function foo() {
      function bar() {
          console.log(this); // global
      }
      bar(); // the same as AO.bar()
  }

  foo();


  // The situation with a recursive call of the named function expression
  (function foo(bar) {

      console.log(this);

      // "should" be special object, but always (correct) global
      !bar && foo(1);

  })(); // global
  // At the first call of function, base object is the parent activation
  // object (or the global object), at the recursive call ‚Äî base object
  // should be special object storing the optional name of a function
  // expression. However, in this case this value is also always set to global

#+end_src

*** this in function called as the constructor
*Dmitry S√≥shnikov*
In this case, the ~new~ operator calls the internal ~[[Construct]]~ method of the ~A~ function which, in turn, after object creation, calls the internal ~[[Call]]~ method, all the same function ~A~, having provided as ~this~ value *newly created object*.

#+begin_src javascript

  function A() {
      console.log(this); // newly created object, below - "a" object
      this.x = 10;
  }

  var a = new A();
  console.log(a.x); // 10

#+end_src

*MDN*
When a function is used as a constructor (with the ~new~ keyword), its ~this~ is bound to the *new object being constructed*, no matter which object the constructor function is accessed on. The value of ~this~ becomes the value of the ~new~ expression unless the constructor returns another non‚Äìprimitive value.

#+begin_src javascript

  function C() {
      this.a = 37;
  }

  let o = new C();
  console.log(o.a); // 37

  function C2() {
      this.a = 37;
      return { a: 38 };
  }

  o = new C2();
  console.log(o.a); // 38
  // because an object was returned during construction, the new object
  // that this was bound to gets discarded. (This essentially makes the
  // statement this.a = 37; dead code. It's not exactly dead because it
  // gets executed, but it can be eliminated with no outside effects)

#+end_src

*** this in class context
A class can be *split into two contexts*: /static/ and /instance/. Constructors, methods, and instance field initializers (public or private) belong to the instance context. Static methods, static field initializers, and static initialization blocks belong to the static context. The ~this~ value is different in each context.

*instance*
Class constructors are always called with ~new~, so their behavior is the same as [[this in function called as the constructor][function constructors]]: the ~this~ value is the new *instance being created*. Class methods behave like methods in object literals ‚Äî the ~this~ value is the object that the method *was accessed on*. If the method is not transferred to another object, ~this~ is generally an instance of the class.

*static*
Static methods are not properties of ~this~. They are properties of the class itself. Therefore, they are generally accessed on the class, and ~this~ is the value of the *class* (or a *subclass*). Static initialization blocks are also evaluated with ~this~ set to the current class.

Field initializers are also evaluated in the context of the class. Instance fields are evaluated with ~this~ set to the *instance* being constructed. Static fields are evaluated with ~this~ set to the current *class*. This is why /arrow functions/ in field initializers are bound to the instance for instance fields and to the class for static fields.

#+begin_src javascript

  class C {
    instanceField = this;
    static staticField = this;
  }

  const c = new C();
  console.log(c.instanceField === c); // true
  console.log(C.staticField === C); // true

#+end_src

*** this in arrow functions
Arrow functions *do not bind their own* ~this~ but can see the this binding of the *scope around them*. ~this~ retains the value of the enclosing lexical context's ~this~. In other words, when evaluating an arrow function's body, the language does not create a new ~this~ binding.

For example, in global code, ~this~ is always ~globalThis~ regardless of strictness, because of the global context binding.

Arrow functions *create a closure over* the ~this~ value of its surrounding scope, which means arrow functions behave as if they are "auto-bound" ‚Äî no matter how it's invoked, ~this~ is bound to what it was when the function *was created*. The same applies to arrow functions created inside other functions: their ~this~ remains that of the *enclosing lexical context*.

#+begin_src javascript

  function normalize() {
      console.log(this.coords.map(n => n / this.length));
  }

  normalize.call({coords: [0, 2, 3], length: 5});
  // ‚Üí [0, 0.4, 0.6]

  normalize()
  // console.log(this.coords.map(n => n / this.length));
  //                         ^
  // TypeError: Cannot read properties of undefined (reading 'map')
  // This is due that here 'this' is 'global' and 'glocal.coords == undefined'

#+end_src

*Dmitry S√≥shnikov*
Introduced in ES2015 arrow functions use *lexical* (i.e. static) scope, and capture ~this~ in the *lexical environment*, same as other variables.

Until arrow functions, every new function defined its own ~this~ value. This proved to be less than ideal with an object-oriented style of programming.

#+begin_src javascript

  function Person() {
      // The Person() constructor defines `this` as itself.
      this.age = 0;

      setInterval(function growUp() {
          // In nonstrict mode, the growUp() function defines `this`
          // as the global object, which is different from the `this`
          // defined by the Person() constructor.
          this.age++;
      }, 1000);
  }

  const p = new Person();

#+end_src

In ECMAScript 3/5, this issue was fixed by assigning the value in ~this~ to a variable that could be closed over.

#+begin_src javascript

  function Person() {
      // Some choose `that` instead of `self`.
      // Choose one and be consistent.
      const self = this;
      self.age = 0;

      setInterval(function growUp() {
          // The callback refers to the `self` variable of which
          // the value is the expected object.
          self.age++;
      }, 1000);

  }

#+end_src

Alternatively, a bound function could be created so that the proper ~this~ value *would be passed to* the ~growUp()~ function.

An arrow function does not have its own ~this~; the ~this~ value of *the enclosing execution context* is used. Thus, in the following code, the ~this~ within the function that is passed to ~setInterval~ has the same value as ~this~ in the enclosing function:

#+begin_src javascript

  function Person() {
      this.age = 0;

      setInterval(() => {
          this.age++; // `this` properly refers to the person object
      }, 1000);
  }

  const p = new Person();

#+end_src

In the following example, we create ~obj~ with a method ~getThisGetter~ that returns a function that returns the value of ~this~. The returned function is created as an arrow function, so its ~this~ is permanently bound to the ~this~ of its *enclosing function*. The value of ~this~ inside ~getThisGetter~ can be set in the call, which in turn sets the return value of the returned function.

#+begin_src javascript

  const obj = {
      getThisGetter() {
          const getter = () => this;
          return getter;
      },
  };

  const fn = obj.getThisGetter();
  console.log(fn() === obj); // true
  // We can call getThisGetter as a method of obj, which binds this to obj
  // inside its body. The returned function is assigned to a variable
  // fn. Now, when calling fn, the value of this returned is still the one
  // set by the call to getThisGetter, which is obj. If the returned
  // function was not an arrow function, such calls would cause the this
  // value to be globalThis, because getThisGetter is non-strict.

  const fn2 = obj.getThisGetter;
  console.log(fn2()() === globalThis); // true in non-strict mode
  // But be careful if you unbind the method of obj without calling it,
  // because getThisGetter is still a method that has a varying this
  // value. Calling fn2()() in the following example returns globalThis,
  // because it follows the this from fn2(), which is globalThis since it's
  // called without being attached to any object.

#+end_src

Example of arrow functions called in different ways.

#+begin_src javascript

  // 'use strict'
  function foo() {
      console.log(this);
      const arrow = () => console.log(this);
      return arrow;
  }

  foo();
  // global     // 'undefined' in strict mode
  foo()();
  // global     // 'undefined' in strict mode
  // global     // 'undefined' in strict mode

  const fooBind = foo();
  fooBind();
  // global     // 'undefined' in strict mode
  // global     // 'undefined' in strict mode

  foo.call({});
  // {}
  foo.call({})();
  // {}
  // {}

  const obj = { foo };

  obj.foo();
  // { foo: [Function: foo] }
  obj.foo()();
  // { foo: [Function: foo] }
  // { foo: [Function: foo] }

#+end_src

*** this in object literals
In methods in object literals ‚Äî the ~this~ value is the object that the method *was accessed on*.

#+begin_src javascript

  'use strict'
  const obj = {
      a: this,
      foo() {
          return this;
      }
  }

  console.log(obj.foo());
  // { a: global, foo: [Function: foo] }

  const fooRef = obj.foo;
  console.log(fooRef())
  // undefined      // 'global' in non-strict mode

#+end_src

*** this in callbacks
When a function is passed as a callback, the value of ~this~ depends on *how the callback is called*, which is determined by the *implementor of the API*. Callbacks are /typically/ called with a ~this~ value of ~undefined~ (calling it directly without attaching it to any object), which means if the function is non‚Äìstrict, the value of ~this~ is the global object (~globalThis~). This is the case for iterative array methods, the ~Promise()~ constructor, etc.

#+begin_src javascript

  function logThis() {
    "use strict";
    console.log(this);
  }

  [1, 2, 3].forEach(logThis); // undefined, undefined, undefined

#+end_src

Unlike arrow functions, every new function defines its own ~this~ value. This proved to be less than ideal with an object-oriented style of programming.

#+begin_src javascript

  function Person() {
      // The Person() constructor defines `this` as itself.
      this.age = 0;

      setInterval(function growUp() {
          // In nonstrict mode, the growUp() function defines `this`
          // as the global object, which is different from the `this`
          // defined by the Person() constructor.
          this.age++;
      }, 1000);
  }

  const p = new Person();

#+end_src

*** Manual setting of this value for a function call (bound functions)
There are two methods defined in the ~Function.prototype~ (therefore they are accessible to all functions), allowing to specify ~this~ value of a function call manually. These are ~apply~ and ~call~ methods.

Both of them accept as the first argument ~this~ value which is used in a called context. A difference between these methods is insignificant: for the ~apply~ the second argument necessarily should be an array (or, the array-like object, for example, ~arguments~), in turn, the ~call~ method can accept any arguments; obligatory arguments for both methods is only the first ‚Äî ~this~ value.

#+begin_src javascript

  var b = 10;

  function a(c) {
      console.log(this.b);
      console.log(c);
  }

  a(20); // this === global, this.b == 10, c == 20

  a.call({b: 20}, 30); // this === {b: 20}, this.b == 20, c == 30
  a.apply({b: 30}, [40]) // this === {b: 30}, this.b == 30, c == 40

#+end_src

** Higher-order functions
Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions.

Higher-order functions allow us to abstract over actions, not just values. They come in several forms.

Higher-order functions start to shine when you need to *compose* operations.

Being able to pass function values to other functions is a deeply useful aspect of JavaScript. It allows us to write functions that model computations with ‚Äúgaps‚Äù in them. The code that calls these functions can fill in the gaps by providing function values.

Arrays provide a number of useful higher-order methods. You can use ~forEach~ to loop over the elements in an array. The ~filter~ method returns a new array containing only the elements that pass the predicate function. Transforming an array by putting each element through a function is done with ~map~. You can use ~reduce~ to combine all the elements in an array into a single value. The ~some~ method tests whether any element matches a given predicate function. And ~findIndex~ finds the position of the first element that matches a predicate.

*Wikipedia*
First-class citizen is an entity which supports all the operations generally available to other entities. These operations typically include being passed as an argument, returned from a function, and assigned to a variable (including local identifiers), just as any other data type can.

/Higher-order/ functions are closely related to /first-class/ functions in that higher-order functions and first-class functions both allow functions as arguments and results of other functions. The distinction between the two is subtle: "higher-order" describes a mathematical concept of functions that operate on other functions, while "first-class" is a computer science term for programming language entities that have no restriction on their use (thus first-class functions can appear anywhere in the program that other first-class entities like numbers can, including as arguments to other functions and as their return values).

** Environment
*** Execution context
**** Execution context
An execution context abstractly may be represented as a simple object. Every execution context has set of properties (which we may call a context‚Äôs state) necessary to track the execution progress of its associated code.

Besides these three needed properties (a variable object, a [[this]] value and a scope chain), an execution context may have any additional state depending on implementation.

#+begin_src artist

  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ                       Execution context                          ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  |  Variable object  | { vars, function declarations,arguments... } |
  |------------------------------------------------------------------|
  |    Scope chain    | [ Variable object + all parent scopes ]      |
  |------------------------------------------------------------------|
  |    this Value     |         Context object                       |
  +------------------------------------------------------------------+

#+end_src

**** Execution context stack
There are *three types* of ECMAScript code: *global code*, *function code* and *eval code*. Every code is evaluated in its execution context. There is only one global context and may be many instances of function and eval execution contexts. Every call of a function, enters the function execution context and evaluates the function code type. Every call of ~eval~ function, enters the eval execution context and evaluates its code.

Notice, that one function may generate infinite set of contexts, because every call to a function (even if the function calls itself recursively) produces a new context with a new context state:

#+begin_src javascript

  function foo(bar) {}

  // call the same function, generate three different contexts in each
  // call, with different context state (e.g. value of the "bar" argument)

  foo(10);
  foo(20);
  foo(30);

#+end_src

An execution context may activate another context, e.g. a function calls another function (or the global context calls a global function), and so on. Logically, this is implemented as a stack, which is called the /execution context stack/.

A *context which activates another context* is called a /caller/. A *context is being activated* is called a /callee/. A callee at the same time may be a caller of some other callee (e.g. a function called from the global context, calls then some inner function).

When a caller activates (calls) a callee, the caller suspends its execution and passes the control flow to the callee. The callee is pushed onto the the stack and is becoming a running (active) execution context. After the callee‚Äôs context ends, it returns control to the caller, and the evaluation of the caller‚Äôs context proceeds (it may activate then other contexts) till the its end, and so on. A callee may simply return or exit with an exception. A thrown but not caught exception may exit (pop from the stack) one or more contexts.

I.e. all the ECMAScript program runtime is presented as the execution context (EC) stack, where top of this stack is an active context.

When program begins it enters the global execution context, which is the bottom and the first element of the stack. Then the global code provides some initialization, creates needed objects and functions. During the execution of the global context, its code may activate some other (already created) function, which will enter their execution contexts, pushing new elements onto the stack, and so on. After *the initialization is done, the runtime system is waiting for some event* (e.g. user‚Äôs mouse click) which will activate some function and which will enter a new execution context.

#+begin_src artist

  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ    EC stack   ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  |   Active EC   |<---top---
  |---------------|
  |      ...      |
  |---------------|
  |      ECN      |
  |---------------|
  |   Global EC   |
  +---------------+

#+end_src

We define the stack of execution contexts as an array. The *stack is pushed every time on entering a function* (even if the function is called recursively or as the constructor), and also at built-in ~eval~ function work.

#+begin_src javascript

  ECStack = [];

#+end_src

**** Types of executable code
***** Global code
This type of code is processed at level Program: i.e. the loaded external ~.js-~ file or the local inline-code (inside the ~<script></script>~ tags). The global code *does not include any parts of a code which are in bodies of functions*.

At initialization (program start), ECStack looks like:

#+begin_src javascript

  ECStack = [
      globalContext
  ];

#+end_src

***** Function code
On entering the function code (all kinds of functions), =ECStack= is pushed with new elements. It is necessary to notice that the code of concrete function does not include codes of the inner functions.

#+begin_src javascript

  //Let‚Äôs take the function which calls itself recursively once:
  (function foo(flag) {
      if (flag) {
          return;
      }
      foo(true);
  })(false);

  // Then, ECStack is modified as follows:

  // first activation of foo
  ECStack = [
      <foo> functionContext
      globalContext
  ];

  // recursive activation of foo
  ECStack = [
      <foo> functionContext ‚Äì recursively
      <foo> functionContext
      globalContext
  ];

#+end_src

Every return from a function exits the current execution context and =ECStack= popped accordingly ‚Äî consecutively and upside-down ‚Äî quite natural implementation of a stack. After the work of this code is finished, =ECStack= again contains only =globalContext= ‚Äî until the program end.

A thrown but not caught exception may also exit one or more execution contexts:

#+begin_src javascript

  (function foo() {
      (function bar() {
          throw 'Exit from bar and foo contexts';
      })();
  })();

#+end_src

***** Eval code
In this case, there is a concept of a calling context, i.e. a context from which ~eval~ function is called.

The actions made by ~eval~, such as variable or function definition, influence exactly the calling context:

*Note*: in the strict-mode of ES5, ~eval~ already does not influence the calling context, but instead evaluates the code in the local sandbox.

*** Variable objects
**** Variable object
***** Variable object
Always in programs we declare functions and variables which then successfully use building our systems. If variables are related with the execution context, it should know where its data are stored and how to get them. This mechanism is called a /variable object/.

A variable object is a *container of data associated with the execution context*. It‚Äôs a special object that stores *variables* and *function declarations* defined in the *context*.

The variable object is created and filled with initial values every time on [[Entering the execution context][entering the context]], and that its updating occurs at [[Code execution][code execution]] phase.

*Notice*, that [[Function expressions][function expressions]] (in contrast with [[Function declarations][function declarations]]) are not included into the variable object.

*Note*: in ES5 the concept of variable object is replaced with [[Environment (scope chain)][lexical environments model]].

A variable object is an abstract concept. In different context types, physically, it‚Äôs presented using different object. For example, in the global context the variable object is the [[Global object][global object]] itself (that‚Äôs why we have an ability to refer global variables via property names of the global object).

When we declare a variable or a function, there is nothing else as *creation of the new property of the VO* with the name and value of our variable.

Variables and inner functions defined within a scope of a function are not visible directly outside and do not pollute the global variable object.

#+begin_src javascript

  var foo = 10;

  function bar() {} // function declaration, FD
  (function baz() {}); // function expression, FE

  console.log(
      this.foo == foo, // true
      window.bar == bar // true
  );

  console.log(baz); // ReferenceError, "baz" is not defined

  +------------------------+
  |        Global VO       |
  +------------------------+
  |    foo    |     10     |
  |------------------------|
  |    bar    | <function> |
  |------------------------|
  |       <built-ins>      |
  +------------------------+

#+end_src

Notice, accessing global variables via properties of the global object in ES2015 is only allowed for the variables created via ~var~ keyword. The ~let~, ~const~, and classes *do not create properties*.

#+begin_src javascript

  var foo = 10;
  console.log(this.foo); // 10

  let bar = 20;
  console.log(this.bar); // undefined

#+end_src

This is due the /Global Environment Record/ in ES2015 is *split into two parts*: Object Environment Record (which is returned as ~this~ value in the global context), and Declarative Environment Record (in this case this is very Activation Object).

And first related thing to it, is while not being able to assign to an undeclared identifier, we can normally assign to a new non-existing property of the global object:

#+begin_src javascript

  'use strict';

  this.baz = 10;

  console.log(baz); // OK, 10

  // Can normally reassign
  baz = 20;

  console.log(baz); // 20

#+end_src

*Note*: /identifier resolution/ is a process of determination to which variable object in [[Scope chain][scope chain]] the variable (or the function declaration) belongs.

On return from this algorithm we have always a value of ~type Reference~, which *base* component *is the corresponding variable object* (or ~null~ if variable is not found), and a *property name* component *is the name* of the looked up (resolved) identifier.

***** Global object
****** Dmitry S√≥shnikov
The /global object/ is the object which is *created before entering any execution context*; this object exists in the single copy, its properties are accessible from any place of the program, the life cycle of the global object ends with program end.

At creation the global object is initialized with such properties as ~Math~, ~String~, ~Date~, ~parseInt~ etc., and also by additional objects among which can be the reference to the global object itself ‚Äî for example, in BOM, ~window~ property of the global object refers to global object (however, not in all implementations):

#+begin_src javascript

  global = {
      Math: <...>,
      String: <...>
      ...
      ...
      window: global
  };

#+end_src

The [[Variable object][variable object]] of the global context ‚Äî here variable object is the global object itself:

#+begin_src javascript

  VO(globalContext) === global;

#+end_src

It is necessary to understand accurately this fact since for this reason declaring a variable in the global context, we have ability to reference it indirectly via property of the global object (for example when the variable name is unknown in advance):

#+begin_src javascript

  var a = new String('test');

  alert(a); // directly, is found in VO(globalContext): "test"

  alert(window['a']); // indirectly via global === VO(globalContext): "test"
  alert(a === this.a); // true

  var aKey = 'a';
  alert(window[aKey]); // indirectly, with dynamic property name: "test"

#+end_src

****** MDN
The /global object/ in JavaScript is an object which represents the *global scope*.

*Note*: In a programming environment, the *global scope* is the scope that contains, and is visible in, all other scopes.

*Note*: /Globally available objects/, which are objects in the global scope, are sometimes also referred to as global objects, but strictly speaking, there is only one global object per environment.

In each JavaScript environment, there's always a global object defined. The global object's interface depends on the execution context in which the script is running. For example:

- In a *web browser*, any code which the script doesn't specifically start up as a background task has a [[Window]] as its global object. This is the vast majority of JavaScript code on the Web.
- Code running in a ~Worker~ has a ~WorkerGlobalScope~ object as its global object.
- Scripts running under *Node.js* have an object called *global* as their global object.

The ~globalThis~ global property allows one to access the global object regardless of the current environment.

~var~ statements and [[Function declarations][function declarations]] at the top level of a script create properties of the global object. On the other hand, ~let~ and ~const~ declarations never create properties of the global object.

The properties of the global object are automatically added to the *global scope*.

In JavaScript, the global object always holds a reference to itself:

#+begin_src javascript

  console.log(globalThis === globalThis.globalThis); // true (everywhere)
  console.log(window === window.window); // true (in a browser)
  console.log(self === self.self); // true (in a browser or a Web Worker)
  console.log(frames === frames.frames); // true (in a browser)
  console.log(global === global.global); // true (in Node.js)

#+end_src

***** Variables, and global object properties
Often various articles and even books on JavaScript claim that:

‚Äúit is possible to declare global variables using ~var~ keyword (in the global context) and without using ~var~ keyword (in any place)‚Äù.

It is not so. Remember: variables are declared *only* with using ~var~ keyword.

And assignments like:

#+begin_src javascript

  a = 10;

#+end_src

just create the *new property* (but *not the variable*) of the [[Global object][global object]]. ‚ÄúNot the variable‚Äù is not in the sense that it cannot be changed, but ‚Äúnot the variable‚Äù in concept of variables in ECMAScript (which then also become properties of the global object because of ~VO(globalContext)=== global~).

And the difference is the following:

#+begin_src javascript

  alert(a); // undefined
  alert(b); // "b" is not defined

  b = 10;
  var a = 20;

#+end_src

All again depends on [[Variable object][VO]] and phases of its modifications ([[Entering the execution context][entering the context]] stage and the [[Code execution][code execution]] stage):

Entering the context:

#+begin_src javascript

  VO = {
      a: undefined
  };

#+end_src

We see that at this phase there is no any ~b~ since it is not a variable, ~b~ will appear only at code execution phase (but in our case won‚Äôt since there is an error).

Let‚Äôs change the code:

#+begin_src javascript

  alert(a); // undefined, we know why

  b = 10;
  alert(b); // 10, created at code execution

  var a = 20;
  alert(a); // 20, modified at code execution

#+end_src

**** Activation object
***** Activation object
When a function is activated (called) by the [[Caller and callee][caller]], a special object called an /activation object/ is created. It‚Äôs filled with formal parameters and the special ~arguments~ object (which is a map of formal parameters but with index-properties). The activation object then is used as a [[Variable object][variable object]] of the function context.

I.e. a function‚Äôs variable object is the same simple variable object, but besides *variables* and [[Function declarations][function declarations]], it also stores *formal parameters* and ~arguments~ object and called the activation object.

An activation object is *created on entering the context of a function* and initialized by property arguments which value is the [[Arguments object]].

*Notice*, in ES5 the concepts of variable object, and activation object are combined into the [[Environment (scope chain)][lexical environments]] model.

#+begin_src javascript

  function foo(x, y) {
      var z = 30;
      function bar() {} // FD
      (function baz() {}); // FE
  }

  foo(10, 20);

  +------------------------------------+
  |         Activation object          |
  +------------------------------------+
  |       x       |         10         |
  |------------------------------------|
  |       y       |         20         |
  |------------------------------------|
  |   arguments   | {0: 10, 1: 20, ..} |
  |------------------------------------|
  |       z       |         30         |
  |------------------------------------|
  |      bar      |     <function>     |
  +------------------------------------+

#+end_src

***** Arguments object
*Arguments* object is a property of the [[Activation object][activation object]]. It contains the following properties:

- callee :: the reference to the current function;
- length :: quantity of real passed arguments;
- properties-indexes :: (integer, converted to string) which values are the values of function‚Äôs arguments (from left to right in the list of arguments). Quantity of these properties-indexes == arguments.length. Values of properties-indexes of the arguments object and present (really passed) formal parameters are shared.

#+begin_src javascript

  function foo(x, y, z) {

      // quantity of defined function arguments (x, y, z)
      alert(foo.length); // 3

      // quantity of really passed arguments (only x, y)
      alert(arguments.length); // 2

      // reference of a function to itself
      alert(arguments.callee === foo); // true

      // parameters sharing

      alert(x === arguments[0]); // true
      alert(x); // 10

      arguments[0] = 20;
      alert(x); // 20

      x = 30;
      alert(arguments[0]); // 30

      // however, for not passed argument z,
      // related index-property of the arguments
      // object is not shared

      z = 40;
      alert(arguments[2]); // undefined

      arguments[2] = 50;
      alert(z); // 40

  }

  foo(10, 20);

  // Concerning the last case, in older versions of Google Chrome there was
  // a bug ‚Äî there parameter z and arguments[2] were also shared.

#+end_src

When entering the context of a function, recall also that a special ~arguments~ object is created which stores the values of formal parameters. In the strict mode, the arguments object has undergone several changes among which are that the arguments does not share anymore values of its properties and real ~argument~ variables. Property ~callee~ (the reference to the function itself) was also deprecated in strict mode.

#+begin_src javascript

  function foo(a) {
      var b = 20;
  }
  foo(10);

  // abstractly we have the following VariableEnvironment (Activation
  // Object) component of the foo function context:
  fooContext.VariableEnvironment = {
      environmentRecord: {
          arguments: {0: 10, length: 1, callee: foo},
          a: 10,
          b: 20
      },
      outer: globalEnvironment
  };

#+end_src

*** Processing the context code
**** Introduction
Processing of the execution context code is divided on two basic stages:

1. [[Entering the execution context]]
2. [[Code execution]]

Notice, that processing of these two stages are the general behavior and independent from the type of the context (i.e. it is fair for both: global and function contexts).

**** Entering the execution context
On entering the execution context (but before the code execution), [[Variable object][VO]] is filled with the following properties:

- for each *formal parameter* of a function (if we are in function execution context) :: a property of the variable object with a name and value of formal parameter is created; for not passed parameters ‚Äî property of VO with a name of formal parameter and value ~undefined~ is created;

- for each [[Function declarations][function declaration]] (FunctionDeclaration, FD) :: a property of the variable object with a name and value of a function-object is created; if the variable object already contains a property with the same name, replace its value and attributes;

-  for each *variable declaration* (var, VariableDeclaration) :: a property of the variable object with a variable name and value ~undefined~ is created; if the variable name is the same as a name of already declared formal parameter or a function, the variable declaration does not disturb the existing property.

#+begin_src javascript

  function test(a, b) {
      var c = 10;
      function d() {}
      var e = function _e() {};
      (function x() {}); // Function Expresion does not affect
  }

  test(10); // call

  // On entering the test function context with the
  // passed parameter 10, AO is the following:

  AO(test) = {
      a: 10,
      b: undefined,
      c: undefined,
      d: <reference to FunctionDeclaration "d">,
      e: undefined
  };

#+end_src

Like ~x~, function ~_e~ is also a function-expression, but because of assigning it to the variable ~e~, it becomes accessible via the ~e~ name.

And after that there comes the second phase of processing of a context code ‚Äî the code execution stage.

**** Code execution
The function expression ~_e~ is still in memory only because it is saved to declared variable ~e~.

#+begin_src javascript

  function test(a, b) {
      var c = 10;
      function d() {}
      var e = function _e() {};
      (function x() {});
  }

  test(10); // call

  // AO/VO during the code interpretation is modified as follows:
  AO['c'] = 10;
  AO['e'] = <reference to FunctionExpression "_e">;

#+end_src

More precise and classical example:

#+begin_src javascript

  alert(x); // function

  var x = 10;
  alert(x); // 10

  x = 20;

  function x() {}

  alert(x); // 20

#+end_src

Why in the first alert ~x~ is a function and moreover is accessible before the declaration? Why it‚Äôs not ~10~ or ~20~? Because, according to the rule ‚Äî *VO is filled with function declarations on entering the context*. Also, at the same phase, on entering the context, there is a variable declaration ~x~, *the step of variable declarations semantically goes after function and formal parameters declarations* and on this phase *do not disturb the value* of the already declared function or formal parameter with the same name.

Therefore, on entering the context VO is filled as follows:

#+begin_src javascript

  VO = {};

  VO['x'] = <reference to FunctionDeclaration "x">

  // found var x = 10;
  // if function "x" would not be already defined
  // then "x" be undefined, but in our case
  // variable declaration does not disturb
  // the value of the function with the same name

  VO['x'] = <the value is not disturbed, still function>

#+end_src

And then *at code execution phase, VO is modified* as follows:

#+begin_src javascript

  VO['x'] = 10;
  VO['x'] = 20;

#+end_src

*** Scope chain
**** Scope chain
A *scope chain* is a list of objects (chain of variable objects) that are searched for identifiers appear in the code of the context.

The scope chain of a function context *is created at function call* and consists of the [[Activation object][activation object]] and the internal ~[[Scope]]~ property of this function.

#+begin_src javascript

  // Schematically in the context:
  activeExecutionContext = {
      VO: {...}, // or AO
      this: thisValue,
      Scope: [ // Scope chain list of all variable
               // objects for identifiers lookup
               ]
  };

  // where Scope by definition is:
  Scope = AO + [[Scope]]

  // For our examples we can represent Scope,
  // and [[Scope]] as normal ECMAScript arrays:
  var Scope = [VO1, VO2, ..., VOn]; // scope chain

#+end_src

A scope chain is mostly related with inner functions.

The rule is simple and similar to a prototype chain: if a variable is not found in the own scope (in the own variable/activation object), its lookup proceeds in the parent‚Äôs variable object, and so on.

Regarding contexts, identifiers are: names of variables, function declarations, formal parameters, etc. When a function refers in its code the identifier which is not a local variable (or a local function or a formal parameter), such variable is called a [[Free variable][free variable]]. And to search these free variables exactly a scope chain is used.

In general case, a scope chain is a list of all those parent variable objects, plus (in the front of scope chain) the function‚Äôs own variable/activation object. However, the *scope chain may contain also any other object*, e.g. objects dynamically added to the scope chain during the execution of the context ‚Äî such as *with-objects* or special objects of *catch-clauses*.

When resolving (looking up) an identifier, the scope chain is searched starting from the activation object, and then (if the identifier isn‚Äôt found in the own activation object) up to the top of the scope chain ‚Äî repeat, the same just like with a prototype chain.

*Note*: /static scope/ is when function knows the resolution environment for free variables at time of *creation*. And /closure/ is a natural *continuation of the static scope*. One can say: ‚Äúclosure == static scope‚Äù.

#+begin_src javascript

  var x = 10;

  (function foo() {
      var y = 20;
      (function bar() {
          var z = 30;
          // "x" and "y" are "free variables"
          // and are found in the next (after
          // bar's activation object) object
          // of the bar's scope chain
          console.log(x + y + z);
      })();
  })();

  +----------------------------------+
  |  bar context scope chain         |
  |                                  |
  |     +----------------------+     |
  |     |         bar AO       |     |
  |     +----------------------+     |
  |     |      z     |    30   |     |
  |     |----------------------|     |
  |     | __parent__ |     |   |     |
  |     +----------------- | --+     |
  |                        |         |
  |  +-------------------- | -----+  |
  |  |  bar.[[Scope]] ‚îå----‚îò      |  |
  |  |                v           |  |
  |  |  +----------------------+  |  |
  |  |  |         foo AO       |  |  |
  |  |  +----------------------+  |  |
  |  |  |      y     |    20   |  |  |
  |  |  |----------------------|  |  |
  |  |  | __parent__ |     |   |  |  |
  |  |  +----------------- | --+  |  |
  |  |                ‚îå----‚îò      |  |
  |  |                V           |  |
  |  |  +----------------------+  |  |
  |  |  |       Global VO      |  |  |
  |  |  +----------------------+  |  |
  |  |  |      x     |    10   |  |  |
  |  |  |----------------------|  |  |
  |  |  |  <other properties>  |  |  |
  |  |  |----------------------|  |  |
  |  |  | __parent__ |   null  |  |  |
  |  |  +----------------------+  |  |
  |  +----------------------------+  |
  +----------------------------------+

#+end_src

**** ~[[Scope]]~ property
The ~[[Scope]]~ is a hierarchical chain of all parent [[Variable objects][variable objects]], which are above the current function context; the chain is saved to the function at its creation.

Notice the important point ‚Äî ~[[Scope]]~ *is saved at function creation* ‚Äî statically (invariably), *once and forever* ‚Äî until function destruction. I.e. function can be never called, but ~[[Scope]]~ property is already written and stored in function object.

Another moment which should be considered is that ~[[Scope]]~ in contrast with Scope (Scope chain) is the property of a function instead of a context.

On entering the context and after creation of AO/VO, [[Scope chain][Scope]] property of the context (which is a scope chain for variables lookup) is defined as follows:

#+begin_src javascript

  Scope = AO|VO + [[Scope]]

#+end_src

High light here is that the activation object *is the first element of the Scope array*, i.e. added to the front of scope chain.

**** Environment (scope chain)
If we allow nested inner functions and want to have the static (lexical) scope, and at the same time ‚Äî to have all these functions as [[First-class function][first-class]], we should save all free variables used by a function at the moment of the function‚Äôs creation.

The most straightforward and the easiest way to implement such an algorithm, is to save the complete parent environment in which we were created. Later, at our own activation, we‚Äôll create our own environment, fill it with local variables and parameters, and set as our outer environment the saved one ‚Äî in order to find free variables there.

It is possible to use the term environment either for a single bindings object, or for the whole list of all binding objects corresponding to the deepness of the nested level. In the later case we may call the binding objects as frames of the environment. From this viewpoint:

- Definition :: An environment is a sequence of frames. Each frame is a record (possibly empty) of bindings, which associate variable names with their corresponding values.

Notice, since this is a generic definition, we use the abstract concept of a record without specifying exact implementation structure ‚Äî it may be a hash-table placed in the heap, or a stack memory, or even registers of the virtual machine, etc.

#+begin_src javascript

  // Global environment (GE)
  var x = 10;

  function foo(y) {
      // environment of "foo" function (E1)
      var z = 30;

      function bar(q) {
          // environment of "bar" function (E2)
          return x + y + z + q;
      }

      return bar;       // return "bar" to the outside
  }

  var bar = foo(20);

  bar(40); // 100

  +------------------------------------------------------------------+
  | Environment E2 (bar function)                                    |
  |                                                                  |
  | +----------------+                                               |
  | | Global frame   |                                               |
  | |                |<--                                            |
  | | +------------+ |  |    +----------------+                      |
  | | |    x: 10   | | outer | foo frame      |                      |
  | | +------------+ |  |    |                |<--                   |
  | | +------------+ |  -----| +------------+ |  |    +------------+ |
  | | | foo: <fun> | |       | |    y: 20   | | outer | bar frame  | |
  | | +------------+ |       | +------------+ |  |    |            | |
  | | +------------+ |       | +------------+ |  ---- | +--------+ | |
  | | | bar: <fun> | |       | |    z: 30   | |       | |  q: 40 | | |
  | | +------------+ |       | +------------+ |       | +--------+ | |
  | +----------------+       | +------------+ |       +------------+ |
  |                          | | bar: <fun> | |                      |
  |                          | +------------+ |                      |
  |                          +----------------+                      |
  +------------------------------------------------------------------+

  // Each frame also has a pointer to its enclosing (or an outer)
  // environment. The outer reference of the global frame is null.

#+end_src

Notice, a one environment may serve as an enclosing environment for several inner environments:

#+begin_src javascript

  // Global environment (GE)
  var x = 10;

  function foo() {
      // "foo" environment (E1)
      var x = 20;
      var y = 30;

      console.log(x + y);
  }

  function bar() {
      // "bar" environment (E2)
      var z = 40;

      console.log(x + z);
  }

  // Thus in pseudo-code:

  // global
  GE = {
      x: 10,
      outer: null
  };

  // foo
  E1 = {
      x: 20,
      y: 30,
      outer: GE
  };

  // bar
  E2 = {
      z: 40,
      outer: GE
  };

                 +------------------+
                 | Global frame (GE)|
                 |  +------------+  |
                 |  |    x: 10   |  |
                 |  +------------+  |
                 |  +------------+  |
                 |  | foo: <fun> |  |
                 |  +------------+  |
                 |  +------------+  |
                 |  | bar: <fun> |  |
                 |  +------------+  |
                 +------------------+
                     ^          ^
                     |          |
             --outer--          --outer--
             |                          |
   +------------------+                 |
   | foo frame (E1)   |                 |
   |  +------------+  |           +----------------+
   |  |    x: 20   |  |           | bar frame (E2) |
   |  +------------+  |           |   +--------+   |
   |  +------------+  |           |   |  z: 40 |   |
   |  |    y: 30   |  |           |   +--------+   |
   |  +------------+  |           +----------------+
   +------------------+

  // That is, binding x in respect of the environment E1
  // shadows the same name binding in the global frame.

#+end_src

*** Caller and callee
A *context which activates another context* is called a /caller/. A *context is being activated* is called a /callee/.

** Miscellaneous
*** Recursion
*Wikipedia*
Iteration (looping) in functional languages is usually accomplished via recursion. Recursive functions invoke themselves, letting an operation be repeated until it reaches the base case. In general, recursion requires maintaining a stack, which consumes space in a linear amount to the depth of recursion. This could make recursion prohibitively expensive to use instead of imperative loops. However, a special form of recursion known as tail recursion can be recognized and optimized by a compiler into the same code used to implement iteration in imperative languages. Tail recursion optimization can be implemented by transforming the program into continuation passing style during compiling, among other approaches.

*Eloquent*
It is perfectly okay for a function to call itself, as long as it doesn‚Äôt do it so often that it overflows the stack. A function that calls itself is called recursive. Recursion allows some functions to be written in a different style.

For example, this ~power~ function, which does the same as the ** (exponentiation) operator:

#+begin_src javascript

  function power(base, exponent) {
      if (exponent == 0) {
          return 1;
      } else {
          return base * power(base, exponent - 1);
      }
  }

  console.log(power(2, 3));
  // ‚Üí 8

  // Another way using ternary operator.
  function power(base, exponent) {
      return (exponent == 0) ? 1 : base * power(base, exponent - 1);
  }

#+end_src

However, this implementation has one problem: in typical JavaScript implementations, it‚Äôs about three times slower than a version using a [[for]] loop. Running through a simple loop is generally cheaper than calling a function multiple times.

Recursion is not always just an inefficient alternative to looping. Some problems really are easier to solve with recursion than with loops. Most often these are problems that require exploring or processing several ‚Äúbranches‚Äù, each of which might branch out again into even more branches.

Consider this puzzle: by starting from the number ~1~ and repeatedly either adding ~5~ or multiplying by ~3~, an infinite set of numbers can be produced. How would you write a function that, given a number, tries to find a sequence of such additions and multiplications that produces that number?

For example, the number ~13~ could be reached by first multiplying by ~3~ and then adding ~5~ twice, whereas the number ~15~ cannot be reached at all.

#+begin_src javascript

  function findSolution(target) {
      function find(current, history) {
          if (current == target) {
              return history;
          } else if (current > target) {
              return null;
          } else {
              return find(current + 5, `(${history} + 5)`) ||
                  find(current * 3, `(${history} * 3)`);
          }
      }
      return find(1, "1");
  }

  console.log(findSolution(24));
  // ‚Üí (((1 * 3) + 5) * 3)

  // find(1, "1")
  //   find(6, "(1 + 5)")
  //     find(11, "((1 + 5) + 5)")
  //       find(16, "(((1 + 5) + 5) + 5)")
  //         too big
  //       find(33, "(((1 + 5) + 5) * 3)")
  //         too big
  //     find(18, "((1 + 5) * 3)")
  //       too big
  //   find(3, "(1 * 3)")
  //     find(8, "((1 * 3) + 5)")
  //       find(13, "(((1 * 3) + 5) + 5)")
  //         found!

  // The indentation indicates the depth of the call stack.


  //                                           find(1,)
  //    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  //                   find(6,)                   ||                find(3,)
  //  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  //      find(11,)       ||     find(18,)        ||     find(8,)     ||   ...
  // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ
  // find(16,)||find(33,)   find(23,)||find(54,)   find(13,)||find(24,)    ...
  //   #1          #2          #3         #4          #5

  // # iteration number (in the iteration #5 the result 13 is reached)

  //                                        1+5+5+5=16   #1
  //                                    /
  //                          1+5+5=11
  //                        /           \
  //                      /                 1+5+5*3=33   #2
  //                    /
  //              1+5=6
  //          /         \
  //         /            \                 1+5*3+5=23   #3
  //        /               \           /
  //       /                  1+5*3=18
  //      /
  //     /                              \   1+5*3*3=54   #4
  //    /
  // 1
  //    \
  //     \                                  1*3+5+5=13   #5
  //      \                             /
  //       \                  1*3+5=8
  //        \               /           \
  //         \            /
  //          \         /
  //              1*3=3
  //                    \

#+end_src

*** Pure function
A pure function is a specific kind of value-producing function that not only has no side effects (memory or I/O) but also doesn‚Äôt rely on side effects from other code‚Äîfor example, it doesn‚Äôt read global bindings whose value might change. A pure function has the pleasant property that, *when called with the same arguments, it always produces the same value* (and doesn‚Äôt do anything else). A call to such a function can be substituted by its return value without changing the meaning of the code. When you are not sure that a pure function is working correctly, you can test it by simply calling it and know that if it works in that context, it will work in any context. Nonpure functions tend to require more scaffolding to test.

#+begin_src javascript

  function printZeroPaddedWithLabel(number, label) {
      let numberString = String(number);
      while (numberString.length < 3) {
          numberString = "0" + numberString;
      }
      console.log(`${numberString} ${label}`);
  }

  function zeroPad(number, width) {
      let string = String(number);
      while (string.length < width) {
          string = "0" + string;
      }
      return string;
  }

#+end_src

The first helper function in the farm example, ~printZeroPaddedWithLabel~, is called for its side effect: it prints a line. The second version, ~zeroPad~, is called for its return value. It is no coincidence that the second is useful in more situations than the first. Functions that create values are easier to combine in new ways than functions that directly perform side effects.

*Wikipedia*
In computer programming, a pure function is a function that has the following properties:
-  the function return values are identical for identical arguments (no variation with local static variables, non-local variables, mutable reference arguments or input streams), and
-  the function has no side effects (no mutation of local static variables, non-local variables, mutable reference arguments or input/output streams).

Pure functions (or expressions) have no side effects (memory or I/O). This means that pure functions have several useful properties, many of which can be used to optimize the code:

- If the result of a pure expression is not used, it can be removed without affecting other expressions.
- If a pure function is called with arguments that cause no side-effects, the result is constant with respect to that argument list (sometimes called referential transparency or idempotence), i.e., calling the pure function again with the same arguments returns the same result. (This can enable caching optimizations such as memoization.)
- If there is no data dependency between two pure expressions, their order can be reversed, or they can be performed in parallel and they cannot interfere with one another (in other terms, the evaluation of any pure expression is thread-safe).
- If the entire language does not allow side-effects, then any evaluation strategy can be used; this gives the compiler freedom to reorder or combine the evaluation of expressions in a program (for example, using deforestation).

#+begin_src javascript

  // Pure function:
  function sum(a, b) {
      return a + b
  }
  sum(1, 2) // 3
  sum(1, 2) // 3

  // Impure function:
  console.log(Math.random()) // 0.8891108266488603
  console.log(Math.random()) // 0.9590062769956789


  // Impure function:
  let value = 0

  function add(increase) {
      value += increase // Side-effect
      return value
  }
  add(2) // 2
  add(2) // 4

#+end_src

* Methods
** Arrays
*** Array.prototype.push
The ~push()~ method of ~Array~ instances adds values to the end of an array.

#+begin_src javascript

  let sequence = [1, 2, 3];

  sequence.push(4);
  console.log(sequence.push(-9)) // 5 (output length of the array)
  console.log(sequence);  // ‚Üí [1, 2, 3, 4, -9]

  sequence.push(6,7,8);
  console.log(sequence);  // [1, 2, 3, 4, -9, 6, 7, 8]


  let arr = [];
  arr.push(1,3,5);
  console.log(arr)  // [ 1, 3, 5 ]

#+end_src

*** Array.prototype.pop
Removing the last value in the array and returning it.

#+begin_src javascript

  let sequence = [1, 2, 3];

  console.log(sequence.pop());  // ‚Üí 3
  console.log(sequence);  // ‚Üí [1, 2]

#+end_src

*** Array.prototype.shift
*Removes the first* element from an array and returns that removed element. This method changes the length of the array.

#+begin_src javascript

  const array1 = [1, 2, 3];
  const firstElement = array1.shift();

  console.log(array1);  // Array [2, 3]
  console.log(firstElement);  // 1

#+end_src

*** Array.prototype.unshift
*Adds* the specified elements to the *beginning* of an array and returns the new length of the array.

#+begin_src javascript

  const array1 = [1, 2, 3];

  console.log(array1.unshift(4, 5));  // 5
  console.log(array1);  // Array [4, 5, 1, 2, 3]

#+end_src

*** Array.prototype.fill
Changes all elements within a range of indices in an array to a static value. It returns the modified array.

#+begin_src javascript

  const array1 = [1, 2, 3, 4];

  // Fill with 0 from position 2 until position 4
  console.log(array1.fill(0, 2, 4));
  // Array [1, 2, 0, 0]

  // Fill with 5 from position 1
  console.log(array1.fill(5, 1));
  // Array [1, 5, 5, 5]

  console.log(array1.fill(6));
  // Array [6, 6, 6, 6]

#+end_src

*** Array.prototype.join
*Creates and returns a new string* by concatenating all of the elements in this array, separated by commas or a specified separator string. If the array has only one item, then that item will be returned without using the separator.

#+begin_src javascript

  const elements = ['Fire', 'Air', 'Water'];

  console.log(elements.join());  // "Fire,Air,Water"
  console.log(elements.join(''));  // "FireAirWater"
  console.log(elements.join('-'));  // "Fire-Air-Water"

#+end_src

*** Array.prototype.concat
Is used to *merge two or more arrays*. This method does not change the existing arrays, but instead returns a new array.

#+begin_src javascript

  const array1 = ['a', 'b', 'c'];
  const array2 = ['d', 'e', 'f'];
  const array3 = array1.concat(array2);

  console.log(array3);
  // Array ["a", "b", "c", "d", "e", "f"]

#+end_src

*** Array.prototype.forEach
*Eloquent*: loop over the elements in an array.

Executes a provided function once for each array element.

*Note*: ~forEach()~ is more or less a kind of method for *iterating* an array.

*Note*: The ~forEach~ method does not returns a new array based on the given array. The [[map]] method returns an entirely new array. The ~forEach~ method returns ~undefined~. The ~map~ method returns the newly created array according to the provided callback function.

#+begin_src javascript

  // Syntax:
  forEach(callbackFn)
  forEach(callbackFn, thisArg)


  const array1 = ['a', 'b', 'c'];

  array1.forEach((element) => console.log(element));
  // "a"
  // "b"
  // "c"


  let arrayForEach = [3 , 5 , 7];
  let arrayMap = [3 , 5 , 7];

  console.log(arrayForEach.forEach((ele) => ele + 5 )) // undefined
  console.log(arrayMap.map((ele) => ele + 5 ))         // [ 8, 10, 12 ]
  console.log(arrayForEach);                           // [ 3, 5, 7 ]
  console.log(arrayMap);                               // [ 3, 5, 7 ]

#+end_src

*** Array.prototype.find
Returns the first element in the provided array that satisfies the provided testing function. If no values satisfy the testing function, ~undefined~ is returned.

- If you need the *index* of the found element in the array, use [[Array.prototype.findIndex][findIndex]].
- If you need to find the *index of a value*, use [[Array.prototype.indexOf][indexOf]]. (It's similar to ~findIndex~ , but checks each element for /equality with the value/ instead of using a testing function.)
- If you need to find if a value *exists* in an array, use [[Array.prototype.includes][includes]]. Again, it checks each element for /equality with the value/ instead of using a testing function.
- If you need to find if *any element satisfies* the provided /testing/ function, use [[Array.prototype.some][some]].
- If you need to find *all elements that satisfy* the provided /testing/ function, use [[Array.prototype.filter][filter]].

#+begin_src javascript

  const array1 = [5, 12, 8, 130, 44];

  console.log(array1.find((element) => element > 10));  // 12

  // Comparison with other similar methods:
  console.log(array1.findIndex((element) => element > 10));  // 1
  console.log(array1.indexOf(12));  // 1
  console.log(array1.includes(12));  // true
  console.log(array1.some((element) => element > 10));  // true
  console.log(array1.filter((element) => element > 10));  // [12, 130, 44]

#+end_src

*** Array.prototype.findIndex
*Eloquent*: finds the position of the first element that matches a predicate.

Returns the index of the first element in an array that satisfies the provided testing function. If no elements satisfy the testing function, ~-1~ is returned.

#+begin_src javascript

  const array1 = [5, 12, 8, 130, 44];

  const isLargeNumber = (element) => element > 13;

  console.log(array1.findIndex(isLargeNumber));
  // 3


  // Comparison with other similar methods:
  const array1 = [5, 12, 8, 130, 44];

  console.log(array1.findIndex((element) => element > 10));  // 1

  console.log(array1.find((element) => element > 10));  // 12
  console.log(array1.indexOf(12));  // 1
  console.log(array1.includes(12));  // true
  console.log(array1.some((element) => element > 10));  // true
  console.log(array1.filter((element) => element > 10));  // [12, 130, 44]

#+end_src

*** Array.prototype.indexOf
The ~indexOf()~ method of Array instances returns the *first index* at which a given element can be found in the array, or ~-1~ if it is not present.

#+begin_src javascript

  const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];

  console.log(beasts.indexOf('bison')); // 1

  // Start from index 2
  console.log(beasts.indexOf('bison', 2)); // 4

  console.log(beasts.indexOf('giraffe')); // -1


  // Comparison with other similar methods:
  const array1 = [5, 12, 8, 130, 44];

  console.log(array1.indexOf(12));  // 1

  console.log(array1.find((element) => element > 10));  // 12
  console.log(array1.findIndex((element) => element > 10));  // 1
  console.log(array1.includes(12));  // true
  console.log(array1.some((element) => element > 10));  // true
  console.log(array1.filter((element) => element > 10));  // [12, 130, 44]

#+end_src

*** Array.prototype.includes
Determines whether an array includes a certain value among its entries, returning ~true~ or ~false~ as appropriate.

#+begin_src javascript

  const array1 = [1, 2, 3];

  console.log(array1.includes(2));  //  true

  const pets = ['cat', 'dog', 'bat'];

  console.log(pets.includes('cat'));  //  true
  console.log(pets.includes('at'));  //  false


  // Comparison with other similar methods:
  const array1 = [5, 12, 8, 130, 44];

  console.log(array1.includes(12));  // true

  console.log(array1.indexOf(12));  // 1
  console.log(array1.find((element) => element > 10));  // 12
  console.log(array1.findIndex((element) => element > 10));  // 1
  console.log(array1.some((element) => element > 10));  // true
  console.log(array1.filter((element) => element > 10));  // [12, 130, 44]

#+end_src

*** Array.prototype.some
*Eloquent*: tests whether any element matches a given predicate function.

Tests whether at least one element in the array passes the test implemented by the provided function. It returns true if, in the array, it finds an element for which the provided function returns true; otherwise it returns false. It doesn't modify the array.

#+begin_src javascript

  const array = [1, 2, 3, 4, 5];

  // Checks whether an element is even
  const even = (element) => element % 2 === 0;

  console.log(array.some(even));
  //  true


  // Comparison with other similar methods:
  const array1 = [5, 12, 8, 130, 44];

  console.log(array1.some((element) => element > 10));  // true

  console.log(array1.indexOf(12));  // 1
  console.log(array1.find((element) => element > 10));  // 12
  console.log(array1.findIndex((element) => element > 10));  // 1
  console.log(array1.includes(12));  // true
  console.log(array1.filter((element) => element > 10));  // [12, 130, 44]

#+end_src

*** Array.prototype.filter
*Eloquent*: returns a new array containing only the elements that pass the predicate function.

Creates a *shallow copy* of a portion of a given array, filtered down to just the elements from the given array that pass the test implemented by the provided function.

#+begin_src javascript

  const words = ['spray', 'elite', 'exuberant', 'destruction', 'present'];

  const result = words.filter((word) => word.length > 6);

  console.log(result);
  // Array ["exuberant", "destruction", "present"]


  // Comparison with other similar methods:
  const array1 = [5, 12, 8, 130, 44];

  console.log(array1.filter((element) => element > 10));  // [12, 130, 44]

  console.log(array1.indexOf(12));  // 1
  console.log(array1.find((element) => element > 10));  // 12
  console.log(array1.findIndex((element) => element > 10));  // 1
  console.log(array1.includes(12));  // true
  console.log(array1.some((element) => element > 10));  // true

#+end_src

*** Array.prototype.map
*Eloquent*: transforming an array by putting each element through a function.

Creates a new array populated with the results of calling a provided function on every element in the calling array.

*Note*: The [[forEach]] method does not returns a new array based on the given array. The ~map~ method *returns an entirely new array*. The ~forEach~ method returns ~undefined~. The ~map~ method returns the newly created array according to the provided callback function.

*Parameters*:
- callbackFn :: A function to execute for each element in the array. Its return value is added as a single element in the new array. The function is called with the following arguments:
  - ~element~ The current element being processed in the array.
  - ~index~ The index of the current element being processed in the array.
  - ~array~ The array ~map()~ was called upon.
- thisArg (Optional) :: A value to use as this when executing callbackFn. See iterative methods.

#+begin_src javascript

  const array1 = [1, 4, 9, 16];

  // Pass a function to map
  const map1 = array1.map((x) => x * 2);

  console.log(map1);
  // Array [2, 8, 18, 32]


  const array2 = ['a','b','c'];

  array2.map((arg,index) => {
      console.log(arg, index);
  })
  // a 0
  // b 1
  // c 2
  // d 3

#+end_src

*** Array.prototype.reduce
*Eloquent*: combine all the elements in an array into a single value.

Executes a user-supplied "reducer" callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value.

The first time that the callback is run there is no "return value of the previous calculation". If supplied, an initial value may be used in its place. Otherwise the array element at index ~0~ is used as the initial value and iteration starts from the next element (index ~1~ instead of index ~0~).

#+begin_src javascript

  // Sum of all the elements in an array:
  const array1 = [1, 2, 3, 4];

  // 0 + 1 + 2 + 3 + 4
  const initialValue = 0;
  const sumWithInitial = array1.reduce(
      (accumulator, currentValue) => accumulator + currentValue,
      initialValue,
  );
  console.log(sumWithInitial); // 10

  const sumWithoutInitial = array1.reduce(
      (accumulator, currentValue) => accumulator + currentValue
  );
  console.log(sumWithoutInitial); // 10


  // Syntax:
  arr.reduce(callback(acumulator,currentValue), initialValue)
  arr.reduce(callback(acumulator,currentValue))

#+end_src

*Eloquent*
It builds a value by repeatedly taking a single element from the array and combining it with the current value. When summing numbers, you‚Äôd start with the number zero and, for each element, add that to the sum.

The parameters to ~reduce~ are, apart from the array, a combining function and a start value.

#+begin_src javascript

  function reduce(array, combine, start) {
      let current = start;
      for (let element of array) {
          current = combine(current, element);
      }
      return current;
  }

  console.log(reduce([1, 2, 3, 4], (a, b) => a + b, 0)); // ‚Üí 10

#+end_src

The standard array method ~reduce~, which of course corresponds to this function, has an added convenience. If your array contains at least one element, you are allowed to leave off the ~start~ argument. The method will take the first element of the array as its start value and start reducing at the second element.

*** Array.prototype.lastIndexOf
Returns the *last index* at which a given element can be found in the array, or ~-1~ if it is not present. The array is searched backwards, starting at ~fromIndex~.

#+begin_src javascript

  const animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];

  console.log(animals.lastIndexOf('Dodo'));  // 3
  console.log(animals.lastIndexOf('Tiger'));  //  1

#+end_src

*** Array.prototype.slice
Returns a shallow copy of a *portion of an array* into a new array object selected from ~start~ (~start~ *included*) to ~end~ (~end~ *not included*) where ~start~ and ~end~ represent the index of items in that array. The original array will not be modified.

When the ~end~ index is not given, ~slice~ will take all of the elements after the ~start~ index. You can also omit the start index to copy the entire array.

Negative ~end~ index counts back from the end of the array.

#+begin_src javascript

  const letters = ["A", "B", "C", "D", "E"];

  // Starts at 0 (included) to the end (not included).
  // Slice from 2 to last:
  console.log(letters.slice(2)); // ["C", "D", "E"]

  // Slice the last 2 (slice from -2 to last):
  console.log(letters.slice(-2)); // ["D", "E"]

  // Slice from the start to -2 ( to 2 before the last):
  console.log(letters.slice(0, -2)); // ["A", "B", "C"]

  // Slice from start to 1:
  console.log(letters.slice(0,2)); // ["A", "B"]

  // Slice from 2 to 3:
  console.log(letters.slice(2, 4)); // ["C", "D"]

  // Makes a copy:
  console.log(letters.slice()); // ["A", "B", "C", "D", "E"]

#+end_src

*Parameters*:

- start Optional :: Zero-based index at which to start extraction, converted to an integer.
  - Negative index counts back from the end of the array ‚Äî if ~-array.length <= start < 0~ , ~start + array.length~ is used.
  - If ~start < -array.length~ or ~start~ is omitted, ~0~ is used.
  - If ~start >= array.length~ , nothing is extracted.

- end Optional :: Zero-based index at which to end extraction, converted to an integer. ~slice()~ extracts up to but not including end.
  - Negative index counts back from the end of the array ‚Äî if ~-array.length <= end < 0~ , ~end + array.length~ is used.
  - If ~end < -array.length~ , ~0~ is used.
  - If ~end >= array.length~ or ~end~ is omitted, ~array.length~ is used, causing all elements until the end to be extracted.
  - If ~end~ implies a position before or at the position that ~start~ implies, nothing is extracted.

*** Array.prototype.splice
Changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.

This a mutating method. It may change the content of ~this~. If the specified number of elements to insert differs from the number of elements being removed, the array's ~length~ will be changed as well.

To create a new array with a segment removed and/or replaced without mutating the original array, use ~toSpliced()~. To access part of an array without modifying it, see [[Array.prototype.slice][slice()]].

#+begin_src javascript

  // Syntax:
  splice(start, deleteCount, item1, item2, /* ‚Ä¶, */ itemN)


  const months = ['Jan', 'March', 'April', 'June'];
  months.splice(1, 0, 'Feb'); // Inserts at index 1
  console.log(months); // ["Jan", "Feb", "March", "April", "June"]

  months.splice(4, 1, 'May'); // Replaces 1 element at index 4
  console.log(months); // ["Jan", "Feb", "March", "April", "May"]


#+end_src

*Parameters*:
- start :: Zero-based index at which to start changing the array, converted to an integer.
- deleteCount Optional :: An integer indicating the number of elements in the array to remove from ~start~ .
- item1, ‚Ä¶, itemN Optional :: The elements to add to the array, beginning from ~start~. If you do not specify any elements, ~splice()~ will only remove elements from the array.

*Return value*:
An array containing the deleted elements. If only one element is removed, an array of one element is returned. If no elements are removed, an empty array is returned.

*** Array.from
The ~Array.from()~ *static method* creates a new, shallow-copied ~Array~ instance from an iterable or array-like object.

The [[Spread syntax]] is another method to create an array copy but there‚Äôs a subtle difference between ~Array.from~ operates on both array-likes and iterables while the spread syntax works only with iterables.

#+begin_src javascript

  console.log(Array.from('foo'));
  // Array ["f", "o", "o"]

  console.log(Array.from([1, 2, 3], (x) => x + x));
  // Array [2, 4, 6]


  // Example of an array that changes over time:
  // If you want a solid collection of nodes, as opposed to a live one, you
  // can convert the collection to a real array by calling Array.from.
  let arrayish = {0: "one", 1: "two", length: 2};
  let array = Array.from(arrayish);
  console.log(array.map(s => s.toUpperCase()));
  // ‚Üí ["ONE", "TWO"]


  let ages = new Map();
  ages.set("Boris", 39);
  ages.set("Liang", 22);
  ages.set("J√∫lia", 62);

  console.log(ages);
  // Map(3) { 'Boris' => 39, 'Liang' => 22, 'J√∫lia' => 62 }
  console.log(Array.from(ages.keys()));
  // [ 'Boris', 'Liang', 'J√∫lia' ]
  console.log(ages.keys());
  // [Map Iterator] { 'Boris', 'Liang', 'J√∫lia' }

#+end_src

*** Copy an array
Remember the [[Object.assign]] method. It is possible to do the same thing with the [[Spread syntax][spread syntax]].

This way of copying an object is much shorter than ~let objCopy = Object.assign({}, obj)~ or for an array ~let arrCopy = Object.assign([], arr)~ so we prefer to use it whenever we can.

#+begin_src javascript

  let arr = [1, 2, 3];

  let arrCopy = [...arr]; // spread the array into a list of parameters
  // then put the result into a new array

  // do the arrays have the same contents?
  alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

  // are the arrays equal?
  alert(arr === arrCopy); // false (not same reference)

  // modifying our initial array does not modify the copy:
  arr.push(4);
  alert(arr); // 1, 2, 3, 4
  alert(arrCopy); // 1, 2, 3

#+end_src

** Strings
*** length
The length data property of a String value contains the length of the string in UTF-16 code units.

*Note*: UTF-16 is generally considered a bad idea today. It‚Äôs easy to write programs that pretend code units and characters are the same thing. And if your language doesn‚Äôt use two-unit characters, that will appear to work just fine. But as soon as someone tries to use such a program with some less common Chinese characters, it breaks. Fortunately, with the advent of emoji, everybody has started using [[Strings and character codes][two-unit characters]], and the burden of dealing with such problems is more fairly distributed.

#+begin_src javascript

  // Example:
  let string = "abc";
  console.log(string.length);  // ‚Üí 3
  console.log(string[1]);  // ‚Üí b


  // Be careful with some characters:
  let string = "üåπüêâ";
  console.log(string.length);  // ‚Üí 4
  console.log(string[1]);  // ‚Üí ÔøΩ (Invalid half-character)


  // Example:
  const str = 'Life, the universe and everything. Answer:';
  console.log(`${str} ${str.length}`);
  // Life, the universe and everything. Answer: 42

#+end_src

*** String.prototype.padStart
*Pads this string with another string* (multiple times, if needed) *until the resulting string reaches the given length*. The padding is applied from the start of this string.

#+begin_src javascript

  const str1 = '5';

  console.log(str1.padStart(2, '0'));
  // "05"

  const fullNumber = '2034399002125581';
  const last4Digits = fullNumber.slice(-4);
  const maskedNumber = last4Digits.padStart(fullNumber.length, '*');

  console.log(maskedNumber);
  // "************5581"
#+end_src

*** String.prototype.concat
Concatenates the string arguments to this string and returns a new string.

#+begin_src javascript

  // Syntax:
  concat(str1)
  concat(str1, str2, /* ‚Ä¶, */ strN)


  const str1 = "Hello";
  const str2 = "World";

  console.log(str1.concat(" ", str2));  // "Hello World"
  console.log(str2.concat(", ", str1)); // "World, Hello"


  const greetList = ["Hello", " ", "Venkat", "!"];
  "".concat(...greetList); // "Hello Venkat!"
  "".concat({}); // "[object Object]"
  "".concat([]); // ""
  "".concat(null); // "null"
  "".concat(true); // "true"
  "".concat(4, 5); // "45"

#+end_src

*** String.prototype.slice
*Extracts a section* of this string and returns it as a new string, without modifying the original string.

#+begin_src javascript

  // Example:
  console.log("coconuts".slice(4, 7));  // ‚Üí nut


  // Example:
  const letters = "ABCDE";

  // Starts at 0 (included) to the end (not included).
  // Slice from 2 to last:
  console.log(letters.slice(2)); // CDE

  // Slice the last 2 (slice from -2 to last):
  console.log(letters.slice(-2)); // DE

  // Slice from the start to -2 ( to 2 before the last):
  console.log(letters.slice(0, -2)); // ABC

  // Slice from start to 1:
  console.log(letters.slice(0,2)); // AB

  // Slice from 2 to 3:
  console.log(letters.slice(2, 4)); // CD

  // Slice from -4 to -2:
  console.log(letters.slice(-4, -2)); // BC

#+end_src

*** String.prototype.indexOf
Searches this string and returns the *index of the first occurrence* of the specified substring. It takes an optional starting position and returns the first occurrence of the specified substring at an index greater than or equal to the specified number.

One difference is that a string‚Äôs ~indexOf~ can search for a string containing more than one character, whereas the corresponding array method looks only for a single element.

#+begin_src javascript

  // Syntax:
  indexOf(searchString)
  indexOf(searchString, position)


  // Example:
  console.log("coconut".indexOf("u"));  // ‚Üí 5
  console.log("coconut".indexOf("z"));  // ‚Üí -1

  // Search more than one character:
  console.log("one two three".indexOf("ee")); // ‚Üí 11


  // Example:
  const paragraph = "I think Ruth's dog is cuter than your dog!";

  const searchTerm = 'dog';
  const indexOfFirst = paragraph.indexOf(searchTerm);

  console.log(`The index of the first "${searchTerm}" is ${indexOfFirst}`);
  // "The index of the first "dog" is 15"

  console.log(
      `The index of the second "${searchTerm}" is ${paragraph.indexOf(
      searchTerm,
      indexOfFirst + 1,
    )}`,
  );
  // "The index of the second "dog" is 38"

#+end_src

*** String.prototype.trim
*Removes whitespace* from both ends of this string and returns a new string, without modifying the original string.

To return a new string with whitespace trimmed from just one end, use ~trimStart()~ or ~trimEnd()~.

#+begin_src javascript

  // Example:
  const greeting = '   Hello world!   ';

  console.log(greeting);  // "   Hello world!   ";
  console.log(greeting.trim());  // "Hello world!";


  // Example:
  console.log("  okay \n ".trim());  // ‚Üí okay

#+end_src

*** String.prototype.repeat
Constructs and returns a new string which contains the specified number of copies of this string, concatenated together.

#+begin_src javascript

  // Example:
  console.log("LA".repeat(3));  // ‚Üí LALALA

  // Example:
  const mood = 'Happy! ';

  console.log(`I feel ${mood.repeat(3)}`);
  // "I feel Happy! Happy! Happy! "

#+end_src

*** String.prototype.split
*Takes a pattern and divides* this string into an ordered list of substrings by searching for the pattern, puts these substrings into an array, and returns the array.

*Note*: ~split~ method also allows a [[Regular Expressions][regular expression]] as its argument.

#+begin_src javascript

  const str = 'The quick brown fox jumps over the lazy dog.';

  const words = str.split(' ');
  console.log(words[3]);
  // "fox"

  const chars = str.split('');
  console.log(chars[8]);
  // "k"

  const strCopy = str.split();
  console.log(strCopy);
  // Array ["The quick brown fox jumps over the lazy dog."]

#+end_src

*** String.prototype.match
Retrieves the result of matching this string against a [[Regular Expressions][regular expression]].

*Note*: When called with a global expression, instead of returning an array similar to that returned by [[RegExp.prototype.exec][exec]], ~match~ will find all matches of the pattern in the string and return an array containing the matched strings.

#+begin_src javascript

  // Syntax:
  // string.match(Re) =>
  // [ match, matchGroup1, matchGroup2, index, input, groups ]

  const paragraph = 'The quick brown fox jumps over the lazy dog. It barked.';
  const regex = /[A-Z]/;
  const regexGlobal = /[A-Z]/g;
  const found = paragraph.match(regex);
  const foundG = paragraph.match(regexGlobal);

  console.log(found);
  // [ 'T', index: 0, input: 'The quick brown ...', groups: undefined ]
  console.log(foundGlobal);
  //  Array ["T", "I"]

  console.log(regex.exec(paragraph));
  // ['T', index: 0, input: 'The quick brown ...', groups: undefined]


  console.log("Banana".match(/an/g));
  // ‚Üí ["an", "an"]
  console.log(/an/g.exec("Banana"));
  // [ 'an', index: 1, input: 'Banana', groups: undefined ]

#+end_src

*** String.prototype.search
Executes a search for a match between a [[Regular Expressions][regular expression]] and this string, returning the index of the first match in the string (like [[String.prototype.indexOf][indexOf]] but with regexp).

*Note*: Unfortunately, there is no way to indicate that the match should start at a given offset (like we can with the second argument to ~indexOf~), which would often be useful.

#+begin_src javascript

  console.log("  word".search(/\S/)); // ‚Üí 2
  console.log("    ".search(/\S/));  // ‚Üí -1


  const paragraph = "I think Ruth's dog is cuter than your dog!";
  // Anything not a word character, whitespace or apostrophe
  const regex = /[^\w\s']/g;

  console.log(paragraph.search(regex));  //  41
  console.log(paragraph[paragraph.search(regex)]);  //  "!"


#+end_src

*** String.prototype.replace
**** Brief
Replace matches of a pattern with a replacement string or function.

The first argument can also be a regular expression, in which case the first match of the regular expression is replaced. When a ~g~ option (for *global*) is added to the regular expression, *all* matches in the string will be replaced, not just the first.

Returns a new string with one, some, or all matches of a ~pattern~ replaced by a replacement. The ~pattern~ can be a string or a [[Regular Expressions][RegExp]], and the ~replacement~ can be a string or a function called for each match. If ~pattern~ is a string, only the first occurrence will be replaced. The original string is left unchanged.

#+begin_src javascript

  // Syntax:
  replace(pattern, replacement)


  console.log("papa".replace("p", "m"));  // ‚Üí mapa

  console.log("borobudur".replace(/[ou]/, "A"));  // ‚Üí bArobudur
  console.log("borobudur".replace(/[ou]/g, "A")); // ‚Üí bArAbAdA


  const paragraph = "I think Ruth's dog is cuter than your dog!";
  const regex = /Dog/i;
  console.log(paragraph.replace(regex, 'ferret'));
  //  "I think Ruth's ferret is cuter than your dog!"

#+end_src

It is possible to use replace to write a function that removes all comments from a piece of JavaScript code.

#+begin_src javascript

  function stripComments(code) {
      return code.replace(/\/\/.*|\/\*[^]*?\*\//g, "");
  }

  console.log(stripComments("1 + /* 2 */3"));  // ‚Üí 1 + 3
  console.log(stripComments("x = 10;// ten!"));  // ‚Üí x = 10;
  console.log(stripComments("1 /* a */+/* b */ 1"));  // ‚Üí 1 + 1

#+end_src

**** Matching groups in the replacement string
The real power of using regular expressions with ~replace~ comes from the fact that we can refer to matched groups in the replacement string. For example, say we have a big string containing the names of people, one name per line, in the format ~Lastname, Firstname~. If we want to swap these names and remove the comma to get a ~Firstname Lastname~ format, we can use the following code:

*Note*: The ~$1~ and ~$2~ in the replacement string refer to the parenthesized groups in the pattern. *The whole match can be referred to with* ~$&~.

#+begin_src javascript

  console.log(
      "Liskov, Barbara\nMcCarthy, John\nWadler, Philip"
          .replace(/(\w+), (\w+)/g, "$2 $1"));
  // ‚Üí Barbara Liskov
  //   John McCarthy
  //   Philip Wadler

#+end_src

**** Function as second argument
It is possible to pass a function‚Äîrather than a string‚Äîas the second argument to ~replace~. For each replacement, the function will be called with the matched groups (as well as the whole match) as arguments, and its return value will be inserted into the new string.

#+begin_src javascript

  // Syntax with function:
  string.replace(regexp, function (match,
                                   firstGroupMatch,
                                   SecondGroupMatch,
                                   ...,
                                   indexMatch,
                                   string) {...})


  // Here‚Äôs a small example:
  let s = "the cia and fbi";
  console.log(s.replace(/\b(fbi|cia)\b/g,
                        str => str.toUpperCase()));
  // ‚Üí the CIA and FBI


  // Here‚Äôs a more interesting one:
  let stock = "1 lemon, 2 cabbages, and 101 eggs";
  function minusOne(match, amount, unit) {
      amount = Number(amount) - 1;
      if (amount == 1) { // only one left, remove the 's'
          unit = unit.slice(0, unit.length - 1);
      } else if (amount == 0) {
          amount = "no";
      }
      return amount + " " + unit;
  }
  console.log(stock.replace(/(\d+) (\w+)/g, minusOne));
  // ‚Üí no lemon, 1 cabbage, and 100 eggs
  // The (\d+) group ends up as the amount argument to the function, and
  // the (\w+) group gets bound to unit.

#+end_src

** Objects
*** Object.keys
Find out what properties an object has. This static method returns an array of a given object's own enumerable string-keyed property names.

*Note*: ~Object.keys~ returns only enumerable properties, and [[Object.getOwnPropertyNames]] returns both: enumerable and non-enumerable properties.

#+begin_src javascript

  const object1 = {
      a: 'somestring',
      b: 42,
      c: false,
  };

  console.log(Object.keys(object1));
  // Array ["a", "b", "c"]

  // Difference between Object.keys and getOwnPropertyNames:
  var foo = {bar: 10, baz: 20};

  Object.defineProperty(foo, "x", {
      value: 30,
      enumerable: false
  });

  console.log(Object.keys(foo)); // ["bar", "baz"]
  console.log(Object.getOwnPropertyNames(foo)); // ["bar", "baz", "x"]

#+end_src

*** Object.getOwnPropertyNames
Returns an array of all properties (*including non-enumerable* properties except for those which use Symbol) found directly in a given object.

*Note*: [[Object.keys]] returns only enumerable properties, and ~Object.getOwnPropertyNames~ returns both: enumerable and non-enumerable properties.

#+begin_src javascript

  // Syntax:
  Object.getOwnPropertyNames(obj)


  const object1 = {
      a: 1,
      b: 2,
      c: 3,
    };

  console.log(Object.getOwnPropertyNames(object1));
  // Expected output: Array ["a", "b", "c"]


  // Difference between Object.keys and getOwnPropertyNames:
  var foo = {bar: 10, baz: 20};

  Object.defineProperty(foo, "x", {
      value: 30,
      enumerable: false
  });

  console.log(Object.keys(foo)); // ["bar", "baz"]
  console.log(Object.getOwnPropertyNames(foo)); // ["bar", "baz", "x"]

#+end_src

*** Object.create
Creates a new object, using an existing object as the *prototype* of the newly created object.

#+begin_src javascript

  // Syntax:
  Object.create(parentProto, propertiesObject)


  // Example:
  let a = {
      x: 10,
      calculate: function (z) {
          return this.x + this.y + z;
      }
  };

  let b = Object.create(a, {y: {value: 20,enumerable: true}});
  console.log(a)  // { x: 10, calculate: [Function: calculate] }
  console.log(b)  // { y: 20 }
  let c = Object.create(a, {y: {value: 20}});
  console.log(c)  // { }


  // Example:
  let protoRabbit = {
      speak(line) {
          console.log(`The ${this.type} rabbit says '${line}'`);
      }
  };
  let killerRabbit = Object.create(protoRabbit);
  killerRabbit.type = "killer";
  killerRabbit.speak("SKREEEE!");
  // ‚Üí The killer rabbit says 'SKREEEE!'

  // A property like speak(line) in an object expression is a shorthand way
  // of defining a method. It creates a property called speak and gives it
  // a function as its value.

#+end_src

*Note*: It is possible to create objects with *no* prototype. If you pass ~null~ to Object. ~create~, the resulting object will not derive from ~Object.prototype~ and can safely be used as a [[Map]] (a map (noun) is a data structure that associates values (the keys) with other values).

#+begin_src javascript

  let obj = Object.create(null);

  console.log("toString" in obj); // ‚Üí false

  console.log(Object.getPrototypeOf(obj) == Object.prototype);  // ‚Üí false
  console.log(Object.getPrototypeOf(obj) == null);              // ‚Üí true

#+end_src

*** Object.assign
Function that *copies all properties* from one object (it also can copy arrays) into another (copy only properties, not the prototype).

*Eloquent*: sometimes the use of ~Object.assign~ is intended to create a new object that is a clone of the old one, but with one property added or overwritten. ~Object.assign~ takes its first argument and adds all properties from any further arguments to it. Thus, giving it an empty object will cause it to fill a fresh object.

*Note*: (blueprint copies) after such objects are created, they can extend their own properties, but *changing prototypes do not affect* created children.

*Note*: use ~[]~ when adding a property from a binding.

*Note*: sometimes [[Spread syntax][spread syntax]] can also be used to get same result.

*Warning*: note that ~Object.assign()~ triggers setters, whereas the spread syntax doesn't!

#+begin_src javascript

  let objectA = {a: 1, b: 2};

  Object.assign(objectA, {b: 3, c: 4},{d: 5});
  console.log(objectA);
  // ‚Üí {a: 1, b: 3, c: 4, d: 5}

  // Using [] to add new property from binging
  let otherProperty = "e";
  Object.assign(objectA, {[otherProperty]: 6});
  console.log(objectA);
  // {a: 1, b: 3, c: 4, d: 5, e: 6}


  // It also works to create a new object with others:
  // (a clone of the  objectA, but with one property added or overwritten)
  Object.assign({}, objectA, {d: 5});
  // {a: 1, b: 2, d:5}


  let base = {x: 10};
  let child = Object.assign({}, base);
  child.y = 20;
  console.log(child.x); // 10, copy-"inherited" at creation time, own
  console.log(child.y); // 20, own
  base.z = 30;
  console.log(child.z); // undefined, no delegation

#+end_src

Copying arrays.

#+begin_src javascript

  let arr = [3, 5, 7];
  let arrCopy = Object.assign([], arr)
  console.log(arrCopy); // [ 3, 5, 7 ]

#+end_src

*** Object.getPrototypeOf
Returns the prototype (i.e. the value of the internal ~[[Prototype]]~ property) of the specified object.

*Dmitry S√≥shnikov*
Directly returns the ~[[Prototype]]~ property of an object ‚Äî the original prototype of the instance. However, in contrast with ~__proto__~, being only a getter, it does not allow to set the prototype.

#+begin_src javascript

  // {} empty object
  let obj = {};
  console.log(Object.getPrototypeOf(obj) == Object.prototype);  // ‚Üí true
  console.log(obj.__proto__ == Object.prototype);               // ‚Üí true
  console.log(Object.getPrototypeOf(Object.prototype));         // ‚Üí null
  console.log(Object.prototype.__proto__);                      // ‚Üí null

  // object created with no prototype
  let obj2 = Object.create(null);
  console.log(Object.getPrototypeOf(obj2) == null);  // true
  console.log(obj2.__proto__ ==  null);              // true

  // [] empty array
  console.log(Object.getPrototypeOf(Math.max) == Function.prototype); // true
  console.log(Object.getPrototypeOf([]) == Array.prototype);          // true

  // Constructor
  function Letter(number) {
      this.number = number;
  }
  console.log(Object.getPrototypeOf(Letter) == Function.prototype) // true
  console.log(Object.getPrototypeOf(Letter.prototype) == Object.prototype)
  // true

  let a = new Letter(1);
  console.log(Object.getPrototypeOf(a) == Letter.prototype); // true

#+end_src

*** Object.setPrototypeOf
Static method sets the prototype (i.e., the internal ~[[Prototype]]~ property) of a specified object to another object or null.

*Note*: because this feature is a part of the language, it is still the burden on engine developers to implement that feature performantly (ideally). Until engine developers address this issue, if you are concerned about performance, you should avoid setting the ~[[Prototype]]~ of an object. Instead, create a new object with the desired ~[[Prototype]]~ using [[Object.create]].

#+begin_src javascript

  // Syntax:
  Object.setPrototypeOf(obj, prototype)


  const obj = {};
  const parent = { foo: "bar" };

  console.log(obj.foo);
  // Expected output: undefined

  Object.setPrototypeOf(obj, parent);

  console.log(obj.foo);
  // Expected output: "bar"

#+end_src

*** Object.freeze
Freezes an object. Freezing an object prevents extensions and makes existing properties non-writable and non-configurable. A frozen object can no longer be changed: new properties cannot be added, existing properties cannot be removed, their enumerability, configurability, writability, or value cannot be changed, and the object's prototype cannot be re-assigned. ~freeze()~ returns the same object that was passed in.

Freezing an object is the highest integrity level that JavaScript provides.

#+begin_src javascript

  const obj = {
      prop: 42,
  };

  Object.freeze(obj);

  obj.prop = 33;
  // Throws an error in strict mode

  console.log(obj.prop);
  //  42

#+end_src

*** Object.isFrozen
Determines if an object is [[Object.freeze][frozen]].

#+begin_src javascript

  const object1 = {
    property1: 42,
  };

  console.log(Object.isFrozen(object1)); // false

  Object.freeze(object1);
  console.log(Object.isFrozen(object1)); // true

#+end_src

*** Object.prototype.hasOwnProperty
Returns a boolean indicating whether this object has the specified property as its *own* property (*as opposed to inheriting it*).

*Note*: [[Object.hasOwn]] is recommended over ~hasOwnProperty()~, in browsers where it is supported.

#+begin_src javascript

  const object1 = {};
  object1.property1 = 42;

  console.log(object1.hasOwnProperty('property1'));  //  true
  console.log(object1.hasOwnProperty('toString'));  //  false
  console.log(object1.hasOwnProperty('hasOwnProperty'));  //  false

#+end_src

*** Object.prototype.toString
Returns a string representing this object. This method is meant to be overridden by derived objects for custom type coercion logic.

JavaScript calls the ~toString~ method to convert an object to a primitive value. You rarely need to invoke the ~toString~ method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.

To use the base ~Object.prototype.toString()~ with an object that has it overridden (or to invoke it on ~null~ or ~undefined~), you need to call [[Function.prototype.call]] or [[Function.prototype.apply]] on it, passing the object you want to inspect as the first parameter (called ~thisArg~).

~Object.prototype.toString()~ returns ~"[object Type]"~ , where ~Type~ is the object type.

*Wikipedia*: ~toString()~ function return a description of the object as a string.

#+begin_src javascript

  const arr = [1, 2, 3];

  arr.toString(); // "1,2,3"
  Object.prototype.toString.call(arr); // "[object Array]"


  function Dog(name) {
      this.name = name;
  }

  const dog1 = new Dog('Gabby');

  Dog.prototype.toString = function dogToString() {
      return `${this.name}`;
  };

  console.log(dog1.toString()); // Gabby


  let one = 123.456
  let string = "string";
  let arr = [1,2,'three'];
  let obj = { a: 1, b: "two", c: () => 1}

  console.log(one.toString())     // 123.456
  console.log(string.toString())  // string
  console.log(arr.toString())     // 1,2,three
  console.log(obj.toString())     // [object Object]

#+end_src

*Dmitry S√≥shnikov*
To get the ~[[Class]]~ internal property from ECMAScript programs is possible. This method should return the string: ~"[object " + [[Class]] + "]"~.

#+begin_src javascript

  var getClass = Object.prototype.toString;
  getClass.call({}); // [object Object]
  getClass.call([]); // [object Array]
  getClass.call(new Number(1)); // [object Number]

#+end_src

Using ~toString()~ in this way is unreliable; objects can change the behavior of ~Object.prototype.toString()~ by defining a ~Symbol.toStringTag~ property, leading to unexpected results.

*** Object.prototype.valueOf
The ~valueOf()~ method of Object instances converts the ~this~ value to an object. This method is meant to be overridden by derived objects for custom type conversion logic.

JavaScript calls the ~valueOf~ method to convert an object to a primitive value. You rarely need to invoke the ~valueOf~ method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.

This method is called in priority by numeric conversion and primitive conversion, but string conversion calls ~toString()~ in priority, and ~toString()~ is very likely to return a string value (even for the [[Object.prototype.toString]] base implementation), so ~valueOf()~ is usually not called in this case.

#+begin_src javascript

    // The base valueOf() method returns the this value itself, converted to
    // an object if it isn't already. Therefore its return value will never
    // be used by any primitive conversion algorithm.
    const obj = { foo: 1 };
    console.log(obj.valueOf() === obj); // true

    console.log(Object.prototype.valueOf.call("primitive"));
    // [String: 'primitive'] (a wrapper object)


    var a = new Number(1);
    var primitiveA = Number(a); // implicit "valueOf" call
    var alsoPrimitiveA = a.valueOf(); // explicit

    console.log([
        typeof a, // "object"
        typeof primitiveA, // "number"
        typeof alsoPrimitiveA // "number"
    ]);


  function MyNumberType(n) {
    this.number = n;
  }

  MyNumberType.prototype.valueOf = function () {
    return this.number;
  };

  const object1 = new MyNumberType(4);

  console.log(object1 + 3); // 7

#+end_src

All objects that inherit from ~Object.prototype~ (that is, all except null-prototype objects) inherit the ~toString()~ method. The ~Object.prototype.valueOf()~ base implementation is deliberately useless: by returning an object, its return value will never be used by any primitive conversion algorithm. Many built-in objects override this method to return an appropriate primitive value. When you create a custom object, you can override ~valueOf()~ to call a custom method, *so that your custom object can be converted to a primitive value*. Generally, ~valueOf()~ is used to return a value that is most meaningful for the object ‚Äî unlike ~toString()~, it does not need to be a string. Alternatively, you can add a ~[Symbol.toPrimitive]()~ method, which allows even more control over the conversion process, and will always be preferred over ~valueOf~ or ~toString~ for any type conversion.

*** Object.create vs Object.assign
*Delegation-based* prototypes use dynamic dispatch for the implementation. In ECMAScript we may delegate using ~Object.create~ method (or explicit ~__proto__~ link):

#+begin_src javascript

  let base = {x: 10};
  let child = Object.create(base);
  child.y = 20;
  console.log(child.x); // 10, inherited, via delegation
  console.log(child.y); // 20, own

  base.z = 30;
  console.log(child.z); // 30, again via delegation

  console.log(child);   // { y: 20 }

#+end_src

In *concatenative* model objects are just ‚Äúblueprint copies‚Äù of their prototypes. After such objects are created, they can extend their own properties, but changing prototypes do not affect created children. In ECMAScript concatenative model can be seen on ~Object.assign~ behavior:

#+begin_src javascript

  let base = {x: 10};
  let child = Object.assign({}, base);
  child.y = 20;
  console.log(child.x); // 10, copy-"inherited" at creation time, own
  console.log(child.y); // 20, own

  base.z = 30;
  console.log(child.z); // undefined, no delegation

  console.log(child);   // { x: 10, y: 20 }

#+end_src

*** Copy an object
Remember the [[Object.assign]] method. It is possible to do the same thing with the [[Spread syntax][spread syntax]].

This way of copying an object is much shorter than ~let objCopy = Object.assign({}, obj)~ or for an array ~let arrCopy = Object.assign([], arr)~ so we prefer to use it whenever we can.

#+begin_src javascript

  let obj = { a: 1, b: 2, c: 3 };

  let objCopy = { ...obj }; // spread the object into a list of parameters
  // then return the result in a new object

  // do the objects have the same contents?
  alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

  // are the objects equal?
  alert(obj === objCopy); // false (not same reference)

  // modifying our initial object does not modify the copy:
  obj.d = 4;
  alert(JSON.stringify(obj)); // {"a":1,"b":2,"c":3,"d":4}
  alert(JSON.stringify(objCopy)); // {"a":1,"b":2,"c":3}

  let otherObject = {h: 8, ...obj}
  console.log(otherObject) // -> { h: 8, a: 1, b: 2, c: 3 }

#+end_src

*** Miscellaneous
**** Object.preventExtensions
*Note*:  non-extensible objects.

**** Object.isExtensible
*Note*:  non-extensible objects.

**** Object.seal
*Note*: "sealed": non-extensible and non-configurable objects.

**** Object.isSealed
*Note*: "sealed": non-extensible and non-configurable objects.

**** Object.defineProperty
The meta-method ~Object.defineProperty~ is not only for creating object‚Äôs properties, but also for altering them. Moreover, it returns altered object, so we can use this method to bind newly created object to needed variable name, making it in one action:

#+begin_src javascript

  // create "foo" object and define "bar" property
  var foo = Object.defineProperty({}, "bar", {
      value: 10,
      enumerable: true
  });

  // alter value and enumerable attribute
  Object.defineProperty(foo, "bar", {
      value: 20,
      enumerable: false
  });

  console.log(foo.bar); // 20

#+end_src

**** Object.defineProperties

**** Object.getOwnPropertyDescriptor
Getting the descriptor object of a property.

** DOMs
*** windows
**** window.prompt()
Instructs the browser to display a dialog with an optional message prompting the user to input some text, and to wait until the user either submits the text or cancels the dialog.

*Parameters*:
- ~message (Optional)~ A string of text to display to the user. Can be omitted if there is nothing to show in the prompt window.
- ~defaultValue (Optional)~ A string containing the default value displayed in the text input field.

*Return value*: A string containing the text entered by the user, or null.

#+begin_src javascript

  let sign = prompt("What's your sign?");

  if (sign.toLowerCase() === "scorpio") {
      alert("Wow! I'm a Scorpio too!");
  }


  // Nnote that output is a string. That means you should
  // sometimes cast the value given by the user.
  const aNumber = Number(window.prompt("Type a number", ""));


  // there are many ways to use the prompt feature
  sign = window.prompt(); // open the blank prompt window
  sign = prompt(); //  open the blank prompt window
  sign = window.prompt("Are you feeling lucky"); // open the window with Text "Are you feeling lucky"
  sign = window.prompt("Are you feeling lucky", "sure"); // open the window with Text "Are you feeling lucky" and default value "sure"

#+end_src

**** window.scrollTo()
Scrolls the *document* to specified coordinates.

*Parameters*:
  - ~x-coord~ is the pixel along the horizontal axis of the document that you want displayed in the upper left.
  - ~y-coord~ is the pixel along the vertical axis of the document that you want displayed in the upper left.

  - or -

    ~options~ A dictionary containing the following parameters:
    - ~top~ Specifies the number of pixels along the Y axis to scroll the window or element.
    -  ~left~ Specifies the number of pixels along the X axis to scroll the window or element.
    - ~behavior~ Determines whether scrolling is instant or animates smoothly. This option is a string which must take one of the following values:
      - ~smooth1~: scrolling should animate smoothly
      - ~instant1~: scrolling should happen instantly in a single jump
      - ~auto1~: scroll behavior is determined by the computed value of ~scroll-behavior~

    *Return value*: None (~undefined~).

#+begin_src javascript

  // Syntax
  scrollTo(x-coord, y-coord)
  scrollTo(options)


  window.scrollTo(0, 1000);

  // Using options:
  window.scrollTo({
      top: 100,
      left: 100,
      behavior: "smooth",
  });


#+end_src

**** window.requestAnimationFrame()
Tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. It requests the browser to call a user-supplied callback function before the next repaint.

The frequency of calls to the callback function will generally match the display refresh rate. The most common refresh rate is 60hz, (60 cycles/frames per second), though 75hz, 120hz, and 144hz are also widely used. ~requestAnimationFrame()~ calls are paused in most browsers when running in background tabs or hidden ~<iframe>~ s, in order to improve performance and battery life.

*Note*: Your callback function must call ~requestAnimationFrame()~ again if you want to animate another frame. ~requestAnimationFrame()~ is one-shot.

*Warning*: Be sure always to use the first argument (or some other method for getting the current time) to calculate how much the animation will progress in a frame ‚Äî *otherwise, the animation will run faster on high refresh-rate screens*.

*Parameters*:
- callback :: the function to call when it's time to update your animation for the next repaint. This callback function is passed a single argument:
  - timestamp :: a ~DOMHighResTimeStamp~ indicating the end time of the previous frame's rendering (based on the number of milliseconds since time [[performance.timeOrigin][origin]]).
    The timestamp is a decimal number, in milliseconds, but with a minimal precision of 1 millisecond. For ~Window~ objects (not ~Workers~), it is equal to ~document.timeline.currentTime~. This timestamp is shared between all windows that run on the same agent (all same-origin windows and, more importantly, same-origin iframes) ‚Äî which allows synchronizing animations across multiple ~requestAnimationFrame~ callbacks. *The timestamp value is also similar to calling* [[performance.now()]] *at the start of the callback function*, but it is never the same value.
    When multiple callbacks queued by ~requestAnimationFrame()~ begin to fire in a single frame, each receives the same timestamp even though time has passed during the computation of every previous callback's workload.

*Note*: This /timeline/ is *unique* to each ~document~ and persists for the lifetime of the ~document~ including calls to ~Document.open()~ (INS if /timeline/ is the same that previous ~document.timeline.currentTime~).

*Return value*: A ~long~ integer value, the request ID, that uniquely identifies the entry in the callback list. This is a non-zero value, but you may not make any other assumptions about its value. You can pass this value to ~window.cancelAnimationFrame()~ to cancel the refresh callback request.

#+begin_src javascript

  // The following displays a picture of a cat that moves around in an ellipse:
  <p style="text-align: center">
  <img src="img/cat.png" style="position: relative">
  </p>

  <script>
  let cat = document.querySelector("img");
  let angle = Math.PI / 2;
  function animate(time, lastTime) {
      if (lastTime != null) {
          // from the second call onwards
          angle += (time - lastTime) * 0.001;
      }
      // Note that styles usually need units.
      cat.style.top = (Math.sin(angle) * 20) + "px";
      cat.style.left = (Math.cos(angle) * 200) + "px";
      requestAnimationFrame(newTime => animate(newTime, time));
  }
  requestAnimationFrame(animate);
  </script>

  // The animation function is passed the current time as an argument. To
  // ensure that the motion of the cat per millisecond is stable, it bases
  // the speed at which the angle changes on the difference between the
  // current time and the last time the function ran. If it just moved the
  // angle by a fixed amount per step, the motion would stutter if, for
  // example, another heavy task running on the same computer were to
  // prevent the function from running for a fraction of a second.

#+end_src

*Building other interface to* ~requesAnimationFrame~:
The interface of requestAnimationFrame is quite primitive‚Äîusing it requires us to track the time at which our function was called the last time around and call requestAnimationFrame again after every frame.

Let‚Äôs define a helper function that wraps those boring parts in a convenient interface and allows us to simply call runAnimation, giving it a function that expects a time difference as an argument and draws a single frame. When the frame function returns the value false, the animation stops.

When the browser tab or window with our page is hidden, requestAnimationFrame calls will be suspended until the tab or window is shown again. In this case, the difference between lastTime and time will be the entire time in which the page was hidden.

The function also converts the time steps to seconds, which are an easier quantity to think about than milliseconds.

#+begin_src javascript

  function runAnimation(frameFunc) {
      let lastTime = null;
      function frame(time) {
          if (lastTime != null) {
              let timeStep = Math.min(time - lastTime, 100) / 1000;
              if (frameFunc(timeStep) === false) return;
          }
          lastTime = time;
          requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
  }

#+end_src

The ~cancelAnimationFrame~ function works in the same way as ~clearTimeout~ ‚Äîcalling it on a value returned by [[window.requestAnimationFrame()][requestAnimationFrame]] will cancel that frame (assuming it hasn‚Äôt already been called).

*Note*: If we just updated the DOM in a loop, the page would freeze, and nothing would show up on the screen. *Browsers do not update their display while a JavaScript program is running, nor do they allow any interaction with the page*. This is why we need ~requestAnimationFrame~ ‚Äîit lets the browser know that we are done for now, and it can go ahead and do the things that browsers do, such as updating the screen and responding to user actions.

**** window.setTimeout()
Sets a timer which executes a function or specified piece of code once the timer expires.

*Parameters*:
- functionRef :: A function to be executed after the timer expires.
- delay (Optional) :: The time, in milliseconds that the timer should wait before the specified function or code is executed. If this parameter is omitted, a value of 0 is used, meaning execute "immediately", or more accurately, the next event cycle.
- param1, ‚Ä¶, paramN (Optional) :: Additional arguments which are passed through to the function specified by ~functionRef~.

*Return value*: The returned ~timeoutID~ is a positive integer value which identifies the timer created by the call to ~setTimeout()~. This value can be passed to ~clearTimeout()~ to cancel the timeout.

It is guaranteed that a ~timeoutID~ value will never be reused by a subsequent call to ~setTimeout()~ or ~setInterval()~ on the same object (a window or a worker). However, different objects use separate pools of IDs.

*Note*: ~setTimeout~ run it [[Asynchronous timing][asynchronously]], after the HTML parsing is complete.

#+begin_src javascript

  // Syntax
  setTimeout(functionRef, delay, param1, param2, /* ‚Ä¶, */ paramN)


  // Example:
  <p>Wait 5 seconds for the greeting:</p>
  <h2 id="demo"></h2>

  <script>
  const myTimeout = setTimeout(myGreeting, 5000);
  function myGreeting() {
      document.getElementById("demo").innerHTML = "Happy Birthday!"
  }
  </script>

#+end_src

[[Lexical declarations in the initialization block]]

**** window.clearTimeout()
Cancels a timeout previously established by calling [[window.setTimeout()][setTimeout()]].

If the parameter provided does not identify a previously established action, this method does nothing.

*Parameters*: ~timeoutID~ The identifier of the timeout you want to cancel. This ID was returned by the corresponding call to ~setTimeout()~.

It's worth noting that the pool of IDs used by ~setTimeout()~ and ~setInterval()~ are shared, which means you can technically use ~clearTimeout()~ and ~clearInterval()~ interchangeably. However, for clarity, you should avoid doing so.

*Return value*: None (~undefined~).

#+begin_src javascript

  <p>Click the button to prevent the timeout to execute (You have 3 secs).</p>
  <h2 id="demo"></h2>
  <button onclick="myStopFunction()">Stop it</button>

  <script>
  const myTimeout = setTimeout(myGreeting, 3000);

  function myGreeting() {
      document.getElementById("demo").innerHTML = "Happy Birthday!"
  }

  function myStopFunction() {
      clearTimeout(myTimeout);
  }
  </script>


  let bombTimer = setTimeout(() => {
      console.log("BOOM!");
  }, 500);

  if (Math.random() < 0.5) { // 50% chance
      console.log("Defused.");
      clearTimeout(bombTimer);
  }

#+end_src

**** window.setInterval()
Offered on the [[Window]] and ~WorkerGlobalScope~ interfaces, repeatedly calls a function or executes a code snippet, with a fixed time delay between each call.

This method returns an interval ID which uniquely identifies the interval, so you can remove it later by calling ~clearInterval()~.

*Parameters*:
- func ::  A ~function~ to be executed every ~delay~ milliseconds. The first execution happens after ~delay~ milliseconds.
- delay (Optional) :: The time, in milliseconds (thousandths of a second), the timer should delay in between executions of the specified function or code. Defaults to 0 if not specified.
- arg1, ‚Ä¶,argN (Optional) :: Additional arguments which are passed through to the function specified by func once the timer expires.

*Return value*: The returned ~intervalID~ is a numeric, non-zero value which identifies the timer created by the call to ~setInterval()~; this value can be passed to ~clearInterval()~ to cancel the interval.

It may be helpful to be aware that ~setInterval()~ and ~setTimeout()~ share the same pool of IDs, and that ~clearInterval()~ and ~clearTimeout()~ can technically be used interchangeably. For clarity, however, you should try to always match them to avoid confusion when maintaining your code.

#+begin_src javascript

  // Syntax:
  setInterval(func, delay, arg1, arg2, /* ‚Ä¶, */ argN)


  const intervalID = setInterval(myCallback,500, "Parameter 1", "Parameter 2");

  function myCallback(a, b) {
    // Your code here
    // Parameters are purely optional.
    console.log(a);
    console.log(b);
  }


  // Next example is useful because it shows how the function inside
  // setInterval can be made to vary parameters using the remainder
  // operator, that is, each call to setInterval brings different parameters.

  // Example of building an animation in a canvas (pack multiple sprites
  // (image elements) into a single image file and then draw only the part
  // you need). This is done by moving the axes of the image to paint the
  // necessary frame. In this case only the x-axis will be moved by a
  // remainder operator.

  <canvas></canvas>

  <script>
  let cx = document.querySelector("canvas").getContext("2d");
  let img = document.createElement("img");
  img.src = "img/player.png";
  let spriteW = 24, spriteH = 30;
  img.addEventListener("load", () => {
      let cycle = 0;
      setInterval(() => {
          cx.clearRect(0, 0, spriteW, spriteH);
          cx.drawImage(img,
                       // source rectangle
                       cycle * spriteW, 0, spriteW, spriteH,
                       // destination rectangle
                       0,               0, spriteW, spriteH);
          cycle = (cycle + 1) % 8;
      }, 120);
  });
  </script>
      // The cycle binding tracks our position in the animation. For each
  // frame, it is incremented and then clipped back to the 0 to 7 range by
  // using the remainder operator. This binding is then used to compute the
  // x-coordinate that the sprite for the current pose has in the picture.

#+end_src

**** window.clearInterval()
Cancels a timed, repeating action which was previously established by a call to [[window.setInterval()][setInterval()]]. If the parameter provided does not identify a previously established action, this method does nothing.

*Parameters*: ~intervalID~ The identifier of the repeated action you want to cancel. This ID was returned by the corresponding call to ~setInterval()~.

It's worth noting that the pool of IDs used by ~setInterval()~ and ~setTimeout()~ are shared, which means you can technically use ~clearInterval()~ and ~clearTimeout()~ interchangeably. However, for clarity, you should avoid doing so.

*Return value*: None (~undefined~).

#+begin_src javascript

  <h1>The Window Object</h1>
  <h2>The setInterval() and clearInterval() Methods</h2>
  <p id="demo"></p>
  <button onclick="myStop()">Stop the time</button>

  <script>
  const myInterval = setInterval(myTimer, 1000);

  function myTimer() {
    const date = new Date();
    document.getElementById("demo").innerHTML = date.toLocaleTimeString();
  }

  function myStop() {
    clearInterval(myInterval);
  }
  </script>


  let ticks = 0;
  let clock = setInterval(() => {
      console.log("tick", ticks++);
      if (ticks == 10) {
          clearInterval(clock);
          console.log("stop.");
      }
  }, 200);

#+end_src

**** load event
The ~load~ event is fired when the whole page has loaded, including all dependent resources such as stylesheets, scripts, iframes, and images. This is in contrast to ~DOMContentLoaded~, which is fired as soon as the page DOM has been loaded, without waiting for resources to finish loading.

This event is not cancelable and does not bubble.

*Note*: All events named ~load~ *will* not propagate to ~Window~, even with ~bubbles~ initialized to ~true~. To catch ~load~ events on the ~window~, that ~load~ event must be dispatched directly to the ~window~.

*Note*: The ~load~ event that is dispatched when the main document has loaded *is* dispatched on the ~window~, but has two mutated properties: ~target~ is ~document~, and ~path~ is ~undefined~. These two properties are mutated due to legacy conformance.

#+begin_src javascript

  // Syntax:
  // Use the event name in methods like addEventListener(),
  addEventListener("load", (event) => {});
  // or set an event handler property.
  onload = (event) => {};


  // Log a message when the page is fully loaded:
  window.addEventListener("load", (event) => {
      console.log("page is fully loaded");
  });

  // The same, but using the onload event handler property:
  window.onload = (event) => {
      console.log("page is fully loaded");
  };

#+end_src

*** documents
**** document.documentElement
Returns the [[Element]] that is the root element of the [[document]] (for example, the ~<html>~ element for HTML documents).

*Value*: A ~Element~ object.

#+begin_src javascript

  console.log(document.documentElement);
  // <!doctype html>
  // <html>
  //   <head>
  //     <title>My home page</title>
  //   </head>
  //   <body>
  //     <h1>My home page</h1>
  // </body>
  // </html>


  // Get the name of the document element node:
  document.documentElement.nodeName;


  // firstTier is a NodeList of the direct children of the root element
  // such as <head> and <body>
  console.log(document.documentElement.childNodes);
  // NodeList(3) [head, text, body]

  for (const child of firstTier) {
      // do something with each direct child of the root element
  }

#+end_src

**** document.body
Represents the <body> or <frameset> node of the current document, or null if no such element exists.

*Value*: One of the following: ~<body>~, ~<frameset>~, ~null~.

#+begin_src javascript

  console.log(document.body);
  //   <body>
  //     <h1>My home page</h1>
  //   </body>


  // Given this HTML: <body id="oldBodyElement"></body>
  alert(document.body.id); // "oldBodyElement"

#+end_src

**** document.querySelector()
Returns the first [[Element]] within the document that matches the specified selector, or group of selectors. If no matches are found, ~null~ is returned.

This method works in a similar way than [[document.querySelectorAll()]]. ~document.querySelector~ is useful if you want a specific, single element. It will return only the first matching element or null when no element matches.

*Note*: The matching is done using depth-first pre-order traversal of the document's nodes starting with the first element in the document's markup and iterating through sequential nodes by order of the number of child nodes.

*Parameters*: ~selectors~ A string containing one or more selectors to match. This string must be a valid CSS selector string; if it isn't, a ~SyntaxError~ exception is thrown.

*Note*: Characters that are not part of standard CSS syntax must be escaped using a backslash character. Since JavaScript also uses backslash escaping, be especially careful when writing string literals using these characters.

*Return value*: An [[Element]] object representing the first element in the document that matches the specified set of CSS selectors, or ~null~ is returned if there are no matches.

#+begin_src javascript

  // Finding the first element matching a class
  const el = document.querySelector(".myclass");

  // Finding id element
  const el = document.querySelector("#myid");

  // Finding p tag
  const el = document.querySelector("p");

  // Finding attribute value
  let buttons = document.querySelector("[name=color]");

#+end_src

**** document.querySelectorAll()
Returns a *static* (not live) [[NodeList]] representing a list of the document's elements that match the specified group of selectors.

*Parameters*: A string containing one or more selectors to match against. This string must be a valid /CSS selector/ string; if it's not, a ~SyntaxError~ exception is thrown.

*Note*: Characters which are not part of standard CSS syntax must be escaped using a backslash character.

*Return value*: A non-live ~NodeList~ containing one [[Element]] object for each element that matches at least one of the specified selectors or an empty ~NodeList~ in case of no matches.

*Note*: If the specified ~selectors~ include a CSS pseudo-element, the returned list is always empty.

#+begin_src javascript

  // To obtain a NodeList of all of the <p> elements in the document:
  const matches = document.querySelectorAll("p");


  <p>And if you go chasing
  <span class="animal">rabbits</span></p>
  <p>And you know you're going to fall</p>
  <p>Tell 'em a <span class="character">hookah smoking
  <span class="animal">caterpillar</span></span></p>
  <p>Has given you the call</p>

  <script>
  function count(selector) {
      return document.querySelectorAll(selector).length;
  }
  console.log(count("p"));           // All <p> elements
  // ‚Üí 4
  console.log(count(".animal"));     // Class animal
  // ‚Üí 2
  console.log(count("p .animal"));   // Animal inside of <p>
  // ‚Üí 2
  console.log(count("p > .animal")); // Direct child of <p>
  // ‚Üí 1
  </script>


  // Example to match attributes:
  <label>
    <input type="radio" name="color" value="orange"> Orange
  </label>
  <label>
    <input type="radio" name="color" value="lightgreen"> Green
  </label>
  <label>
    <input type="radio" name="color" value="lightblue"> Blue
  </label>

  <script>
  let buttons = document.querySelectorAll("[name=color]");
  for (let button of Array.from(buttons)) {
      button.addEventListener("change", () => {
          document.body.style.background = button.value;
      });
  }
  </script>
  // The square brackets in the CSS query given to querySelectorAll are
  // used to match attrs. It selects elements whose name attr is "color".


  // Search all tags like this => <div state="open">
  const dsr = document.querySelectorAll("div[state]");

#+end_src

**** document.getElementsByTagName()
Returns an [[HTMLCollection]] of elements with the given tag name.

The complete document is searched, including the root node. The returned ~HTMLCollection~ is *live*, meaning that it updates itself automatically to stay in sync with the DOM tree without having to call ~document.getElementsByTagName()~ again.

*Parameters*: ~name~ A string representing the name of the elements. The special string ~*~ represents all elements.

*Return value*: A live ~HTMLCollection~ of found elements in the order they appear in the tree.

*Note*: The latest W3C specification says returned value is an ~HTMLCollection~; however, this method returns a [[NodeList]] in WebKit browsers.

#+begin_src javascript

  // Get all elements with the tag name "li":
  const collection = document.getElementsByTagName("li");

  // Get all elements in the document:
  const collection = document.getElementsByTagName("*");

  // Change the inner HTML of the first <p> element in the document:
  document.getElementsByTagName("p")[0].innerHTML = "Hello World!";


  let link = document.body.getElementsByTagName("a")[0];
  console.log(link.href);
  // http://eloquentjavascript.net/

#+end_src

**** document.getElementById()
Returns an [[Element]] object representing the element whose ~id~ property matches the specified string.

*Parameters*: ~id~ The ID of the element to locate. The ID is a case-sensitive string which is unique within the document.

*Return value*: An [[Element]] object describing the DOM element object matching the specified ID, or ~null~ if no matching element was found in the document.

#+begin_src javascript

  <p>My ostrich Gertrude:</p>
  <p><img id="gertrude" src="img/ostrich.png"></p>

  <script>
  let ostrich = document.getElementById("gertrude");
  console.log(ostrich.src);
  // http://localhost:8000/img/ostrich.png
  </script>

#+end_src

**** document.getElementsByClassName()
Returns an array-like object of all child elements which have all of the given class name(s).

When called on the [[Document]] object, the complete document is searched, including the root node. You may also call ~getElementsByClassName()~ on any element; it will return only elements which are descendants of the specified root element with the given class name(s).

*Warning*: This is a *live* [[HTMLCollection]]. Changes in the DOM will reflect in the array as the changes occur. If an element selected by this array no longer qualifies for the selector, it will automatically be removed. Be aware of this for iteration purposes.

*Parameters*: ~names~ A string representing the class name(s) to match; multiple class names are separated by whitespace.

*Return value*: A live ~HTMLCollection~ of found elements.

#+begin_src javascript

  // Get all elements that have a class of 'test':
  document.getElementsByClassName("test");

  // Get all elements that have both the 'red' and 'test' classes:
  document.getElementsByClassName("red test");

  // Get all elements that have a class of 'test', inside of an element
  // that has the ID of 'main':
  document.getElementById("main").getElementsByClassName("test");

  // Get the first element with a class of 'test', or undefined if there is
  // no matching element:
  document.getElementsByClassName("test")[0];



  // We can also use methods of Array.prototype on any HTMLCollection by
  // passing the HTMLCollection as the method's this value. Here we'll
  // find all div elements that have a class of 'test':
  const testElements = document.getElementsByClassName("test");
  const testDivs = Array.prototype.filter.call(
      testElements,
      (testElement) => testElement.nodeName === "DIV",
  );

#+end_src

Get the first element whose class is 'test':
This is the most commonly used method of operation.

#+begin_src javascript

  <html lang="en">
  <body>
  <div id="parent-id">
    <p>hello world 1</p>
    <p class="test">hello world 2</p>
    <p>hello world 3</p>
    <p>hello world 4</p>
  </div>

  <script>
  const parentDOM = document.getElementById("parent-id");

  const test = parentDOM.getElementsByClassName("test");
  // a list of matching elements, *not* the element itself
  console.log(test); // HTMLCollection[1]

  const testTarget = parentDOM.getElementsByClassName("test")[0];
  // the first element, as we wanted
  console.log(testTarget); // <p class="test">hello world 2</p>
  </script>
  </body>
  </html>

#+end_src

**** document.createElement()
Creates the HTML element specified by *tagName*, or an ~HTMLUnknownElement~ if tagName isn't recognized.

*Parameters*:
- ~tagName~ A string that specifies the type of element to be created. The ~nodeName~ of the created element is initialized with the value of *tagName*. Don't use qualified names (like "html:a") with this method. When called on an HTML document, ~createElement()~ converts tagName to lower case before creating the element. In Firefox, Opera, and Chrome, ~createElement(null)~ works like ~createElement("null")~.
- ~options~ (Optional) An object with the following properties: ~is~ The tag name of a custom element previously defined via ~customElements.define()~.

*Return value*: The new [[Element]].

*Note*: A new ~HTMLElement~ is returned if the document is an ~HTMLDocument~, which is the most common case. Otherwise a new ~Element~ is returned.

#+begin_src javascript

  // Create a <p> element and append it to the document:
  const para = document.createElement("p");
  para.innerText = "This is a paragraph";
  document.body.appendChild(para);

#+end_src

**** document.createTextNode()
Creates a new ~Text~ node. This method can be used to escape HTML characters.

*Parameters*: ~data~ A string containing the data to be put in the text node.

*Return value*: A ~Text~ node.

#+begin_src javascript

  // Create a text node and append it to the document:
  const textNode = document.createTextNode("Hello World");
  document.body.appendChild(textNode);


  // Create a <h1> element with a text node:
  const h1 = document.createElement("h1");
  const textNode = document.createTextNode("Hello World");
  h1.appendChild(textNode);

#+end_src

*** nodes
**** textContent
Represents the text content of the node and its descendants.

*Warning*: Setting ~textContent~ on a node removes *all* of the node's children and replaces them with a single text node with the given string value.

*Note*: ~textContent~ and [[HTMLElement: innerText][HTMLElement.innerText]] are easily confused, but the two properties are different in important ways.

*Differences from innerText*
- textContent :: gets the content of *all* elements, including ~<script>~ and ~<style>~ elements. In contrast, ~innerText~ only shows "human-readable" elements.
- textContent :: returns every element in the node. In contrast, ~innerText~ is aware of styling and won't return the text of "hidden" elements. Moreover, since ~innerText~ takes CSS styles into account, reading the value of ~innerText~ triggers a reflow to ensure up-to-date computed styles. (Reflows can be computationally expensive, and thus should be avoided when possible.)

*Differences from innerHTML*
[[innerHTML][Element.innerHTML]] returns HTML, as its name indicates. Sometimes people use ~innerHTML~ to retrieve or write text inside an element, but ~textContent~ has better performance because its value is not parsed as HTML. Moreover, using ~textContent~ can prevent XSS attacks.

#+begin_src javascript

  <div id="divA">This is <span>some</span> text!</div>

  // You can use textContent to get the element's text content:
  let text = document.getElementById("divA").textContent;
  // The text variable is now: 'This is some text!'

  // If you prefer to set the element's text content, you can do:
  document.getElementById("divA").textContent = "This text is different!";
  // The HTML for divA is now:
  // <div id="divA">This text is different!</div>


  // Compares innerText with Node.textContent. Note how innerText is
  // aware of things like <br> elements, and ignores hidden elements.
  <h3>Source element:</h3>
  <p id="source">
    <style>
      #source {
          color: red;
      }
      #text {
          text-transform: uppercase;
      }
    </style>
    <span id="text">
      Take a look at<br />
      how this text<br />
      is interpreted below.
    </span>
    <span style="display:none">HIDDEN TEXT</span>
  </p>
  <h3>Result of textContent:</h3>
  <textarea id="textContentOutput" rows="6" cols="30" readonly>‚Ä¶</textarea>
  <h3>Result of innerText:</h3>
  <textarea id="innerTextOutput" rows="6" cols="30" readonly>‚Ä¶</textarea>

  <script>
  const source = document.getElementById("source");
  const textContentOutput = document.getElementById("textContentOutput");
  const innerTextOutput = document.getElementById("innerTextOutput");

  textContentOutput.value = source.textContent;
  innerTextOutput.value = source.innerText;
  </script>
  // Source element:

  // Take a look at
  // how this text
  // is interpreted below.

  // Result of textContent:
  // +----------------------------------+
  // |  #source {                       |
  // |      color: red;                 |
  // |    }                             |
  // |    #text {                       |
  // |      text-transform: uppercase;  |
  // |    }                             |
  // |                                  |
  // |                                  |
  // |    Take a look at                |
  // |    how this text                 |
  // |    is interpreted below.         |
  // |                                  |
  // |  HIDDEN TEXT                     |
  // +----------------------------------+

  // Result of innerText:
  // +---------------------+
  // |TAKE A LOOK AT       |
  // |HOW THIS TEXT        |
  // |IS INTERPRETED BELOW.|
  // +---------------------+

#+end_src

**** nodeType
The read-only ~nodeType~ property of a ~Node~ interface is an integer that identifies what the node is. It distinguishes different kind of nodes from each other, such as ~elements~, ~text~ and ~comments~.

*Value*: An integer which specifies the type of the node. Possible values are:

|  /#/ | /Name/                        | /e.g/                         |
|----+-----------------------------+-----------------------------|
|  1 | ELEMENT_NODE                | <p>, <div>, ‚Ä¶               |
|  2 | ATTRIBUTE_NODE              | An Attribute of an Element  |
|  3 | TEXT_NODE                   | Text inside Element or Attr |
|  8 | COMMENT_NODE                | <!-- ‚Ä¶ -->                  |
|  9 | DOCUMENT_NODE               | A Document node             |
|    |                             |                             |
|  4 | CDATA_SECTION_NODE          | <!CDATA[[ ‚Ä¶ ]>              |
|  7 | PROCESSING_INSTRUCTION_NODE | <?xml-stylesheet ‚Ä¶ ?>       |
| 10 | DOCUMENT_TYPE_NODE          | <!DOCTYPE html>             |
| 11 | DOCUMENT_FRAGMENT_NODE      | A DocumentFragment node     |

#+begin_src javascript

  console.log(document.nodeType) // 9
  document.nodeType === Node.DOCUMENT_NODE; // true
  document.doctype.nodeType === Node.DOCUMENT_TYPE_NODE; // true

  document.createDocumentFragment().nodeType === Node.DOCUMENT_FRAGMENT_NODE;
  // true

  const p = document.createElement("p");
  p.textContent = "Once upon a time‚Ä¶";

  console.log(p.nodeType) // 1
  p.nodeType === Node.ELEMENT_NODE; // true
  p.firstChild.nodeType === Node.TEXT_NODE; // true


  // This example checks if the first node inside the document element is a
  // comment, and displays a message if not.
  const node = document.documentElement.firstChild;
  if (node.nodeType !== Node.COMMENT_NODE) {
      console.warn("You should comment your code!");
  }

#+end_src

**** nodeValue
The ~nodeValue~ property of the [[Node]] interface returns or sets the value of the current node.

*Value*: A string containing the value of the current node, if any.
- For the *document* itself, ~nodeValue~ returns ~null~.
- For *text*, *comment*, and *CDATA* nodes, ~nodeValue~ returns the content of the node.
- For attribute nodes, the value of the attribute is returned.

[[Attr][Note]]: remember the ‚Äúnode‚Äù attribute is not a node itself of the document DOM (is not part of the document tree), it cannot be retrieved by the usual methods. However, when they refer to the value as in the statement above, they refer to the value of the attribute *object*. (INS)

| /Node/                  | /Value of nodeValue/                  |
|-----------------------+-------------------------------------|
| Text                  | Content of the text node            |
| Comment               | Content of the comment              |
| CDATASection          | Content of the CDATA section        |
| Element               | null                                |
| Document              | null                                |
| DocumentType          | null                                |
| ProcessingInstruction | Entire content excluding the target |
| DocumentFragment      | null                                |
| NamedNodeMap          | null                                |

*Note*: When ~nodeValue~ is defined to be ~null~, setting it has no effect.

#+begin_src javascript

  // Return the node value of the first <button> element in the document:
  const element = document.getElementsByTagName("BUTTON")[0];
  let value = element.childNodes[0].nodeValue;


  // Example:
  <div id="d1" some="something">Hello world</div>
  <!-- Example of comment -->
  <output id="result">Not calculated yet.</output>

  <script>
    let node = document.querySelector("body").firstChild;
    let result = "Node names are:\n";
    while (node) {
        result += `Value of ${node.nodeName}: ${node.nodeValue}\n`;
        node = node.nextSibling;
    }

    const output = document.getElementById("result");
    output.innerText = result;
  </script>
  // Hello world            /* This is the first html tag content  */
  // Node names are:        /* From here down is the script output */
  // Value of #text:        /* This text is for the spaces and newlines */

  // Value of DIV: null
  // Value of #text:

  // Value of #comment: Example of comment
  // Value of #text:

  // Value of OUTPUT: null
  // Value of #text:

  // Value of SCRIPT: null

#+end_src

**** nodeName
The read-only ~nodeName~ property of [[Node]] returns the name of the current node as a string.

*Value*: A string.

*Note*: this will return the tag name in all uppercase.

| /Node/                  | /Value/                                     |
|-----------------------+-------------------------------------------|
| Attr                  | The value of Attr.name                    |
| Element               | The value of Element.tagName              |
| Text                  | The string "#text"                        |
| Comment               | The string "#comment"                     |
| Document              | The string "#document"                    |
| CDATASection          | The string "#cdata-section"               |
| DocumentType          | The value of DocumentType.name            |
| ProcessingInstruction | The value of ProcessingInstruction.target |
| DocumentFragment      | The string "#document-fragment"           |

#+begin_src javascript

  // Return the node name of the <body> element:
  document.body.nodeName;
  // BODY

#+end_src

**** parentNode
The read-only ~parentNode~ property of the [[Node]] interface returns the parent of the specified node in the DOM tree.

[[Document]] and [[DocumentFragment]] nodes can never have a parent, so ~parentNode~ will always return ~null~. It also returns ~null~ if the node has just been created and is not yet attached to the tree.

*Value*: A ~Node~ that is the parent of the current node. The parent of an element is an ~Element~ node, a ~Document~ node, or a ~DocumentFragment~ node.

#+begin_src javascript

  if (node.parentNode) {
      // remove a node from the tree, unless
      // it's not in the tree already
      node.parentNode.removeChild(node);
  }

#+end_src

**** childNodes
The read-only ~childNodes~ property of the [[Node]] interface returns a *live* [[NodeList]] of *child nodes* of the given element where the first child node is assigned index ~0~. Child nodes include elements, text and comments.

*Note*: The ~NodeList~ being live means that its content is changed each time new children are added or removed. Browsers insert text nodes into a document to represent whitespace in the source markup. Therefore a node obtained, for example, using ~Node.childNodes[0]~ may refer to a whitespace text node rather than the actual element the author intended to get.

*Note*: Although ~NodeList~ is not an ~Array~, it is possible to iterate over it with ~forEach()~. It can also be converted to a real Array using [[Array.from]].

The items in the collection of nodes are objects, not strings. To get data from node objects, use their properties.

It is important to keep in mind that childNodes includes all child nodes, including non-element nodes like text and comment. To get a collection containing only elements, use Element.children instead.

*Value*: A live ~NodeList~ containing the children of the node.

*Note*: Several calls to ~childNodes~ return the same ~NodeList~.

#+begin_src javascript

  // Note that parg is an object reference to a <p> element

  // First check that the element has child nodes
  if (parg.hasChildNodes()) {
      let children = parg.childNodes;

      for (const node of children) {
          // Do something with each child as children[i]
          // NOTE: List is live! Adding or removing children will
          // change the list's `length`
      }
  }


  // Remove all children from a node:
  // This is one way to remove all children from a node
  // box is an object reference to an element
  while (box.firstChild) {
      // The list is LIVE so it will re-index each call
      box.removeChild(box.firstChild);
  }

#+end_src

**** previousSibling
The read-only ~previousSibling~ property of the [[Node]] interface returns the node immediately preceding the specified one in its parent's [[childNodes]] list, or ~null~ if the specified node is the first in that list.

*Note*: Browsers insert text nodes into a document to represent whitespace in the source markup. Therefore a node obtained, for example, using [[firstChild]] or ~Node.previousSibling~ may refer to a whitespace text node rather than the actual element the author intended to get. You can use [[previousElementSibling]] to get the previous element node (skipping text nodes and any other non-element nodes).

*Value*: A [[Node]] representing the previous sibling of the current node, or ~null~ if there are none.

#+begin_src javascript

  // We have a series of img elements directly adjacent to each other, with
  // no whitespace between them.

  <img id="b0" /><img id="b1" /><img id="b2" />

  document.getElementById("b1").previousSibling; // <img id="b0">
  document.getElementById("b2").previousSibling.id; // "b1"


  // In this example, there are whitespace text nodes (line breaks) between
  // the img elements.

  <img id="b0" />
  <img id="b1" />
  <img id="b2" />

  document.getElementById("b1").previousSibling; // #text
  document.getElementById("b1").previousSibling.previousSibling;//<img id="b0">
  document.getElementById("b2").previousSibling.previousSibling;//<img id="b1">
  document.getElementById("b2").previousSibling; // #text
  document.getElementById("b2").previousSibling.id; // undefined

#+end_src

**** firstChild
Returns the node's first child in the tree, or ~null~ if the node has no children.

If the node is a [[Document]], this property returns the first node in the list of its direct children.

*Note*: This property returns any type of node that is the first child of this one. It may be a ~Text~ or a ~Comment~ node. If you want to get the first Element that is a child of another element, consider using ~Element.firstElementChild~.

*Value*: A [[Node]], or ~null~ if there are none.

#+begin_src javascript

 <p id="para-01">
   <span>First span</span>
 </p>

  <script>
    const p01 = document.getElementById("para-01");
    console.log(p01.firstChild.nodeName);
  </script>
  // The console will show -> '#text'
  // because a text node is inserted to maintain the whitespace between the
  // end of the opening <p> and <span> tags. Any whitespace will create a
  // #text node, from a single space to multiple spaces, returns, tabs, and
  // so on.

  <p id="para-01"><span>First span</span></p>

  <script>
    const p01 = document.getElementById("para-01");
    console.log(p01.firstChild.nodeName);
  </script>
  // Now the console will show -> 'SPAN'.

#+end_src

**** nextSibling
The read-only ~nextSibling~ property of the [[Node]] interface returns the node immediately following the specified one in their parent's [[childNodes]], or returns ~null~ if the specified node is the last child in the parent element.

*Note*: Browsers insert ~Text~ nodes into a document to represent whitespace in the source markup. Therefore a node obtained, for example, using ~Node.firstChild~ or ~Node.previousSibling~ may refer to a whitespace text node rather than the actual element the author intended to get. You can use [[nextElementSibling]] to obtain the next element skipping any whitespace nodes, other between-element text, or comments.

*Value*: A [[Node]] representing the next sibling of the current node, or ~null~ if there are none.

#+begin_src javascript

  html

  <div id="div-1">Here is div-1</div>
  <div id="div-2">Here is div-2</div>
  <br />
  <output><em>Not calculated.</em></output>

  js

  let el = document.getElementById("div-1").nextSibling;
  let i = 1;

  let result = "Siblings of div-1:<br/>";

  while (el) {
      result += `${i}. ${el.nodeName}<br/>`;
      el = el.nextSibling;
      i++;
  }

  const output = document.querySelector("output");
  output.innerHTML = result;

#+end_src

**** appendChild()
Adds a node to the end of the list of children of a specified parent node.

*Note*: If the given child is a reference to an existing node in the document, ~appendChild()~ moves it from its current position to the new position ‚Äî there is no requirement to remove the node from its parent node before appending it to some other node. This means that a node can't be in two points of the document simultaneously. The [[cloneNode()][Node.cloneNode()]] method can be used to make a copy of the node before appending it under the new parent. Copies made with ~cloneNode~ are not automatically kept in sync.

~appendChild()~ returns the newly appended node, instead of the parent node. This means you can append the new node as soon as it's created without losing reference to it.

*Note*: Unlike this method, the [[append()][Element.append()]] method supports multiple arguments and appending strings. You can prefer using it if your node is an element.

*Parameters*: ~aChild~ The node to append to the given parent node (commonly an element).

*Return value*: A [[Node]] that is the appended child (~aChild~), except when ~aChild~ is a [[DocumentFragment]], in which case the empty ~DocumentFragment~ is returned.

#+begin_src javascript

  // Append a paragraph to the body:
  // Create a new paragraph element, and append it to the end of the
  // document body:
  const p = document.createElement("p");
  document.body.appendChild(p);

#+end_src

~appendChild()~ returns the newly appended node, or if the child is a ~DocumentFragment~, the emptied fragment.

If the given child is a DocumentFragment, the entire contents of the DocumentFragment are moved into the child list of the specified parent node.

**** insertBefore()
Inserts a node before a *reference node* as a child of a specified parent node.

If the given node already exists in the document, ~insertBefore()~ moves it from its current position to the new position. (That is, it will automatically be removed from its existing parent before appending it to the specified new parent.)

This means that a node cannot be in two locations of the document simultaneously.

*Note*: The [[cloneNode()][Node.cloneNode()]] can be used to make a copy of the node before appending it under the new parent. Note that the copies made with ~cloneNode()~ will not be automatically kept in sync.

*Parameters*:
- ~newNode~ The node to be inserted.
- ~referenceNode~ The node before which ~newNode~ is inserted. If this is ~null~, then ~newNode~ is inserted at the end of node's child nodes.

*Note* that ~insertBefore~ expect the *new* node as their first argument.

*Note*: ~referenceNode~ is not an optional parameter. You must explicitly pass a ~Node~ or ~null~. Failing to provide it or passing invalid values may behave differently in different browser versions.

*Return value*: Returns the added child (unless ~newNode~ is a [[DocumentFragment]], in which case the empty ~DocumentFragment~ is returned).

#+begin_src javascript

  // Create an <li> element
  const newNode = document.createElement("li");
  // Create a text node
  const textNode = document.createTextNode("Water");
  // Append the text to the <li> element
  newNode.appendChild(textNode);

  const list = document.getElementById("myList");
  // Insert the <li> element before the first child in a <ul>:
  list.insertBefore(newNode, list.children[0]);

#+end_src

If the given child is a ~DocumentFragment~, the entire contents of the ~DocumentFragment~ are moved into the child list of the specified parent node.

**** replaceChild()
Replaces a child node within the given (parent) node.

*Parameters*:
- ~newChild~ The new node to replace ~oldChild~.
  *Warning*: If the new node is already present somewhere else in the DOM, it is first removed from that position.
- ~oldChild~ The child to be replaced.

*Note* that ~replaceChild~ expect the *new* node as their first argument.

*Return value*: The replaced [[Node]]. This is the same node as ~oldChild~.

*Note*: The parameter order, *new* before *old*, is unusual. ~Element.replaceWith()~, applying only to nodes that are elements, may be easier to read and use.

#+begin_src javascript

  // Replace a text node in an <li> element with a new text node:
  const newNode = document.createTextNode("Water");
  const element = document.getElementById("myList").children[0];

  element.replaceChild(newNode, element.childNodes[0]);
  //     Before:            After:

  //     Coffee             Wate
  //     Tea                Tea
  //     Milk               Milk

#+end_src

**** hasChildNodes()
Returns a boolean value indicating whether the given [[Node]] has [[childNodes][child nodes]] or not.

*Parameters*: None.

*Return value*: A boolean value that is ~true~ if the node has child nodes, and ~false~ otherwise.

#+begin_src javascript

  let foo = document.getElementById("foo");

  if (foo.hasChildNodes()) {
      // Do something with 'foo.childNodes'
  }

#+end_src

**** cloneNode()
Returns a duplicate of the node on which this method was called. Its parameter controls if the subtree contained in a node is also cloned or not.

Cloning a node copies all of its attributes and their values, including intrinsic (inline) listeners. It does not copy event listeners added using [[addEventListener()]] or those assigned to element properties (e.g., ~node.onclick = someFunction~ ). Additionally, for a [[Canvas][<canvas>]] element, the painted image is not copied.

*Warning*: ~cloneNode()~ may lead to duplicate element IDs in a document! If the original node has an ~id~ attribute, and the clone will be placed in the same document, then you should modify the clone's ID to be unique. Also, ~name~ attributes may need to be modified, depending on whether duplicate names are expected.

To clone a node to insert into a different document, use ~Document.importNode()~ instead.

*Parameters*:
- deep (Optional) ::
  If ~true~, then the node and its whole subtree, including text that may be in child ~Text~ nodes, is also copied.
  If ~false~, only the node will be cloned. The subtree, including any text that the node contains, is not cloned.
  Note that ~deep~ has no effect on void elements, such as the ~<img>~ and ~<input>~ elements.

*Return value*:
The new ~Node~ cloned. The cloned node has no parent and is not part of the document, until it is added to another node that is part of the document, using [[appendChild()][Node.appendChild()]] or a similar method.

#+begin_src javascript

  // Syntax
  cloneNode()
  cloneNode(deep)


  <ul id="myList1"><li>Coffee</li><li>Tea</li></ul>
  <ul id="myList2"><li>Water</li><li>Milk</li></ul>

  // Copy a <li> element from "myList2" to "myList1":
  const node = document.getElementById("myList2").lastChild;
  const clone = node.cloneNode(true);

  document.getElementById("myList1").appendChild(clone);
  // Before:           After:

  //     Coffee            Coffee
  //     Tea               Tea
  //                       Milk
  //     Water
  //     Milk              Wate
  //                       Milk

#+end_src

*** elements
**** innerHTML
Gets or sets the HTML or XML markup contained within the element.

To insert the HTML into the document rather than replace the contents of an element, use the method [[insertAdjacentHTML()]].

*Value* A string containing the HTML serialization of the element's descendants. Setting the value of ~innerHTML~ removes all of the element's descendants and replaces them with nodes constructed by parsing the HTML given in the string *htmlString*.

#+begin_src javascript

  <p id="myP">I am a paragraph.</p>
  <p>The content of "myP" is:</p>
  <p id="demo"></p>

  <script>
  let html = document.getElementById("myP").innerHTML;
  document.getElementById("demo").innerHTML = html;
  </script>

  // Output:
  // I am a paragraph.
  // The content of "myP" is:
  // I am a paragraph.


  // Difference between innerHTML and outerHTML:
  <p id="myP">I am a paragraph.</p>
  <p>The content of "myP" is:</p>
  <p id="demo"></p>

  <script>
  let myP = document.getElementById("myP");
  console.log(myP.innerHTML);
  console.log(myP.outerHTML);
  </script>
  // I am a paragraph.
  // <p id="myP">I am a paragraph.</p>


  // Example
  <div id="d">
    <p>Content</p>
    <p>Further Elaborated</p>
  </div>

  const d = document.getElementById("d");
  console.log(d.outerHTML);
  console.log(d.innerHTML);
  // <div id="d"><p>Content</p><p>Further Elaborated</p></div>
  //             <p>Content</p><p>Further Elaborated</p>

#+end_src

**** outerHTML
Gets the serialized HTML fragment describing the element including its descendants. It can also be set to replace the element with nodes parsed from the given string.

To only obtain the HTML representation of the contents of an element, or to replace the contents of an element, use the [[innerHTML]] property instead.

*Value* Reading the value of ~outerHTML~ returns a string containing an HTML serialization of the ~element~ and its descendants. Setting the value of ~outerHTML~ replaces the element and all of its descendants with a new DOM tree constructed by parsing the specified ~htmlString~.

#+begin_src javascript

  // Getting the value of an element's outerHTML property
  <div id="d">
    <p>Content</p>
    <p>Further Elaborated</p>
  </div>

  const d = document.getElementById("d");
  console.log(d.outerHTML);
  console.log(d.innerHTML);
  // <div id="d"><p>Content</p><p>Further Elaborated</p></div>
  //             <p>Content</p><p>Further Elaborated</p>

  // Replacing a node by setting the outerHTML property
  <div id="container">
    <div id="d">This is a div.</div>
  </div>

  const container = document.getElementById("container");
  const d = document.getElementById("d");

  console.log(container.firstElementChild.nodeName); // logs "DIV"

  d.outerHTML = "<p>This paragraph replaced the original div.</p>";

  console.log(container.firstElementChild.nodeName); // logs "P"
  // The #d div is no longer part of the document tree,
  // the new paragraph replaced it.

#+end_src

**** children
Returns a *live* [[HTMLCollection]] which contains all of the *child elements* of the [[element]] upon which it was called.

~Element.children~ includes only element nodes. To get all child nodes, including non-element nodes like text and comment nodes, use [[childNodes][Node.childNodes]].

*Note*: An ~HTMLCollection~ in the HTML DOM is live; it is automatically updated when the underlying document is changed. For this reason it is a good idea to make a copy (e.g., using [[Array.from]]) to iterate over if adding, moving, or removing nodes.

*Note*: The ~children~ property, which is like ~childNodes~ but contains only element (type 1) children, not other types of child nodes. This can be useful when you aren‚Äôt interested in text nodes.

*Value*: An ~HTMLCollection~ which is a live, ordered collection of the DOM elements which are children of ~node~. You can access the individual child nodes in the collection by using either the ~item()~ method on the collection, or by using JavaScript array-style notation.

If the element has no element children, then ~children~ is an empty list with a ~length~ of ~0~.

#+begin_src javascript

  const myElement = document.getElementById("foo");
  for (const child of myElement.children) {
      console.log(child.tagName);
  }

#+end_src

**** previousElementSibling
Returns the [[Element]] immediately prior to the specified one in its parent's children list, or ~null~ if the specified element is the first one in the list.

*Value*: An [[Element]] object, or ~null~.

#+begin_src javascript

  <div id="div-01">Here is div-01</div>
  <div id="div-02">Here is div-02</div>
  <li>This is a list item</li>
  <li>This is another list item</li>
  <div id="div-03">Here is div-03</div>

  <script>
    let el = document.getElementById("div-03").previousElementSibling;
    document.write("<p>Siblings of div-03</p><ol>");
    while (el) {
        document.write("<li>" + el.nodeName + "</li>");
        el = el.previousElementSibling;
    }
    document.write("</ol>");
  </script>

  // Siblings of div-03

  //    1. LI
  //    2. LI
  //    3. DIV
  //    4. DIV

#+end_src

**** nextElementSibling
Returns the element immediately following the specified one in its parent's children list, or ~null~ if the specified element is the last one in the list.

*Value*: A [[Element]] object, or ~null~.

#+begin_src javascript

  <div id="div-01">Here is div-01</div>
  <div id="div-02">Here is div-02</div>

  <script>
    let el = document.getElementById("div-01").nextElementSibling;
    console.log("Siblings of div-01:");
    while (el) {
        console.log(el.nodeName);
        el = el.nextElementSibling;
    }
  </script>

  // This example outputs the following into the console when it loads:
  // Siblings of div-01:
  // DIV
  // SCRIPT

#+end_src

**** classList
Is a read-only property that returns a live ~DOMTokenList~ collection of the ~class~ attributes of the element. This can then be used to manipulate the class list.

Using ~classList~ is a convenient alternative to accessing an element's list of classes as a space-delimited string via [[className][element.className]].

Although the ~classList~ property itself is read-only, you can modify its associated ~DOMTokenList~ using the ~add()~ , ~remove()~ , ~replace()~ , and [[toggle()]] methods.

You can test whether the element contains a given class using the ~classList.contains()~ method.

#+begin_src javascript

  const div = document.createElement("div");
  div.className = "foo";

  // our starting state: <div class="foo"></div>
  console.log(div.outerHTML);

  // use the classList API to remove and add classes
  div.classList.remove("foo");
  div.classList.add("anotherclass");

  // <div class="anotherclass"></div>
  console.log(div.outerHTML);

  // if visible is set remove it, otherwise add it
  div.classList.toggle("visible");

  // add/remove visible, depending on test conditional, i less than 10
  div.classList.toggle("visible", i < 10);

  // false
  console.log(div.classList.contains("foo"));

  // add or remove multiple classes
  div.classList.add("foo", "bar", "baz");
  div.classList.remove("foo", "bar", "baz");

  // add or remove multiple classes using spread syntax
  const cls = ["foo", "bar"];
  div.classList.add(...cls);
  div.classList.remove(...cls);

  // replace class "foo" with class "bar"
  div.classList.replace("foo", "bar");

#+end_src

**** className
Gets and sets the value of the ~class~ attribute of the specified element.

*Value* A string variable representing the class or space-separated classes of the current element.

*Note*: The name ~className~ is used for this property instead of ~class~ because of conflicts with the "class" keyword in many languages which are used to manipulate the DOM.

*Note*: The ~class~ is an HTML Attribute, while the ~className~ is a DOM Property.

#+begin_src javascript

  const el = document.getElementById("item");
  el.className = el.className === "active" ? "inactive" : "active";

#+end_src

**** remove()
Removes the element from the DOM.

*Parameters*: None.

*Return value*: None (~undefined~).

#+begin_src javascript

  <div id="div-01">Here is div-01</div>
  <div id="div-02">Here is div-02</div>
  <div id="div-03">Here is div-03</div>

  const element = document.getElementById("div-02");
  element.remove(); // Removes the div with the 'div-02' id

#+end_src

**** setAttribute()
Sets the value of an attribute on the specified element. If the attribute already exists, the value is updated; otherwise a new attribute is added with the specified name and value.

*Parameters*:
- ~name~ A string specifying the name of the attribute whose value is to be set. The attribute name is automatically converted to all lower-case when setAttribute() is called on an HTML element in an HTML document.
- ~value~ A string containing the value to assign to the attribute. Any non-string value specified is converted automatically into a string.

Boolean attributes are considered to be ~true~ if they're present on the element at all. You should set ~value~ to the empty string (~""~) or the attribute's name, with no leading or trailing whitespace.

Since the specified ~value~ gets converted into a string, specifying ~null~ doesn't necessarily do what you expect. Instead of removing the attribute or setting its value to be ~null~, it instead sets the attribute's value to the string ~"null"~. If you wish to remove an attribute, call [[removeAttribute()]].

*Return value*: None (~undefined~).

*Note*: be careful, the attributes (HTML) are not necessarily the same as the properties. (INS)

#+begin_src javascript

  // setAttribute() is used to set attributes on a <button>.
  <button>Hello World</button>

  const button = document.querySelector("button");

  button.setAttribute("name", "helloButton");
  button.setAttribute("disabled", "");
  // <button name="helloButton" disabled>Hello World</button>

#+end_src

**** getAttribute()
Returns the value of a specified attribute on the element.

If the given attribute does not exist, the value returned will either be ~null~ or ~""~ (the empty string).

*Parameters*: ~attributeName~ is the name of the attribute whose value you want to get.

*Return value*: A string containing the value of ~attributeName~.

*Note*: be careful, the attributes (HTML) are not necessarily the same as the properties. (INS)

#+begin_src javascript

  // <!-- example div in an HTML DOC -->
  <div id="div1">Hi Champ!</div>

  // in a console
  const div1 = document.getElementById("div1");
  //=> <div id="div1">Hi Champ!</div>

  const exampleAttr = div1.getAttribute("id");
  //=> "div1"

  const align = div1.getAttribute("align");
  //=> null

#+end_src

**** hasAttribute()
Returns a *Boolean* value indicating whether the specified element has the *specified attribute* or not.

#+begin_src javascript

  // Syntax
  hasAttribute(name)


  const foo = document.getElementById("foo");
  if (foo.hasAttribute("bar")) {
      // do something
  }

#+end_src

**** hasAttributes()
Returns a *boolean* value indicating whether the current element has *any attributes* or not.

#+begin_src javascript

  // Syntax
  hasAttributes(name)


  let foo = document.getElementById("foo");
  if (foo.hasAttributes()) {
      // Do something with 'foo.attributes'
  }

#+end_src

**** getAttributeNames()
Returns the attribute names of the element as an ~Array~ of strings. If the element has no attributes it returns an empty array.

Using ~getAttributeNames()~ along with [[getAttribute()]], is a memory-efficient and performant alternative to accessing ~Element.attributes~.

The names returned by ~getAttributeNames()~ are qualified attribute names, meaning that attributes with a namespace prefix have their names returned with that namespace prefix (not the actual namespace), followed by a colon, followed by the attribute name (for example, ~xlink:href~), while any attributes which have no namespace prefix have their names returned as-is (for example, ~href~).

#+begin_src javascript

  // Syntax
  getAttributeNames()


  const element = document.createElement("a");

  // set "href" attribute with no namespace and no namespace prefix
  element.setAttribute("href", "https://example.com");
  // set "href" attribute with namespace and also "xlink" namespace prefix
  element.setAttributeNS(
      "http://www.w3.org/1999/xlink",
      "xlink:href",
      "https://example.com",
  );
  // set "show" attribute with namespace but no namespace prefix
  element.setAttributeNS("http://www.w3.org/1999/xlink", "show", "new");

  // Iterate over element's attributes
  for (const name of element.getAttributeNames()) {
      const value = element.getAttribute(name);
      console.log(name, value);
  }
  // href https://example.com
  // xlink:href https://example.com
  // show new

#+end_src

**** removeAttribute()
Removes the attribute with the specified name from the element.

*Parameters*: ~attrName~ A string specifying the name of the attribute to remove from the element. If the specified attribute does not exist, ~removeAttribute()~ returns without generating an error.

*Return value*: None (~undefined~).

#+begin_src javascript

  // Given: <div id="div1" disabled width="200px">
  document.getElementById("div1").removeAttribute("disabled");
  // Now: <div id="div1" width="200px">

#+end_src

**** toggleAttribute()
Toggles a Boolean attribute (removing it if it is present and adding it if it is not present) on the given element.

*Parameters*:
- name :: A string specifying the name of the attribute to be toggled. The attribute name is automatically converted to all lower-case when ~toggleAttribute()~ is called on an HTML element in an HTML document.
- force (Optional) ::  A boolean value which has the following effects:
  - if not specified at all, the ~toggleAttribute~ method "toggles" the attribute named ~name~ ‚Äî removing it if it is present, or else adding it if it is not present
  - if true, the ~toggleAttribute~ method adds an attribute named ~name~
  - if false, the ~toggleAttribute~ method removes the attribute named ~name~

*Return value*: ~true~ if attribute ~name~ is eventually present, and ~false~ otherwise.

#+begin_src javascript

  // Syntax
  toggleAttribute(name)
  toggleAttribute(name, force)


  <input value="text" /> <button>toggleAttribute("disabled")</button>

  <script>
  const button = document.querySelector("button");
  const input = document.querySelector("input");

  button.addEventListener("click", () => {
      input.toggleAttribute("disabled");
  });
  </script>

#+end_src

**** append()
Inserts a set of [[Node]] objects or string objects after the last child of the ~Element~. String objects are inserted as equivalent ~Text~ nodes.

Differences from [[appendChild()][Node.appendChild()]]:

- Element.append() :: allows you to also append string objects, whereas ~Node.appendChild()~ only accepts ~Node~ objects.
- Element.append() :: has no return value, whereas ~Node.appendChild()~ returns the appended ~Node~ object.
- Element.append() :: can append several nodes and strings, whereas ~Node.appendChild()~ can only append one node.

*Parameters*: ~param1~, ~‚Ä¶~, ~paramN~ A set of Node or string objects to insert.

*Return value*: None (~undefined~).

#+begin_src javascript

  // Syntax
  append(param1, param2, /* ‚Ä¶, */ paramN)


  // Appending an element
  let div = document.createElement("div");
  let p = document.createElement("p");
  div.append(p);
  console.log(div.childNodes); // NodeList [ <p> ]

  // Appending text
  let div = document.createElement("div");
  div.append("Some text");
  console.log(div.textContent); // "Some text"

  // Appending an element and text
  let div = document.createElement("div");
  let p = document.createElement("p");
  div.append("Some text", p);
  console.log(div.childNodes); // NodeList [ #text "Some text", <p> ]

#+end_src

**** insertAdjacentHTML()
Parses the specified text as HTML or XML and inserts the resulting nodes into the DOM tree at a specified position.

The ~insertAdjacentHTML()~ method does not reparse the element it is being used on, and thus it does not corrupt the existing elements inside that element. This avoids the extra step of serialization, making it much faster than direct [[innerHTML]] manipulation.

*Parameters*:
- position :: A string representing the position relative to the element. Must be one of the following strings:
  - ~"beforebegin"~ Before the element. Only valid if the element is in the DOM tree and has a parent element.
  - ~"afterbegin"~ Just inside the element, before its first child.
  - ~"beforeend"~ Just inside the element, after its last child.
  - ~"afterend"~ After the element. Only valid if the element is in the DOM tree and has a parent element.
- text ::  The string to be parsed as HTML or XML and inserted into the tree

*Return value*: None (~undefined~)

#+begin_src javascript

  // Syntax
  insertAdjacentHTML(position, text)

  // We can visualize the possible positions for the inserted content:
  // beforebegin
  <p>
    // afterbegin
    foo
    // beforeend
  </p>
  // afterend


  // Example:
  <h1>The Element Object</h1>
  <h2 id="myH2">My Header</h2>

  const h2 = document.getElementById("myH2");
  let html = "<p>My new paragraph.</p>";
  h2.insertAdjacentHTML("afterend", html);
  // The Element Object
  // My Header
  // My new paragraph.

#+end_src

**** insertAdjacentElement()
Inserts a given element node at a given position relative to the element it is invoked upon.

*Parameters*:
- position :: A string representing the position relative to the ~targetElement~; must match (case-insensitively) one of the following strings:
  - ~'beforebegin'~ Before the ~targetElement~ itself
  - ~'afterbegin'~ Just inside the ~targetElement~, before its first child
  - ~'beforeend'~ Just inside the ~targetElement~, after its last child
  - ~'afterend'~ After the ~targetElement~ itself
- element ::  The element to be inserted into the tree.

*Return value*: The element that was inserted, or ~null~, if the insertion failed.

#+begin_src javascript

  // Syntax
  insertAdjacentElement(position, element)

  // Visualization of position names
  // beforebegin
  <p>
    // afterbegin
    foo
    // beforeend
  </p>
  // afterend


  // Example:
  <h1>The Element Object</h1>
    <span id="mySpan" style="color:red">My span</span>
  <h2 id="myH2">My Header</h2>

  const span = document.getElementById("mySpan");
  const h2 = document.getElementById("myH2");
  h2.insertAdjacentElement("afterend", span);
  // The Element Object
  // My Header
  // My span

#+end_src

**** getBoundingClientRect()
Returns a ~DOMRect~ object providing information about the size of an element and its position relative to the *viewport*.

*Parameters*: None.

*Return value*: The returned value is a ~DOMRect~ object which is the smallest rectangle which contains the entire element, including its padding and border-width. The ~left~, ~top~, ~right~, ~bottom~, ~x~, ~y~, ~width~, and ~height~ properties describe the position and size of the overall rectangle in pixels. Properties other than ~width~ and ~height~ are relative to the top-left of the viewport.

#+begin_src javascript

  // Return the size of an element and its position relative to the viewport:
  const rect = element.getBoundingClientRect();

#+end_src

#+begin_src artist

  +-----------------------------------------------------------+
  |(0,0)              ^                     ^                 |
  |                   |                     |                 |
  |                   | y / top             |                 |
  |                   |                     |                 |
  |                   v                     | bottom          |
  |                 +-----------------+     |                 |
  |<--------------->|                 |     |                 |
  |    x / left     |     Element     |     |                 |
  |                 |                 |     v                 |
  |                 +-----------------+------                 |
  |<--------------------------------->|                       |
  |              right                                        |
  |                                                           |
  |                                                           |
  +-----------------------------------------------------------+

#+end_src

**** attachShadow()
Attaches a shadow DOM tree to the specified element and returns a reference to its [[ShadowRoot]].

#+begin_src javascript

  // Syntax
  attachShadow(options)


  // Word count custom element
  <h1>Word count rating widget</h1>

  <article contenteditable="">
    <h2>Sample heading</h2>

    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc
      tellus. Vivamus porttitor nunc vel nibh rutrum hendrerit.</p>

    <p is="word-count"></p>
  </article>

  <script>
  // Create a class for the element
  class WordCount extends HTMLParagraphElement {
      constructor() {
          // Always call super first in constructor
          super();

          // count words in element's parent element
          const wcParent = this.parentNode;

          function countWords(node) {
              const text = node.innerText || node.textContent;
              return text
                  .trim()
                  .split(/\s+/g)
                  .filter((a) => a.trim().length > 0).length;
          }

          const count = `Words: ${countWords(wcParent)}`;

          // Create a shadow root
          const shadow = this.attachShadow({ mode: "open" });

          // Create text node and add word count to it
          const text = document.createElement("span");
          text.textContent = count;

          // Append it to the shadow root
          shadow.appendChild(text);

          // Update count when element content changes
          setInterval(() => {
              const count = `Words: ${countWords(wcParent)}`;
              text.textContent = count;
          }, 200);
      }
  }

  // Define the new element
  customElements.define("word-count", WordCount, { extends: "p" });
  </script>

#+end_src

*Disabling shadow DOM*
If the element has a static property named ~disabledFeatures~, which is an array containing the string ~"shadow"~ , then the ~attachShadow()~ call will throw an exception.

#+begin_src javascript

  class MyCustomElement extends HTMLElement {
      // Disable shadow DOM for this element.
      static disabledFeatures = ["shadow"];

      constructor() {
          super();
      }

      connectedCallback() {
          // Create a shadow root.
          // This will throw an exception.
          const shadow = this.attachShadow({ mode: "open" });
      }
  }

  // Define the new element
  customElements.define("my-custom-element", MyCustomElement);

#+end_src

*** HTMLElements
**** innerText
Represents the rendered text content of a node and its descendants.

As a getter, it approximates the text the user would get if they highlighted the contents of the element with the cursor and then copied it to the clipboard. As a setter this will replace the element's children with the given value, converting any line breaks into ~<br>~ elements.

*Note*: ~innerText~ is easily confused with [[textContent][Node.textContent]], but there are important differences between the two. Basically, ~innerText~ is aware of the rendered appearance of text, while ~textContent~ is not.

*Value*: A string representing the rendered text content of an element.

*Warning*: Setting ~innerText~ on a node removes *all* of the node's children and replaces them with a single text node with the given string value.

#+begin_src javascript

  // Compares innerText with Node.textContent. Note how innerText is
  // aware of things like <br> elements, and ignores hidden elements.
  <h3>Source element:</h3>
  <p id="source">
    <style>
      #source {
        color: red;
      }
      #text {
        text-transform: uppercase;
      }
    </style>
    <span id="text">
      Take a look at<br />
      how this text<br />
      is interpreted below.
    </span>
    <span style="display:none">HIDDEN TEXT</span>
  </p>
  <h3>Result of textContent:</h3>
  <textarea id="textContentOutput" rows="6" cols="30" readonly>‚Ä¶</textarea>
  <h3>Result of innerText:</h3>
  <textarea id="innerTextOutput" rows="6" cols="30" readonly>‚Ä¶</textarea>


  <script>
  const source = document.getElementById("source");
  const textContentOutput = document.getElementById("textContentOutput");
  const innerTextOutput = document.getElementById("innerTextOutput");

  textContentOutput.value = source.textContent;
  innerTextOutput.value = source.innerText;
  </script>
      // Source element:

  // Take a look at
  // how this text
  // is interpreted below.

  // Result of textContent:
  // +----------------------------------+
  // |  #source {                       |
  // |      color: red;                 |
  // |    }                             |
  // |    #text {                       |
  // |      text-transform: uppercase;  |
  // |    }                             |
  // |                                  |
  // |                                  |
  // |    Take a look at                |
  // |    how this text                 |
  // |    is interpreted below.         |
  // |                                  |
  // |  HIDDEN TEXT                     |
  // +----------------------------------+

  // Result of innerText:
  // +---------------------+
  // |TAKE A LOOK AT       |
  // |HOW THIS TEXT        |
  // |IS INTERPRETED BELOW.|
  // +---------------------+

#+end_src

**** style
The read-only ~style~ property of the [[HTMLElement]] returns the *inline* style of an element in the form of a live ~CSSStyleDeclaration~ object that contains a list of all styles properties for that element with values assigned only for the attributes that are defined in the element's inline ~style~ attribute.

Shorthand properties are expanded. If you set ~style="border-top: 1px solid black"~ , the longhand properties ( ~border-top-color~, ~border-top-style~, and ~border-top-width~ ) are set instead.

This property is read-only, meaning it is not possible to assign a ~CSSStyleDeclaration~ object to it. Nevertheless, it is possible to set an inline style by assigning a string directly to the ~style~ property. In this case the string is forwarded to ~CSSStyleDeclaration.cssText~. Using ~style~ in this manner will completely overwrite all inline styles on the element.

Therefore, to add specific styles to an element without altering other style values, it is generally preferable to set individual properties on the ~CSSStyleDeclaration~ object. For example, you can write ~element.style.backgroundColor = "red"~.

A style declaration is reset by setting it to ~null~ or an empty string, e.g., ~elt.style.color = null~.

*Value*: A live ~CSSStyleDeclaration~ object.

*Note*: CSS property names are converted to JavaScript identifier with these rules:
- If the property is made of one word, it remains as it is: ~height~ stays as is (in lowercase).
- If the property is made of several words, separated by dashes, the dashes are removed and it is converted to camel case: ~background-attachment~ becomes ~backgroundAttachment~.
- The property ~float~, being a reserved JavaScript keyword, is converted to ~cssFloat~.

The ~style~ property has the same priority in the CSS cascade as an inline style declaration set via the ~style~ attribute.


#+begin_src javascript

  // The Style object can be accessed from the head section of the
  // document, or from specific HTML element(s).

  // 1. Accessing a specified element's style object:
  // Get the value of a "myP"s top-border:
  <p id="myP" style="border-top: 5px solid red;"></p>
  <p id="demo"></p>

  <script>
    let value = document.getElementById("myP").style.borderTop;
    console.log(value); // 5px solid red
  </script>

  // 2. Accessing style object(s) from the head section of the document:
  <p>Click the button to display the style properties of this document.</p>
    <button onclick="myFunction()">Try it</button>
  <p id="demo"></p>

  <style>
    body {background-color: yellow; color: red;}
  </style>

  <script>
    function myFunction() {
        var x = document.getElementsByTagName("STYLE")[0];
        document.getElementById("demo").innerHTML = x.innerHTML;
    }
  </script>


  <body style="font-weight:bold">
    <div style="border-top: 1px solid blue; color:red" id="elt">
      An example div
    </div>
    <pre id="out"></pre>
  </body>

  const element = document.getElementById("elt");
  const out = document.getElementById("out");
  const elementStyle = element.style;

  // We loop through all styles (for‚Ä¶of doesn't work with CSSStyleDeclaration)
  for (const prop in elementStyle) {
      if (Object.hasOwn(elementStyle, prop)) {
          out.textContent += `${
        elementStyle[prop]
      } = '${elementStyle.getPropertyValue(elementStyle[prop])}'\n`;
      }
  }

  // An example div
  // border-top-color = 'blue'
  // border-top-style = 'solid'
  // border-top-width = '1px'
  // color = 'red'

#+end_src

**** dataset
The ~dataset~ read-only property of the [[HTMLElement]] interface provides read/write access to custom data attributes ( ~data-*~ ) on elements. It exposes a map of strings (~DOMStringMap~) with an entry for each ~data-*~ attribute.

*Note*: the ~dataset~ property itself can be read, but not directly written. Instead, all writes must be to the individual properties within the ~dataset~, which in turn represent the data attributes.

*** eventTargets
**** addEventListener()
Registers the second argument to be called whenever the event described by its first argument occurs.

*MDN*
Sets up a function that will be called whenever the specified event is delivered to the target.

Common targets are [[Element]], or its children, [[Document]], and [[Window]], but the target may be any object that supports events (such as ~IDBRequest~).

*Note*: The ~addEventListener()~ method is the recommended way to register an event listener. The benefits are as follows:
- It allows adding more than one handler for an event. This is particularly useful for libraries, JavaScript modules, or any other kind of code that needs to work well with other libraries or extensions.
- In contrast to using an ~onXYZ~ property, it gives you finer-grained control of the phase when the listener is activated (capturing vs. bubbling).
- It works on any event target, not just HTML or SVG elements.

The method ~addEventListener()~ works by adding a function, or an object that implements a ~handleEvent()~ function, to the list of event listeners for the specified event type on the [[EventTarget]] on which it's called. If the function or object is already in the list of event listeners for this target, the function or object is not added a second time.

*Note*: If a particular anonymous function is in the list of event listeners registered for a certain target, and then later in the code, an identical anonymous function is given in an ~addEventListener~ call, the second function will *also* be added to the list of event listeners for that target.

Indeed, anonymous functions are not identical even if defined using the same unchanging source-code called repeatedly, even if in a loop.

Repeatedly defining the same unnamed function in such cases can be problematic.

If an event listener is added to an [[EventTarget]] from inside another listener ‚Äî that is, during the processing of the event ‚Äî that event will not trigger the new listener. However, the new listener may be triggered during a later stage of event flow, such as during the bubbling phase.

*Parameters*:
- ~type~ A case-sensitive string representing the *event type* to listen for.
- ~listener~ The object that receives a notification (an object that implements the ~Event~ interface) when an event of the specified type occurs. This must be ~null~, an object with a ~handleEvent()~ method, or a JavaScript function.
- ~options~ (optional) An object that specifies characteristics about the event listener.

*Return value*: None (~undefined~).

#+begin_src javascript

  <p>Click this document to activate the handler.</p>

  <script>
    window.addEventListener("click", () => {
        console.log("You knocked?");
    });
  </script>


  // Add a click event to the document:
  document.addEventListener("click", myFunction);

  function myFunction() {
      document.getElementById("demo").innerHTML = "Hello World";
  }

#+end_src

**** removeEventListener()
Removes an event listener previously registered with [[addEventListener()][EventTarget.addEventListener()]] from the target. The event listener to be removed is identified using a combination of the event type, the event listener function itself, and various optional options that may affect the matching process.

Calling ~removeEventListener()~ with arguments that do not identify any currently registered event listener on the ~EventTarget~ has no effect.

If an event listener is removed from an ~EventTarget~ while another listener of the target is processing an event, it will not be triggered by the event. However, it can be reattached.

*Warning*: If a listener is registered twice, one with the *capture* flag set and one without, you must remove each one separately. Removal of a capturing listener does not affect a non-capturing version of the same listener, and vice versa.

Event listeners can also be removed by passing an ~AbortSignal~ to an ~addEventListener()~ and then later calling ~abort()~ on the controller owning the signal.

*Parameters*:
  - ~type~ A string which specifies the type of event for which to remove an event listener.
  - ~listener~ The event listener function of the event handler to remove from the event target.
  - ~options~ (Optional) An options object that specifies characteristics about the event listener. The available options are:
    - ~capture~: A boolean value that specifies whether the event listener to be removed is registered as a capturing listener or not. If this parameter is absent, the default value false is assumed.
  - ~useCapture~ (Optional) A boolean value that specifies whether the event listener to be removed is registered as a capturing listener or not. If this parameter is absent, the default value false is assumed.

*Return value*: None.

#+begin_src javascript

  <button>Act-once button</button>

  <script>
    let button = document.querySelector("button");
    function once() {
      console.log("Done.");
      button.removeEventListener("click", once);
    }
    button.addEventListener("click", once);
  </script>

#+end_src

**** dispatchEvent()
Sends an ~Event~ to the object, (synchronously) invoking the affected event listeners in the appropriate order. The normal event processing rules (including the capturing and optional bubbling phase) also apply to events dispatched manually with ~dispatchEvent()~.

Calling dispatchEvent() is the last step to firing an event. The event should have already been created and initialized using an [[Event() constructor][Event()]] constructor.

*Note*: When calling this method, the ~Event.target~ property is initialized to the current ~EventTarget~.

Unlike "native" events, which are fired by the browser and invoke event handlers asynchronously via the event loop, ~dispatchEvent()~ invokes event handlers synchronously. All applicable event handlers are called and return before ~dispatchEvent()~ returns.

*Parameter*
- event :: The ~Event~ object to dispatch. Its ~Event.target~ property will be set to the current ~EventTarget~.

*Return value* ~false~ if ~event~ is cancelable, and at least one of the event handlers which received ~event~ called ~Event.preventDefault()~. Otherwise ~true~.

#+begin_src javascript

  dispatchEvent(event)

#+end_src

*** events
**** target
Returns the element where the event occured.

Is a reference to the object onto which the event was dispatched. It is different from ~Event.currentTarget~ when the event handler is called during the bubbling or capturing phase of the event.

*Value* The associated [[EventTarget]].

#+begin_src javascript

  // Get the element where the event occurred:
  <body onclick="myFunction(event)" style="border:1px solid black">
  <button>This is a button</button>
  <p id="demo"></p>

  <script>
  function myFunction(event) {
    let text = event.target.nodeName;
    document.getElementById("demo").innerHTML = text;
  }
  </script>


  // If you have a node containing a long list of buttons, it may be more
  // convenient to register a single click handler on the outer node and
  // have it use the target property to figure out whether a button was
  // clicked, rather than register individual handlers on all of the
  // buttons.
  <button>A</button>
  <button>B</button>
  <button>C</button>

  <script>
  document.body.addEventListener("click", event => {
      if (event.target.nodeName == "BUTTON") {
          console.log("Clicked", event.target.textContent);
      }
  });
  </script>

#+end_src

**** Event() constructor
The ~Event()~ constructor creates a new ~Event~ object. An event created in this way is called a synthetic event, as opposed to an event fired by the browser, and can be dispatched by a script.

*Values*:
- type :: A string with the name of the event.
- options (Optional) :: An object with the following properties:
  - ~bubbles (Optional)~ A boolean value indicating whether the event bubbles. The default is ~false~.
  - ~cancelable (Optional)~ A boolean value indicating whether the event can be cancelled. The default is ~false~.
  - ~composed (Optional)~ A boolean value indicating whether the event will trigger listeners outside of a [[Shadow DOM][shadow root]]. The default is ~false~.

*Return value:* a new Event object.

#+begin_src javascript

  // Syntax
  new Event(type, options)


  // create a look event that bubbles up and cannot be canceled
  const evt = new Event("look", { bubbles: true, cancelable: false });
  document.dispatchEvent(evt);

  // event can be dispatched from any element, not only the document
  let myDiv = document.querySelector("div")
  myDiv.dispatchEvent(evt);

#+end_src

**** event.stopPropagation()
Prevents further propagation of the current event in the capturing and bubbling phases. It does not, however, prevent any default behaviors from occurring; for instance, clicks on links are still processed. If you want to stop those behaviors, see the ~preventDefault()~ method. It also does not prevent propagation to other event-handlers of the current element. If you want to stop those, see ~stopImmediatePropagation()~.

*Parameters*: None.

*Return value*: None.

#+begin_src javascript

  // The following example registers "mousedown" handlers on both a button
  // and the paragraph around it. When clicked with the right mouse button,
  // the handler for the button calls stopPropagation, which will prevent
  // the handler on the paragraph from running. When the button is clicked
  // with another mouse button, both handlers will run.

  <p>A paragraph with a <button>button</button>.</p>

  <script>
    let para = document.querySelector("p");
    let button = document.querySelector("button");
    para.addEventListener("mousedown", () => {
        console.log("Handler for paragraph.");
    });
    button.addEventListener("mousedown", event => {
      console.log("Handler for button.");
      if (event.button == 2) event.stopPropagation();
    });
  </script>

#+end_src

**** event.preventDefault()
Tells the user agent that if the event does not get explicitly handled, its default action should not be taken as it normally would be.

The event continues to propagate as usual, unless one of its event listeners calls [[event.stopPropagation()][stopPropagation()]] or ~stopImmediatePropagation()~, either of which terminates propagation at once.

As noted below, calling ~preventDefault()~ for a non-cancelable event, such as one dispatched via ~EventTarget.dispatchEvent()~, without specifying ~cancelable: true~ has no effect.

#+begin_src javascript

  <a href="https://developer.mozilla.org/">MDN</a>

  <script>
  let link = document.querySelector("a");
  link.addEventListener("click", event => {
    console.log("Nope.");
    event.preventDefault();
  });
  </script>

#+end_src

*** HTMLInputElements
**** name
Indicates the name of the ~<input>~ element. It reflects the element's ~name~ attribute.

*Value*: a string representing the element's name.

#+begin_src javascript

  <p>
    <label for="planet">Which planet were you born on?</label>
    <input id="planet" type="text" name="origin" />
  </p>

  <script>
    const inputElement = document.querySelector("#planet");
    // "Element's name: origin"
    console.log(`Element's name: ${inputElement.name}`);
    inputElement.name = "planet"; // updates the element's name
  </script>

#+end_src

**** value
The value property of the [[HTMLInputElement]] interface represents the *current value of the ~<input>~ element* as a string.

*Note*: this property differs from the other [[Difference in text properties][text properties]] in that the ~<input>~ tag specifies an *input field where the user can enter data*.

This property can also be set directly, for example to set a default value based on some condition.

*Value*: a string containing the value of the ~<input>~ element, or the empty string if the input element has no value set.

*Note*: the ~value~ property (for *text* and *select* fields) is commonly used to read or set the field‚Äôs content.

#+begin_src javascript

  // Displays the current value as the user enters data into the input.
  <label for="given-name">Your name:</label>
  <input name="given-name" id="given-name" />
  <pre id="log"></pre>

  <script>
    const logElement = document.getElementById("log");
    const inputElement = document.getElementById("given-name");

    inputElement.addEventListener("keyup", () => {
      logElement.innerText = `Name: ${inputElement.value}`;
    });
  </script>


  // Example:
  <label>
    <input type="radio" name="color" value="orange"> Orange
  </label>
    <label>
    <input type="radio" name="color" value="lightgreen"> Green
  </label>
    <label>
    <input type="radio" name="color" value="lightblue"> Blue
  </label>

  <script>
    let buttons = document.querySelectorAll("[name=color]");
    for (let button of Array.from(buttons)) {
        button.addEventListener("change", () => {
            document.body.style.background = button.value;
        });
    }
  </script>

#+end_src

**** checked
Specifies the current checkedness of the element; that is, whether the form control is checked or not.

The boolean ~checked~ property is relevant to the ~radio~ (~<input type="radio">~) and ~checkbox~ (~<input type="checkbox">~) input types.

The presence of the HTML ~checked~ attribute indicates the checkbox is checked by *default*. It does not indicate whether this checkbox is *currently* checked: if the checkbox's state is changed, this content attribute does not reflect the change; only the ~HTMLInputElement~'s ~checked~ IDL property is updated. The ~checked~ attribute is reflected by the ~defaultChecked~ property.

When a radio input ~checked~ property is ~true~, all other radio inputs with the same [[name]] are ~false~. If any radio button in a same-named group of radio buttons is ~required~, as long as one button in the group is ~checked~, the ~ValidityState~ object's read-only ~valueMissing~ property for each radio button in the group will be ~false~.

A checkbox's value is only included in the submitted data upon form submission if ~checked~ is true. The value of the ~HTMLInputElement.indeterminate~ property has no effect on a checkbox's ~checked~ value.
*Value*: a boolean.

 *Note*: the ~checked~ property (for *checkboxes* and radio *buttons*) is commonly used to read or set the field‚Äôs content.

#+begin_src javascript

  const inputElement = document.getElementById("contactMail");
  console.log(inputElement.checked);
  inputElement.checked = true;

#+end_src

*** CustomElementRegistrys
**** CustomElementRegistry.define()
The ~define()~ method of the ~CustomElementRegistry~ interface adds a definition for a custom element to the custom element registry, mapping its name to the constructor which will be used to create it.

*Parameters*:
- name :: Name for the new custom element.
- constructor :: Constructor for the new custom element.
- options (Optional) ::  Object that controls how the element is defined. One option is currently supported:
  - ~extends~ String specifying the name of a built-in element to extend. Used to create a customized built-in element.

*Return value*: None (~undefined~).

#+begin_src javascript

  // Syntax
  define(name, constructor)
  define(name, constructor, options)

#+end_src

There are two types of custom element you can create:

- *Autonomous custom elements* are standalone elements, that don't inherit from built-in HTML elements.
- *Customized built-in elements* are elements that inherit from, and extend, built-in HTML elements.

To define an autonomous custom element, you should omit the ~options~ parameter.

To define a customized built-in element, you must pass the ~options~ parameter with its ~extends~ property set to the name of the built-in element that you are extending, and this must correspond to the interface that your custom element class definition inherits from. For example, to customize the ~<p>~ element, you must pass ~{extends: "p"}~ to ~define()~, and the class definition for your element must inherit from ~HTMLParagraphElement~.

Defining an autonomous custom element

#+begin_src javascript

  class MyAutonomousElement extends HTMLElement {
      constructor() {
          super();
      }
  }
  // This element doesnt do anything: a real autonomous element would
  // implement its functionality in its constructor and in the lifecycle
  // callbacks provided by the standard.

  // However, the above class definition satisfies the requirements of the
  // define() method, so we can define it with the following code:
  customElements.define("my-autonomous-element", MyAutonomousElement);

  // We could then use it in an HTML page like this:
  <my-autonomous-element>Element contents</my-autonomous-element>

#+end_src

Defining a customized built-in element

#+begin_src javascript

  class MyCustomizedBuiltInElement extends HTMLParagraphElement {
      constructor() {
          super();
      }
  }
  // This element extends the built-in <p> element.

  // In this minimal example the element doesnt implement any
  // customization, so it will behave just like a normal <p>
  // element. However, it does satisfy the requirements of define():

  customElements.define(
      "my-customized-built-in-element",
      MyCustomizedBuiltInElement,
      {
          extends: "p",
      },
  );

  // We could then use it in an HTML page like this:
  <p is="my-customized-built-in-element"></p>

#+end_src

*** CSSStyleDeclarations
**** setProperty()
The ~CSSStyleDeclaration.setProperty()~ method interface sets a new value for a property on a CSS style declaration object.

#+begin_src javascript

  setProperty(propertyName, value)
  setProperty(propertyName, value, priority)

#+end_src

*** Miscellaneous
**** NodeList
~NodeList~ objects are collections of [[nodes]] , usually returned by properties such as [[childNodes][Node.childNodes]] and methods such as [[document.querySelectorAll()]].

*Note*: Although ~NodeList~ is not an ~Array~, it is possible to iterate over it with ~forEach()~. It can also be converted to a real Array using [[Array.from]].

*Note*: In some cases, the ~NodeList~ is *live*, which means that changes in the DOM automatically update the collection.

It's good to keep this distinction in mind when you choose how to iterate over the items in the ~NodeList~, and whether you should cache the list's ~length~.

#+begin_src javascript

  // For example, Node.childNodes is live:
  const parent = document.getElementById("parent");
  let childNodes = parent.childNodes;
  console.log(childNodes.length); // let's assume "2"
  parent.appendChild(document.createElement("div"));
  console.log(childNodes.length); // outputs "3"

#+end_src

**** observedAttributes()
A static property named ~observedAttributes~. This must be an array containing the names of all attributes for which the element needs change notifications.

An implementation of the ~attributeChangedCallback()~ lifecycle callback.

The ~attributeChangedCallback()~ callback is then called whenever an attribute whose name is listed in the element's ~observedAttributes~ property is added, modified, removed, or replaced.

The callback is passed three arguments:
- The name of the attribute which changed.
- The attribute's old value.
- The attribute's new value.


#+begin_src javascript

  // This autonomous element will observe a size attribute, and log the old
  // and new values when they change:
  // Create a class for the element
  class MyCustomElement extends HTMLElement {
      static observedAttributes = ["size"];

      constructor() {
          super();
      }

      attributeChangedCallback(name, oldValue, newValue) {
          console.log(
              `Attribute ${name} has changed from ${oldValue} to ${newValue}.`,
          );
      }
  }

  customElements.define("my-custom-element", MyCustomElement);

  // Note that if the element's HTML declaration includes an observed
  // attribute, then attributeChangedCallback() will be called after the
  // attribute is initialized, when the element's declaration is parsed for
  // the first time. So in the following example,
  // attributeChangedCallback() will be called when the DOM is parsed, even
  // if the attribute is never changed again
  <my-custom-element size="100"></my-custom-element>

#+end_src

**** Date.now()
The ~Date.now()~ static method returns the number of milliseconds elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC.

Also, ~Date.now()~ may have been impacted by system and user clock adjustments, clock skew, etc. as it is relative to the Unix epoch (1970-01-01T00:00:00Z) and dependent on the system clock. The [[performance.now()]] method on the other hand is relative to the [[performance.timeOrigin][timeOrigin]] property which is a monotonic clock: its current time never decreases and isn't subject to adjustments.

You can use ~Date.now()~ to get the current time in milliseconds, then subtract a previous time to find out how much time elapsed between the two calls.

#+begin_src javascript

  const start = Date.now();
  doSomeLongRunningProcess();
  console.log(`Time elapsed: ${Date.now() - start} ms`);

#+end_src

**** performance.now()
The ~performance.now()~ method returns a high resolution timestamp in milliseconds. It represents the *time elapsed since* [[performance.timeOrigin][Performance.timeOrigin]] (*the time when navigation has started in window contexts*, or the time when the worker is run in Worker and ServiceWorker contexts).

Also, [[Date.now()]] may have been impacted by system and user clock adjustments, clock skew, etc. as it is relative to the Unix epoch (1970-01-01T00:00:00Z) and dependent on the system clock. ~The performance.now()~ method on the other hand is relative to the [[performance.timeOrigin][timeOrigin]] property which is a monotonic clock: its current time never decreases and isn't subject to adjustments.

To determine how much time has elapsed since a particular point in your code, you can do something like this:

#+begin_src javascript

  const t0 = performance.now();
  doSomething();
  const t1 = performance.now();
  console.log(`Call to doSomething took ${t1 - t0} milliseconds.`);

#+end_src

**** performance.timeOrigin
The timeOrigin read-only property (*unique* to each ~document~ and persists for the lifetime of the ~document~ (INS)) of the Performance interface returns the high resolution timestamp that is used as the baseline for performance-related timestamps.

A high resolution timestamp which considered to be the beginning of the current document's lifetime.

#+begin_src

  (1970-01-01T00:00:00Z)
      -----
        |
        |
        |
        |                               document
        |                              +---------+   -----
        |                              |    ‚ñ°    |     |
        |                              |  /   \  |     |
        |                              | ‚ñ°     ‚ñ° |     |  context was
        |                      -----   +---------+   -----  created
        |                        |         timeOrigin = 1734754733655.766
        |                        |
        |                        |
        |                        |
  js  -----                    -----
  Date.now() = 1734754733721     performance.now() = 65.316447

      timeOrigin     +   performance.now()   =   Date.now()
  1734754733655.766  +       65.316447       =   1734754733721.0825

#+end_src

It's calculated like this:

- If the script's ~global object~ is a ~Window~, the time origin is determined as follows:
  - If the current ~Document~ is the first one loaded in the ~Window~, the time origin is *the time at which the browser context was created*.
  - If during the process of unloading the previous document which was loaded in the window, a confirmation dialog was displayed to let the user confirm whether or not to leave the previous page, the time origin is the time at which the user confirmed that navigating to the new page was acceptable.
   - If neither of the above determines the time origin, then the time origin is the time at which the navigation responsible for creating the window's current ~Document~ took place.

- If the script's global object is a ~WorkerGlobalScope~ (that is, the script is running as a web worker), the time origin is the moment at which the worker was created.

- In all other cases, the time origin is undefined.

**** content
The ~HTMLTemplateElement.content~ property returns a ~<template>~ element's template contents (a [[DocumentFragment]]).

*Value*: A ~DocumentFragment~.

#+begin_src javascript

  const templateElement = document.querySelector("#foo");
  const documentFragment = templateElement.content.cloneNode(true);

#+end_src

**** toggle()
The ~toggle()~ method of the ~DOMTokenList~ interface removes an existing token from the list and returns ~false~. If the token doesn't exist it's added and the function returns ~true~.

*Parameters*:
  - token :: a string representing the token you want to toggle.
  - force (Optional) :: if included, turns the toggle into a one way-only operation. If set to ~false~, then ~token~ will only be removed, but not added. If set to ~true~, then ~token~ will only be added, but not removed.

*Return value*:
A boolean value, ~true~ or ~false~, indicating whether ~token~ is in the list after the call or not.

*Note*: often use with [[classList]].

#+begin_src javascript

  // Syntax
  toggle(token)
  toggle(token, force)


  // Toggling a class on click:
  <span class="a b">classList is 'a b'</span>

  <script>
    const span = document.querySelector("span");
    const classes = span.classList;

    span.addEventListener("click", () => {
      const result = classes.toggle("c");
      span.textContent = `'c' ${
        result ? "added" : "removed"
      }; classList is now "${classes}".`;
    });
  </script>

#+end_src

**** Difference in text properties
- textContent :: *text content* of the node and its descendants. Setting ~textContent~ on a node removes *all* of the node's children and replaces them with a single text node with the given string value.
/get/: all elements, including ~<script>~ and ~<styles>~ elements
/return/: every element in the node

- innerText :: *rendered text* content of a node and its descendants
/get/: only "*human-readable*" elements
/return/: aware of styling and won't  return the text of "hidden" elements

- innerHTML :: the *HTML contained* within the element. Setting the value of ~innerHTML~ removes all of the element's descendants and replaces them with nodes constructed by parsing the HTML given in the string *htmlString*. To insert the HTML into the document rather than replace the contents of an element, use the method [[insertAdjacentHTML()]].
/get/:
/return/: HTML

- outerHTML :: serialized *HTML fragment* (*HTML contained and the element itself*) describing the element including its descendants
/get/:
/return/: string containing an HTML serialization

- value :: represents the *current value of the ~<input>~ element* (input field where the *user can enter data*) as a string. (this property differs greatly from the previous ones but is placed here because it sometimes leads to confusion)
/get/:
/return/:

#+begin_src html

    <h1>Word count rating widget</h1>

    <article contenteditable="">
      <style> p { color: red; } </style>

      <h2>Sample heading</h2>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>

      <p hidden>This paragraph is hidden.</p>

      <p is="word-count"></p>
    </article>

  <script>
  let article = document.querySelector("article");
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  console.log(article.textContent);
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        p { color: red; }

       Sample heading
       Lorem ipsum dolor sit amet, consectetur adipiscing elit.

       This paragraph is hidden.



  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  console.log(article.innerText);
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  Sample heading

  Lorem ipsum dolor sit amet, consectetur adipiscing elit.
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  console.log(article.innerHTML);
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

       <style> p { color: red; } </style>

       <h2>Sample heading</h2>
       <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>

       <p hidden="">This paragraph is hidden.</p>

       <p is="word-count"></p>

  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  console.log(article.outerHTML);
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  <article contenteditable="">
       <style> p { color: red; } </style>

       <h2>Sample heading</h2>
       <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>

       <p hidden="">This paragraph is hidden.</p>

       <p is="word-count"></p>
      </article>
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  console.log(article.value);
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  undefined
  </script>

#+end_src

** Maths
*** Math.random
Returns a floating-point, pseudo-random number that's greater than or equal to ~0~ (inclusive) and less than ~1~ (exclusive) , with approximately uniform distribution over that range ‚Äî which you can then scale to your desired range. The implementation selects the initial seed to the random number generation algorithm; it cannot be chosen or reset by the user.

*Note*: ~Math.random()~ does not provide cryptographically secure random numbers. Do not use them for anything related to security. Use the Web Crypto API instead, and more precisely the ~window.crypto.getRandomValues()~ method.

#+begin_src javascript

  console.log(Math.random());
  // ‚Üí 0.36993729369714856

  // If we want a whole random number instead of a fractional one:
  console.log(Math.floor(Math.random() * 10));  // ‚Üí 2

  // Multiplying random number by the length of an array gives us a random
  // index for the array.
  Math.floor(Math.random() * array.length)

  // 50% chance
  if (Math.random() < 0.5) {
  }

#+end_src

*Note*: it might be tempting to use ~Math.round()~, but doing so would cause your random numbers to follow a non-uniform distribution, which may not be acceptable for your needs.

*** Math.max
Returns the largest of the numbers given as input parameters, or ~-Infinity~ if there are no parameters.

#+begin_src javascript

  console.log(Math.max(1, 3, 2));  // 3
  console.log(Math.max(-1, -3, -2));  // -1

  const array1 = [1, 3, 2];
  console.log(Math.max(...array1));  // 3

#+end_src

*** Math.pow
Returns the value of a base raised to a power.

#+begin_src javascript

  console.log(Math.pow(7, 3));  // 343
  console.log(Math.pow(4, 0.5));  // 2
  console.log(Math.pow(7, -2));  // 0.02040816326530612 // (1/49)
  console.log(Math.pow(-7, 0.5));  // NaN

#+end_src

*** Math.sqrt
Returns the square root of a number. That is

‚àÄ x ‚â• 0 , ùôºùöäùöùùöë.ùöúùööùöõùöù ( ùö° ) = x = the unique  y ‚â• 0  such that  y 2 = x

#+begin_src javascript

  function calcHypotenuse(a, b) {
      return Math.sqrt(a * a + b * b);
  }

  console.log(calcHypotenuse(3, 4));
  // 5

#+end_src

*** Math.cos
Returns the cosine of a number in radians.

#+begin_src javascript

  function getCircleX(radians, radius) {
      return Math.cos(radians) * radius;
  }

  console.log(getCircleX(1, 10));
  // 5.403023058681398

#+end_src

*** Math.round
Returns the value of a number rounded to the *nearest integer*.

#+begin_src javascript

  console.log(Math.round(0.9));
  // 1

  console.log(Math.round(5.95), Math.round(5.5), Math.round(5.05));
  // 6 6 5

  console.log(Math.round(-5.05), Math.round(-5.5), Math.round(-5.95));
  // -5 -5 -6

#+end_src

*** Math.floor
Always rounds down and returns the *largest integer less than or equal* to a given number.

#+begin_src javascript

  console.log(Math.floor(5.95));  //  5
  console.log(Math.floor(5.05));  //  5
  console.log(Math.floor(5));     //  5
  console.log(Math.floor(-5.05)); // -6

  // If we want a whole random number instead of a fractional one:
  console.log(Math.floor(Math.random() * 10));  // ‚Üí 2

#+end_src

*** Math.ceil
Always rounds up and returns the *smallest integer greater than or equal* to a given number.

#+begin_src javascript

  console.log(Math.ceil(0.95));   //  1
  console.log(Math.ceil(4));      //  4
  console.log(Math.ceil(7.004));  //  8
  console.log(Math.ceil(-7.004)); // -7

#+end_src

*** Math.abs
Returns the absolute value of a number.

#+begin_src javascript

  function difference(a, b) {
      return Math.abs(a - b);
  }

  console.log(difference(3, 5));  // 2
  console.log(difference(5, 3));  // 2
  console.log(difference(1.23456, 7.89012));
  // 6.6555599999999995

#+end_src

*** Math.PI
The ~Math.PI~ static data *property* represents the ratio of the circumference of a circle to its diameter, approximately ~3.14159~.

#+begin_src javascript

  console.log(Math.PI);
  // 3.141592653589793


  function calculateCircumference(radius) {
      return 2 * Math.PI * radius;
  }

  console.log(calculateCircumference(10));
  // 62.83185307179586

#+end_src

** Classes
*** Date
JavaScript has a standard class for representing dates‚Äîor, rather, points in time. It is called ~Date~. If you simply create a date object using ~new~, you get the current date and time.

*Note*: JavaScript uses a convention where month numbers start at zero (so December is 11), yet day numbers start at one.

#+begin_src javascript

  console.log(new Date());
  // ‚Üí Mon Nov 13 2017 16:19:11 GMT+0100 (CET)


  // Create an object for a specific time:
  console.log(new Date(2009, 11, 9));
  // ‚Üí Wed Dec 09 2009 00:00:00 GMT+0100 (CET)
  console.log(new Date(2009, 11, 9, 12, 59, 59, 999));
  // ‚Üí Wed Dec 09 2009 12:59:59 GMT+0100 (CET)

#+end_src

Timestamps are stored as the number of milliseconds since the start of 1970, in the UTC time zone. This follows a convention set by ‚ÄúUnix time‚Äù, which was invented around that time. You can use negative numbers for times before 1970. The ~getTime~ method on a date object returns this number. It is big, as you can imagine.

#+begin_src javascript

  console.log(new Date(2013, 11, 19).getTime());
  // ‚Üí 1387407600000
  console.log(new Date(1387407600000));
  // ‚Üí Thu Dec 19 2013 00:00:00 GMT+0100 (CET)

#+end_src

Date objects provide methods such as ~getFullYear~, ~getMonth~, ~getDate~, ~getHours~, ~getMinutes~, and ~getSeconds~ to extract their components.

*** Map
A *map* (noun) is a data structure that associates values (the keys) with other values. For example, you might want to map names to ages. It is possible to use objects for this.

#+begin_src javascript

  let ages = {
      Boris: 39,
      Liang: 22,
      J√∫lia: 62
  };

  console.log(`J√∫lia is ${ages["J√∫lia"]}`);
  // ‚Üí J√∫lia is 62
  console.log("Is Jack's age known?", "Jack" in ages);
  // ‚Üí Is Jack's age known? false
  console.log("Is toString's age known?", "toString" in ages);
  // ‚Üí Is toString's age known? true

#+end_src

As such, using plain objects as maps is dangerous. There are several possible ways to avoid this problem. First, it is possible to create objects with no prototype. If you pass null to ~Object.create~, the resulting object will not derive from ~Object.prototype~ and can safely be used as a map.

#+begin_src javascript

  console.log("toString" in Object.create(null));
  // ‚Üí false

#+end_src

Object property names must be strings. If you need a map whose keys can‚Äôt easily be converted to strings‚Äîsuch as objects‚Äîyou cannot use an object as your map.

Fortunately, JavaScript comes with a class called ~Map~ that is written for this exact purpose. It stores a mapping and allows any type of keys.

#+begin_src javascript

  let ages = new Map();
  ages.set("Boris", 39);
  ages.set("Liang", 22);
  ages.set("J√∫lia", 62);

  console.log(`J√∫lia is ${ages.get("J√∫lia")}`);
  // ‚Üí J√∫lia is 62
  console.log("Is Jack's age known?", ages.has("Jack"));
  // ‚Üí Is Jack's age known? false
  console.log(ages.has("toString"));
  // ‚Üí false
#+end_src

The methods ~set~, ~get~, and ~has~ are part of the interface of the ~Map~ object.

If you do have a plain object that you need to treat as a map for some reason, it is useful to know that ~Object.keys~ returns only an object‚Äôs own keys, not those in the prototype. As an alternative to the ~in~ operator, you can use the ~hasOwnProperty~ method, which ignores the object‚Äôs prototype.

#+begin_src javascript

  console.log({x: 1}.hasOwnProperty("x"));
  // ‚Üí true
  console.log({x: 1}.hasOwnProperty("toString"));
  // ‚Üí false

#+end_src

** RegExps
*** RegExp.prototype.test
If you pass it a string, it will return a Boolean telling you whether the string contains a match of the pattern in the expression (*test whether a given string matches it*).

The ~test()~ method of ~RegExp~ instances executes a search with this regular expression for a match between a regular expression and a specified string. Returns ~true~ if there is a match; ~false~ otherwise.

JavaScript ~RegExp~ objects are stateful when they have the ~global~ or ~sticky~ flags set (e.g., ~/foo/g~ or ~/foo/y~). They store a [[Property lastIndex][lastIndex]] from the previous match. Using this internally, ~test()~ can be used to *iterate* over multiple matches in a string of text (with capture groups).

#+begin_src javascript

  console.log(/abc/.test("abcde"));  // ‚Üí true
  console.log(/abc/.test("abxde"));  // ‚Üí false


  const str = 'table football';
  const regex = new RegExp('foo*');
  const globalRegex = new RegExp('foo*', 'g');

  console.log(regex.test(str));  //  true

  console.log(globalRegex.lastIndex);  //  0
  console.log(globalRegex.test(str));  //  true
  console.log(globalRegex.lastIndex);  //  9
  console.log(globalRegex.test(str));  //  false

  const globalRegex2 = new RegExp('foo*?', 'g');
  console.log(globalRegex2.test(str));  //  true
  console.log(globalRegex2.lastIndex);  //  8
  console.log(globalRegex2.test(str));  //  false

#+end_src

*** RegExp.prototype.exec
**** Brief
Return ~null~ if no match was found and return an object (an array of strings containing all matched groups, whose first element is the string that was matched) with information about the match otherwise. Such an array has an ~index~ property that indicates where the match started.

Groups can be useful for extracting parts of a string. If we don‚Äôt just want to verify whether a string contains a date but also extract it and construct an object that represents it, we can wrap parentheses around the digit patterns and directly pick the date out of the result of ~exec~.

#+begin_src javascript

  // Syntax:
  // Re.exec(string) =>
  // [ match, matchGroup1, matchGroup2, index, input, groups ]

  let match = /\d+/.exec("one two 100");
  console.log(match);
  // [ '100', index: 8, input: 'one two 100', groups: undefined ]
  console.log(match.index); // ‚Üí 8
  // exec has an index property that tells us where in the string the
  // successful match begins.


  const regex1 = RegExp('foo*', 'g');
  const str1 = 'table football, foosball';
  let array1;

  while ((array1 = regex1.exec(str1)) !== null) {
      console.log(`Found ${array1[0]}. Next starts at ${regex1.lastIndex}.`);
      //  "Found foo. Next starts at 9."
      //  "Found foo. Next starts at 19."
  }


  // Putting parentheses around the parts of the expression that we are
  // interested in, we can now create a date object from a string.
  function getDate(string) {
      let [_, month, day, year] =
          /(\d{1,2})-(\d{1,2})-(\d{4})/.exec(string);
      return new Date(year, month - 1, day);
  }
  console.log(getDate("1-30-2003"));
  // ‚Üí Thu Jan 30 2003 00:00:00 GMT+0100 (CET)
  // The _ (underscore) binding is ignored and used only to skip the full
  // match element in the array returned by exec.

#+end_src

**** Subexpressions grouped with parentheses
When the regular expression contains subexpressions grouped with parentheses, the text that matched those groups will also show up in the array. The whole match is always the first element. The next element is the part matched by the first group (the one whose opening parenthesis comes first in the expression), then the second group, and so on.

#+begin_src javascript

  let quotedText = /'([^']*)'/;
  console.log(quotedText.exec("she said 'hello'"));
  // [ "'hello'", 'hello', index: 9, input: "she said 'hello'",
  //  groups: undefined ]

#+end_src

When a group does not end up being matched at all (for example, when followed by a question mark), its position in the output array will hold ~undefined~. Similarly, when a group is matched multiple times, only the last match ends up in the array.

#+begin_src javascript

  console.log(/bad(ly)?/.exec("bad"));
  // [ 'bad', undefined, index: 0, input: 'bad', groups: undefined ]
  console.log(/(\d)+/.exec("123"));
  // [ '123', '3', index: 0, input: '123', groups: undefined ]

#+end_src

**** Property lastIndex
Regular expression objects have properties. One such property is ~source~, which contains the string that expression was created from. Another property is ~lastIndex~, which controls, in some limited circumstances, *where the next match will start*.

Those circumstances are that the regular expression must have the global (~g~) or sticky (~y~) option enabled, and the match must happen through the ~exec~ method.

If the match was successful, the call to ~exec~ automatically updates the ~lastIndex~ property to point after the match. If no match was found, ~lastIndex~ is set back to zero, which is also the value it has in a newly constructed regular expression object.

#+begin_src javascript

  let pattern = /y/g;
  // console.log(match.index); 0

  pattern.lastIndex = 3;

  let match = pattern.exec("xyzzy");
  console.log(match.index);  // ‚Üí 4
  console.log(pattern.lastIndex);  // ‚Üí 5

#+end_src

**** Multiple exec calls
When using a shared regular expression value for multiple ~exec~ calls, these automatic updates to the ~lastIndex~ property can cause problems. Your regular expression might be accidentally starting at an index that was left over from a previous call.

#+begin_src javascript

  let digit = /\d/g;
  console.log(digit.exec("here it is: 1"));
  // [ '1', index: 12, input: 'here it is: 1', groups: undefined ]
  console.log(digit.exec("and now: 1"));
  // ‚Üí null

#+end_src

**** Looping over matches
A common thing to do is to scan through all occurrences of a pattern in a string, in a way that gives us access to the match object in the loop body.

#+begin_src javascript

  let input = "A string with 3 numbers in it... 42 and 88.";
  let number = /\b\d+\b/g;
  let match;
  while (match = number.exec(input)) {
      console.log("Found", match[0], "at", match.index);
  }
  // ‚Üí Found 3 at 14
  //   Found 42 at 33
  //   Found 88 at 40

#+end_src

*** String.prototype.match
Retrieves the result of matching this string against a [[Regular Expressions][regular expression]].

*Note*: when called with a global expression, instead of returning an array similar to that returned by [[RegExp.prototype.exec][exec]], ~match~ will find all matches of the pattern in the string and return an array containing the matched strings.

#+begin_src javascript

  // Syntax:
  // string.match(Re) =>
  // [ match, matchGroup1, matchGroup2, index, input, groups ]

  const paragraph = 'The quick brown fox jumps over the lazy dog. It barked.';
  const regex = /[A-Z]/;
  const regexGlobal = /[A-Z]/g;
  const found = paragraph.match(regex);
  const foundG = paragraph.match(regexGlobal);

  console.log(found);
  // [ 'T', index: 0, input: 'The quick brown ...', groups: undefined ]
  console.log(foundGlobal);
  //  Array ["T", "I"]

  console.log(regex.exec(paragraph));
  // ['T', index: 0, input: 'The quick brown ...', groups: undefined]


  console.log("Banana".match(/an/g));
  // ‚Üí ["an", "an"]
  console.log(/an/g.exec("Banana"));
  // [ 'an', index: 1, input: 'Banana', groups: undefined ]

#+end_src

*** String.prototype.search
Executes a search for a match between a [[Regular Expressions][regular expression]] and this string, returning the index of the first match in the string (like [[String.prototype.indexOf][indexOf]] but with regexp).

*Note*: unfortunately, there is no way to indicate that the match should start at a given offset (like we can with the second argument to ~indexOf~), which would often be useful.

#+begin_src javascript

  console.log("  word".search(/\S/)); // ‚Üí 2
  console.log("    ".search(/\S/));  // ‚Üí -1


  const paragraph = "I think Ruth's dog is cuter than your dog!";
  // Anything not a word character, whitespace or apostrophe
  const regex = /[^\w\s']/g;

  console.log(paragraph.search(regex));  //  41
  console.log(paragraph[paragraph.search(regex)]);  //  "!"


#+end_src

*** String.prototype.replace
**** Brief
Replace matches of a pattern with a replacement string or function.

The first argument can also be a regular expression, in which case the first match of the regular expression is replaced. When a ~g~ option (for *global*) is added to the regular expression, *all* matches in the string will be replaced, not just the first.

Returns a new string with one, some, or all matches of a ~pattern~ replaced by a replacement. The ~pattern~ can be a string or a [[Regular Expressions][RegExp]], and the ~replacement~ can be a string or a function called for each match. If ~pattern~ is a string, only the first occurrence will be replaced. The original string is left unchanged.

#+begin_src javascript

  // Syntax:
  replace(pattern, replacement)


  console.log("papa".replace("p", "m"));  // ‚Üí mapa

  console.log("borobudur".replace(/[ou]/, "A"));  // ‚Üí bArobudur
  console.log("borobudur".replace(/[ou]/g, "A")); // ‚Üí bArAbAdA


  const paragraph = "I think Ruth's dog is cuter than your dog!";
  const regex = /Dog/i;
  console.log(paragraph.replace(regex, 'ferret'));
  //  "I think Ruth's ferret is cuter than your dog!"

#+end_src

It is possible to use replace to write a function that removes all comments from a piece of JavaScript code.

#+begin_src javascript

  function stripComments(code) {
      return code.replace(/\/\/.*|\/\*[^]*?\*\//g, "");
  }

  console.log(stripComments("1 + /* 2 */3"));  // ‚Üí 1 + 3
  console.log(stripComments("x = 10;// ten!"));  // ‚Üí x = 10;
  console.log(stripComments("1 /* a */+/* b */ 1"));  // ‚Üí 1 + 1

#+end_src

**** Matching groups in the replacement string
The real power of using regular expressions with ~replace~ comes from the fact that we can refer to matched groups in the replacement string. For example, say we have a big string containing the names of people, one name per line, in the format ~Lastname, Firstname~. If we want to swap these names and remove the comma to get a ~Firstname Lastname~ format, we can use the following code:

*Note*: The ~$1~ and ~$2~ in the replacement string refer to the parenthesized groups in the pattern. *The whole match can be referred to with* ~$&~.

#+begin_src javascript

  console.log(
      "Liskov, Barbara\nMcCarthy, John\nWadler, Philip"
          .replace(/(\w+), (\w+)/g, "$2 $1"));
  // ‚Üí Barbara Liskov
  //   John McCarthy
  //   Philip Wadler

#+end_src

**** Function as second argument
It is possible to pass a function‚Äîrather than a string‚Äîas the second argument to ~replace~. For each replacement, the function will be called with the matched groups (as well as the whole match) as arguments, and its return value will be inserted into the new string.

#+begin_src javascript

  // Syntax with function:
  string.replace(regexp, function (match,
                                   firstGroupMatch,
                                   SecondGroupMatch,
                                   ...,
                                   indexMatch,
                                   string) {...})


  // Here‚Äôs a small example:
  let s = "the cia and fbi";
  console.log(s.replace(/\b(fbi|cia)\b/g,
                        str => str.toUpperCase()));
  // ‚Üí the CIA and FBI


  // Here‚Äôs a more interesting one:
  let stock = "1 lemon, 2 cabbages, and 101 eggs";
  function minusOne(match, amount, unit) {
      amount = Number(amount) - 1;
      if (amount == 1) { // only one left, remove the 's'
          unit = unit.slice(0, unit.length - 1);
      } else if (amount == 0) {
          amount = "no";
      }
      return amount + " " + unit;
  }
  console.log(stock.replace(/(\d+) (\w+)/g, minusOne));
  // ‚Üí no lemon, 1 cabbage, and 100 eggs
  // The (\d+) group ends up as the amount argument to the function, and
  // the (\w+) group gets bound to unit.

#+end_src

*** Patterns

#+begin_src javascript

  // Blank lines and lines starting with semicolons:
  /^\s*(;.*)?$/


  // A word without the letter e (or E):
  /\b[^\We]+\b/i


  // Change single quotes to double quotes:
  let example = "'I'm the cook,' he said, 'it's my job.'";
  console.log(example.replace(/(^|\W)'|'(\W|$)/g, '$1"$2'));
  // ‚Üí "I'm the cook," he said, "it's my job."


  // Match plus or minus:
  [+\-]?
  // Match plus, minus, or nothing:
  (\+|-|)

#+end_src

** Functions
*** Function.prototype.call
Calls this function with a given ~this~ value and arguments provided individually.

Pass ~this~ explicitly. Takes the ~this~ value as its first argument and treats further arguments as normal parameters.

*Note*: the difference between [[Function.prototype.bind]] method is insignificant: for the ~apply~ the second argument necessarily should be an array (or, the array-like object, for example, ~arguments~), in turn, the ~call~ method can accept any arguments; obligatory arguments for both methods is only the first ‚Äî ~this~ value.

*Note (Dmitry S√≥shnikov)*: the most usage bound functions find in attaching them as event listeners, or in postponed (~setTimeout~) functions, that still should operate on some objects as their ~this~ value.

#+begin_src javascript

  function Product(name, price) {
      this.name = name;
      this.price = price;
  }

  function Food(name, price) {
      Product.call(this, name, price);
      this.category = 'food';
  }

  console.log(new Food('cheese', 5).name);
  //  "cheese"

#+end_src

*Note*: the ~this~ value passed via a function call (including calls made using ~Function.prototype.apply~ and ~Function.prototype.call~) do [[~this~ value restrictions][not coerce]] the passed ~this~ value to an object.

*** Function.prototype.bind
**** MDN
Creates a *new function* that, when called, calls this function with its ~this~ keyword set to the provided value, and a given sequence of arguments preceding any provided when the new function is called.

The ~bind()~ function creates a new *bound* function. Calling the bound function generally results in the execution of the function it wraps, which is also called the *target* function. The bound function will store the parameters passed ‚Äî which include the value of this and the first few arguments ‚Äî as its internal state. These values are stored in advance, instead of being passed at call time. *You can generally see* ~const boundFn = fn.bind(thisArg, arg1, arg2)~ as being equivalent to ~const boundFn = (...restArgs) => fn.call(thisArg, arg1, arg2, ...restArgs)~ for the effect when it's called (but not when ~boundFn~ is constructed).

*Note*: the difference between [[Function.prototype.call]] method is insignificant: for the ~apply~ the second argument necessarily should be an array (or, the array-like object, for example, ~arguments~), in turn, the ~call~ method can accept any arguments; obligatory arguments for both methods is only the first ‚Äî ~this~ value.

*Parameters*:
- thisArg :: The value to be passed as the ~this~ parameter to the target function func when the bound function is called. If the function is not in strict mode, ~null~ and ~undefined~ will be *replaced with the global object*, and primitive values will be converted to objects. The value is ignored if the bound function is constructed using the new operator.
- arg1, ‚Ä¶, argN (Optional) :: Arguments to prepend to arguments provided to the bound function when invoking ~func~.

#+begin_src javascript

  // Syntax
  bind(thisArg, arg1, arg2, /* ‚Ä¶, */ argN)


  const module = {
      x: 42,
      getX: function () {
          return this.x;
      },
  };

  const unboundGetX = module.getX;
  console.log(unboundGetX()); // The function gets invoked at the global scope
  // undefined

  const boundGetX = unboundGetX.bind(module);
  console.log(boundGetX());
  // 42

#+end_src


*Note*: the ~this~ value passed via a function call (including calls made using ~Function.prototype.apply~ and ~Function.prototype.call~) do [[~this~ value restrictions][not coerce]] the passed ~this~ value to an object.

*Example: Creating a bound function*
The simplest use of ~bind()~ is to make a function that, no matter how it is called, is called with a particular ~this~ value.

A common mistake is to extract a method from an object, then to later call that function and expect it to use the original object as its ~this~ (e.g., by using the method in callback-based code).

Without special care, however, the original object is usually lost. Creating a bound function from the function, using the original object, neatly solves this problem:

#+begin_src javascript

  // Top-level 'this' is bound to 'globalThis' in scripts.
  this.x = 9;
  const module = {
      x: 81,
      getX() {
          return this.x;
      },
  };

  // The 'this' parameter of 'getX' is bound to 'module'.
  console.log(module.getX()); // 81

  const retrieveX = module.getX;
  // The 'this' parameter of 'retrieveX' is bound to
  // 'globalThis' in non-strict mode.
  console.log(retrieveX()); // 9

  // Create a new function 'boundGetX' with the
  // 'this' parameter bound to 'module'.
  const boundGetX = retrieveX.bind(module);
  console.log(boundGetX()); // 81

#+end_src

*Note*: If you run this example in strict mode, the ~this~ parameter of ~retrieveX~ will be bound to ~undefined~ instead of ~globalThis~, causing the ~retrieveX()~ call to fail.

If you run this example in an ECMAScript module, top-level ~this~ will be bound to ~undefined~ instead of ~globalThis~, causing the ~this.x = 9~ assignment to fail.

If you run this example in a Node CommonJS module, top-level ~this~ will be bound to ~module.exports~ instead of ~globalThis~. However, the ~this~ parameter of ~retrieveX~ will still be bound to ~globalThis~ in non-strict mode and to ~undefined~ in strict mode. Therefore, in non-strict mode (the default), the ~retrieveX()~ call will return undefined because ~this.x = 9~ is writing to a different object (module.exports) from what getX is reading from (~globalThis~).

*Note*: another simplest use of ~bind()~ is to make a function with pre-specified initial arguments.

**** Dmitry S√≥shnikov
*Bound this*
The current implementation of the ~Function.prototype.bind~ has two purposes, which are the static bound ~this~ value and the partial application of a function.

The main purpose of the ~bind~ method is to statically bind a ~this~ value for subsequent calls of a function. A ~this~ value can vary in every function call. So, the main purpose of the ~bind~ is to fix this ‚Äúissue‚Äù which can appear e.g. when we attach a method of an object as event handler of some DOM element. Using a bound function we can always have a correct this value in the event‚Äôs handling.

#+begin_src javascript

  var widget = {
      state: {...},
      onClick: function onWidgetClick(event) {
          if (this.state.active) {
              ...
          }
      }
  };

  document.getElementById("widget").onclick = widget.onClick.bind(widget);

#+end_src

I used simple click event attaching in the example above ‚Äî via ~onclick~ method, but on practice you can better use multiple listeners pattern using ~addEventListener~ or ~attachEvent~. However the goal of the example is to show how ~this~ value is predefined and bound to the ~widget~ object inside the ~onclick~ method, and ~this.state~ property is available.

*Partial application*
Another purpose of the current ‚Äúbind‚Äù implementation is a currying (or closer to mathematics ‚Äî a partial application of a function). It is the technique of transforming a function of multiple arguments to a chain of functions each with a single argument that produce at the end the same result. Which means we can generate functions based on other functions, and some (or maybe all) arguments of the new function can be predefined. And applying the new function with the rest arguments (with the last part of arguments) forms a partial application of the function.

#+begin_src javascript

  function foo(x, y) {
      // partial
      if (typeof y == "undefined") {
          return function partialFoo(y) {
              // complete
              return x + y;
          };
      }
      // complete
      return x + y;
  }

  foo(10, 20); // 30
  foo(10)(20); // 30

  var partialFoo = foo(10); // function
  partialFoo(20); // 30

#+end_src

The practical rationale of partial application can be the case when you often use a function with the same (repeating from call to call) part of arguments. In such case it is convenient to encapsulate these arguments, making a new partial function. Another good practical example can be again attaching an event listener with bound ~this~ value and some bound data which will be available at the activation of the listener‚Äôs handler. As a simplest example of such bound data can be event object itself.

Theoretically, partial application is related with some mathematical theorems and also with lambda calculus where functions have only one argument.

So, practically, using ‚Äúbind‚Äù method, we can make partial functions:

#+begin_src javascript

  function foo(x, y) {
      return x + y;
  }

  var partialFoo = foo.bind(null, 10);
  partialFoo(20) // 30

  // In this example a static bound this value is not essential for us (we
  // didn‚Äôt even use this keyword inside the function), but the currying
  // is. Of course, we can combine these two purposes of the bind method.

#+end_src

**** ManzDev
WebComponent example

#+begin_src javascript

  <button>Here!</button>

  // without bind
  class EventManager {
      constructor(element) {
          element.addEventListener("click", this.sendMessage);
      }

      sendMessage() {
          alert("Has hecho click en el bot√≥n");
          console.log(this);    // this = referencia al <button>
      }
  }

  const button = document.querySelector("button");
  const eventManager = new EventManager(button);

  // with bind
  class EventManager {
      constructor(element) {
          element.addEventListener("click", this.sendMessage.bind(this));
      }

      sendMessage() {
          alert("Has hecho click en el bot√≥n");
          console.log(this);    // this = referencia a EventManager
      }
  }

  const button = document.querySelector("button");
  const eventManager = new EventManager(button);

  // using arrow function
  class EventManager {
      constructor(element) {
          element.addEventListener("click", () => this.sendMessage());
      }

      sendMessage() {
          alert("Has hecho click en el bot√≥n");
          console.log(this);    // this = referencia a EventManager
      }
  }

  const button = document.querySelector("button");
  const eventManager = new EventManager(button);

#+end_src

*** Function.prototype.apply
*W3Schools*
With the ~apply()~ method, you can write a method that can be used *on different objects*. This method is very handy if you want to use an *array* instead of an argument list.

*MDN*
The ~apply()~ method of Function instances calls this function with a given ~this~ value, and ~arguments~ provided as an array (or an array-like object).

In general, ~fn.apply(null, args)~ is equivalent to ~fn(...args)~ with the parameter spread syntax, except args is expected to be an array-like object in the former case with ~apply()~, and an iterable object in the latter case with spread syntax.

*Note*: this function is almost identical to [[Function.prototype.call][call()]], except that the function arguments are passed to ~call()~ individually as a list, while for ~apply()~ they are combined in one object, typically an array ‚Äî for example, ~func.call(this, "eat", "bananas")~ vs. ~func.apply(this, ["eat", "bananas"]~).

#+begin_src javascript

  // Syntax:
  apply(thisArg)
  apply(thisArg, argsArray)

#+end_src

*Note*: the ~this~ value passed via a function call (including calls made using ~Function.prototype.apply~ and ~Function.prototype.call~) do [[~this~ value restrictions][not coerce]] the passed ~this~ value to an object.

Using ~apply()~ to append an array to another:

#+begin_src javascript

  const array = ["a", "b"];
  const elements = [0, 1, 2];
  array.push.apply(array, elements);
  console.info(array); // ["a", "b", 0, 1, 2]

  // The same effect can be achieved with the spread syntax.
  const array = ["a", "b"];
  const elements = [0, 1, 2];
  array.push(...elements);
  console.info(array); // ["a", "b", 0, 1, 2]

#+end_src

Clever usage of ~apply()~ allows you to use built-in functions for some tasks that would probably otherwise require manually looping over a collection (or using the spread syntax).

#+begin_src javascript

  // Since JavaScript arrays do not have a max() method,
  // you can apply the Math.max() method instead.

  // min/max number in an array
  const numbers = [5, 6, 2, 3, 7];

  // using Math.min/Math.max apply
  let max = Math.max.apply(null, numbers);
  // This about equal to Math.max(numbers[0], ‚Ä¶)
  // or Math.max(5, 6, ‚Ä¶)

  let min = Math.min.apply(null, numbers);

  // The first argument (null) does not matter. It's not used
  Math.max.apply(" ", [5, 6, 2, 3, 7]); // Will also return 7

  // vs. loop based algorithm
  max = -Infinity;
  min = +Infinity;

  for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] > max) {
      max = numbers[i];
    }
    if (numbers[i] < min) {
      min = numbers[i];
    }
  }

#+end_src

*Dmitry S√≥shnikov*
One interesting feature which is related with bound functions, is an ability to call a constructor function with various number of arguments. Thus, needed arguments are passed as an array. I.e. we get sort of ~Function.prototype.apply~ but available for the applying with ~new~ ‚Äî in using the function as a constructor. A slightly modified example from MDC:

However, we should consider that such approach is not efficient, since every time we should create a new bound function for that, so the example is mostly academical.

#+begin_src javascript

  Function.prototype.construct = function (args) {

      var
      boundArgs = [].concat.apply([null], args),
      boundFn = this.bind.apply(this, boundArgs);

      return new boundFn();

  }

  function Point(x, y) {
      this.x = x;
      this.y = y;
  }

  var point = Point.construct([2, 4]);
  console.log(point.x, point.y); // 2, 4

#+end_src

The following is a brief explanation of the ~Math.max~ and ~concat~ functions that will help explaini why their behavior is different when used with ~apply~ and/or ~bind~.

*Note*: because ~max()~ is a static method of ~Math~, you always use it as ~Math.max()~, rather than as a method of a ~Math~ object you created (~Math~ is not a constructor).

*Note*: the ~push()~ method is /generic/. It only expects the ~this~ value to have a ~length~ property and integer-keyed properties.

#+begin_src javascript

  Math.max.apply(null, [1, 2, 3])
  // Math.max(1, 2, 3)
  // 3

  [1, 2, 3].concat.apply([4, 5, 6], [7, 8, 9])
  // oldThis.concat.apply(newThis, [7, 8, 9])
  // [4, 5, 6].concat(7, 8, 9)
  // [4, 5, 6, 7, 8, 9]

  Math.max.bind.apply(Math.min, [1, 2, 3])()
  // oldThis.bind.apply(newThis, [1, 2, 3])
  // Math.min.bind(1, 2, 3)                 // this => 1
  // const boundFn = (...restArgs) => Math.min.call(this, 2, 3, ...restArgs)
  // boundFn()
  // 2

#+end_src

*** Function()
The ~Function()~ constructor creates ~Function~ objects. Calling the constructor directly can create functions dynamically, but suffers from security and similar (but far less significant) performance issues as ~eval()~. However, unlike ~eval~ (which may have access to the local scope), the ~Function~ constructor creates functions which execute in the global scope only.

~Function~ objects created with the ~Function~ constructor are parsed when the function is created. This is less efficient than creating a function with a function expression or function declaration and calling it within your code, because such functions are parsed with the rest of the code.

All arguments passed to the function, except the last, are treated as the names of the identifiers of the parameters in the function to be created, in the order in which they are passed. The function will be dynamically compiled as a function expression.

*Eloquent*: ~Function~ is a built-in JavaScript function that takes a list of arguments (as a comma-separated string) and a string containing the function body and returns a function value with those arguments and that body. This is an interesting concept‚Äî *it allows a program to create new pieces of program from string data* ‚Äîbut also a dangerous one, since if someone can trick your program into putting a string they provide into ~Function~, they can make the program do anything they want.

*Parameters*:
- ~arg1, ‚Ä¶, argN (Optional)~ Names to be used by the function as formal argument names. Each must be a string that corresponds to a valid JavaScript parameter (any of plain identifier, rest parameter, or destructured parameter, optionally with a default), or a list of such strings separated with commas.
- ~functionBody~ A string containing the JavaScript statements comprising the function definition.

#+begin_src javascript

  // Syntax:
  new Function(functionBody)
  new Function(arg1, arg2, /* ‚Ä¶, */ argN, functionBody)
  // Function() can be called with or without new.
  // Both create a new Function instance.

  const sum = new Function('a', 'b', 'return a + b');
  console.log(sum(2, 6));  // 8

#+end_src

** Operators
*** Unary operators
**** typeof
Not all operators are symbols. Some are written as words. One example is the ~typeof~ operator, which produces a string value naming the type of the value you give it.

#+begin_src javascript

  console.log(typeof 4.5) // ‚Üí number
  console.log(typeof "x") // ‚Üí string


  // The typeof operator can be unintuitive if not properly
  // understood. And one such example of that is with the value null.
  console.log(typeof null); // "object"

#+end_src

*Dmitry S√≥shnikov*
With the explicit reference to a prototype ‚Äî via the ~prototype~ property of the constructor, the work of the ~instanceof~ operator is related.

This operator works *exactly* with the prototype chain of an object but not with the constructor itself. Take this into account, since there is often misunderstanding at this place. That is, when there is a check:

#+begin_src javascript

  if (foo instanceof Foo) {
      ...
  }

#+end_src

it *does not mean* the check whether the object ~foo~ is *created* by the ~Foo~ constructor!

All the ~instanceof~ operator does is only takes the value of the ~Foo.prototype~ property and *checks its presence in the prototype chain* of ~foo~, starting from the ~foo.[[Prototype]]~.

#+begin_src javascript

  function A() {}
  A.prototype.x = 10;

  var a = new A();
  console.log(a.x); // 10

  console.log(a instanceof A); // true

  // if set A.prototype
  // to null...
  A.prototype = null;

  // ...then "a" object still
  // has access to its
  // prototype - via a.[[Prototype]]
  console.log(a.x); // 10

  // however, instanceof operator
  // can't work anymore, because
  // starts its examination from the
  //prototype property of the constructor
  console.log(a instanceof A); // error, A.prototype is not an object

#+end_src

**** minus ( - )
The minus operator can be used both as a binary operator and as a unary operator.

#+begin_src javascript

  console.log(- (10 - 2))
  // ‚Üí -8

#+end_src

**** delete
Removes a property from an object. If the property's value is an object and there are no more references to the object, the object held by that property is eventually released automatically.

#+begin_src javascript

  const Employee = {
      firstname: 'Maria',
      lastname: 'Sanchez',
  };

  console.log(Employee.firstname);  // "Maria"

  delete Employee.firstname;
  console.log(Employee.firstname);  // undefined

#+end_src

**** !
*Not* is written as an exclamation mark ( ~!~ ). It is a unary operator that flips the value given to it.

#+begin_src javascript

  console.log(!true)  // ‚Üí false
  console.log(!false) // ‚Üí true

#+end_src

*** Binary operators
**** in
The ~in~ operator returns ~true~ if the *specified property* is *in the specified object or its prototype chain*.

The binary ~in~ operator, when applied to a string and an object, tells you whether that object has a property with that name. The difference between setting a property to ~undefined~ and actually deleting it is that, in the first case, the object still has the property (it just doesn‚Äôt have a very interesting value), whereas in the second case the property is no longer present and ~in~ will return ~false~.

#+begin_src javascript

  const car = { make: 'Honda', model: 'Accord', year: 1998 };
  console.log('make' in car);  //  true

  delete car.make;
  if ('make' in car === false) {
      car.make = 'Suzuki';
  }
  console.log(car.make);  //  "Suzuki"


  let anObject = {left: 1, right: 2};
  console.log(anObject.left);  // ‚Üí 1

  delete anObject.left;
  console.log(anObject.left);  // ‚Üí undefined
  console.log("left" in anObject);  // ‚Üí false
  console.log("right" in anObject);  // ‚Üí true

#+end_src

**** instanceof
Tests to see if the ~prototype~ *property* of a constructor *appears anywhere in the prototype chain of an object*. The return value is a boolean value. Its behavior can be customized with ~Symbol.hasInstance~.

This operator can, given an object and a constructor, tell you whether that object is an instance of that constructor (show if an object was derived from a specific class).

The operator can also be applied to standard constructors like ~Array~. Almost every object is an instance of ~Object~.

#+begin_src javascript

  function Car(make, model, year) {
      this.make = make;
      this.model = model;
      this.year = year;
  }
  const auto = new Car('Honda', 'Accord', 1998);

  console.log(auto instanceof Car);  //  true
  console.log(auto instanceof Object);  //  true


  // Matrix is a class and SymmetricMatrix is an extended class.
  console.log(new SymmetricMatrix(2) instanceof SymmetricMatrix);
  // ‚Üí true
  console.log(new SymmetricMatrix(2) instanceof Matrix);
  // ‚Üí true
  console.log(new Matrix(2, 2) instanceof SymmetricMatrix);
  // ‚Üí false


  console.log([1] instanceof Array);  // ‚Üí true

#+end_src

*Dmitry S√≥shnikov*

#+begin_src javascript

  if (foo instanceof Foo) {
      ...
  }

#+end_src

it *does not mean* the check whether the object ~foo~ is *created* by the ~Foo~ constructor!

All the ~instanceof~ operator does is only takes the value of the ~Foo.prototype~ property and *checks its presence in the prototype chain* of ~foo~, starting from the ~foo.[[Prototype]]~.

** Miscellaneous
*** JSON.stringify
The ~JSON.stringify()~ static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.

#+begin_src javascript

  console.log(JSON.stringify({ x: 5, y: 6 }));
  // Expected output: '{"x":5,"y":6}'

  console.log(
      JSON.stringify([new Number(3), new String('false'), new Boolean(false)]),
  );
  // '[3,"false",false]'

  console.log(JSON.stringify({ x:[10, undefined,function () {},Symbol('')] }));
  // '{"x":[10,null,null,null]}'

  console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
  // '"2006-01-02T15:04:05.000Z"'


  // Note: == on objects or arrays, will return true only when the two are
  // the exact same value. Comparing the JSON strings is a crude but
  // effective way to compare their content.
  if (JSON.stringify(connections.get(name)) ==
      JSON.stringify(neighbors)) return;

#+end_src

*** JSON.parse
The ~JSON.parse()~ static method parses a JSON string, constructing the JavaScript value or object described by the string. An optional reviver function can be provided to perform a transformation on the resulting object before it is returned.

#+begin_src javascript

  const json = '{"result":true, "count":42}';
  const obj = JSON.parse(json);

  console.log(obj);  // {result: true, count: 42}
  console.log(obj.count);  // 42
  console.log(obj.result); // true

#+end_src

*** parseInt
~parseInt~ is for parsing (that‚Äôs why it‚Äôs named so) a number from a string. That means, this method does something *more than just a type conversion*:

#+begin_src javascript

  parseInt("08Gb", 10); // 8

#+end_src

If you need just a type conversion, an alternative way can be used, e.g. applying the ~Number~ constructor as a function ‚Äî because it exactly performs ~ToNumber~ conversion in this case. If the value of an argument is known and can be converted to number, it can be (and could in ES3) safely used without specifying any radix:

#+begin_src javascript

  Number("08"); // 8

  // alternative way
      +"08"; // 8

#+end_src

Of course, it won‚Äôt parse an argument as parseInt does:

#+begin_src javascript

  Number("08Gb"); // NaN

#+end_src

*** encodeURIComponent
Encode the URL encoding format which is used to scaped some characters in query strings.

Encodes a URI by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two surrogate characters). Compared to encodeURI(), this function encodes more characters, including those that are part of the URI syntax.

#+begin_src javascript

  console.log(encodeURIComponent("Yes?"));
  // ‚Üí Yes%3F
  console.log(decodeURIComponent("Yes%3F"));
  // ‚Üí Yes?

  // Example of request:
  GET /example/message.html?name=Jean&message=Yes%3F HTTP/1.1
  // The actual message encoded in the URL is ‚ÄúYes?‚Äù  In this case,
  // the question mark must be scaped.
  // 3F, which is 63 in decimal notation, is the code of a
  // question mark character.

#+end_src

*** readAsText
The ~readAsText()~ method of the [[FileReader]] interface is used to read the contents of the specified ~Blob~ or ~File~. When the read operation is complete, the ~readyState~ property is changed to ~DONE~, the ~loadend~ event is triggered, and the ~result~ property contains the contents of the file as a text string.

*Parameters*:
- blob :: the Blob or File from which to read.
- encoding (Optional) :: a string specifying the encoding to use for the returned data. By default, UTF-8 is assumed if this parameter is not specified.

*Return value*: none (~undefined~).

#+begin_src javascript

  // Syntax
  readAsText(blob)
  readAsText(blob, encoding)

  // Example:
  <input type="file" onchange="previewFile()" /><br />
  <p class="content"></p>

  <script>
    function previewFile() {
        const content = document.querySelector(".content");
        const [file] = document.querySelector("input[type=file]").files;
        const reader = new FileReader();

        reader.addEventListener(
            "load",
            () => {
                // this will then display a text file
                content.innerText = reader.result;
            },
            false,
        );

        if (file) {
            reader.readAsText(file);
        }
    }
  </script>

#+end_src

*** console.dir
Displays a list of the *properties* of the specified JavaScript *object*. In browser consoles, the output is presented as a hierarchical listing with disclosure triangles that let you see the contents of child objects.

#+begin_src javascript

  // Syntax:
  console.dir(object)
  console.dir(object, options)

  // In runtimes like Node and Deno, where console output goes to the
  // terminal and is therefore not interactive, the options parameter
  // provides a way to customize the way the object is presented.
  console.dir(object, { depth: null, showHidden: true, colors: false })
  // depth: null means: print all levels. Defaults to 2.

#+end_src

** Exercises
*** Write a class that produces vectors
Write a class ~Vec~ that represents a vector in two-dimensional space. It takes ~x~ and ~y~ parameters (numbers), which it should save to properties of the same name.

Give the ~Vec~ prototype methods, ~plus~, that take another vector as a parameter and return a new vector that has the sum of the two vectors‚Äô (~this~ and the parameter) x and y values.

Add a getter property ~length~ to the prototype that computes the length of the vector‚Äîthat is, the distance of the point (x, y) from the origin (0, 0).

**** Solution

#+begin_src javascript

  class Vec {
      constructor(x, y) {
          this.x = x;
          this.y = y;
      }

      plus(other) {
          return new Vec(this.x + other.x, this.y + other.y);
      }

      get length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
      }
  }

  console.log(new Vec(1, 2).plus(new Vec(2, 3)));  // ‚Üí Vec{x: 3, y: 5}
  console.log(new Vec(3, 4).length); // ‚Üí 5

#+end_src

*** Write a class that produces iterable matrix*
Let‚Äôs implement an iterable data structure. We‚Äôll build a *matrix* class, acting as a two-dimensional array.

**** Solution

#+begin_src javascript

  class Matrix {
      constructor(width, height, element = (x, y) => undefined) {
          this.width = width;
          this.height = height;
          this.content = [];

          for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                  this.content[y * width + x] = element(x, y);
              }
          }
      }

      get(x, y) {
          return this.content[y * this.width + x];
      }
      set(x, y, value) {
          this.content[y * this.width + x] = value;
      }
  }

#+end_src

When looping over a matrix, you are usually interested in the position of the elements as well as the elements themselves, so we‚Äôll have our iterator produce objects with ~x~, ~y~, and ~value~ properties.

#+begin_src javascript

  class MatrixIterator {
      constructor(matrix) {
          this.x = 0;
          this.y = 0;
          this.matrix = matrix;
      }

      next() {
          if (this.y == this.matrix.height) return {done: true};

          let value = {x: this.x,
                       y: this.y,
                       value: this.matrix.get(this.x, this.y)};
          this.x++;
          if (this.x == this.matrix.width) {
              this.x = 0;
              this.y++;
          }
          return {value, done: false};
      }
  }

#+end_src

Let‚Äôs set up the ~Matrix~ class to be iterable. We'll use after-the-fact prototype manipulation to add methods to classes so that the individual pieces of code remain small and self-contained. In a regular program, where there is no need to split the code into small pieces, you‚Äôd declare these methods directly in the class instead.

#+begin_src javascript

  Matrix.prototype[Symbol.iterator] = function() {
      return new MatrixIterator(this);
  };

#+end_src

We can now loop over a matrix with ~for/of~.

#+begin_src javascript

  let matrix = new Matrix(2, 2, (x, y) => `value ${x},${y}`);
  for (let {x, y, value} of matrix) {
      console.log(x, y, value);
  }
  // ‚Üí 0 0 value 0,0
  // ‚Üí 1 0 value 1,0
  // ‚Üí 0 1 value 0,1
  // ‚Üí 1 1 value 1,1

#+end_src

*** Create a function that counts element types
The ~countBy~ function expects a collection (anything that we can loop over with ~for/of~) and a function that computes a group name for a given element. It returns an array of objects, each of which names a group and tells you the number of elements that were found in that group.

#+begin_src javascript

  // countBy(items, groupName)
  console.log(countBy([1, 2, 3, 4, 5], n => n > 2));
  // ‚Üí [{name: false, count: 2}, {name: true, count: 3}]
  console.log(countBy([0, 1, 2, 3, 4, 5, 0], n => {
      if      (n == 0)     return "zero";
      else if (n % 2 == 0) return "even";
      else                 return  "odd";
  }));
  // [ { name: 'zero', count: 2 }, { name: 'odd', count: 3 },
  //   { name: 'even', count: 2 } ]

#+end_src

**** Solution

#+begin_src javascript

  function countBy(items, groupName) {
      let counts = [];
      for (let item of items) {
          let name = groupName(item);
          let known = counts.findIndex(c => c.name == name);
          if (known == -1) {
              counts.push({name, count: 1});
          } else {
              counts[known].count++;
          }
      }
      return counts;
  }

  console.log(countBy([1, 2, 3, 4, 5], n => n > 2));
  // ‚Üí [{name: false, count: 2}, {name: true, count: 3}]

#+end_src

*** Scans a document for text nodes
Scans a document for *text* nodes containing a given string and returns ~true~ when it has found one.

#+begin_src javascript

  console.log(talksAbout(document.body, "book")); // ‚Üí true

#+end_src

**** Solution

#+begin_src javascript

  function talksAbout(node, string) {
      if (node.nodeType == Node.ELEMENT_NODE) {
          for (let child of node.childNodes) {
              if (talksAbout(child, string)) {
                  return true;
              }
          }
          return false;
      } else if (node.nodeType == Node.TEXT_NODE) {
          return node.nodeValue.indexOf(string) > -1;
      }
  }

  console.log(talksAbout(document.body, "book")); // ‚Üí true

#+end_src

*** Write a script that replaces all images (~<img>~ tags)
Say we want to write a script that replaces all images (~<img>~ tags) in the document with the text held in their ~alt~ attributes, which specifies an alternative textual representation of the image.

#+begin_src javascript

  <p>The <img src="img/cat.png" alt="Cat"> in the
  <img src="img/hat.png" alt="Hat">.</p>

  <p><button onclick="replaceImages()">Replace</button></p>

  <script>
  function replaceImages() {
      let images = document.body.getElementsByTagName("img");
      for (let i = images.length - 1; i >= 0; i--) {
          let image = images[i];
          if (image.alt) {
              let text = document.createTextNode(image.alt);
              image.parentNode.replaceChild(text, image);
          }
      }
  }
  </script>
  // The loop that goes over the images starts at the end of the list. This
  // is necessary because the node list returned by a method like
  // getElementsByTagName (or a property like childNodes) is *live*.

#+end_src

*** Function that creates an element node and treats the rest as children*
Defines a utility ~elt~, which creates an element node and treats the rest of its arguments as children to that node. This function is then used to add an attribution to a quote.

#+begin_src javascript

  <blockquote id="quote">
    No book can ever be finished. While working on it we learn
    just enough to find it immature the moment we turn away from it.
  </blockquote>

  document.getElementById("quote").appendChild(
      elt("footer", "‚Äî",
          elt("strong", "Karl Popper"),
          ", preface to the second edition of ",
          elt("em", "The Open Society and Its Enemies"),
          ", 1950"));
  // No book can ever be finished. While working on it we learn just enough
  // to find it immature the moment we turn away from it.  ‚ÄîKarl Popper,
  // preface to the second edition of The Open Society and Its Enemies,
  // 1950

#+end_src

**** Solution

#+begin_src javascript

  <blockquote id="quote">
    No book can ever be finished. While working on it we learn
    just enough to find it immature the moment we turn away from it.
  </blockquote>

  <script>
  function elt(type, ...children) {
      let node = document.createElement(type);
      for (let child of children) {
          if (typeof child != "string") node.appendChild(child);
          else node.appendChild(document.createTextNode(child));
      }
      return node;
  }

  document.getElementById("quote").appendChild(
      elt("footer", "‚Äî",
          elt("strong", "Karl Popper"),
          ", preface to the second edition of ",
          elt("em", "The Open Society and Its Enemies"),
          ", 1950"));
  </script>

#+end_src

*** Build two codes that measures the time each one takes
A program that repeatedly alternates between reading DOM layout information and changing the DOM forces a lot of layout computations to happen and will consequently run very slowly. The following code is an example of this. It contains two different programs that build up a line of X characters 2,000 pixels wide and measures the time each one takes.

**** Solution

#+begin_src javascript

  <p><span id="one"></span></p>
  <p><span id="two"></span></p>

  <script>
    function time(name, action) {
        let start = Date.now(); // Current time in milliseconds
        action();
        console.log(name, "took", Date.now() - start, "ms");
    }

    time("naive", () => {
        let target = document.getElementById("one");
        while (target.offsetWidth < 2000) {
            target.appendChild(document.createTextNode("X"));
        }
     });
  // ‚Üí naive took 32 ms

  time("clever", function() {
      let target = document.getElementById("two");
      target.appendChild(document.createTextNode("XXXXX"));
      // calculate how many "X" we need to fill 2000 width
      let total = Math.ceil(2000 / (target.offsetWidth / 5));
      target.firstChild.nodeValue = "X".repeat(total);
  });
  // ‚Üí clever took 1 ms
  </script>

#+end_src

*** Displays a picture of a cat that moves around in an ellipse*

**** Solution

#+begin_src javascript

  <p style="text-align: center">
    <img src="img/cat.png" style="position: relative">
  </p>

   <script>
    let cat = document.querySelector("img");
    let angle = Math.PI / 2;
    function animate(time, lastTime) {
        if (lastTime != null) {
            // from the second call onwards
            angle += (time - lastTime) * 0.001;
        }
        // Note that styles usually need units.
        cat.style.top = (Math.sin(angle) * 20) + "px";
        cat.style.left = (Math.cos(angle) * 200) + "px";
        requestAnimationFrame(newTime => animate(newTime, time));
    }
    requestAnimationFrame(animate);
  </script>
  // The animation function is passed the current time as an argument. To
  // ensure that the motion of the cat per millisecond is stable, it bases
  // the speed at which the angle changes on the difference between the
  // current time and the last time the function ran. If it just moved the
  // angle by a fixed amount per step, the motion would stutter if, for
  // example, another heavy task running on the same computer were to
  // prevent the function from running for a fraction of a second.

#+end_src

*** Displays a bar and sets up event handlers for dragging
Displays a bar and sets up event handlers so that dragging to the left or right on this bar makes it narrower or wider.

**** Solution

#+begin_src javascript

  <p>Drag the bar to change its width:</p>
  <div style="background: orange; width: 60px; height: 20px">
  </div>

  <script>
    let lastX; // Tracks the last observed mouse X position
    let bar = document.querySelector("div");
    bar.addEventListener("mousedown", event => { // Note that's "mousedown"
      if (event.button == 0) { // Note the singular: "button"
        lastX = event.clientX;
        window.addEventListener("mousemove", moved); // Note that's "mousedown"
        event.preventDefault(); // Prevent selection
      }
  });

  function moved(event) {
    if (event.buttons == 0) { // Note the pulural: "buttons"
      // Note that's "mousemove"
      window.removeEventListener("mousemove", moved);
    } else {
      let dist = event.clientX - lastX;
      let newWidth = Math.max(10, bar.offsetWidth + dist);
      bar.style.width = newWidth + "px";
      lastX = event.clientX;
    }
  }
  </script>

#+end_src

*** Show red circles around every touching finger (touchscreen)

**** Solution

#+begin_src javascript

  <style>
    dot { position: absolute; display: block;
          border: 2px solid red; border-radius: 50px;
         height: 100px; width: 100px; }
  </style>
  <p>Touch this page</p>

  <script>
    function update(event) {
        for (let dot; dot = document.querySelector("dot");) {
            dot.remove();
        }
        // event.touches.length => # of fingers touching the screen
        for (let i = 0; i < event.touches.length; i++) {
            let {pageX, pageY} = event.touches[i];
            let dot = document.createElement("dot");
            dot.style.left = (pageX - 50) + "px";
            dot.style.top = (pageY - 50) + "px";
            document.body.appendChild(dot);
        }
  }
  window.addEventListener("touchstart", update);
  window.addEventListener("touchmove", update);
  window.addEventListener("touchend", update);
  </script>

#+end_src

*** Write a page showing a balloon üéà inflating/deflating
Write a page that displays a balloon (using the balloon emoji, üéà). When you press the up arrow, it should inflate (grow) 10 percent, and when you press the down arrow, it should deflate (shrink) 10 percent.

You can control the size of text (emoji are text) by setting the ~font-size~ CSS property (~style.fontSize~) on its parent element. The key names of the arrow keys are "~ArrowUp~" and "~ArrowDown~".

And add a feature where, if you blow up the balloon past a certain size, it explodes (üí• ).

**** Solution

#+begin_src javascript

  <!doctype html>

  <p>üéà</p>

  <script>
    let p = document.querySelector("p");
    let size;
    function setSize(newSize) {
        size = newSize;
        p.style.fontSize = size + "px";
    }
  setSize(20);

  function handleArrow(event) {
      if (event.key == "ArrowUp") {
          if (size > 70) {
              p.textContent = "üí•";
              document.body.removeEventListener("keydown", handleArrow);
          } else {
              setSize(size * 1.1);
              event.preventDefault();
          }
      } else if (event.key == "ArrowDown") {
          setSize(size * 0.9);
          event.preventDefault();
      }
  }
  document.body.addEventListener("keydown", handleArrow);
  </script>

#+end_src

*** Mouse trail (elements that would follow the pointer as you moved)
Implement a *mouse trail* ‚Äîa series of elements that would follow the mouse pointer as you moved it across the page.

**** Solution

#+begin_src javascript

  // Eloquent solution:
  <!doctype html>

  <style>
  .trail { /* className for the trail elements */
      position: absolute;
      height: 6px; width: 6px;
      border-radius: 3px;
      background: teal;
  }
  body {
      height: 300px;
  }
  </style>

  <body>
  <script>
  let dots = [];
  for (let i = 0; i < 12; i++) {
      let node = document.createElement("div");
      node.className = "trail";
      document.body.appendChild(node);
      dots.push(node);
  }
  let currentDot = 0;

  window.addEventListener("mousemove", event => {
      let dot = dots[currentDot];
      dot.style.left = (event.pageX - 3) + "px";
      dot.style.top = (event.pageY - 3) + "px";
      currentDot = (currentDot + 1) % dots.length;
  });
  </script>
  </body>


  // Another solution (RF):
  <style>
    div {
      position: absolute;
      background: orange;
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
  </style>


  <script>
  let maxNode = 50;
  let timer;

  window.addEventListener("mousemove", e => {

      let nodes = Array.from(document.querySelectorAll("div"));

      if (nodes.length == maxNode) {
          nodes[0].remove();
      }

      if (nodes.length < maxNode) {
          let div = document.createElement("div");
          div.style.top  = event.pageY - 5 + "px";
          div.style.left = event.pageX - 5 + "px";
          document.body.appendChild(div);
      }

      clearTimeout(timer);
      timer = setTimeout( () => {
          for(let node of document.querySelectorAll("div")) {
              node.remove();
          }
      }, 250)

  })
  </script>

#+end_src

*** React when the user has typed something (e.g. printing a console.log)*
We want to react when the user has typed something, but we don‚Äôt want to do it immediately for every input event. When they are typing quickly, we just want to wait until a pause occurs.

**** Solution

#+begin_src javascript

  <textarea>Type something here...</textarea>

  <script>
    let textarea = document.querySelector("textarea");
    let timeout;
    textarea.addEventListener("input", () => {
        clearTimeout(timeout);
        timeout = setTimeout(() => console.log("Typed!"), 500);
    });
  </script>

#+end_src

Some types of events have the potential to fire rapidly, many times in a row. When handling such events, you must be careful not to do anything too time-consuming or your handler will take up so much time that interaction with the document starts to feel slow.

If you do need to do something nontrivial in such a handler, you can use [[window.setTimeout()][setTimeout()]] to make sure you are not doing it too often.

*** Create a function that gets a date from a string
For example, input this string ~"1-30-2003"~ and return ~Thu Jan 30 2003 00:00:00 GMT+0100 (CET)~.

**** Solution

#+begin_src javascript

  function getDate(string) {
      let [_, month, day, year] =
          /(\d{1,2})-(\d{1,2})-(\d{4})/.exec(string);
      return new Date(year, month - 1, day);
  }
  console.log(getDate("1-30-2003"));
  // ‚Üí Thu Jan 30 2003 00:00:00 GMT+0100 (CET)

#+end_src

*** Transform a string
Build a function that subtracts one unit from quantities in a string. For example:
Input ~"1 lemon, 2 cabbages, and 101 eggs"~
Output ‚Üí ~"no lemon, 1 cabbage, and 100 eggs"~

**** Solution

#+begin_src javascript

  let stock = "1 lemon, 2 cabbages, and 101 eggs";
  function minusOne(match, amount, unit) {
      amount = Number(amount) - 1;
      if (amount == 1) { // only one left, remove the 's'
          unit = unit.slice(0, unit.length - 1);
      } else if (amount == 0) {
          amount = "no";
      }
      return amount + " " + unit;
  }
  console.log(stock.replace(/(\d+) (\w+)/g, minusOne));
  // ‚Üí no lemon, 1 cabbage, and 100 eggs
  // The (\d+) group ends up as the amount argument to the function, and
  // the (\w+) group gets bound to unit.

#+end_src

*** A JavaScript workbench
Build an interface that allows people to type and run pieces of JavaScript code.

Put a button next to a ~<textarea>~ field that, when pressed, uses the ~Function~ to wrap the text in a function and call it. Convert the return value of the function, or any error it raises, to a string and display it below the text field.

**** Solution
#+begin_src javascript

  <!doctype html>
  <script src="code/chapter/18_http.js"></script>

  <textarea id="code">return "hi";</textarea>
  <button id="button">Run</button>
  <pre id="output"></pre>

  <script>
    document.querySelector("#button").addEventListener("click", () => {
        let code = document.querySelector("#code").value;
        let outputNode = document.querySelector("#output");
        try {
            let result = Function(code)();
            outputNode.innerText = String(result);
        } catch (e) {
            outputNode.innerText = "Error: " + e;
        }
    });
  </script>

#+end_src

*** Note-taking application*
Implements a crude note-taking application. It keeps a set of named notes and allows the user to edit notes and create new ones.

**** Solution

#+begin_src javascript

  Notes: <select></select> <button>Add</button><br>
  <textarea style="width: 100%"></textarea>

  <script>
    let list = document.querySelector("select");
    let note = document.querySelector("textarea");

  let state;
  function setState(newState) {
      list.textContent = "";
      for (let name of Object.keys(newState.notes)) {
          let option = document.createElement("option");
          option.textContent = name;
          if (newState.selected == name) option.selected = true;
          list.appendChild(option);
      }
      note.value = newState.notes[newState.selected];

      localStorage.setItem("Notes", JSON.stringify(newState));
      state = newState;
  }
  setState(JSON.parse(localStorage.getItem("Notes")) ?? {
      notes: {"shopping list": "Carrots\nRaisins"},
      selected: "shopping list"
  });

  list.addEventListener("change", () => {
      setState({notes: state.notes, selected: list.value});
  });
  note.addEventListener("change", () => {
      setState({
          notes: Object.assign({}, state.notes,
                               {[state.selected]: note.value}),
          selected: state.selected
      });
  });
  document.querySelector("button")
      .addEventListener("click", () => {
          let name = prompt("Note name");
          if (name) setState({
              notes: Object.assign({}, state.notes, {[name]: ""}),
              selected: name
          });
      });
  // This is the same as above but using  spread syntax:
  // note.addEventListener("change", () => {
  //   let {selected} = state;
  //   setState({
  //     notes: {...state.notes, [selected]: note.value},
  //     selected
  //   });
  // });
  // document.querySelector("button")
  //   .addEventListener("click", () => {
  //     let name = prompt("Note name");
  //     if (name) setState({
  //       notes: {...state.notes, [name]: ""},
  //       selected: name
  //     });
  //   });
  </script>

#+end_src

*** Program to automatically collect information from a data file*
Imagine we are writing a program to automatically collect information about our enemies from the Internet. The configuration file looks like this:

#+begin_src sh

  searchengine=https://duckduckgo.com/?q=$1
  spitefulness=9.7

  ; comments are preceded by a semicolon...
  ; each section concerns an individual enemy
  [larry]
  fullname=Larry Doe
  type=kindergarten bully
  website=http://www.geocities.com/CapeCanaveral/11451

  [davaeorn]
  fullname=Davaeorn
  type=evil wizard
  outputdir=/home/marijn/enemies/davaeorn

#+end_src

The exact rules for this format (which is a widely used format, usually called an INI file) are as follows:

- Blank lines and lines starting with semicolons are ignored.
- Lines wrapped in [ and ] start a new section.
- Lines containing an alphanumeric identifier followed by an = character add a setting to the current section.
- Anything else is invalid.

Our task is to convert a string like this into an object whose properties hold strings for settings written before the first section header and subobjects for sections, with those subobjects holding the section‚Äôs settings.

*Note*: Some operating systems, however, use not just a newline character to separate lines but a carriage return character followed by a newline ( ~"\r\n"~ ).

#+begin_src javascript

  console.log(parseINI(`
  name=Vasilis
  [address]
  city=Tessaloniki
  [larry]
  fullname=Larry Doe
  type=kindergarten bully`));
  // {name: 'Vasilis', address: { city: 'Tessaloniki' },
  //  larry: { fullname: 'Larry Doe', type: 'kindergarten bully' }}

#+end_src

**** Tip
Put objects inside an object using a reference

**** Solution

#+begin_src javascript

  function parseINI(string) {
      // Start with an object to hold the top-level fields
      let result = {};
      let section = result; // section => current object
      string.split(/\r?\n/).forEach(line => {
          let match;
          if (match = line.match(/^(\w+)=(.*)$/)) {
              section[match[1]] = match[2];
          } else if (match = line.match(/^\[(.*)\]$/)) {
              section = result[match[1]] = {};
              // Same as:
              // result[match[1]] = {};
              // section = result[match[1]]; // reference to current object
          } else if (!/^\s*(;.*)?$/.test(line)) {
              throw new Error("Line '" + line + "' is not valid.");
          }
      });
      return result;
  }

  console.log(parseINI(`
  name=Vasilis
  [address]
  city=Tessaloniki
  [larry]
  fullname=Larry Doe
  type=kindergarten bully`));
  // {name: 'Vasilis', address: { city: 'Tessaloniki' },
  //  larry: { fullname: 'Larry Doe', type: 'kindergarten bully' }}

  // Explanatory diagram:
  // Object is created and referenced
  result = {          }
  section ------/

  // Properties are introduced using a reference
  result = { property: value }
  section ------/

  // Properties are introduced using a reference
  result = { property: value, property2: value }
  section ------/

  // Se introduce un nuevo objeto vac√≠o y se cambia la referencia a este
  result = { property: value, property2: value , {     } }
  section ------------------------------------------/

  // The process is repeated
  result = { property: value, property2: value , { property: value } }
  section ------------------------------------------/

#+end_src

*** Write a kind of prompt function*
Write a code that prompts the user for a letter for a direction (L -> left or R -> right) until it gets a valid answer, and handles well any kind of error that it may throw.

#+begin_src javascript

  promptDirection("Where?");
  // if 'left' return 'L'
  // if 'right' return 'R'
  // handle any possible errors

#+end_src

**** Solution

#+begin_src javascript

  class InputError extends Error {}

  function promptDirection(question) {
      let result = prompt(question);
      if (result.toLowerCase() == "left") return "L";
      if (result.toLowerCase() == "right") return "R";
      throw new InputError("Invalid direction: " + result);
  }

  for (;;) {
      try {
          let dir = promptDirection("Where?");
          console.log("You chose ", dir);
          break;
      } catch (e) {
          if (e instanceof InputError) {
              console.log("Not a valid direction. Try again.");
          } else {
              throw e;
          }
      }
  }

#+end_src

*** Create a toggle menu*

#+begin_src js

  // Toggle (start):            Toggle (end):
  üìÇ Candy menu      /* => */   üìÅ  Candy men
       Lollipop
       Fruit Toast
       Cup Cake

#+end_src

**** Tip
Use Shadow DOM, template, CSS (pseudoelements).

**** Solution

#+begin_src javascript
  <!doctype html>
  <template id="tmpl">
    <style>
    ul {
      margin: 0;
      list-style: none;
      padding-left: 20px;
    }

    ::slotted([slot="title"]) {
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
    }

    ::slotted([slot="title"])::before {
      content: 'üìÇ';
      font-size: 14px;
    }

    .closed ::slotted([slot="title"])::before {
      content: 'üìÅ';
    }

    .closed ul {
      display: none;
    }
    </style>

    <div class="menu">
      <slot name="title"></slot>
      <ul><slot name="item"></slot></ul>
    </div>
  </template>

  <script>
  customElements.define('custom-menu', class extends HTMLElement {
    connectedCallback() {
      this.attachShadow({mode: 'open'});
      this.shadowRoot.append( tmpl.content.cloneNode(true) );

      this.shadowRoot.querySelector('slot[name="title"]').onclick = () => {
        this.shadowRoot.querySelector('.menu').classList.toggle('closed');
      };
    }
  });
  </script>

  <custom-menu>
    <span slot="title">Candy menu</span>
    <li slot="item">Lollipop</li>
    <li slot="item">Fruit Toast</li>
    <li slot="item">Cup Cake</li>
  </custom-menu>

#+end_src

*** Write a function that loads a script asynchronously
Practical exersice to understand [[Callbacks][callbacks]] and error handling.

[[Javascript.Info (handling errors)]]

*** Create time-wasting code
Build code that waits X amount of seconds or delays the execution of the program.

**** Solution

#+begin_src javascript

  // Using 'for' loop (Bad)
  let start = Date.now();
  for(let x = 0; x < 1000; x++) {console.log("Waiting...")};
  console.log("Wasted time until", Date.now() - start);

  // Using 'Date.now' and 'while' (Better)
  let waitXMilliseconds = 50;
  let start = Date.now();
  while(Date.now() < start + waitXMilliseconds) {};
  console.log("Wasted time until", Date.now() - start);

#+end_src

*** Write a partial function that adds two numbers
It is the technique of transforming a function of multiple arguments to a chain of functions each with a single argument that produce at the end the same result. Which means we can generate functions based on other functions, and some (or maybe all) arguments of the new function can be predefined. And applying the new function with the rest arguments (with the last part of arguments) forms a partial application of the function.

Anwser -> [[Partial application]]

**** tip
Use [[Function.prototype.bind]] function.

*** Call a constructor with various number of arguments
Thus, needed arguments are passed as an array.

#+begin_src javascript

  Foo([1,2,3]) /* instead of */ Foo(1,2,3)

#+end_src

**** Tip
We get sort of ~Function.prototype.apply~ but available for the applying with ~new~ ‚Äî in using the function as a constructor.

**** Solution

#+begin_src javascript

  Function.prototype.construct = function (args) {

      var
      boundArgs = [].concat.apply([null], args),
      boundFn = this.bind.apply(this, boundArgs);

      return new boundFn();

  }

  function Point(x, y) {
      this.x = x;
      this.y = y;
  }

  var point = Point.construct([2, 4]);
  console.log(point.x, point.y); // 2, 4

#+end_src

* Data structures
** Array
The ~Array~ object, as with arrays in other programming languages, enables storing a collection of multiple items under a single variable name, and has members for performing common array operations.

In JavaScript, arrays aren't primitives but are instead ~Array~ objects with the following core characteristics:

- *JavaScript arrays are resizable and can contain a mix of different data types*. (When those characteristics are undesirable, use typed arrays instead.)
- *JavaScript arrays are not associative arrays* and so, array elements cannot be accessed using arbitrary strings as indexes, but must be accessed using nonnegative integers (or their respective string form) as indexes.
- *JavaScript arrays are zero-indexed*: the first element of an array is at index ~0~, the second is at index ~1~, and so on ‚Äî and the last element is at the value of the array's ~length~ property minus ~1~.
- *JavaScript array-copy operations create shallow copies*. (All standard built-in copy operations with any JavaScript objects create shallow copies, rather than deep copies).

*Eloquent*: JavaScript provides a data type specifically for storing sequences of values. It is called an array and is written as a list of values between square brackets, separated by commas.

Arrays, then, are just a kind of object specialized for storing sequences of things. If you evaluate ~typeof []~, it produces ~"object"~. You can see them as long, flat octopuses with all their tentacles in a neat row, labeled with numbers.

You can iterate over arrays using a special kind of [[for]] loop‚Äî ~for (let element of array)~.

#+begin_src javascript

  // Enter new elements in an array:
  const arrayEmpty = [];
  let some = 'something';
  arrayEmpty[3] = something;
  console.log(arrayEmpty);        // [ <3 empty items>, 'something' ]
  console.log(arrayEmpty.length); // 4

#+end_src

** Mutability
The types of values  numbers, strings, and Booleans, are all *immutable‚Äîit* is impossible to change values of those types. You can combine them and derive new values from them, but when you take a specific string value, that value will always remain the same. The text inside it cannot be changed. If you have a string that contains ~"cat"~ , it is not possible for other code to change a character in your string to make it spell ~"rat"~ .

Objects work differently. You can change their properties, causing a single object value to have different content at different times.

When we have two numbers, 120 and 120, we can consider them precisely the same number, whether or not they refer to the same physical bits. With objects, there is a difference between having two references to the same object and having two different objects that contain the same properties.

#+begin_src javascript

  let object1 = {value: 10};
  let object2 = object1;
  let object3 = {value: 10};

  console.log(object1 == object2); // ‚Üí true
  console.log(object1 == object3); // ‚Üí false

  object1.value = 15;
  console.log(object2.value); // ‚Üí 15
  console.log(object3.value); // ‚Üí 10

#+end_src

Bindings can also be changeable or constant, but this is separate from the way their values behave. Even though number values don‚Äôt change, you can use a ~let~ binding to keep track of a changing number by changing the value the binding points at. Similarly, though a ~const~ binding to an object can itself not be changed and will continue to point at the same object, the contents of that object might change.

#+begin_src javascript

  const score = {visitors: 0, home: 0};
  // This is okay
  score.visitors = 1;
  // This isn't allowed
  score = {visitors: 1, home: 1};

#+end_src

When you compare objects with JavaScript‚Äôs ~==~ operator, it compares by identity: it will produce ~true~ only if both objects are precisely the same value. Comparing different objects will return ~false~, even if they have identical properties.

** Rest parameters
*** Brief
When we see "~...~" in the code, it is either [[Rest parameter]] or the [[Spread syntax]].

There‚Äôs an easy way to distinguish between them:

- When ~...~ is at the *end of function parameters*, it‚Äôs ‚Äúrest parameters‚Äù and gathers the rest of the *list of arguments into an array*.
- When ~...~ occurs in a *function call or alike*, it‚Äôs called a ‚Äúspread syntax‚Äù and expands an *array into a list of arguments*.

Use patterns:

- Rest parameters are used to create functions that accept any number of arguments.
- The spread syntax is used to pass an array to functions that normally require a list of many arguments.

Together they help to travel between a list and an array of parameters with ease.

All arguments of a function call are also available in ‚Äúold-style‚Äù ~arguments~: array-like iterable object.

*** Rest parameter
To write a function that accept any number of arguments, you put three dots before the function‚Äôs last parameter, like this (*turns list of arguments into a array*):

#+begin_src javascript

  function max(...numbers) {
      let result = -Infinity;
      for (let number of numbers) {
          if (number > result) result = number;
      }
      return result;
  }
  console.log(max(4, 1, 9, -2)); // numbers [4, 1, 9, -2]
  // ‚Üí 9
  console.log(max([4, 1, 9, -2])); // numbers [[4, 1, 9, -2]]
  // ‚Üí -Infinity

#+end_src

When such a function is called, the *rest parameter* is bound to an array containing all further arguments. If there are other parameters before it, their values aren‚Äôt part of that array.

[[Spread syntax]]:
You can use a similar three-dot notation to call a function with an array of arguments (turns array into a list of arguments).

#+begin_src javascript

  let numbers = [5, 1, 7];
  console.log(max(...numbers)); // same as: max(5, 1, 7)
  // ‚Üí 7

#+end_src

This ‚Äúspreads‚Äù out the array into the function call, passing its elements as separate arguments. It is possible to include an array like that along with other arguments, as in ~max(9, ...numbers, 2)~.

Square bracket array notation similarly allows the triple-dot operator to spread another array into the new array.

#+begin_src javascript

  let words = ["never", "fully"];
  console.log(["will", ...words, "understand"]);
  // ‚Üí ["will", "never", "fully", "understand"]

#+end_src

*** Spread syntax
It's commonly used to *get the list of parameters from an array*.

*Note*: the spread syntac also work with objects.

When ~...arr~ is used in the function call, it ‚Äúexpands‚Äù an iterable object ~arr~ into the list of arguments.

*We used arrays in the spread syntax, but any iterable will do*. For instance, we can  use the spread syntax to turn the string into array of characters.

The spread syntax internally uses iterators to gather elements, the same way as [[for...of]] does.

#+begin_src javascript

  let arr = [3, 5, 1];

  Math.max(arr);    // NaN
  Math.max(...arr); // 5 (spread turns array into a list of arguments)
  // We also can pass multiple iterables this way:
  Math.max(2, ...arr, 25); // 25


  // Also, the spread syntax can be used to merge arrays:
  let arr = [3, 5, 1];
  let arr2 = [8, 9, 15];

  let merged = [0, ...arr, 2, ...arr2];
  // [ 0,3,5,1,2,8,9,15 ] // (0, then arr, then 2, then arr2)

#+end_src

Using spread syntax in objects.

*Note*: shallow-cloning (excluding ~prototype~) or merging objects is now possible using a shorter syntax than [[Object.assign]].

#+begin_src javascript

  const obj1 = { foo: "bar", x: 42 };
  const obj2 = { foo: "baz", y: 13 };

  const clonedObj = { ...obj1 };
  // { foo: "bar", x: 42 }

  const mergedObj = { ...obj1, ...obj2 };
  // { foo: "baz", x: 42, y: 13 }


  let obj = {a: 1, b: 2, c:3};
  let newObj = {...obj, d: 4, e: 5};
  console.log(newObj);
  // { a: 1, b: 2, c: 3, d: 4, e: 5 }


  let obj2 = { notes: {a: 1, b: 2, c:3},
               selected: "whatever"};
  let newObj2 = {...obj2.notes, d: 4, e: 5};
  console.log(newObj2);
  // { a: 1, b: 2, c: 3, d: 4, e: 5 }

#+end_src

Here we use the spread syntax to turn the string into array of characters:

#+begin_src javascript

  let str = "Hello";
  console.log([...str]); // [ H,e,l,l,o ]
  // So, for a string, for..of returns characters and ...str becomes
  // "H","e","l","l","o". The list of characters is passed to array
  // initializer [...str].

#+end_src

For this particular task we could also use [[Array.from]], because it converts an iterable (like a string) into an array:

#+begin_src javascript

  let str = "Hello";

  // Array.from converts an iterable into an array
  Array.from(str); // [ H,e,l,l,o ]

#+end_src

The result is the same as ~[...str]~.

But there‚Äôs a subtle difference between ~Array.from(obj)~ and ~[...obj]~:

- ~Array.from~ operates on both array-likes and iterables.
- The spread syntax works only with iterables.

So, for the task of turning something into an array, ~Array.from~ tends to be more universal.

*ManzDev*

#+begin_src javascript

  // Iterar sobre un array dependiendo del n√∫mero de array.
  let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  for c in arr;
  for i in [...Array(c).keys()];
  // Ejemplo de c = 5:
  let c = 5;
  console.log(...Array(c).keys()); // 0 1 2 3 4

#+end_src

** Destructuring
The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables.

*Note*: if the object values ‚Äã‚Äãchange, the new assigned values ‚Äã‚Äãdo not change.

#+begin_src javascript

  // Objects:
  const obj = { a: 1, b: 2 };
  const { a, b } = obj;
  console.log(a) // 1
  console.log(b) // 2
  // is equivalent to:
  // const a = obj.a;
  // const b = obj.b;

  // If the object values ‚Äã‚Äãchange, the new assigned values ‚Äã‚Äãdo not change:
  obj.a = 10;
  obj.b = 20;
  console.log(a) // 1
  console.log(b) // 2
  console.log(obj) // { a: 10, b: 20 }


  // Arrays:
  const x = [1, 2, 3, 4, 5];
  const [y, z] = x;
  console.log(y); // 1
  console.log(z); // 2


  // Examples:
  let a, b, rest;
  [a, b] = [10, 20];
  console.log(a); // 10
  console.log(b); // 20

  [a, b, ...rest] = [10, 20, 30, 40, 50];
  console.log(rest); // Array [30, 40, 50]

#+end_src

* Object-oriented programming
** Brief
JavaScript‚Äôs objects are containers that hold other data. In programming culture, /object-oriented programming/ is a *set of techniques that use objects* as the central principle of program organization. Though no one really agrees on its precise definition, object-oriented programming has shaped the design of many programming languages, including JavaScript.

The main idea in object-oriented programming is to use objects, or rather types of objects, as the unit of program organization. Setting up a program as a number of strictly separated object types provides a way to think about its structure and thus to enforce some kind of discipline, preventing everything from becoming entangled.

*Wikipedia*
Durante a√±os, los programadores se han dedicado a construir aplicaciones muy parecidas que resolv√≠an una y otra vez los mismos problemas. Para conseguir que sus esfuerzos pudiesen ser utilizados por otras personas se cre√≥ la POO que consiste en una serie de normas para garantizar la interoperabilidad entre usuarios de manera que el c√≥digo se pueda reutilizar.

Como ejemplo vamos a ver c√≥mo modernizar√≠amos en un esquema POO una fracci√≥n, es decir, esa estructura matem√°tica que tiene un numerador y un denominador que divide al numerador. La fracci√≥n ser√° el objeto y tendr√° dos propiedades, el numerador y el denominador. Luego podr√≠a tener varios m√©todos como simplificarse, sumarse con otra fracci√≥n o n√∫mero, restarse con otra fracci√≥n, etc.

** Object
*** Brief
Numbers, Booleans, and strings are the atoms that data structures are built from. Many types of information require more than one atom, though. Objects allow us to group values‚Äîincluding other objects‚Äîto build more complex structures.

The ~Object~ type represents one of JavaScript's data types. It is an unordered collection of key-value pairs, and has a single [[Prototype][prototype]] object.  It is used to store various keyed collections and more complex entities. The prototype may be either an object or the ~null~ value.

Objects in ECMAScript are created via, so-called, [[constructor][constructors]], or the object initializer / literal syntax.

The ~Object~ type (do not confuse with the ~Object~ constructor) is the only type that represents ECMAScript objects.

The keys of objects are called *properties* (properties whose names aren‚Äôt valid binding names or valid numbers have to be quoted). Properties are containers for primitive values and other objects. In case when properties contain functions as their values, they are called *methods*.

Property bindings are similar to the tentacle model of [[Bindings][bindings]]. They *grasp* values, but other bindings and properties might be holding onto those same values. You may think of *objects as octopuses with any number of tentacles, each of which has a name tattooed on it*.

The [[delete]] operator cuts off a tentacle from such an octopus. It is a unary operator that, when applied to an object property, will remove the named property from the object. This is not a common thing to do, but it is possible.

Nearly all objects in JavaScript are instances of ~Object~; a typical object inherits properties (including methods) from ~Object.prototype~, although these properties may be shadowed (a.k.a. overridden).

Changes to the ~Object.prototype~ object are seen by all objects through prototype chaining, unless the properties and methods subject to those changes are overridden further along the prototype chain. This provides a very powerful although potentially dangerous mechanism to override or extend object behavior.

*Note*: the braces have two meanings in JavaScript. At the start of a statement, they start a [[Block statement][block of statements]]. In any other position, they describe an object.

#+begin_src javascript

  // One way to create an object is by using braces as an expression.
  var x = { // object "x" with three properties: a, b, c
      a: 10, // primitive value
      b: {z: 100}, // object "b" with property z
      c: function () { // function (method)
          console.log('method x.c');
      }
  };

  console.log(x.a);   // 10
  console.log(x.b);   // {z: 100}
  console.log(x.b.z); // 100
  x.c();              // 'method x.c'
  // Reading a property that doesn‚Äôt exist will give the value undefined.

  // we have the structure with three explicit own properties and one
  // implicit __proto__ property, which is the reference to the prototype

  +----------------------+                   +-----------------+
  |           x          |      ‚îå----------->|   x  prototype  |
  +----------------------+      |            +-----------------+
  |     a     |    10    |      |            |       ...       |
  |----------------------|      |            | some properties |
  |     b     | {z: 100} |      |            |       ...       |
  |----------------------|      |            +-----------------+
  |     c     | function |      |
  |----------------------|      |
  | __proto__ |     ------------‚îò
  +----------------------+

#+end_src

Objects in ES are fully /dynamic/. It means that we may *add, modify or remove properties of objects at any time* of program execution.

Some properties cannot be modified ‚Äî read-only properties or deleted ‚Äî [[Property descriptors/attributes][non-configurable]] properties.

*Note*: ES5 standardized [[Internal properties][static]] objects which cannot be extended with new properties and none of the properties can be modified or deleted. These are so-called *frozen* objects, which can be gotten by applying [[Object.freeze]] method.

Also it‚Äôs possible just to prevent extensions using ~Object.preventExtensions(o)~ method, and to control specific attributes with ~Object.defineProperty(o)~ method.

*Note*: when you compare objects with JavaScript‚Äôs ~==~ operator, it compares by identity: it will produce ~true~ only if both objects are precisely the same value. Comparing different objects will return ~false~, even if they have identical properties.

*Note*: the difference between setting a property to ~undefined~ and actually deleting it is that, in the first case, the object still has the property (it just doesn‚Äôt have a very interesting value), whereas in the second case the property is no longer present.

*** Wraping objects
*Temporary objects wrapping*
‚ÄúEverything in JS is an object.‚Äù ‚Äî *wrong*.

The fact we are able to access the ~toString~ method directly from the ~1~ literal value, may mistakenly bring us to quick conclusions that ‚Äúeverything in JS is an object‚Äù.

JS however distinguish primitive values and objects, and the only reason why we can access methods from primitives is the *temporary objects wrapping*. In other languages the process is also known as ‚Äúauto-boxing‚Äù, i.e. a boxed (heap-allocated) value of some class is created, and can now provide access to the methods of this class.

#+begin_src javascript

  1..toString(); // "1"

  // Same as:
  const __temp = new Number(1);
  __temp.toString(); // "1"

  // later __temp is destroyed by GC

#+end_src

*Special wapper objects*
For some primitives the specification defines special *wrapper objects*. These are following objects:

- Boolean-object
- String-object
- Number-object

Such objects are created with corresponding built in constructors and contain primitive value ~[[PrimitiveValue]]~ as one of /internal properties/. Object representation can be converted into primitive values and vice-versa.

Besides, there are also objects created by special built in constructors: ~Function~ (function objects constructor) ~Array~ (arrays constructor), ~RegExp~ (regular expressions constructor), ~Math~ (the mathematical module), ~Date~ (the constructor of dates), etc. Such objects are also values of type ~Object~ and their distinction from each other is managed by internal properties.

#+begin_src javascript

  var c = new Boolean(true);
  var d = new String('test');
  var e = new Number(10);

  console.log(c, d, e);
  // [Boolean: true]  [String: 'test']  [Number: 10]

  // conversion: ToPrimitive
  c = Boolean(c);
  d = String(d);
  e = Number(e);

  console.log(c, d, e);
  // true  test  10

  // conversion: ToObject  (back to Object)
  c = Object(c);
  d = Object(d);
  e = Object(e);

  console.log(c, d, e);
  // [Boolean: true]  [String: 'test']  [Number: 10]

#+end_src

*** Properties
**** Brief
A JavaScript property is a member of an object that associates a key with a value.

A property consists of the following parts:

-  A *name* (also called a key), which is either a [[Strings][string]] or a [[Symbols][symbol]].
-  A *value*, which can be any JavaScript value. A property that has a function as its value may also be called a method.
-  Some [[Property descriptors/attributes][attributes]], which specify how the property can be read and written. A property may have the ~configurable~, ~enumerable~, and ~writable~ attributes.

[[Named accessor property][Accessor properties]] do not have an actual "value". The value is represented indirectly through a pair of functions, one (the getter) invoked when reading the value and one (the setter) invoked when setting the value. However, accessor properties behave like regular data properties on the surface, because the getter and setter functions are invoked automatically and are typically transparent to JavaScript code.

The two main ways to access properties in JavaScript are with a [[Property access: dot and square brackets][dot and with square brackets]]. Both ~value.x~ and ~value[x]~ access a property on ~value~ ‚Äî *but not necessarily the same property*. The difference is in how ~x~ is interpreted. When using a dot, the word after the dot is the literal name of the property. When using square brackets, *the expression between the brackets is evaluated to get the property name*. Whereas ~value.x~ fetches the property of ~value~ named ‚Äúx‚Äù, ~value[x]~ tries to evaluate the expression ~x~ and uses the result, converted to a string, as the property name.

So if you know that the property you are interested in is called color, you say ~value.color~. If you want to extract the property named *by the value held in the binding* ~i~, you say ~value[i]~. Property names are strings. They can be any string, but the dot notation works only with names that look like valid binding names. So if you want to access a property named ~2~ or ~John Doe~, you must use square brackets: ~value[2]~ or ~value["John Doe"]~.

Almost all JavaScript values have properties. The exceptions are ~null~ and ~undefined~. If you try to access a property on one of these nonvalues, you get an error.

#+begin_src javascript

  null.length;
  // ‚Üí TypeError: null has no properties

#+end_src

The property's value (including the getter and setter) and its attributes are stored in a data record called the [[Properties and property descriptors/attributes][property descriptor]]. Many methods, such as ~Object.getOwnPropertyDescriptor()~ and ~Object.defineProperty()~, work with property descriptors.

**** Property syntax
Object property syntax:

#+begin_src javascript

  const a = "foo";
  const b = 42;
  const c = {};

  const o = {
      a: a,
      b: b,
      c: c,
  };

  // Shorthand property names
  const o = { a, b, c };

  // In other words,
  console.log(o.a === { a }.a); // true

#+end_src

A property of an object can also refer to a function or a [[Named accessor property][getter or setter]] method.

Methods are nothing more than properties that hold function values.

Usually a method needs to do something with the object it was called on. When a function is called as a method‚Äîlooked up as a property and immediately called, as in ~object.method()~ ‚Äîthe binding called ~this~ in its body automatically points at the object that it was called on.

#+begin_src javascript

  const o = {
    property: function (parameters) {},
    get property() {},
    set property(value) {},
  };

  // Shorthand notation: the keyword function is no longer necessary.
  const o = {
    property(parameters) {},
  };

#+end_src

**** Prototype setter
A property definition of the form ~__proto__: value~ or ~"__proto__": value~ does not create a property with the name ~__proto__~. Instead, if the provided value is an object or ~null~, it points the ~[[Prototype]]~ of the created object to that value. (If the value is not an object or ~null~, the object is not changed.)

#+begin_src javascript

  const obj1 = {};
  console.log(Object.getPrototypeOf(obj1) === Object.prototype); // true

  const obj2 = { __proto__: null };
  console.log(Object.getPrototypeOf(obj2)); // null

  const protoObj = {};
  const obj3 = { "__proto__": protoObj };
  console.log(Object.getPrototypeOf(obj3) === protoObj); // true

  const obj4 = { __proto__: "not an object or null" };
  console.log(Object.getPrototypeOf(obj4) === Object.prototype); // true
  console.log(Object.hasOwn(obj4, "__proto__")); // false


  // Property definitions that do not use "colon" notation are not
  // prototype setters. They are property definitions that behave
  // identically to similar definitions using any other name.
  const __proto__ = "variable";

  const obj1 = { __proto__ };
  console.log(Object.getPrototypeOf(obj1) === Object.prototype); // true
  console.log(Object.hasOwn(obj1, "__proto__")); // true
  console.log(obj1.__proto__); // "variable"

#+end_src

*** Property access: dot and square brackets
JavaScript has dot ~.~ and square bracket ~[]~ property access. The former is used when the property or method name is a valid identifier and is known before runtime. The later allows forming names of properties *dynamically*. It can be used for /array access/, when the property name is /not a valid identifier/, when a property is a /symbol/, or when it‚Äôs /dynamic/:

#+begin_src javascript

  var a = {testProperty: 10};

  console.log(a.testProperty);    // 10, dot notation
  console.log(a[testProperty]);   // Error: testProperty is not defined
  console.log(a['testProperty']); // 10, bracket notation

  var propertyName = 'Property';
  console.log(a['test' + propertyName]); // bracket with dynamic property


  const data = [1, 2, 3];

  data.0;      // error, not a valid identifier
  data[0];     // 1
  data['0'];   // 1

  const k = 0;
  data.k;      // undefined, "k" name doesn't exist
  data[k];     // 1, OK dynamic access

#+end_src

*There is one important feature* ‚Äî property accessor always calls ~ToObject~ conversion for the object standing on left hand side from the property accessor. And because of this implicit conversion it is possible roughly speaking to say that ‚Äúeverything in JavaScript is an object‚Äù (of course not everything since there are also [[Primitive values][primitive things]]).

The dot and the square bracket notation, are just property access and resolve to the same ~toString~ method in our initial example ‚Äî just inside the square brackets can be *any expression* (variables, strings, function calls), which evaluate to a property name.

If we use property accessor with a *primitive value*, we just create *intermediate wrapper object* with corresponding value. After the work is finished, this wrapper is *removed*.

#+begin_src javascript

  1[(() => 'toString')()]();  // "1"
  // equivalent as
  (1).toString()              // "1"

  // An arrow function is created, immediately invoked, returning
  // the 'toString' value as the property name.


  // obj[] same accessor mechanism as arr[] (RF)
  const obj = { 1:'one', 2:'two', 3:'three'};
  const arr = ['one', 'two', 'three'];

  // Evaluate the expression, convert it to a string,
  // and now look for the identifier (RF)
  obj[(4 - 2).toString()];               // two
  arr[(function () { return 4 * 0})()];  // one

#+end_src

*** Properties and property descriptors/attributes
**** Brief
Usually saying that ‚Äúan object has some property‚Äù we mean an association between a /property name/ and its /value/. But as we know from the ES3 analysis, a property *structure is more complex* than just a /string name/. It also has set of attributes, e.g. ~[[Writable]]~, ~[[Enumerable]]~ and other. So from this viewpoint *a property is as an object itself*.

A property can be either own, i.e. contained directly by an object, or inherited, i.e. contained by one of the objects in the prototype chain.

There are [[Property kinds][named]] properties, which available for ECMAScript program, and [[Internal properties][internal]] properties, which available directly only on implementation level (however, it is possible to manage some of them in ECMAScript program via special methods).

Related with corresponding named property type, a descriptor can be either a [[Named data property][data property]] descriptor or an [[Named accessor property][accessor property]] descriptor.

Thus, because of specified /default values/ for the attributes, if corresponding descriptor is /empty/, a *data property* is created. Obviously, a data property is also created if descriptor object contains either ~writable~ or ~value~ properties. In case if a descriptor object has either a ~get~ or a ~set~ property, accordingly an *accessor property* is defined. For getting the descriptor object of a property there is meta-method [[Object.getOwnPropertyDescriptor]]:

#+begin_src javascript

  // define several properties at once
  Object.defineProperties(foo, {
    bar: {}, // "empty" descriptor,
    baz: {get: function () {}}
  });

  var barProperty = Object.getOwnPropertyDescriptor(foo, "bar");
  var hasOwn = Object.prototype.hasOwnProperty;

  console.log(
    barProperty.value, // undefined
    hasOwn.call(barProperty, "value"), // true

    barProperty.get, // undefined
    hasOwn.call(barProperty, "get"), // false

    barProperty.set, // undefined
    hasOwn.call(barProperty, "set"), // false
  );

  console.log(foo.bar); // undefined (correct), in Rhino 1.73 - null
  console.log(foo.nonExisting); // undefined and in Rhino too

  // in contrast "baz" property is an accessor property

  var bazProperty = Object.getOwnPropertyDescriptor(foo, "baz");

  console.log(
    bazProperty.value, // undefined
    hasOwn.call(bazProperty, "value"), // false

    bazProperty.get, // function
    hasOwn.call(bazProperty, "get"), // true

    bazProperty.set, // undefined
    hasOwn.call(bazProperty, "set"), // false
  );

#+end_src

And ~Property Identifier~ type is used to associate a property /name/ with its descriptor. So, /properties/ being values of the ~Property Identifier~ type are pairs of the form ~(name, descriptor)~:

#+begin_src javascript

  // Abstractly:
  foo.bar = 10;

  // property is an object of the Property Identifier type
  var barProperty = {
    name: "bar",
    descriptor: {
      value: 10,
      writable: true,
      enumerable: true,
      configurable: true
    }
  };

#+end_src

**** Property kinds
***** Named data property
/Data property/ has a name (which is always a string) and a direct associated with it value.

In case if the value of a property is a function, such property is called a method. But this direct function values should not be confused with indirect special accessor-functions.

#+begin_src javascript

  // define in the declarative form
  var foo = {
      bar: 10 // direct Number type value
  };

  // define in the imperative form,
  // also direct, but Function type value, a "method"
  foo.baz = function () {
      return this.bar;
  };

#+end_src

A simple assignment operator now corresponds to the reversed default state of all attributes.

#+begin_src javascript

  // simple assignment (if we create a new property)
  foo.bar = 10;

  // the same as
  Object.defineProperty(foo, "bar", {
      value: 10,
      writable: true,
      enumerable: true,
      configurable: true
  });

#+end_src

***** Named accessor property
A /named accessor property/ associates a name (also ‚Äî only a string) with one or two accessor functions: a [[Getters, setters, and statics][getter and a setter]].

The accessor functions *are used to store or retrieve a value* that is associated with the property name *indirectly*.

Using setters and getters mostly makes more sense only when we need to *encapsulate some complex calculations using auxiliary helper data*, and making usage of this property convenient ‚Äî i.e. just as it would be a simple data property. For non-abstract things, using accessors may not be that useful.

In an example with the ~element.innerHTML~ property shown elsewhere ‚Äî  where we abstractly say that ‚Äúnow html of this element is the following‚Äù, while inside the setter function for the ~innerHTML~ property there are difficult calculations and checks which cause then rebuilding of the DOM tree and updating the user interface.

The cases which /really deserve/ using accessors usually are related with /increasing of an abstraction/, encapsulating auxiliary helper data. The simplest example:

#+begin_src javascript

  var foo = {};

  // encapsulated context
  (function () {

    // some internal state
    var data = [];

    Object.defineProperty(foo, "bar", {

      get: function getBar() {
        return "We have " + data.length + " bars: " + data;
      },

      set: function setBar(value) {

        // call getter first
        console.log('Alert from "bar" setter: ' + this.bar);

        data = Array(value).join("bar-").concat("bar").split("-");

        // of course if needed we can update
        // also some public property
        this.baz = 'updated from "bar" setter: ' + value;

      },

      configurable: true,
      enumerable: true

    });

  })();

  foo.baz = 100;
  console.log(foo.baz); // 100

  // first getter will be called inside the setter:
  // We have 0 bars:
  foo.bar = 3;

  // getting
  console.log(foo.bar); // We have 3 bars: bar, bar, bar
  console.log(foo.baz); // updated from "bar" setter: 3

  // Of course, this example isn‚Äôt so practical, but it
  // shows the main purpose of accessors

#+end_src

**** Property descriptors/attributes
***** Named property (data and accessor)
/Named/ properties are distinct by a set of /attributes/. Thus, common for *both* (data and accessor) named property types in ECMA-262-5 are two attributes:

- ~[[Enumerable]]~ :: attribute determines in ~true~ state that a property is *enumerated* by a ~for-in~ enumeration.

- ~[[Configurable]]~ :: attribute (in ES3 ‚Äî reversed state of ~{DontDelete}~) in ~false~ state prevents attempts to *delete* the property, *change* the property to be an accessor property, or change its attributes (other than ~[[Value]]~).

Notice, if ~[[Configurable]]~ attribute has been set once to ~false~, it cannot be turned back to ~true~. As we just said, we cannot change even other attributes, e.g. ~[[Enumerable]]~ in such case. We may though change ~[[Value]]~ attribute and ~[[Writable]]~, but only from ~true~ to ~false~; not vice-versa ‚Äî if ~[[Writable]]~ was already set to false, it cannot be turned to ~true~ in non-configurable property.

***** Named property (data)
In addition to [[Named property (data and accessor)][general attributes]] of named properties, a data property has the following attributes:

- ~[[Value]]~ :: attribute specifies a *value* retrieved by reading the property.

- ~[[Writable]]~ :: attribute (reversed state of ~{ReadOnly}~ in ES3) in ~false~ state prevents attempts to *change* the property‚Äôs ~[[Value]]~ attribute using ~[[Put]]~ internal method.

The complete attributes map for a named *data* property with /default/ values is:

#+begin_src javascript

  var defaultDataPropertyAttributes = {
      [[Value]]: undefined,
      [[Writable]]: false,
      [[Enumerable]]: false,
      [[Configurable]]: false
  };

#+end_src

***** Named property (accessor)
In addition to [[Named property (data and accessor)][general attributes]], an accessor property has the following attributes which related with a getter and a setter respectively:

- ~[[Get]]~ :: attribute is a function object which is called every time for retrieving indirect value related with the property name. Do not confuse this property attribute with the same name internal method of an object ‚Äî the general reader of a property value. So in case of accessor property, internal ~[[Get]]~ method of an object calls ~[[Get]]~ attribute of a property of the object.

- ~[[Set]]~ :: attribute being also a function is used in turn for setting the new value associated with a name. This attribute is called by the ~[[Put]]~ internal method of an object.

And the complete attributes map for a named *accessor* property with default values is:

#+begin_src javascript

    var defaultAccessorPropertyAttributes = {
        [[Get]]: undefined,
        [[Set]]: undefined,
        [[Enumerable]]: false,
        [[Configurable]]: false
    };

#+end_src

Accordingly, if ~[[Set]]~ attribute is absent, an accessor property is read only ‚Äî like in case of false ~[[Writable]]~ attribute of a data property.

**** Definition, and assignment of properties
***** Define data property
In default state properties are constants:

#+begin_src javascript

  // define in the declarative form
  var foo = {
      bar: 10 // direct Number type value
  };

  // define in the imperative form,
  // also direct, but Function type value, a "method"
  foo.baz = function () {
      return this.bar;
  };


  // define a global constant
  Object.defineProperty(this, "MAX_SIZE", {
      value: 100
  });

  console.log(MAX_SIZE); // 100

  MAX_SIZE = 200; // error in strict mode, [[Writable]] = false,
  delete MAX_SIZE; // error in strict mode, [[Configurable]] = false

  console.log(MAX_SIZE); // still 100

#+end_src

Notice also that meta-method [[Object.defineProperty]] is not only for creating object‚Äôs properties, but also for altering them. Moreover, it returns altered object, so we can use this method to bind newly created object to needed variable name, making it in one action:

#+begin_src javascript

  // create "foo" object and define "bar" property
  var foo = Object.defineProperty({}, "bar", {
    value: 10,
    enumerable: true
  });

  // alter value and enumerable attribute
  Object.defineProperty(foo, "bar", {
    value: 20,
    enumerable: false
  });

  console.log(foo.bar); // 20

#+end_src

***** Define accessor property
An accessor property can be defined either using meta-method [[Object.defineProperty]]:

#+begin_src javascript

  var foo = {};

  Object.defineProperty(foo, "bar", {

      get: function getBar() {
          return 20;
      },

      set: function setBar(value) {
          // setting implementation
      }

  });

  foo.bar = 10; // calls foo.bar.[[Set]](10)

  // independently always 20
  console.log(foo.bar); // calls foo.bar.[[Get]]()

#+end_src

Or also in the declarative view using object initialiser:

#+begin_src javascript

  var foo = {

      get bar () {
          return 20;
      },

      set bar (value) {
          console.log(value);
      }

  };

  foo.bar = 100;
  console.log(foo.bar); // 20

#+end_src

***** Assignment of data property
A /simple assignment/ operator corresponds to the reversed default state of all attributes.

#+begin_src javascript

  // simple assignment (if we create a new property)
  foo.bar = 10;

  // the same as
  Object.defineProperty(foo, "bar", {
      value: 10,
      writable: true,
      enumerable: true,
      configurable: true
  });

#+end_src

As we know from ES3 series, inherited (data) properties are available for *reading*, but assignment (to a data property) *always creates an own property*:

#+begin_src javascript

  Object.prototype.x = 10;

  var foo = {};

  // read inherited property
  console.log(foo.x); // 10

  // but with assignment create always own property
  foo.x = 20;

  // read own property
  console.log(foo.x); // 20
  console.log(foo.hasOwnProperty("x")); // true

#+end_src

Another thing to note, is that if we try to /shadow/ via assignment a non-writable inherited property, and if we are in strict mode, then ~TypeError~ exception is thrown. This is made regardless whether a property is data or an accessor. However, if we shadow the property not via assignment, but via [[Object.defineProperty]], everything is fine.

***** Assignment of accessor property
In contrast with data properties, inherited accessor properties *are available for modifications* via assignment through an object which inherits these properties:

#+begin_src javascript

  var _x = 10;

  var proto = {
    get x() {
      return _x;
    },
    set x(x) {
      _x = x;
    }
  };

  console.log(proto.hasOwnProperty("x")); // true

  console.log(proto.x); // 10

  proto.x = 20; // set own property

  console.log(proto.x); // 20

  var a = Object.create(proto); // "a" inherits from "proto"

  console.log(a.x); // 20, read inherited

  a.x = 30; // set *inherited*, but not own

  console.log(a.x); // 30
  console.log(proto.x); // 30
  console.log(a.hasOwnProperty("x")); //false

#+end_src

However, if we define ~a~ still inheriting from ~proto~ but with specifying ~x~ as own, assignment of course sets the own property:

#+begin_src javascript

  var a = Object.create(proto, {
      x: {
          value: 100,
          writable: true
      }
  });

  console.log(a.x); // 100, read own

  a.x = 30; // set also own

  console.log(a.x); // 30
  console.log(proto.x); // 20
  console.log(a.hasOwnProperty("x")); // true

  // The same result obviously can be obtained and via setting an
  // own property using meta-method, but not assignment operator:
  var a = Object.create(proto);

  a.x = 30; // set inherited

  Object.defineProperty(a, "x", {
      value: 100,
      writable: true
  });

  a.x = 30; // set own

#+end_src

Another thing to note, is that if we try to /shadow/ via assignment a non-writable inherited property, and if we are in strict mode, then ~TypeError~ exception is thrown. This is made regardless whether a property is data or an accessor. However, if we shadow the property not via assignment, but via [[Object.defineProperty]], everything is fine.

**** Internal properties
***** Brief
This specification uses various internal properties to define the semantics of object values. These internal properties are not part of the ECMAScript language. They are defined by this specification purely for expository purposes. An implementation of ECMAScript must behave as if it produced and operated upon internal properties in the manner described here. The names of internal properties are enclosed in double square brackets ~[[ ]]~. When an algorithm uses an internal property of an object and the object does not implement the indicated internal property, a ~TypeError~ exception is thrown.

Objects in ES5 can be /sealed/, /frozen/ or just /non-extensible/, i.e. *static*.

***** sealed, frozen or non-extensible
****** non-extensible (add)
With all three states an internal ~[[Extensible]]~ property is related. It can be managed using special meta-methods:

#+begin_src javascript

  var foo = {bar: 10};

  console.log(Object.isExtensible(foo)); // true

  Object.preventExtensions(foo);
  console.log(Object.isExtensible(foo)); // false

  foo.baz = 20; // error in "strict" mode
  console.log(foo.baz); // undefined

  // Note, that [[Extensible]] internal property once setting
  // to false cannot be turned back to true.

#+end_src

****** sealed (add, delete)
But even from non-extensible object some properties can be *removed*. To prevent this case a meta-method [[Object.seal]] can help which besides the ~[[Extensible]]~ internal property also set to false ~[[Configurable]]~ attribute of all properties of an object:

*Note*: both sealed and frozen states cannot be turned off back.

#+begin_src javascript

  var foo = {bar: 10};

  console.log(Object.isSealed(foo)); // false

  Object.seal(foo);
  console.log(Object.isSealed(foo)); // true

  delete foo.bar; // error in strict mode
  console.log(foo.bar); // 10

#+end_src

****** frozen (add, delete, modify)
If we want to make an object *completely static* i.e. to *freeze* it, preventing also changing values of existing properties, then we can use corresponding [[Object.freeze]] meta-method. This method besides mentioned ~[[Configurable]]~ attribute and ~[[Extensible]]~ internal property, also for data properties sets attribute ~[[Writable]]~ to ~false~:

*Note*: both sealed and frozen states cannot be turned off back.

#+begin_src javascript

  var foo = {bar: 10};

  print(Object.isFrozen(foo)); // false

  Object.freeze(foo);
  print(Object.isFrozen(foo)); // true

  delete foo.bar; // error in strict mode
  foo.bar = 20; // error in strict

  print(foo.bar); // 10

#+end_src

***** Internal ~[[Prototype]]~ property
In contrast with ES3, ECMA-262-5 provides ability for reading the internal ~[[Prototype]]~ property ‚Äî via the meta-method [[Object.getPrototypeOf]]. Also in the current version of the specification we can create object with specifying needed prototype object ‚Äî using a meta-method [[Object.create]]:

#+begin_src javascript

  // create "foo" object with two own
  // properties "sum" and "length" and which has
  // Array.prototype as its [[Prototype]] property

  var foo = Object.create(Array.prototype, {
    sum: {
      value: function arraySum() {
        // sum implementation
      }
    },
    // non-enumerable but writable!
    // else array methods won't work
    length: {
      value: 0,
      enumerable: false,
      writable: true
    }
  });

  foo.push(1, 2, 3);

  console.log(foo) // Array { '0': 1, '1': 2, '2': 3 }
  console.log(foo.length); // 3  // can't overload internal method (RF)
  console.log(foo.join("-")); "1-2-3"

  // neither "sum", nor "length"
  // are enumerable

  for (var k in foo) {
    console.log(k); // 0, 1, 2
  }

  // getting prototype of "foo"
  var fooPrototype = Object.getPrototypeOf(foo);

  console.log(fooPrototype === Array.prototype); // true

#+end_src

But unfortunately, using even such approach we still cannot create an inherited from ~Array.prototype~ ‚Äúclass‚Äù with *all functionality* of normal arrays *including overloaded* ~[[DefineOwnProperty]]~ internal method (see 15.4.5.1) which handles e.g. ~length~ property. Having example above:

#+begin_src javascript

  foo[5] = 10;
  console.log(foo.length); // still 3

#+end_src

Still the only way to inherit from ~Array.prototype~ and at the same time to *have all related overloaded internal methods*, is to use normal array (i.e. an object which ~[[Class]]~ is "Array") and apply non-standard ~__proto__~ property. So this is available not for all implementations:

#+begin_src javascript

  var foo = [];
  foo.__proto__= {bar: 10};
  foo.__proto__.__proto__= Array.prototype;

  console.log(foo instanceof Array); // true

  console.log(foo.bar); // 10

  console.log(foo.length); // 0

  foo.push(20);

  foo[3] = 30;
  console.log(foo.length); //4

  console.log(foo); // 20,,,30

  foo.length = 0;
  console.log(foo); // empty array

#+end_src

  And unfortunately, in contrast with non-standard ~__proto__~ extension of some ES3 implementations, ES5 does not provide ability for setting an object‚Äôs prototype.

** Abstract data types
An /abstract data type/, or object class, is a subprogram that may contain arbitrarily complicated code but exposes a limited set of methods and properties that people working with it are supposed to use. This allows large programs to be built up out of a number of appliance types, limiting the degree to which these different parts are entangled by requiring them to only interact with each other in specific ways.

Each abstract data type has an *interface*, the collection of operations that external code can perform on it. Any details beyond that interface are /encapsulated/, treated as internal to the type and of no concern to the rest of the program.

Even basic things like numbers can be thought of as an abstract data type whose interface allows us to add them, multiply them, compare them, and so on.

** Encapsulation
Different pieces of a program interact with each other through interfaces, limited sets of functions or bindings that provide useful functionality at a more abstract level, hiding their precise implementation.

Such program pieces are modeled using objects. Their interface consists of a specific set of methods and properties. Properties that are part of the interface are called *public*. The others, which outside code should not be touching, are called *private*.

It is also common to put an underscore ( ~_~ ) character at the start of property names to indicate that those properties are private.

*Separating interface from implementation* is a great idea. It is usually called /encapsulation/.

One useful thing to do with objects is to specify an interface for them and tell everybody that they are supposed to talk to your object only through that interface. The rest of the details that make up your object are now *encapsulated*, hidden behind the interface.

*Wikipedia*
La abstracci√≥n encarada desde el punto de vista de la programaci√≥n orientada a objetos expresa las caracter√≠sticas esenciales de un objeto, las cuales distinguen al objeto de los dem√°s. Adem√°s de distinguir entre los objetos provee l√≠mites conceptuales. Entonces se puede decir que la encapsulaci√≥n separa las caracter√≠sticas esenciales de las no esenciales dentro de un objeto. Si un objeto tiene m√°s caracter√≠sticas de las necesarias los mismos resultar√°n dif√≠ciles de usar, modificar, construir y comprender.

** Prototype
A prototype is another object that is used as a fallback source of properties. When an object gets a request for a property that it does not have, its prototype will be searched for the property, then the prototype‚Äôs prototype, and so on.

The prototype relations of JavaScript objects form a tree-shaped structure, and at the root of this structure sits ~Object.prototype~. It provides a few methods that show up in all objects, such as ~toString~, which converts an object to a string representation.

Functions derive from ~Function.prototype~, and arrays derive from ~Array.prototype~.

*Dmitry S√≥shnikov*
Prototype is an object, which is used either as an original copy for other objects, or as a helper object to which characteristics other objects can delegate in case if these objects do not have the necessary characteristic themselves.

Every object has a prototype (exceptions can be with some system objects). Communication with a prototype is organized via the *internal*, implicit and inaccessible directly ~[[Prototype]]~ property.

*Note*: pay attention, ~F.[[Prototype]]~ is a prototype of the function (constructor) and ~F.prototype~ is a prototype of objects created by this function (often there is a mess in terminology, and ~F.prototype~ in some articles is named as a ‚Äúprototype of the constructor‚Äù that is incorrect).

The most useful application of the prototype in ECMAScript is the storage of *methods*, *default state* and *shared properties* of objects.

[[constructor]] property is set to function‚Äôs ~prototype~ property at function creation. The value of this property is the *circular reference* to the function *itself*:

#+begin_src javascript

  function A() {}
  var a = new A();
  console.log(a.constructor); // function A() {}, by delegation
  console.log(a.constructor === A); // true

#+end_src

Often prototype of an object is incorrectly confused with explicit reference to the prototype via the function‚Äôs ~prototype~ property. Yes, really, it references to the same object, as object‚Äôs ~[[Prototype]]~ property:

#+begin_src javascript

  a.[[Prototype]] ----> Prototype <---- A.prototype

#+end_src

Therefore, sometimes arising statements in articles on JavaScript claiming that ‚Äúdynamic changing of the prototype will affect all objects and they will have that new prototype‚Äù is incorrect. New prototype will have only new objects which will be created after this changing.

The main rule here is: the object‚Äôs prototype is set at the *moment of object‚Äôs creation* and after that cannot be changed to new object. Using the explicit ~prototype~ reference from the constructor if it still refers to the same object, it is possible only to add new or modify existing properties of the object‚Äôs prototype.

*Note*: some implementations, provide explicit reference to object‚Äôs prototype via the non-standard ~__proto__~ property.

#+begin_src javascript

  console.log(Object.getPrototypeOf(a) === a.__proto__)
  // [[Prototype]] same as __proto__

#+end_src

*Note*: ES5 introduced [[Object.getPrototypeOf]] method, which directly returns the ~[[Prototype]]~ property of an object ‚Äî the original prototype of the instance. However, in contrast with ~__proto__~, being only a getter, it does not allow to set the prototype.

#+begin_src javascript

  var a = {
      x: 10,
      calculate: function (z) {
          return this.x + this.y + z;
      }
  };

  var b = {
      y: 20,
      __proto__: a
  };

  var c = {
      y: 30,
      __proto__: a
  };

  // call the inherited method
  b.calculate(30); // 60
  c.calculate(40); // 80


  // Notice: ES5 standardized an alternative way for prototype-based
  // inheritance using Object.create function:

  var b = Object.create(a, {y: {value: 20, enumerable: true}});
  var c = Object.create(a, {y: {value: 30, enumerable: true}});


  +-------------------+                +------------------------+
  |         b         |       ‚îå------->|           a            |
  +-------------------+       |        +------------------------+
  |     y     |   20  |       |        |     x     |     10     |
  |-------------------|       |        |------------------------|
  | __proto__ |    -----------‚î§        | calculate | <function> |
  +-------------------+       |        |------------------------|
                              |        | __proto__ |     |      |
  +-------------------+       |        +---------------  |  ----+
  |         c         |       |                          v
  +-------------------+       |        +------------------------+
  |     y     |   30  |       |        |    Object.prototype    |
  |-------------------|       |        +------------------------+
  | __proto__ |    -----------‚îò        |      <built-ins>       |
  +-------------------+                |------------------------+
                                       | __proto__ |    null    |
                                       +------------------------+

  // See that b and c have access to the calculate method which is defined
  // in a object. And this is achieved exactly via this prototype chain

#+end_src

The rule is simple: if a property or a method is not found in the object itself (i.e. the object has no such an own property), then there is an attempt to find this property/method in the prototype chain. If the property is not found in the prototype, then a prototype of the prototype is considered, and so on, i.e. the whole prototype chain. The first found property/method with the same name is used. Thus, a found property is called inherited property. If the property is not found after the whole prototype chain lookup, then ~undefined~ value is returned.

Objects can have their own *states*, but methods are usually the same. Therefore, methods, for optimization of a memory usage, are usually defined in the prototype. It means that all instances created by this constructor, always *share the same* method.

#+begin_src javascript

  function A(x) {
      this.x = x || 100;
  }

  A.prototype = (function () {

      // initializing context,
      // use additional object

      var _someSharedVar = 500;

      function _someHelper() {
          console.log('internal helper: ' + _someSharedVar);
      }

      function method1() {
          console.log('method1: ' + this.x);
      }

      function method2() {
          console.log('method2: ' + this.x);
          _someHelper();
      }

      // the prototype itself
      return {
          constructor: A,
          method1: method1,
          method2: method2
      };

  })();

  var a = new A(10);
  var b = new A(20);

  a.method1(); // method1: 10
  a.method2(); // method2: 10, internal helper: 500

  b.method1(); // method1: 20
  b.method2(); // method2: 20, internal helper: 500

  // both objects are use
  // the same methods from
  // the same prototype
  console.log(a.method1 === b.method1); // true
  console.log(a.method2 === b.method2); // true

#+end_src

** Class
*** constructor
**** Dmitry S√≥shnikov
Objects in ECMAScript are created via, so-called, constructors. Constructor is a function that *creates* and *initializes* the newly created object.

Often it is needed to have objects with the same or similar state structure (i.e. the same set of properties), and with different state values. In this case we may use a constructor function which produces objects by specified pattern.

Besides creation of objects by specified pattern, a constructor function does another useful thing ‚Äî it *automatically sets a prototype object for newly created objects*. This [[Prototype][prototype]] object is stored in the ~ConstructorFunction.prototype~ property.

The internal ~[[Construct]]~ method is activated by the ~new~ operator applied to the constructor function. This method is responsible for memory allocation and creation of the object.

#+begin_src javascript

  function A() {
      // update newly created object
      this.x = 10;
      // but return different object
      return [1, 2, 3];
  }

  var a = new A();
  var b = A();
  console.log(a);   // [1, 2, 3]
  console.log(a.x); // undefined
  console.log(b);   // [1, 2, 3]
  console.log(b.x); // undefined

  function B() {
      this.x = 10;
  }

  var a2 = new B();
  var b2 = B();
  console.log(a2);   // B { x: 10 }
  console.log(a2.x); // 10
  console.log(b2);   // undefine
  console.log(b2.x); // Error
  // TypeError: Cannot read properties of undefined (reading 'x')

#+end_src

With the keyword ~new~ the [[this in the constructor][constructor]] binds the value of ~this~ to the newly created object. Without ~new~ it keeps the default value of ~this~.

Formally, if to consider a concept of a classification, a combination of the constructor function and the prototype object may be called as a ‚Äúclass‚Äù.

*Notice*: in ES6 the concept of a ‚Äúclass‚Äù is standardized, and is implemented as exactly a syntactic sugar on top of the constructor functions. From this viewpoint prototype chains become as an implementation detail of the class-based inheritance.

**** MDN
A constructor enables you to provide any *custom initialization* that must be done before any other methods can be called on an instantiated object.

#+begin_src javascript

  class Person {
    constructor(name) {
      this.name = name;
    }

    introduce() {
      console.log(`Hello, my name is ${this.name}`);
    }
  }

  const otto = new Person("Otto");

  otto.introduce(); // Hello, my name is Otto

#+end_src

*Note*: if there is a constructor present in the subclass, it needs to first call ~super()~ before using ~this~. The ~super~ keyword can also be used to call corresponding methods of super class.

If you don't provide your own constructor, then a default constructor will be supplied for you. If your class is a base class, the default constructor is empty:

#+begin_src javascript

  constructor() {}

#+end_src

If your class is a derived class, the default constructor calls the parent constructor, passing along any arguments that were provided:

#+begin_src javascript

  constructor(...args) {
    super(...args);
  }

#+end_src

*Note*: the difference between an explicit constructor like the one above and the default constructor is that the latter doesn't actually invoke the array iterator through argument spreading.

Using ~new~ on a class goes through the following steps:

1. (If it's a derived class) The ~constructor~ body before the ~super()~ call is evaluated. This part should not access ~this~ because it's not yet initialized.
2. (If it's a derived class) The ~super()~ call is evaluated, which initializes the parent class through the same process.
3. The current class's /fields/ are initialized.
4. The ~constructor~ body after the ~super()~ call (or the entire body, if it's a base class) is evaluated.

Within the ~constructor~ body, you can access the object being created through ~this~ and access the class that is called with ~new~ through ~new.target~. Note that methods (including getters and setters) and the prototype chain are already initialized on ~this~ before the ~constructor~ is executed, so you can even access methods of the subclass from the constructor of the superclass. However, if those methods use ~this~, the ~this~ will not have been fully initialized yet. This means reading public fields of the derived class will result in ~undefined~, while reading private fields will result in a ~TypeError~.

*** class
**** Brief
JavaScript‚Äôs prototype system can be interpreted as a somewhat informal take on an object-oriented concept called *classes*. A class defines the *shape of a type of object* ‚Äîwhat methods and properties it has. Such an object is called an instance of the class.

So to create an instance of a given class, you have to make an object that derives from the proper prototype, but you also have to make sure it, itself, has the properties that instances of this class are supposed to have. This is what a [[constructor]] function does.

#+begin_src javascript

  function makeRabbit(type) {
      let rabbit = Object.create(protoRabbit);
      rabbit.type = type;
      return rabbit;
  }

#+end_src

JavaScript provides a way to make defining this type of function easier. If you put the keyword ~new~ in front of a function call, the function is treated as a *constructor*. This means that an *object with the right prototype is automatically created*, *bound* to ~this~ in the function, and *returned at the end of the function*.

The prototype object used when constructing objects is found by taking the [[Prototype property][prototype property]] of the constructor function.

#+begin_src javascript

  function Rabbit(type) {
      this.type = type;
  }
  Rabbit.prototype.speak = function(line) {
      console.log(`The ${this.type} rabbit says '${line}'`);
  };

  let weirdRabbit = new Rabbit("weird");
  console.log(weirdRabbit2) // Rabbit { type: 'weird' }

  let otherRabbit = Rabbit("weird"); // without the 'new' keyword
  console.log(otherRabbit) // undefinded

#+end_src

**** Prototype property
Constructors (all functions, in fact) automatically get a property named ~prototype~, which by default holds a plain, empty object that derives from ~Object.prototype~. You can overwrite it with a new object if you want. Or you can add properties to the existing object, as the example does.

It is important to understand the distinction between the way a prototype is associated with a constructor (through its ~prototype~ property) and the way objects have a prototype (which can be found with ~Object.getPrototypeOf~). The actual prototype of a constructor is ~Function.prototype~ since constructors are functions. Its ~prototype~ property holds the prototype used for instances created through it.

#+begin_src javascript

  function Letter(number) {
      this.number = number;
  }

  Letter.prototype.getNumber = function() {
      return this.number;
  };

  let a = new Letter(1);
  let b = new Letter(2);
  // ...
  let z = new Letter(6);

  console.log(
      a.getNumber(), // 1
      b.getNumber(), // 2
      z.getNumber(), // 6
  );

+---------------+
|       a       |
+---------------+         +----------------------+
|   number  | 1 |         |        Letter        |<--‚îê
|---------------|         +----------------------+   |   +------------------+
| __proto__ |  ----‚îê      | __proto__ |      ----------->|Function.prototype|
+---------------+  |      |----------------------|   |   +------------------+
                   |      | prototype |     |    |   |   |   <built-ins>    |
+---------------+  |      +---------------- | ---+   |   |------------------|
|       b       |  |                        v        |   | __proto__ |  |   |
+---------------+  |      +----------------------+   |   +------------- | --+
|   number  | 2 |  |  ‚îå-->|    Letter.prototype  |   |                  |
|---------------|  |  |   +----------------------+   |                  v
| __proto__ |  ----‚îº--‚îò   |constructor|      --------‚îò   +------------------+
+---------------+  |      |----------------------|       | Object.prototype |
                   |      | getNumber |<function>|       +------------------+
+---------------+  |      |----------------------|   ‚îå-->|   <built-ins>    |
|       z       |  |      | __proto__ |      --------‚îò   |------------------|
+---------------+  |      +----------------------+       | __proto__ | null |
|   number  | 6 |  |                                     +------------------+
|---------------|  |
| __proto__ |  ----‚îò
+---------------+

#+end_src

**** Class definition
JavaScript classes are *constructor functions with a prototype property*. That is how they work, and until 2015, that was how you had to write them. These days, we have a less awkward notation.

#+begin_src javascript

  class Rabbit {
      constructor(type) {
          this.type = type;
      }
      speak(line) {
          console.log(`The ${this.type} rabbit says '${line}'`);
      }
  }

  let killerRabbit = new Rabbit("killer");
  // Only for purposes of understanding 'this' can be viewed as:
  // Rabbit("killer", this) // 'this' can be viewed as an additional parameter
  // Rabbit("killer", killerRabbit)//'new' keyword bind 'this' to killerRabbit

  let blackRabbit = new Rabbit("black");

#+end_src

The ~class~ keyword starts a class declaration, which allows us to define a constructor and a set of methods all in a single place. Any number of methods may be written inside the declaration‚Äôs braces. The one named ~constructor~ is treated specially. It provides the actual constructor function, which will be bound to the name ~Rabbit~. The others are packaged into that constructor‚Äôs prototype.

Like ~function~, ~class~ can be used both in statements and in expressions. When used as an expression, it doesn‚Äôt define a binding but just produces the constructor as a value. You are allowed to omit the class name in a class expression.

#+begin_src javascript

  let object = new class { getWord() { return "hello"; } };
  console.log(object.getWord());  // ‚Üí hello

#+end_src

**** Class body
The body of a class is the part that is in curly braces ~{}~. This is where you define class members, such as methods or constructor.

The body of a class is executed in [[Strictness scope][strict mode]] even without the ~"use strict"~ directive.

A class element can be characterized by three aspects:

- Kind :: Getter, setter, method, or field
- Location :: Static or instance
- Visibility :: Public or private

In addition, there are two special class element syntaxes: *constructor* and *static initialization blocks*, with their own references.

*Constructor*
The ~constructor~ method is a special method for *creating* and *initializing* an object created with a class.

A constructor can use the ~super~ keyword to call the constructor of the super class.

You can create instance properties inside the constructor. Alternatively, if your instance properties' values do not depend on the constructor's arguments, you can define them as class fields.

*Static initialization blocks*
Static initialization blocks allow flexible initialization of static properties, including the evaluation of statements during initialization, while granting access to the private scope.

*Methods*
Methods are defined on the prototype of each class instance and are shared by all instances. Methods can be plain functions, async functions, generator functions, or async generator functions.

*Static methods and fields*
The ~static~ keyword defines a static method or field for a class.

*Field declarations*
Class fields are similar to object properties, not variables, so we don't use keywords such as ~const~ to declare them. The fields can be declared with or without a default value. Fields without default values default to ~undefined~. By declaring fields up-front, class definitions become more self-documenting, and the fields are always present, which help with optimizations.

**** Declaring a class
Within a class body, there are a range of features available.

#+begin_src javascript

  class MyClass {
    // Constructor
    constructor() {
      // Constructor body
    }
    // Instance field
    myField = "foo";
    // Instance method
    myMethod() {
      // myMethod body
    }
    // Static field
    static myStaticField = "bar";
    // Static method
    static myStaticMethod() {
      // myStaticMethod body
    }
    // Static block
    static {
      // Static initialization code
    }
    // Fields, methods, static fields, and static methods all have
    // "private" forms
    #myPrivateField = "bar";
  }

#+end_src

**** Evaluation order
1. The ~extends~ clause, if present, is first evaluated. It must evaluate to a valid constructor function or ~null~, or a ~TypeError~ is thrown.
2. The ~constructor~ method is extracted, substituted with a default implementation if ~constructor~ is not present. However, because the ~constructor~ definition is only a method definition, this step is not observable.
3. The class elements' property keys are evaluated in the order of declaration. If the property key is computed, the computed expression is evaluated, with the ~this~ value set to the ~this~ value surrounding the class (not the class itself). None of the property values are evaluated yet.
4. Methods and accessors are installed in the order of declaration. Instance methods and accessors are installed on the ~prototype~ property of the current class, and static methods and accessors are installed on the class itself. Private instance methods and accessors are saved to be installed on the instance directly later. This step is not observable.
5. The class is now initialized with the prototype specified by ~extends~ and implementation specified by ~constructor~. For all steps above, if an evaluated expression tries to access the name of the class, a ~ReferenceError~ is thrown because the class is not initialized yet.
6. The class elements' values are evaluated in the order of declaration:
    - For each /instance field/ (public or private), its initializer expression is saved. The initializer is evaluated during instance creation, at the start of the constructor (for base classes) or immediately before the ~super()~ call returns (for derived classes).
    - For each /static field/ (public or private), its initializer is evaluated with ~this~ set to the class itself, and the property is created on the class.
    - /Static initialization blocks/ are evaluated with ~this~ set to the class itself.
7.  The class is now fully initialized and can be used as a constructor function.

*** class example
Write a class ~Vec~ that represents a vector in two-dimensional space. It takes ~x~ and ~y~ parameters (numbers), which it should save to properties of the same name.

Give the ~Vec~ prototype methods, ~plus~, that take another vector as a parameter and return a new vector that has the sum of the two vectors‚Äô (~this~ and the parameter) x and y values.

Add a getter property ~length~ to the prototype that computes the length of the vector‚Äîthat is, the distance of the point (x, y) from the origin (0, 0).

#+begin_src javascript

  class Vec {
      constructor(x, y) {
          this.x = x;
          this.y = y;
      }

      plus(other) {
          return new Vec(this.x + other.x, this.y + other.y);
      }

      get length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
      }
  }

  console.log(new Vec(1, 2).plus(new Vec(2, 3)));  // ‚Üí Vec{x: 3, y: 5}
  console.log(new Vec(3, 4).length); // ‚Üí 5

#+end_src

*** extends
The ~extends~ keyword is used in class declarations or class expressions to create a class that is a child of another class. The child class inherits all the methods from another class.

The use of the word ~extends~ indicates that this class *shouldn‚Äôt be directly based on the default* ~Object~ prototype but on some other class. This is called the superclass. The derived class is the *subclass*.

*Note*: if there is a constructor present in the subclass, it needs to first call ~super()~ before using ~this~. The ~super~ keyword can also be used to call corresponding methods of super class.

#+begin_src javascript

  // Syntax
  class ChildClass extends ParentClass { /* ‚Ä¶ */ }


  // Matrix class and its symmetric matrix extension class:
  class Matrix {
      constructor(width, height, element = (x, y) => undefined) {
          this.width = width;
          this.height = height;
          this.content = [];

          for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                  this.content[y * width + x] = element(x, y);
              }
          }
      }

      get(x, y) {
          return this.content[y * this.width + x];
      }
      set(x, y, value) {
          this.content[y * this.width + x] = value;
      }
  }

  const matrix4x3 = new Matrix(4,3,(x,y) => x == y ? 1 : 0);
  console.log(matrix4x3);
  // Matrix { width: 4, height: 3,
  //          content: [ 1, 0, 0, 0,
  //                     0, 1, 0, 0,
  //                     0, 0, 1, 0 ]}

  // | (0,0) (1,0) (2,0) (3,0) |
  // | (0,1) (1,1) (2,1) (3,1) |
  // | (0,2) (1,2) (2,2) (3,2) |

  class SymmetricMatrix extends Matrix {
      constructor(size, element = (x, y) => undefined) {
          super(size, size, (x, y) => {
              if (x < y) return element(y, x);
              else return element(x, y);
          });
      }

      set(x, y, value) {
          super.set(x, y, value);
          if (x != y) {
              super.set(y, x, value);
          }
      }
  }

  let matrix = new SymmetricMatrix(5, (x, y) => `${x},${y}`);
  console.log(matrix.get(3, 2)); // ‚Üí 3,2
  console.log(matrix.get(2, 3)); // ‚Üí 3,2

  console.log(Object.getPrototypeOf(Matrix ) == Function.prototype); // true
  console.log(Object.getPrototypeOf(SymmetricMatrix ) == Matrix);    // true

#+end_src

To initialize a ~SymmetricMatrix~ instance, the constructor calls its superclass‚Äôs constructor through the ~super~ keyword. This is necessary because if this new object is to behave (roughly) like a ~Matrix~, it is going to need the instance properties that matrices have.

The ~set~ method again uses ~super~ but this time not to call the constructor but to call a specific method from the superclass‚Äôs set of methods. We are redefining ~set~ but do want to use the original behavior. Because ~this.set~ refers to the *new* ~set~ method, calling that wouldn‚Äôt work. Inside class methods, ~super~ provides a way to call methods as they were defined in the superclass.

*Note*: if the child class is created without anything inside, when an instance is executed, the object will be created the same as if it were created with the parent class (since when not finding a constructor function it looks for it in the prototype), but with instanceOf pointing to the child class (INS).

#+begin_src javascript

  class ChildMatrix1 extends Matrix { }
  const child1 = new ChildMatrix1(4,3,(x,y) => x == y ? 1 : 0);

  console.log(child1);
  // ChildMatrix1 { width: 4,
  //                height: 3,
  //                content: [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0 ] }
  console.log(child1.get(1,1));
  // 1

  class ChildMatrix2 extends Matrix {
      constructor() {
          super();
          this.name = "something"; } }

  const child2 = new ChildMatrix2(4,3,(x,y) => x == y ? 1 : 0);

  console.log(child2);
  // ChildMatrix2 { width: undefined,
  //                height: undefined,
  //                content: [],
  //                name: 'something' }
  console.log(child2.get(1,1));
  // undefined

#+end_src

*** super
The ~super~ keyword is used to call the constructor of its parent class to access the parent's properties and methods.

The ~super~ keyword is used to access properties on an object literal or class's ~[[Prototype]]~, or invoke a superclass's constructor.

The ~super~ keyword can be used in two ways: as a "function call" (~super(...args)~), or as a "property lookup" ( ~super.prop~ and ~super[expr]~ ).

*Note*: ~super~ is a *keyword* and these are special syntactic constructs. ~super~ is not a variable that points to the prototype object. Attempting to read ~super~ itself is a ~SyntaxError~.

*Note*: if there is a constructor present in the subclass, it needs to first call ~super()~ before using ~this~. The ~super~ keyword can also be used to call corresponding methods of super class.

#+begin_src javascript

  // Syntax
  super([arguments]) // calls the parent constructor.
  super.propertyOnParent
  super[expression]

#+end_src

Create a class named "Model" which will inherit the methods from the "Car" class, by using the ~extends~ keyword.

By calling the ~super()~ method in the constructor method, we call the parent's constructor method and gets access to the parent's properties and methods:

#+begin_src javascript

  class Car {
      constructor(brand) {
          this.carname = brand;
      }
      present() {
          return 'I have a ' + this.carname;
      }
  }

  class Model extends Car {
      constructor(brand, mod) {
          super(brand);
          this.model = mod;
      }
      show() {
          return this.present() + ', it is a ' + this.model;
      }
  }

  mycar = new Model("Ford", "Mustang");
  document.getElementById("demo").innerHTML = mycar.show();

#+end_src

From the example; The ~super()~ method refers to the parent class. By calling the ~super()~ method in the constructor method, we call the parent's constructor method and gets access to the parent's properties and methods.

*** Getters, setters, and statics
*Dmitry S√≥shnikov*
*Getters* and *setters* are functions which are indirectly associated with property values. These [[Named accessor property][accessor functions]] are used to store or retrieve a value that is associated with the property name *indirectly*.

Using setters and getters mostly makes more sense only when we need to *encapsulate some complex calculations using auxiliary helper data*, and making usage of this property convenient ‚Äî i.e. just as it would be a simple data property. For non-abstract things, using accessors may not be that useful.

*Eloquent*
You can define getters and setters to secretly call methods every time an object‚Äôs property is accessed. Static methods are methods stored in a class‚Äôs constructor, rather than its prototype.

Interfaces often consist mostly of methods, but it is also okay to include properties that hold non-function values. For example, ~Map~ objects have a ~size~ property that tells you how many keys are stored in them.

It is not even necessary for such an object to compute and store such a property directly in the instance. Even properties that are accessed directly may hide a method call. Such methods are called *getters*, and they are defined by writing ~get~ in front of the method name in an object expression or class declaration.

#+begin_src javascript

  let varyingSize = {
      get size() {
          return Math.floor(Math.random() * 100);
      }
  };

  console.log(varyingSize.size); // ‚Üí 73
  console.log(varyingSize.size); // ‚Üí 49

#+end_src

Whenever someone reads from this object‚Äôs ~size~ property, the associated method is called. You can do a similar thing when a property is written to, using a *setter*.

#+begin_src javascript

  class Temperature {
      constructor(celsius) {
          this.celsius = celsius;
      }
      get fahrenheit() {
          return this.celsius * 1.8 + 32;
      }
      set fahrenheit(value) {
          this.celsius = (value - 32) / 1.8;
      }

      static fromFahrenheit(value) {
          return new Temperature((value - 32) / 1.8);
      }
  }

  let temp = new Temperature(22);
  console.log(temp.fahrenheit);  // ‚Üí 71.6

  temp.fahrenheit = 86;
  console.log(temp.celsius);     // ‚Üí 30

  let temp2 = Temperature.fromFahrenheit(86)
  console.log(temp2.celsius);    // ‚Üí 30
  console.log(temp2.fahrenheit); // ‚Üí 86

#+end_src

The ~Temperature~ class allows you to read and write the temperature in either degrees Celsius or degrees Fahrenheit, but internally it stores only Celsius and automatically converts to and from Celsius in the ~fahrenheit~ getter and setter.

Sometimes you want to attach some properties (~static~) directly to your constructor function, rather than to the prototype. Such methods won‚Äôt have access to a class instance but can, for example, be used to provide *additional ways to create instances*.

Inside a class declaration, methods that have ~static~ written before their name are stored on the constructor. So the ~Temperature~ class allows you to write ~Temperature.fromFahrenheit(100)~ to create a temperature using degrees Fahrenheit.

** Polymorphism
*Eloquent*
When a piece of code is written to work with objects that have a certain interface, any kind of object that happens to support this interface can be plugged into the code, and it will just work.

This technique is called *polymorphism*. Polymorphic code can work with values of different shapes, as long as they support the interface it expects.

~for/of~ loop can loop over several kinds of data structures. This is one [[The iterator interface][case]] of polymorphism‚Äîsuch loops expect the data structure to expose a specific interface, which arrays and strings do.

More than one type may implement the same interface. Code written to use an interface automatically knows how to work with *any number of different objects* that provide the interface. This is called *polymorphism*.

*Wikipedia*
Polymorphism is the provision of a *single interface to entities of different types*. The concept is borrowed from a principle in biology where an organism or species can have many different forms or stages.

*Stackoverflow*
If you think about the Greek roots of the term, it should become obvious.

- Poly = many: polygon = many-sided, polystyrene = many styrenes (a), polyglot = many languages, and so on.
- Morph = change or form: morphology = study of biological form, Morpheus = the Greek god of dreams able to take any form.

So polymorphism is the ability (in programming) to *present the same interface for differing underlying forms* (data types).

For example, in many languages, integers and floats are implicitly polymorphic since you can add, subtract, multiply and so on, irrespective of the fact that the types are different. They're rarely considered as objects in the usual term.

The classic example is the ~Shape~ class and all the classes that can inherit from it (square, circle, dodecahedron, irregular polygon, splat and so on).

With polymorphism, each of these classes will have different underlying data. A point shape needs only two co-ordinates. A circle needs a center and radius. A square or rectangle needs two co-ordinates for the top left and bottom right corners and (possibly) a rotation. An irregular polygon needs a series of lines.

By making the class responsible for its code as well as its data, you can achieve polymorphism. In this example, every class would have its own ~Draw()~ function and the client code could simply do:

#+begin_src

  shape.Draw()

#+end_src

to get the correct behavior for any shape.

This is in contrast to the old way of doing things in which the code was separate from the data, and you would have had functions such as ~drawSquare()~ and ~drawCircle()~.

Object orientation, polymorphism and inheritance are all closely-related concepts and they're vital to know. There have been many "silver bullets" during my long career which basically just fizzled out but the OO paradigm has turned out to be a good one. Learn it, understand it, love it - you'll be glad you did :-)

** Symbols
When I claimed that property names are strings, that wasn‚Äôt entirely accurate. They usually are, but they can also be *symbols*. Symbols are values created with the ~Symbol~ function. Unlike strings, newly created symbols are unique‚Äîyou cannot create the same symbol twice.

#+begin_src javascript

  function Rabbit(type) {
      this.type = type;
  }
  let weirdRabbit = new Rabbit("weird");

  let sym = Symbol("name");
  console.log(sym == Symbol("name")); // ‚Üí false

  Rabbit.prototype[sym] = 55;
  console.log(weirdRabbit[sym]); // ‚Üí 55

  // Be careful, we can do this:
  let sym2 = Symbol("name");
  // 'sym2' stores a different symbol than 'sym'.
  // "name" is just a guide name for us.
  // Remember that 'Symbol("name")' is the one that is
  // unique, 'sym2' is just an identifier.
  Rabbit.prototype[sym2] = 100;
  console.log(weirdRabbit[sym2]); // ‚Üí 100

#+end_src

Being both unique and usable as property names makes symbols suitable for defining interfaces ([[Polymorphism][polymorphism]]) that can peacefully live alongside other properties, no matter what their names are.

#+begin_src javascript

  const toStringSymbol = Symbol("toString");
  Array.prototype[toStringSymbol] = function() {
      return `${this.length} cm of blue yarn`;
  };

  console.log([1, 2].toString()); // ‚Üí 1,2
  console.log([1, 2][toStringSymbol]()); // ‚Üí 2 cm of blue yarn

#+end_src

It is possible to include symbol properties in object expressions and classes by using square brackets around the property name. That causes the *property name to be evaluated*, much like the square bracket property access notation, which allows us to refer to a binding that holds the symbol.

#+begin_src javascript

  let stringObject = {
      [toStringSymbol]() { return "a jute rope"; }
  };
  console.log(stringObject[toStringSymbol]()); // ‚Üí a jute rope

#+end_src

** The iterator interface
The object given to a [[for...of][for/of]] loop is expected to be *iterable*. This means it has a method named with the ~Symbol.iterator~ symbol (a symbol value defined by the language, stored as a property of the [[Symbols][Symbol]] function).

When called, that method should return an object that provides a *second interface*, *iterator*. This is the *actual thing that iterates*. It has a ~next~ method that returns the next result. That result should be an object with a ~value~ property that provides the next value, if there is one, and a ~done~ property, which should be true when there are no more results and false otherwise.

Note that the ~next~, ~value~, and ~done~ property names are plain strings, not symbols. Only ~Symbol.iterator~, which is likely to be added to a *lot* of different objects, is an actual symbol.

We can directly use this interface ourselves.

#+begin_src javascript

  let okIterator = "OK"[Symbol.iterator]();

  console.log(okIterator.next());  // ‚Üí {value: "O", done: false}
  console.log(okIterator.next());  // ‚Üí {value: "K", done: false}
  console.log(okIterator.next());  // ‚Üí {value: undefined, done: true}


  // Only iterable objects have the 'Symbol.iterator' property
  // The 'Symbol.iterator' property is held by prototypes
  const obj = {}; // object
  const arr = []; // array

  console.log(obj[Symbol.iterator]);  //  undefined (not iterable)
  console.log(Object.prototype.hasOwnProperty(Symbol.iterator)); // false

  console.log(arr[Symbol.iterator]);  //  [Function: values] (iterable)
  console.log(Array.prototype.hasOwnProperty(Symbol.iterator));  // true

#+end_src

#+begin_src

                        Symbol.prototype
                +----------------------------------+
                |iterator|Symbol("Symbol.iterator")|
                +------------------------|---------+
                                         |
      arr = [7]                          |     Array.prototype
  +---------------+                 +----v--------------------------+
  |__proto__|   ------------------->|Symbol.iterator|function(){...}|
  +---------------+                 +-----------------------|-------+
                                                            |
      ArrayIterator.prototype <--‚îê                          |
     +----------------------+    |                          |
     | next |function(){...}|    |                          |
     +----------------------+    |                          v
                                 |      arr[Symbol.iterator]() = arrIterator
                                 |         +----------------+
                                 |         |         |      |
                                 ‚îî---------|__proto__|      |
                                           +----------------+
                                                     |
                                                ‚îå----‚îò
                       ‚îå------------------------‚î§
                       |                        |
                       v                        |
               arrIterator.next()               |
               +---------------+                |
               | value |   7   |                |
               | done  | false |                |
               +---------------+                v
                                        arrIterator.next()
                                       +-------------------+
                                       | value | undefined |
                                       | done  |    true   |
                                       +-------------------+

#+end_src

Let‚Äôs implement an iterable data structure. We‚Äôll build a *matrix* class, acting as a two-dimensional array.

#+begin_src javascript

  class Matrix {
      constructor(width, height, element = (x, y) => undefined) {
          this.width = width;
          this.height = height;
          this.content = [];

          for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                  this.content[y * width + x] = element(x, y);
              }
          }
      }

      get(x, y) {
          return this.content[y * this.width + x];
      }
      set(x, y, value) {
          this.content[y * this.width + x] = value;
      }
  }

  const matrix4x3 = new Matrix(4,3,(x,y) => x == y ? 1 : 0);
  console.log(matrix4x3);
  // Matrix { width: 4, height: 3,
  //          content: [ 1, 0, 0, 0,
  //                     0, 1, 0, 0,
  //                     0, 0, 1, 0 ]}

  // | (0,0) (1,0) (2,0) (3,0) |
  // | (0,1) (1,1) (2,1) (3,1) |
  // | (0,2) (1,2) (2,2) (3,2) |

#+end_src

When looping over a matrix, you are usually interested in the position of the elements as well as the elements themselves, so we‚Äôll have our iterator produce objects with ~x~, ~y~, and ~value~ properties.

#+begin_src javascript

  class MatrixIterator {
      constructor(matrix) {
          this.x = 0;
          this.y = 0;
          this.matrix = matrix;
      }

      next() {
          if (this.y == this.matrix.height) return {done: true};

          let value = {x: this.x,
                       y: this.y,
                       value: this.matrix.get(this.x, this.y)};
          this.x++;
          if (this.x == this.matrix.width) {
              this.x = 0;
              this.y++;
          }
          return {value, done: false};
      }
  }

#+end_src

Let‚Äôs set up the ~Matrix~ class to be iterable. We'll use after-the-fact prototype manipulation to add methods to classes so that the individual pieces of code remain small and self-contained. In a regular program, where there is no need to split the code into small pieces, you‚Äôd declare these methods directly in the class instead.

#+begin_src javascript

  Matrix.prototype[Symbol.iterator] = function() {
      return new MatrixIterator(this);
  };


  // you could also declare these methods directly in the class instead
  class Matrix {
      constructor(...) {
          ...
      }

      get(...) {
          ...
      }

      [Symbol.iterator]() {
          return new MatrixIterator(this);
      }
  }

#+end_src

We can now loop over a matrix with ~for/of~.

#+begin_src javascript

  let matrix = new Matrix(2, 2, (x, y) => `value ${x},${y}`);
  for (let {x, y, value} of matrix) {
      console.log(x, y, value);
  }
  // ‚Üí 0 0 value 0,0
  // ‚Üí 1 0 value 1,0
  // ‚Üí 0 1 value 0,1
  // ‚Üí 1 1 value 1,1

#+end_src

** Inheritance
Some matrices are known to be *symmetric*. If you mirror a symmetric matrix around its top-left-to-bottom-right diagonal, it stays the same. In other words, the value stored at ~x~, ~y~ is always the same as that at ~y~, ~x~.

Imagine we need a data structure like [[The iterator interface][Matrix]] but one that enforces the fact that the matrix is and remains symmetrical. We could write it from scratch, but that would involve repeating some code very similar to what we already wrote.

JavaScript‚Äôs prototype system makes it possible to create a *new* class, much like the old class, but with new definitions for some of its properties. The prototype for the new class derives from the old prototype but adds a new definition for, say, the ~set~ method.

In object-oriented programming terms, this is called /inheritance/. *The new class inherits properties and behavior from the old class*.

#+begin_src javascript

  class SymmetricMatrix extends Matrix {
      constructor(size, element = (x, y) => undefined) {
          super(size, size, (x, y) => {
              if (x < y) return element(y, x);
              else return element(x, y);
          });
      }

      set(x, y, value) {
          super.set(x, y, value);
          if (x != y) {
              super.set(y, x, value);
          }
      }
  }

  let matrix = new SymmetricMatrix(5, (x, y) => `${x},${y}`);
  console.log(matrix.get(3, 2)); // ‚Üí 3,2
  console.log(matrix.get(2, 3)); // ‚Üí 3,2

#+end_src

The use of the word [[extends]] indicates that this class shouldn‚Äôt be directly based on the default ~Object~ prototype but on some other class. This is called the superclass. The derived class is the *subclass*.

To initialize a ~SymmetricMatrix~ instance, the constructor calls its superclass‚Äôs constructor through the [[super]] keyword. This is necessary because if this new object is to behave (roughly) like a ~Matrix~, it is going to need the instance properties that matrices have. To ensure the matrix is symmetrical, the constructor wraps the element function to swap the coordinates for values below the diagonal.

The ~set~ method again uses ~super~ but this time not to call the constructor but to call a specific method from the superclass‚Äôs set of methods. We are redefining ~set~ but do want to use the original behavior. Because ~this.set~ refers to the *new* ~set~ method, calling that wouldn‚Äôt work. Inside class methods, ~super~ provides a way to call methods as they were defined in the superclass.

*Inheritance allows us to build slightly different data types from existing data types with relatively little work*. It is a fundamental part of the object-oriented tradition, alongside encapsulation and polymorphism. But while the latter two are now generally regarded as wonderful ideas, inheritance is more controversial.

*Whereas encapsulation and polymorphism can be used to /separate/ pieces of code from each other, reducing the tangledness of the overall program, inheritance fundamentally /ties/ classes together, creating more tangle*. When inheriting from a class, you usually have to know more about how it works than when simply using it.

*Dmitry S√≥shnikov*
ECMAScript uses *delegating inheritance* based on *prototypes*.

The following line describes object structure of the language and shows delegation based inheritance.

#+begin_src javascript

  console.log(1..toString()); // "1"
  // Notice the subtle case of the syntax. Two dots in the example above is
  // not an error. The first dot is used for fractional part of a number,
  // and the second one is already a property accessor:

  1.toString();    // SyntaxError!
  (1).toString();  // OK
  1 .toString();   // OK (space after 1)
  1..toString();   // OK
  1['toString'](); // OK

#+end_src

We can see what happens here:

1. First, from a primitive value ~1~ the wrapper object as ~new Number(1)~ is created;

2. Then the inherited method ~toString~ is called from this wrapper.

Why the inherited? Because objects in ECMAScript can have own properties, and the created wrapper object, in this case, has no own ~toString~ method. Therefore, it inherits it from a prototype, i.e. ~Number.prototype~.

* Asynchronous
** Callbacks
*** Brief
*Eloquent*
One approach to asynchronous programming is to make functions that perform a slow action take an extra argument, a callback function. The action is started, and when it finishes, the callback function is called with the result.

As an example, the ~setTimeout~ function, available both in Node.js and in browsers, waits a given number of milliseconds (a second is a thousand milliseconds) and then calls a function.

#+begin_src javascript

  setTimeout(() => console.log("Tick"), 500);

#+end_src

*MDN*
Functions running in *parallel* with other functions are called *asynchronous*.

Asynchronous programming is a technique that enables your program to start a potentially long-running task and still be able to be responsive to other events while that task runs, rather than having to wait until that task has finished. Once that task has finished, your program is presented with the result.

Many functions provided by browsers, especially the most interesting ones, can potentially take a long time, and therefore, are asynchronous. For example:

- Making HTTP requests using ~fetch()~
- Accessing a user's camera or microphone using ~getUserMedia()~
- Asking a user to select files using ~showOpenFilePicker()~

JavaScript program is /single-threaded/. A thread is a sequence of instructions that a program follows. Because the program consists of a single thread, it can only do one thing at a time: so if it is waiting for our long-running synchronous call to return, it can't do anything else.

What we need is a way for our program to:

1. Start a long-running operation by calling a function.
2. Have that function start the operation and return immediately, so that our program can still be responsive to other events.
3. Have the function execute the operation in a way that does not block the main thread, for example by starting a new thread.
4. Notify us with the result of the operation when it eventually completes.

That's precisely what asynchronous functions enable us to do.

*Event handlers*
The description we just saw of asynchronous functions might remind you of event handlers. Event handlers are really a form of asynchronous programming: you provide a function (the event handler) that will be called, not right away, but whenever the event happens. If "the event" is "the asynchronous operation has completed", then that event could be used to notify the caller about the result of an asynchronous function call.

*Callbacks*
An event handler is a particular type of callback. A callback is just a function that's passed into another function, with the expectation that the callback will be called at the appropriate time. Callbacks used to be the main way asynchronous functions were implemented in JavaScript.

However, callback-based code can get hard to understand when the callback itself has to call functions that accept a callback. This is a common situation if you need to perform some operation that breaks down into a series of asynchronous functions.

Because we sometimes have to call callbacks inside callbacks, we get a deeply nested function, which is much harder to read and debug. This is sometimes called "callback hell" or the "pyramid of doom".

When we nest callbacks like this, it can also get very hard to handle errors: often you have to handle errors at each level of the "pyramid", instead of having error handling only once at the top level.

For these reasons, most modern asynchronous APIs don't use callbacks. Instead, the foundation of asynchronous programming in JavaScript is the [[Promises]].

*** Callback
**** MDN
A callback function (I will call back later!) is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.

The consumer of a callback-based API writes a function that is passed into the API. The provider of the API (called the caller) takes the function and calls back (or executes) the function at some point inside the caller's body. The caller is responsible for passing the right parameters into the callback function. The caller may also expect a particular return value from the callback function, which is used to instruct further behavior of the caller.

Understanding whether the callback is synchronously or asynchronously called is particularly important when analyzing side effects. Consider the following example:

#+begin_src javascript

  // Synchronously.
  let value = 1;

  function doSomething (callBack) {
      callBack();
  }

  doSomething(() => {
    value = 2;
  });

  console.log(value); // 2

  // Asynchronously.
  let value2 = 1;

  setTimeout(() => {
    value2 = 2;
  },1);

  console.log(value2); // 1

#+end_src

Examples of synchronous callbacks include the callbacks passed to [[Array.prototype.map]], [[Array.prototype.forEach]], etc. Examples of asynchronous callbacks include the callbacks passed to [[window.setTimeout()][setTimeout()]] and [[Promise.prototype.then]].

**** Callback hell
An event handler is a particular type of callback. A callback is just a function that's passed into another function, with the expectation that the callback will be called at the appropriate time.

However, callback-based code can get hard to understand when the callback itself has to call functions that accept a callback. This is a common situation if you need to perform some operation that breaks down into a series of asynchronous functions.

#+begin_src javascript

  function doStep1(init) {
    return init + 1;
  }

  function doStep2(init) {
    return init + 2;
  }

  function doStep3(init) {
    return init + 3;
  }

  function doOperation() {
    let result = 0;
    result = doStep1(result);
    result = doStep2(result);
    result = doStep3(result);
    console.log(`result: ${result}`);
  }

  doOperation();

#+end_src

This is  a synchronous program, this is very straightforward. But what if we implemented the steps using callbacks?

#+begin_src javascript

  function doStep1(init, callback) {
    const result = init + 1;
    callback(result);
  }

  function doStep2(init, callback) {
    const result = init + 2;
    callback(result);
  }

  function doStep3(init, callback) {
    const result = init + 3;
    callback(result);
  }

  function doOperation() {
    doStep1(0, (result1) => {
      doStep2(result1, (result2) => {
        doStep3(result2, (result3) => {
          console.log(`result: ${result3}`);
        });
      });
    });
  }

  doOperation();

#+end_src

**** Javascript.Info
Take a look at the function ~loadScript(src)~, that loads a script with the given ~src~:

#+begin_src javascript

  function loadScript(src) {
    // creates a <script> tag and append it to the page
    // this causes the script with given src to start
    // loading and run when complete
    let script = document.createElement('script');
    script.src = src;
    document.head.append(script);
  }

#+end_src

It inserts into the document a new, dynamically created, tag ~<script src="‚Ä¶">~ with the given ~src~. The browser automatically starts loading it and executes when complete.

We can use this function like this:

#+begin_src javascript

  // load and execute the script at the given path
  loadScript('/my/script.js');

#+end_src

The script is executed ‚Äúasynchronously‚Äù, as it starts loading now, but runs later, when the function has already finished.

If there‚Äôs any code below ~loadScript(‚Ä¶)~, it doesn‚Äôt wait until the script loading finishes.

#+begin_src javascript

  loadScript('/my/script.js');
  // the code below loadScript
  // doesn't wait for the script loading to finish
  // ...

#+end_src

The ~loadScript~ function doesn‚Äôt provide a way to track the load completion. The script loads and eventually runs, that‚Äôs all. But we‚Äôd like to know when it happens, to use new functions and variables from that script.

Let‚Äôs add a ~callback~ function as a second argument to ~loadScript~ that should execute when the script loads:

#+begin_src javascript

  function loadScript(src, callback) {
    let script = document.createElement('script');
    script.src = src;

    script.onload = () => callback(script);

    document.head.append(script);
  }

#+end_src

The ~onload~ event basically executes a function after the script is loaded and executed.

That‚Äôs the idea: the second argument is a function (usually anonymous) that runs when the action is completed.

Here‚Äôs a runnable example with a real script:

#+begin_src javascript

  function loadScript(src, callback) {
    let script = document.createElement('script');
    script.src = src;
    script.onload = () => callback(script);
    document.head.append(script);
  }

  loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {
    alert(`Cool, the script ${script.src} is loaded`);
    alert( _ ); // _ is a function declared in the loaded script
  });

#+end_src

That‚Äôs called a ‚Äúcallback-based‚Äù style of asynchronous programming. A function that does something asynchronously should provide a ~callback~ argument where we put the function to run after it‚Äôs complete.

Here we did it in ~loadScript~, but of course it‚Äôs a general approach.

*** Handling errors
What if the script loading fails? Our callback should be able to react on that.

Here‚Äôs an improved version of ~loadScript~ that tracks loading errors:

#+begin_src javascript

  function loadScript(src, callback) {
    let script = document.createElement('script');
    script.src = src;

    script.onload = () => callback(null, script);
    script.onerror = () => callback(new Error(`Script load error for ${src}`));

    document.head.append(script);
  }

#+end_src

It calls ~callback(null, script)~ for successful load and ~callback(error)~ otherwise.

The usage:

#+begin_src javascript

  loadScript('/my/script.js', function(error, script) {
    if (error) {
      // handle error
    } else {
      // script loaded successfully
    }
  });

#+end_src

Once again, the recipe that we used for ~loadScript~ is actually quite common. It‚Äôs called the ‚Äúerror-first callback‚Äù style.

The convention is:

1. The first argument of the ~callback~ is reserved for an error if it occurs. Then ~callback(err)~ is called.
2. The second argument (and the next ones if needed) are for the successful result. Then ~callback(null, result1, result2‚Ä¶)~ is called.

So the single ~callback~ function is used both for reporting errors and passing back results.

*** Pyramid of Doom
For multiple asynchronous actions that follow one after another, we‚Äôll have code like this:

#+begin_src javascript

  loadScript('1.js', function(error, script) {

    if (error) {
      handleError(error);
    } else {
      // ...
      loadScript('2.js', function(error, script) {
        if (error) {
          handleError(error);
        } else {
          // ...
          loadScript('3.js', function(error, script) {
            if (error) {
              handleError(error);
            } else {
              // ...continue after all scripts are loaded (*)
            }
          });

        }
      });
    }
  });
#+end_src

A better way to handle this problem is as follows:

#+begin_src javascript

  loadScript('1.js', step1);

  function step1(error, script) {
    if (error) {
      handleError(error);
    } else {
      // ...
      loadScript('2.js', step2);
    }
  }

  function step2(error, script) {
    if (error) {
      handleError(error);
    } else {
      // ...
      loadScript('3.js', step3);
    }
  }

  function step3(error, script) {
    if (error) {
      handleError(error);
    } else {
      // ...continue after all scripts are loaded (*)
    }
  }

#+end_src

** Promises
*** Brief
**** MDN
A ~Promise~ is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.

A ~Promise~ is in one of these states:
- pending :: initial state, neither fulfilled nor rejected.
- fulfilled :: meaning that the operation was completed successfully.
- rejected :: meaning that the operation failed.

The final state of a pending promise can either be fulfilled with a value or rejected with a reason (error). When either of these options occur, the associated handlers queued up by a promise's ~then~ method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.

A promise is said to be settled if it is either fulfilled or rejected, but not pending.

#+begin_src artist

                                            +-------------+
                                          ->|async actions|
                                         /  +-------------+
                            settled     /
                                       /
                    +--------------------+   return
               ->   |.then(onFulfillment)| --- \
  pending    /      +--------------------+      v pending
  +-------+ / fulfill                            +-------+   +--------+
  |Promise|                                      |Promise|-->|.then() | ....
  +-------+ \ reject                             +-------+   |.catch()|
              \                                   ^          +--------+
                ->  +-----------------------+    /
                    |.then(..., onRejection)|  / return
                    |.catch(onRejection)    |
                    +-----------------------+
                                      \
                                       \
                                        \  +-------------+
                                         ->|error handing|
                                           +-------------+

#+end_src

#+begin_src javascript

  new Promise((resolveOuter) => {
      resolveOuter(
          new Promise((resolveInner) => {
              setTimeout(resolveInner, 1000);
          }),
      );
  });

#+end_src

This promise is already resolved at the time when it's created (because the ~resolveOuter~ is called synchronously), but it is resolved with another promise, and therefore won't be fulfilled until 1 second later, when the inner promise fulfills. In practice, the "resolution" is often done behind the scenes and not observable, and only its fulfillment or rejection are.

*Note*: Several other languages have mechanisms for lazy evaluation and deferring a computation, which they also call "promises", e.g. Scheme. Promises in JavaScript represent processes that are already happening, which can be chained with callback functions. If you are looking to lazily evaluate an expression, consider using a function with no arguments e.g. ~f = () => expression~ to create the lazily-evaluated expression, and ~f()~ to evaluate the expression immediately.

**** Eloquent
*Promise*
Working with abstract concepts is often easier when *those concepts can be represented by values*. In the case of asynchronous actions, you could, instead of arranging for a function to be called at some point in the future, return an object that represents this future event.

This is what the standard class ~Promise~ is for. A promise is an asynchronous action that may complete at some point and produce a value. It is able to notify anyone who is interested when its value is available.

The easiest way to create a promise is by calling ~Promise.resolve~. This function ensures that the value you give it is wrapped in a promise. If it‚Äôs already a promise, it is simply returned‚Äîotherwise, you get a new promise that *immediately finishes with your value as its result*.

#+begin_src javascript

  let fifteen = Promise.resolve(15);
  fifteen.then(value => console.log(`Got ${value}`));
  // ‚Üí Got 15


  // Promise.resolve is used to convert the value returned
  // by someFunction to a promise if it isn‚Äôt already.
  Promise.resolve(someFunction(arg))
      .then(response => callback(null, response),
            failure => callback(failure));

#+end_src

To get the result of a promise, you can use its ~then~ method. This registers a callback function to be called when the promise resolves and produces a value. You can add multiple callbacks to a single promise, and they will be called, even if you add them after the promise has already *resolved* (finished).

But that‚Äôs not all the ~then~ method does. It returns another promise, which resolves to the value that the handler function returns or, if that returns a promise, waits for that promise and then resolves to its result.

*It is useful to think of promises as a device to move values into an asynchronous reality*. A normal value is simply there. A promised value is a value that *might* already be there or might appear at some point in the future. Computations defined in terms of promises act on such wrapped values and are executed asynchronously as the values become available.

To create a promise, you can use ~Promise~ as a constructor. It has a somewhat odd interface‚Äîthe constructor expects a function as argument, which it immediately calls, passing it a function that it can use to resolve the promise. It works this way, instead of for example with a ~resolve~ method, so that only the code that created the promise can resolve it.

This is a example of how you‚Äôd create a promise-based interface:

#+begin_src javascript

  function storage(nest, name) {
      return new Promise(resolve => {
          nest.readStorage(name, result => resolve(result));
      });
  }

  storage(bigOak, "enemies")
      .then(value => console.log("Got", value));

#+end_src

This asynchronous function returns a meaningful value. This is the main advantage of promises‚Äîthey simplify the use of asynchronous functions. Instead of having to pass around callbacks, promise-based functions look similar to regular ones: *they take input as arguments and return their output*. The only difference is that the output may not be available yet.

*Failure*
The chains of promise values created by calls to then and catch can be seen as a pipeline through which asynchronous values or failures move. Since such chains are created by registering handlers, each link has a success handler or a rejection handler (or both) associated with it. Handlers that don‚Äôt match the type of outcome (success or failure) are ignored. But those that do match are called, and their outcome determines what kind of value comes next‚Äîsuccess when it returns a non-promise value, rejection when it throws an exception, and the outcome of a promise when it returns one of those.

#+begin_src javascript

  new Promise((_, reject) => reject(new Error("Fail")))
      .then(value => console.log("Handler 1"))
      .catch(reason => {
          console.log("Caught failure " + reason);
          return "nothing";
      })
      .then(value => console.log("Handler 2", value));
  // ‚Üí Caught failure Error: Fail
  // ‚Üí Handler 2 nothing

#+end_src

Much like an uncaught exception is handled by the environment, JavaScript environments can detect when a promise rejection isn‚Äôt handled and will report this as an error.

*Some example*:

#+begin_src javascript

  // To isolate ourselves from callbacks altogether, we‚Äôll go ahead and
  // also define a wrapper for defineRequestType that allows the handler
  // function to return a promise or plain value and wires that up to the
  // callback for us.
  function requestType(name, handler) {
      defineRequestType(name, (nest, content, source,
                               callback) => {
          try {
              Promise.resolve(handler(nest, content, source))
                  .then(response => callback(null, response),
                        failure => callback(failure));
          } catch (exception) {
              callback(exception);
          }
       });
  }
  // Note that the call to handler had to be wrapped in a try block to make
  // sure any exception it raises directly is given to the callback. This
  // nicely illustrates the difficulty of properly handling errors with raw
  // callbacks‚Äîit is easy to forget to properly route exceptions like that,
  // and if you don‚Äôt do it, failures won‚Äôt get reported to the right
  // callback. Promises make this mostly automatic and thus less
  // error-prone.

#+end_src

*** Definition (syntax/interface)
*MDN*
A Promise is an object representing the eventual completion or failure of an asynchronous operation.

*W3Schools*
"I Promise a Result!"
"*Producing code*" is code that can take some time
"*Consuming code*" is code that must wait for the result
A Promise is an Object that links Producing code and Consuming code

A Promise contains both the *producing code* and calls to the *consuming code*:

#+begin_src javascript

  let myPromise = new Promise(function(myResolve, myReject) {
      // "Producing Code" (May take some time)

      myResolve(); // when successful
      myReject();  // when error
  });

  // "Consuming Code" (Must wait for a fulfilled Promise)
  myPromise.then(
      function(value) { /* code if successful */ },
      function(error) { /* code if some error */ }
  );
  // Promise.then() takes two arguments, a callback for success and another
  // for failure. Both are optional, so you can add a callback for success
  // or failure only.


  // Nota: Una forma de ver la promesa, es lo que significa una promesa en
  // si mismo. Prometo pagarte, no se cuando, ni la cantidad exacta pero
  // prometo darte un valor despu√©s de un tiempo.

  // Creo la promesa de pago (new Promise), el "Producing code" ser√° lo que
  // yo estar√© haciendo para producir el dinero. Cuando termin√© lo que
  // estaba haciendo y tenga un resultado, activo uno de los callback, si
  // fue exitoso, es decir, obtuve algo de dinero (value), ya sea el monto
  // total de la deuda o una fracci√≥n, activo myResolve(value) y le paso el
  // dinero obtenido, si no pude producir nada por alguna excusa (error),
  // activo myReject(error) y le paso la excusa.

  // El "Consuming code" (myPromise.then) ser√° lo que har√© con el resultado
  // de la promesa d√©spues que lo obtenga (debo esperar a que la promesa
  // sea completada por la persona y envie el resultado). El primer
  // argumento de "myPromise.then(successful,error)" ser√° un callback con
  // el valor de la promesa exitosa, es decir, lo que se har√° con el dinero
  // que envi√≥ la persona (function (value) {...}). El segundo argumento
  // sera un callback con el error, que se har√° con el error de que no
  // obtuvimos ning√∫n pago (function (error) {...}).

  // Otro ejemplo puede ser hacer una petici√≥n a un servidor (Producing
  // Code). Si el servidor responde exitosamente entregando el archivo, se
  // le pasa ese archivo a el par√°metro myResolve, si hay un error entonces
  // le pasa tipo de error (e.g. 404) al par√°metro myReject.

  // El "Consuming code" ser√° lo que har√© con el resultado. Si es exitoso
  // se le pasa el archivo como par√°metro al el primer argumento
  // (function(file){...}), si hay un error, se le pasa a el segundo
  // par√°metro el error (function(404){...}).

#+end_src

The function passed to ~new Promise~ is called the /executor/. When ~new Promise~ is created, the executor runs automatically. It contains the producing code which should eventually produce the result.

Its arguments ~myResolve~ and ~myReject~ are callbacks provided by JavaScript itself. Our code is only inside the executor.

When the *producing code* (executor) obtains the result, it should call one of the two callbacks:
- When *Success*  ->  Call ~myResolve(value)~, with result ~value~.
- When *Error*       ->  Call ~myReject(error)~, ~error~ is the error object.

A JavaScript Promise object can be:
- Pending ::  while a Promise object is "pending" (working), the result is undefined.
- Fulfilled :: when a Promise object is "fulfilled", the result is a value.
- Rejected :: when a Promise object is "rejected", the result is an error object.

The Promise object supports two properties: *state* and *result*.

|              | /myPromise.state/ | /myPromise.result/ |
|--------------+-----------------+------------------|
| initially    | "pending"       | undefined        |
| when resolve | "fulfilled"     | a result value   |
| when reject  | "rejected"      | an error object  |

So the executor eventually moves promise to one of these states:

#+begin_src

                                       +--------------------+
                                       | state: "fulfilled" |
                                     ->| result: value      |
                                   /   +--------------------+
                myResolve(value) /
                               /
  new Promise(executor)      /
  +-------------------+    /
  | state: "pending"  |  /
  | result: undefined |  \
  +-------------------+    \
                             \
               myReject(error) \
                                 \     +-------------------+
                                   \   | state: "rejected" |
                                     ->| result: error     |
                                       +-------------------+

#+end_src

A promise that is either resolved or rejected is called *‚Äúsettled‚Äù*, as opposed to an initially ‚Äúpending‚Äù promise.

*Note*: You cannot access the Promise properties state and result. You must use a Promise method ([[Promise.prototype.then][.then]] , [[Promise.prototype.catch][.catch]] , [[Promise.prototype.finally][.finally]]) to handle promises.

*Example*:

#+begin_src javascript

  let promise = new Promise(function(resolve, reject) {
      // The function is executed automatically when the promise is constructed
      // After 1 second signal that the job is done with the result "done"
      setTimeout(() => resolve("done"), 1000);
  });

  // new Promise(executor)
  // +-------------------+                   +--------------------+
  // | state: "pending"  | resolve("done")   | state: "fulfilled" |
  // | result: undefined | --------------->  | result: "done"     |
  // +-------------------+                   +--------------------+


  let promise = new Promise(function(resolve, reject) {
      // After 1 second signal that the job is finished with an error
      setTimeout(() => reject(new Error("Whoops!")), 1000);
  });

  // new Promise(executor)
  // +-------------------+                   +-------------------+
  // | state: "pending"  | reject(error)     | state: "rejected" |
  // | result: undefined | ----------------> | result: error     |
  // +-------------------+                   +-------------------+

#+end_src

To summarize, the executor should perform a job (usually something that takes time) and then call ~resolve~ or ~reject~ to change the state of the corresponding promise object.

*Note*: there can be only a single result or an error. The executor should call only one ~resolve~ or one ~reject~. Any state change is final. All further calls of ~resolve~ and ~reject~ are ignored.

*Note*: we can add handlers (~.then/catch/finally~) any time: if the result is already there, they just execute.

#+begin_src javascript

  // the promise becomes resolved immediately upon creation
  let promise = new Promise(resolve => resolve("done!"));

  promise.then(alert); // done! (shows up right now)

#+end_src

*** Promise.prototype.then
The ~then()~ method of ~Promise~ instances takes up to two arguments: callback functions for the fulfilled and rejected cases of the ~Promise~. It immediately returns an equivalent ~Promise~ object, allowing you to [[Chained Promises][chain]] calls to other promise methods.

*Note*: when a handler returns a value, it becomes the result of that promise, so the next ~.then~ is called with it.

*Note*: the processing chain continues to the next link of the chain even when a ~.then()~ lacks a callback function

#+begin_src javascript

  // Syntax:
  then(onFulfilled)
  then(onFulfilled, onRejected)


  const promise1 = new Promise((resolve, reject) => {
      resolve('Success!');
  });

  promise1.then((value) => {
      console.log(value);
      // "Success!"
  });


  // The processing chain continues to the next link of the
  // chain even when a .then() lacks a callback function
  const myPromise = new Promise((resolve) => {
      setTimeout(() => {
          resolve("foo");
      }, 300);
  });

  myPromise
    .then()
    .then(x => x)
    .then(x => console.log ("exito c => " + x));
  // exito x => foo

#+end_src

If a ~.then~ (or ~catch/finally~, doesn‚Äôt matter) handler returns a promise, the rest of the chain waits until it settles. When it does, its result (or error) is passed further.

#+begin_src

               the call of .then(handler) always returns a promnise:
                                +-------------------+
                                | state: "pending"  |
                                | result: undefined |
                                +-------------------+
                                if handler ends with...

             return value            throw error        return promise
                     /                    |                \
                   /                      |                  \
                 v                        v                    v
                             that promise settles with:
  +--------------------+        +-------------------+
  | state: "fulfilled" |        | state: "rejected" |         +-----+
  | result: value      |        | result: error     |         | ... |
  +--------------------+        +-------------------+         +-----+
                                                         ...with the result
                                                        of the new promise.

#+end_src

*** Promise.prototype.catch
The ~catch()~ method of ~Promise~ instances schedules a function to be called when the promise is rejected. It immediately returns an equivalent ~Promise~ object, allowing you to [[Chained Promises][chain]] calls to other promise methods. *It is a shortcut for* [[Promise.prototype.then][Promise.prototype.then(undefined, onRejected)]], is really just a ~.then()~ without a slot for a callback function (~then(null, failureCallback)~) for the case when the promise is fulfilled.

*Note*: the processing chain continues to the next link of the chain even when a ~.then()~ lacks a callback function

#+begin_src javascript

  // Syntax:
  promiseInstance.catch(onRejected)


  const promise1 = new Promise((resolve, reject) => {
      throw new Error('Uh-oh!');
  });

  promise1.catch((error) => {
      console.error(error);
  });
  // Error: Uh-oh!


  // Processing continues to the next link of the chain
  // even when a .then() lacks a callback function
  const myPromise = new Promise((resolve,reject) => {
      setTimeout(() => {
          reject("Noooo!");
      }, 300);
  });

  myPromise
    .then()
    .then(x => x)
    .then(x => console.log ("exito c => " + x))
    .catch(e => console.log ("error says => " + e));
  // error says => Noooo!

#+end_src

*** Promise.prototype.finally
Just like there‚Äôs a [[finally][finally]] clause in a regular ~try {...} catch {...}~, there‚Äôs ~finally~ in promises.

The call ~.finally(f)~ *is similar to* ~.then(f, f)~ in the sense that ~f~ runs always, when the promise is settled: be it resolve or reject.

The idea of ~finally~ is to set up a handler for performing cleanup/finalizing after the previous operations are complete.

E.g. stopping loading indicators, closing no longer needed connections, etc.


#+begin_src javascript

  new Promise((resolve, reject) => {
      setTimeout(() => resolve("value"), 2000);
  })
  // runs when the promise is settled, doesn't matter successfully or not
      .finally(() => alert("Promise ready")) // triggers first
      .then(result => alert(result)); // <-- .then shows "value"

#+end_src

Please note that ~finally(f)~ *isn‚Äôt exactly an alias* of ~then(f,f)~ though.

There are important differences:

1. A ~finally~ handler has no arguments. In ~finally~ we don‚Äôt know whether the promise is successful or not. That‚Äôs all right, as our task is usually to perform ‚Äúgeneral‚Äù finalizing procedures.

2. A ~finally~ handler ‚Äúpasses through‚Äù the result or error to the next suitable handler. That‚Äôs very convenient, because ~finally~ is not meant to process a promise result. As said, it‚Äôs a place to do generic cleanup, no matter what the outcome was.

3. A ~finally~ handler also shouldn‚Äôt return anything. If it does, the returned value is silently ignored. The only exception to this rule is when a ~finally~ handler throws an error. Then this error goes to the next handler, instead of any previous outcome.

*** Chained Promises
The methods [[Promise.prototype.then][Promise.prototype.then()]] , [[Promise.prototype.catch][Promise.prototype.catch()]] , and [[Promise.prototype.finally][Promise.prototype.finally()]] are used to associate further action with a promise that becomes settled. As these methods return promises, they can be chained.

Each ~.then()~ returns a newly generated promise object, which can optionally be used for chaining; for example:

#+begin_src javascript

  const myPromise = new Promise((resolve) => {
      setTimeout(() => {
          resolve("foo");
      }, 300);
  });

  myPromise
      .then(x => console.log ("exito a => " + x))
      .then(x => console.log ("exito b => " + x))
      .then(x => console.log ("exito c => " + x));
  // exito a => foo
  // exito b => undefined
  // exito c => undefined

#+end_src

*Processing continues to the next link of the chain even when a ~.then()~ lacks a callback function*. Therefore, a chain can safely omit every rejection callback function until the final ~.catch()~.

Handling a rejected promise in each ~.then()~ has consequences further down the promise chain. Sometimes there is no choice, because an error must be handled immediately. In such cases we must throw an error of some type to maintain error state down the chain. On the other hand, in the absence of an immediate need, it is simpler to leave out error handling until a final ~.catch()~ statement. A ~.catch()~ is really just a ~.then()~ without a slot for a callback function for the case when the promise is fulfilled.

#+begin_src javascript

  myPromise
      .then(handleFulfilledA)
      .then(handleFulfilledB)
      .then(handleFulfilledC)
      .catch(handleRejectedAny);

#+end_src

Using arrow functions for the callback functions, implementation of the promise chain might look something like this:

#+begin_src javascript

  myPromise
      .then((value) => `${value} and bar`)
      .then((value) => `${value} and bar again`)
      .then((value) => `${value} and again`)
      .then((value) => `${value} and again`)
      .then((value) => {
          console.log(value);
      })
      .catch((err) => {
          console.error(err);
      });

#+end_src

*Note*: for faster execution, all synchronous actions should preferably be done within one handler, otherwise it would take several ticks to execute all handlers in sequence.

The termination condition of a promise determines the "settled" state of the next promise in the chain. A "fulfilled" state indicates a successful completion of the promise, while a "rejected" state indicates a lack of success. The return value of each fulfilled promise in the chain is passed along to the next ~.then()~, while the reason for rejection is passed along to the next rejection-handler function in the chain.

*** Examples of promises
*W3schools*:

#+begin_src javascript

  function myDisplayer(some) {
      document.getElementById("demo").innerHTML = some;
  }

  let myPromise = new Promise(function(myResolve, myReject) {
      let x = 0;
      let y = 5;

      y = x + y + 15;
      // The producing code (this may take some time)

      if (x == 0) {
          myResolve("OK! => " + y);
      } else {
          myReject("Error");
      }
  });

  myPromise.then(
      function(value) {myDisplayer("This is the final result: " + value);},
      function(error) {myDisplayer(error);}
  );
  // This is the final result: OK! => 20

#+end_src


*MDN*

#+begin_src javascript

  const myFirstPromise = new Promise((resolve, reject) => {
      // We call resolve(...) when what we were doing asynchronously was
      // successful, and reject(...) when it failed.
      // In this example, we use setTimeout(...) to simulate async code.
      setTimeout(() => {
          resolve("Success!"); // Yay! Everything went well!
      }, 250);
  });

  myFirstPromise.then((successMessage) => {
    // successMessage is whatever we passed in the resolve(...) function above.
    // It doesn't have to be a string, but if it is only a succeed
    // message, it probably will be.
    console.log(`Yay! ${successMessage}`);
  });
  // Yay! Success!

#+end_src

*Eloquen*: request
Let‚Äôs make a request function automatically retry the sending of the request a few times before it gives up.

Even when a request and its response are successfully delivered, the response may indicate failure‚Äîfor example, if the request tries to use a request type that hasn‚Äôt been defined or the handler throws an error.

#+begin_src javascript

  class Timeout extends Error {}

  function request(nest, target, type, content) {
      return new Promise((resolve, reject) => {
          let done = false;
          function attempt(n) {
              nest.send(target, type, content, (failed, value) => {
                  done = true;
                  if (failed) reject(failed);
                  else resolve(value);
              });
              setTimeout(() => {
                  if (done) return;
                  // we need to use a recursive function a loop doesn‚Äôt
                  // allow us to stop and wait for an asynchronous action
                  else if (n < 3) attempt(n + 1);
                  else reject(new Timeout("Timed out"));
              }, 250);
          }
          attempt(1);
      });
  }

#+end_src

*** Implicit try‚Ä¶catch
The code of a promise executor and promise handlers has an ‚Äúinvisible ~try..catch~ ‚Äù around it. If an exception happens, it gets caught and treated as a rejection.

#+begin_src javascript

  new Promise((resolve, reject) => {
      throw new Error("Whoops!");
  }).catch(alert); // Error: Whoops!

  // ‚Ä¶Works exactly the same as this:
  new Promise((resolve, reject) => {
      reject(new Error("Whoops!"));
  }).catch(alert); // Error: Whoops!

#+end_src

The ‚Äúinvisible ~try..catch~ ‚Äù around the executor automatically catches the error and turns it into rejected promise.

This happens not only in the executor function, but in its handlers as well. If we ~throw~ inside a ~.then~ handler, that means a rejected promise, so the control jumps to the nearest error handler.

#+begin_src javascript

  new Promise((resolve, reject) => {
    resolve("ok");
  }).then((result) => {
    throw new Error("Whoops!"); // rejects the promise
  }).catch(alert); // Error: Whoops!

#+end_src

This happens for all errors, not just those caused by the ~throw~ statement. For example, a programming error:

#+begin_src javascript

  new Promise((resolve, reject) => {
    resolve("ok");
  }).then((result) => {
    blabla(); // no such function
  }).catch(alert); // ReferenceError: blabla is not defined

#+end_src

The final ~.catch~ not only catches explicit rejections, but also accidental errors in the handlers above.

*Note*: Error in setTimeout
In the example below the ~.catch~ won't trigger. As said in the chapter, there‚Äôs an ‚Äúimplicit ~try..catch~ ‚Äù around the function code. So all *synchronous* errors are handled.

But here the error is generated not while the executor is running, but later. So the promise can‚Äôt handle it.

#+begin_src javascript

  new Promise(function(resolve, reject) {
      setTimeout(() => {
          throw new Error("Whoops!");
      }, 1000);
  }).catch(alert);

#+end_src

*Note*: the next codes and [[Notes about timeline (INS)][timeline]] section explain better what happens in the above example (INS).

1. ~throw new Error~ inside of the ~setTimeout~.

In this case the error can only be caught by the implicit ~try catch~, but the ~try catch~ is executed in the global program sequence, and the ~setTimeout~ is executed afterwards.

#+begin_src javascript

  console.log("0 start program")

  let promise = new Promise(function(resolve, reject) {
      console.log("1 inside the promise (start)")

      setTimeout(() => {
          console.log("2 inside the setTimeout (start)")
          // throw an error
          throw new Error("Whoops!");
          console.log("3 inside the setTimeout (end)")
      }, 1000)

      console.log("4 inside the promise (end)")
  })

  console.log("5 before catch()")
  promise.catch(x => {
      console.log("6 inside catch result: " + x)
  })
  console.log("7 after catch()")

  console.log("8 end program")

  // 0 start program
  // 1 inside the promise (start)
  // 4 inside the promise (end)
  // 5 before catch()
  // 7 after catch()
  // 8 end program
  // 2 inside the setTimeout (start)

  // > Uncaught Error: Whoops!
  // at /home/rich/trials/trial-test/js-tests/test.js:8:14
  //         throw new Error("Whoops!");
  //         ^
  // Error: Whoops!

#+end_src

2. Handler ~reject("REJECT")~ inside of the ~setTimeout~.

In this case, the error can be caught by the ~reject("REJECT")~ handler, which then triggers the promise failure, and the ~catch()~ handler is executed.

#+begin_src javascript

  console.log("0 start program")

  let promise = new Promise(function(resolve, reject) {
      console.log("1 inside the promise (start)")

      setTimeout(() => {
          console.log("2 inside the setTimeout (start)")
          // reject handler
          reject("REJECT")
          console.log("3 inside the setTimeout (end)")
        }, 1000)

      console.log("4 inside the promise (end)")
  })

  console.log("5 before catch()")
  promise.catch(x => {
      console.log("6 inside catch result: " + x)
  })
  console.log("7 after catch()")

  console.log("8 end program")
  // 0 start program
  // 1 inside the promise (start)
  // 4 inside the promise (end)
  // 5 before catch()
  // 7 after catch()
  // 8 end program
  // 2 inside the setTimeout (start)
  // 3 inside the setTimeout (end)
  // 6 inside catch result: REJECT

#+end_src

*** Promise.all()
The ~Promise.all()~ static method takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises fulfill (including when an empty iterable is passed), with an array of the fulfillment values. It rejects when any of the input's promises rejects, with this first rejection reason.

#+begin_src javascript

  // Syntax:
  Promise.all(iterable)


  // Example:
  const promise1 = Promise.resolve(3);
  const promise2 = 42;
  const promise3 = new Promise((resolve, reject) => {
    setTimeout(resolve, 100, 'foo');
  });

  Promise.all([promise1, promise2, promise3]).then((values) => {
    console.log(values);
  });
  // Expected output: Array [3, 42, "foo"]

#+end_src

** Asynchronous timing
This example sets a timeout but then dallies until after the timeout‚Äôs intended point of time, causing the timeout to be late.

#+begin_src javascript

  let start = Date.now();
  setTimeout(() => {
      console.log("Timeout ran at", Date.now() - start);
  }, 20);
  while (Date.now() < start + 50) {}
  console.log("Wasted time until", Date.now() - start);
  // Eloquent
  // ‚Üí Wasted time until 50
  // ‚Üí Timeout ran at    55

  // Chromium:
  // ‚Üí Wasted time until 50
  // ‚Üí Timeout ran at    51

  // Firefox:
  // ‚Üí Wasted time until 50
  // ‚Üí Timeout ran at    52

  // Node.js:
  // ‚Üí Wasted time until 50
  // ‚Üí Timeout ran at    63

#+end_src

*NOTE*: promises always resolve or reject as a new event. Even if a promise is already resolved, *waiting for it will cause your callback to run after the current script finishes*, rather than right away.

#+begin_src javascript

  Promise.resolve("Done").then(console.log);
  console.log("Me first!");
  // ‚Üí Me first!
  // ‚Üí Done

#+end_src

** Async functions
*** Brief
*Eloquent*
JavaScript allows you to write *pseudo-synchronous code to describe asynchronous computation*. An ~async~ function is a function that implicitly returns a promise and that can, in its body, ~await~ other promises in a way that looks synchronous (~async~ functions, allow you to write an asynchronous program as if it were synchronous.).

An ~async~ function is marked by the word ~async~ before the ~function~ keyword. Methods can also be made ~async~ by writing ~async~ before their name. When such a function or method is called, it returns a promise. As soon as the body returns something, that promise is resolved. If it throws an exception, the promise is rejected.

Inside an ~async~ function, the word ~await~ can be put in front of an expression to wait for a promise to resolve and only then continue the execution of the function.

Such a function no longer, like a regular JavaScript function, runs from start to completion in one go. Instead, it can be *frozen* at any point that has an ~await~, and can be resumed at a later time.

*For non-trivial asynchronous code, this notation is usually more convenient than directly using promises*. Even if you need to do something that doesn‚Äôt fit the synchronous model, such as perform multiple actions at the same time, it is easy to combine ~await~ with the direct use of promises.

*Note*: arrow functions can also be made ~async~ by putting the word ~async~ in front of them.

#+begin_src javascript

  network(nest).map(async name => {
      list += `${name}: ${
        await anyStorage(nest, name, `chicks in ${year}`)
      }\n`;
  })

#+end_src

*** Definition (syntax/interface)
**** Javascript.Info
The word ‚Äúasync‚Äù before a function means one simple thing: a function always returns a promise. Other values are wrapped in a resolved promise automatically.

#+begin_src javascript

  // This function returns a resolved promise with the result of 1:
  async function f() {
    return 1;
  }

  f().then(alert); // 1

  // ‚Ä¶We could explicitly return a promise, which would be the same:
  async function f() {
    return Promise.resolve(1);
  }

  f().then(alert); // 1

#+end_src

There‚Äôs another keyword, ~await~, that works only inside ~async~ functions. The keyword ~await~ makes JavaScript wait until that promise *settles* and returns its *result*.

#+begin_src javascript

  // Here‚Äôs an example with a promise that resolves in 1 second:
  async function f() {

      let promise = new Promise((resolve, reject) => {
          setTimeout(() => resolve("done!"), 1000)
      });

      let result = await promise; // wait until the promise resolves (*)

      alert(result); // "done!"
  }

  f();
  // The function execution ‚Äúpauses‚Äù at the line (*) and resumes when the
  // promise settles, with result becoming its result. So the code above
  // shows ‚Äúdone!‚Äù in one second.

#+end_src

Let‚Äôs emphasize: ~await~ *literally suspends the function execution* until the promise settles, and then resumes it with the promise result. That doesn‚Äôt cost any CPU resources, because the JavaScript engine can do other jobs in the meantime: execute other scripts, handle events, etc.

It‚Äôs just a more elegant syntax of getting the promise result than ~promise.then~. And, it‚Äôs easier to read and write.

When we use ~async/await~, we rarely need ~.then~, because ~await~ handles the waiting for us. And we can use a regular ~try..catch~ instead of ~.catch~. That‚Äôs usually (but not always) more convenient.

~async/await~ works well with ~Promise.all~
When we need to wait for multiple promises, we can wrap them in ~Promise.all~ and then ~await~:

#+begin_src javascript

  // wait for the array of results
  let results = await Promise.all([
    fetch(url1),
    fetch(url2),
    ...
  ]);

#+end_src

In the case of an error, it propagates as usual, from the failed promise to ~Promise.all~, and then becomes an exception that we can catch using ~try..catch~ around the call.

**** W3Schools
"async and await make promises easier to write"
~async~ makes a function return a Promise
~await~ makes a function wait for a Promise

#+begin_src javascript

  async function myFunctionAsync() {
      return "Hello";
  }

  // Is the same as:
  function myFunctionNormal() {
      return Promise.resolve("Hello");
  }

  // Even though the return value of an async function behaves as if it is
  // wrapped in a Promise.resolve, they are not equivalent.

  // An async function will return a different reference, whereas
  // Promise.resolve returns the same reference if the given value is a
  // promise.

  // It can be a problem when you want to check the equality of a promise
  // and a return value of an async function.

  console.log(myFunctionNormal());
  // Promise { 'Hello' }
  console.log(myFunctionAsync());
  // Promise { 'Hello' }

  console.log(myFunctionAsync() === myFunctionNormal());
  // false

#+end_src

**** MDN
An ~async function~ declaration creates an ~AsyncFunction~ object. Each time when an async function is called, it returns a new ~Promise~ which will be resolved with the value returned by the async function, or rejected with an exception uncaught within the async function.

Async functions can contain zero or more ~await~ expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of ~async~ and ~await~ enables the use of ordinary ~try~ / ~catch~ blocks around asynchronous code.

*Note*: async function avoid the need to explicitly configure promise chains.

#+begin_src javascript

  function resolveAfter2Seconds() {
      return new Promise((resolve) => {
          setTimeout(() => {
              resolve('resolved');
          }, 2000);
      });
  }
  async function asyncCall() {
      console.log('calling');
      const result = await resolveAfter2Seconds();
      console.log(result);
  }
  asyncCall();
  // calling
  // resolved


  // Async functions always return a promise. If the return value of an
  // async function is not explicitly a promise, it will be implicitly
  // wrapped in a promise.
  async function foo() {
      return 1;
  }

  // It is similar to:
  function fooSimilar() {
      return Promise.resolve(1);
  }


  // Note: 'await' is like a .then() (INS)
  async function foo() {
      const promise = Promise.resolve(1);
      console.log(promise);
      const result = await promise; // 'await' unwraps the promise
      console.log(result);
  }

  // It is similar to:
  function asyncFooSimilar() {
      const promise = Promise.resolve(1);
      console.log(promise);
      promise.then(console.log);
  }

  foo();
  asyncFooSimilar();
  // Promise { 1 }
  // Promise { 1 }
  // 1
  // 1

#+end_src

*Note*: an async function without an await expression will run synchronously. If there is an await expression inside the function body, however, the async function will always complete asynchronously.

*** Error handling
If a promise resolves normally, then ~await promise~ returns the result. But in the case of a rejection, it throws the error, just as if there were a ~throw~ statement at that line.

#+begin_src javascript

  async function f() {
    await Promise.reject(new Error("Whoops!"));
  }

  // ‚Ä¶is the same as this:
  async function f() {
    throw new Error("Whoops!");
  }

#+end_src

We can catch that error using ~try..catch~, the same way as a regular ~throw~:

#+begin_src javascript

  async function f() {

    try {
      let response = await fetch('http://no-such-url');
    } catch(err) {
      alert(err); // TypeError: failed to fetch
    }
  }

  f();

  // In the case of an error, the control jumps to the catch block. We
  // can also wrap multiple lines:
  async function f() {

    try {
      let response = await fetch('/no-user-here');
      let user = await response.json();
    } catch(err) {
      // catches errors both in fetch and response.json
      alert(err);
    }
  }

  f();
#+end_src

If we don‚Äôt have ~try..catch~, then the promise generated by the call of the async function ~f()~ becomes rejected. We can append ~.catch~ to handle it:

#+begin_src javascript

  async function f() {
    let response = await fetch('http://no-such-url');
  }

  // f() becomes a rejected promise
  f().catch(alert); // TypeError: failed to fetch // (*)

  // If we forget to add .catch there, then we get an unhandled promise
  // error (viewable in the console).

#+end_src

*** Asynchronous bugs (gaps whitin the code)
When your program runs synchronously, in a single go, there are no state changes happening except those that the program itself makes. For asynchronous programs this is different‚Äîthey may have *gaps* in their execution during which other code can run.

Let‚Äôs look at an example. One of the hobbies of our crows is to count the number of chicks that hatch throughout the village every year. Nests store this count in their storage bulbs. The following code tries to enumerate the counts from all the nests for a given year:

#+begin_src javascript

  function anyStorage(nest, source, name) {
      if (source == nest.name) return storage(nest, name);
      else return routeRequest(nest, source, "storage", name);
  }

  async function chicks(nest, year) {
      let list = "";
      await Promise.all(network(nest).map(async name => {
          list += `${name}: ${
        await anyStorage(nest, name, `chicks in ${year}`)
      }\n`;
      }));
      return list;
  }


  async function chicks(nest, year) {
      let lines = network(nest).map(async name => {
          return name + ": " +
              await anyStorage(nest, name, `chicks in ${year}`);
      });
      return (await Promise.all(lines)).join("\n");
  }

#+end_src

The code doesn‚Äôt immediately look suspicious...it maps the ~async~ arrow function over the set of nests, creating an array of promises, and then uses ~Promise.all~ to wait for all of these before returning the list they build up.

But it is seriously broken. It‚Äôll always return only a single line of output, listing the nest that was slowest to respond.

#+begin_src javascript

  chicks(bigOak, 2017).then(console.log);

#+end_src

Can you work out why?

The problem lies in the ~+=~ operator, which takes the *current* value of ~list~ at the time where the statement starts executing and then, when the ~await~ finishes, sets the ~list~ binding to be that value plus the added string.

But between the time where the statement starts executing and the time where it finishes there‚Äôs an asynchronous gap. The ~map~ expression runs before anything has been added to the list, so each of the ~+=~ operators starts from an empty string and ends up, when its storage retrieval finishes, setting ~list~ to a single-line list‚Äîthe result of adding its line to the empty string.

This could have easily been avoided by returning the lines from the mapped promises and calling ~join~ on the result of ~Promise.all~, instead of building up the list by changing a binding. As usual, computing new values is less error-prone than changing existing values.

#+begin_src javascript

  async function chicks(nest, year) {
      let lines = network(nest).map(async name => {
          return name + ": " +
              await anyStorage(nest, name, `chicks in ${year}`);
      });
      return (await Promise.all(lines)).join("\n");
  }

#+end_src

Mistakes like this are easy to make, especially when using ~await~, and you should be aware of where the gaps in your code occur. An advantage of JavaScript‚Äôs *explicit* asynchronicity (whether through callbacks, promises, or ~await~) is that spotting these gaps is relatively easy.

** Generators
*** Eloquent
JavaScript has a feature called /generator/ functions. These are similar to [[Async functions][async]], but without the promises.

When you define a function with ~function*~, it becomes a generator. When you call a generator, it returns an [[The iterator interface][iterator]].

#+begin_src javascript

  function* powers(n) {
      for (let current = n;; current *= n) {
          yield current;
      }
  }

  for (let power of powers(3)) {
      if (power > 50) break;
      console.log(power);
  }
  // ‚Üí 3
  // ‚Üí 9
  // ‚Üí 27

#+end_src

Initially, when you call ~powers~, the function is frozen at its start. Every time you call ~next~ on the iterator, the function runs until it hits a ~yield~ expression, which pauses it and causes the yielded value to become the next value produced by the iterator. When the function returns (the one in the example never does), the iterator is done.

Writing iterators is often much easier when you use generator functions.

There‚Äôs no longer a need to create an object to hold the iteration state‚Äîgenerators automatically save their local state every time they yield.

Such ~yield~ expressions may occur only directly in the generator function itself and not in an inner function you define inside of it. The state a generator saves, when yielding, is only its *local* environment and the position where it yielded.

An ~async~ function is a special type of generator. It produces a promise when called, which is resolved when it returns (finishes) and rejected when it throws an exception. Whenever it yields (awaits) a promise, the result of that promise (value or thrown exception) is the result of the ~await~ expression.

*** MDN
A ~function*~ declaration creates a ~GeneratorFunction~ object. Each time when a generator function is called, it returns a new ~Generator~ object, which conforms to the [[The iterator interface][iterator]] protocol. When the iterator's ~next()~ method is called, the generator function's body is executed until the first ~yield~ expression, which specifies the value to be returned from the iterator or, with ~yield*~, delegates to another generator function. The ~next()~ method returns an object with a ~value~ property containing the yielded value and a ~done~ property which indicates whether the generator has yielded its last value, as a boolean. Calling the ~next()~ method with an argument will resume the generator function execution, replacing the ~yield~ expression where an execution was paused with the argument from ~next()~.

Generators in JavaScript ‚Äî especially when combined with Promises ‚Äî are a very powerful tool for asynchronous programming as they mitigate ‚Äî if not entirely eliminate -- the problems with callbacks, such as Callback Hell and Inversion of Control. However, an even simpler solution to these problems can be achieved with [[Async functions][async functions]].

A ~return~ statement in a generator, when executed, will make the generator finish (i.e. the ~done~ property of the object returned by it will be set to ~true~). If a value is returned, it will be set as the ~value~ property of the object returned by the generator. Much like a ~return~ statement, an error thrown inside the generator will make the generator finished ‚Äî unless caught within the generator's body. When a generator is finished, subsequent ~next()~ calls will not execute any of that generator's code, they will just return an object of this form: ~{value: undefined, done: true}~.

~function*~ declarations behave similar to ~function~ declarations ‚Äî they are hoisted to the top of their scope and can be called anywhere in their scope, and they can be redeclared only in certain contexts.

#+begin_src javascript

  function* generator(i) {
      yield i;
      yield i + 10;
  }

  const gen = generator(10);

  console.log(gen.next().value); // 10
  console.log(gen.next().value); // 20


  // Example:
  function* idMaker() {
      let index = 0;
      while (true) {
          yield index++;
      }
  }

  const gen = idMaker();

  console.log(gen.next().value); // 0
  console.log(gen.next().value); // 1
  console.log(gen.next().value); // 2
  console.log(gen.next().value); // 3
  // ‚Ä¶


  // Example with yield*
  function* anotherGenerator(i) {
      yield i + 1;
      yield i + 2;
      yield i + 3;
  }

  function* generator(i) {
      yield i;
      yield* anotherGenerator(i);
      yield i + 10;
  }

  const gen = generator(10);

  console.log(gen.next().value); // 10
  console.log(gen.next().value); // 11
  console.log(gen.next().value); // 12
  console.log(gen.next().value); // 13
  console.log(gen.next().value); // 20

#+end_src

* Document Object Model
** Brief
JavaScript programs may inspect and interfere with the document that the browser is displaying through a data structure called the DOM. This data structure represents the browser‚Äôs model of the document, and a JavaScript program can modify it to change the visible document.

The DOM is organized like a tree, in which elements are arranged hierarchically according to the structure of the document. The objects representing elements have properties such as [[parentNode]] and [[childNodes]], which can be used to navigate through this tree.

The way a document is displayed can be influenced by *styling*, both by attaching styles to nodes directly and by defining rules that match certain nodes. There are many different style properties, such as ~color~ or ~display~. JavaScript code can manipulate an element‚Äôs style directly through its [[Manipulating styles (style property)][style]] property.

** DOM
The Document Object Model (DOM) is a programming interface for web documents. It represents the page so that programs can change the document structure, style, and content. The DOM represents the document as nodes and objects; that way, programming languages can interact with the page.

All of the properties, methods, and events available for manipulating and creating web pages are organized into objects.

In other words: The HTML DOM is a standard for how to get, change, add, or delete HTML elements.

*Eloquent*
When you open a web page in your browser, the browser retrieves the page‚Äôs HTML text and parses it, much like the way our parser from Chapter 12 (Project: A Programming Language "Egg") *parsed programs*. The browser builds up a model of the document‚Äôs structure and uses this model to draw the page on the screen.

This representation of the document is one of the toys that a JavaScript program has available in its sandbox. It is a data structure that you can read or modify. It acts as a *live* data structure: when it‚Äôs modified, the page on the screen is updated to reflect the changes.

The data structure the browser uses to represent the document follows this shape. For each box, there is an object, which we can interact with to find out things such as what HTML tag it represents and which boxes and text it contains. This representation is called the *Document Object Model*, or *DOM* for short.

The global binding [[Document]] gives us access to these objects. Its [[document.documentElement][documentElement]] property refers to the object representing the ~<html>~ tag. Since every HTML document has a head and a body, it also has ~head~ and [[document.body][body]] properties, pointing at those elements.

#+begin_src html

  <!doctype html>
  <html>
    <head>
      <title>My home page</title>
    </head>
    <body>
      <h1>My home page</h1>
      <p>Hello, I am Marijn and this is my home page.</p>
      <p>I also wrote a book! Read it
        <a href="http://eloquentjavascript.net">here</a>.</p>
    </body>
  </html>

  +-----------------------------------------------+
  | html                                          |
  | +-------------------------------------------+ |
  | | head                                      | |
  | | +---------------------------------------+ | |
  | | | title                                 | | |
  | | | My home page                          | | |
  | | +---------------------------------------+ | |
  | +-------------------------------------------+ |
  | +-------------------------------------------+ |
  | | body                                      | |
  | | +---------------------------------------+ | |
  | | | h1                                    | | |
  | | | My home page                          | | |
  | | +---------------------------------------+ | |
  | | +---------------------------------------+ | |
  | | | p                                     | | |
  | | | Hello, I am Marijn and this is...     | | |
  | | +---------------------------------------+ | |
  | | +---------------------------------------+ | |
  | | | p                            +------+ | | |
  | | | I also wrote a book! Read it | a    | | | |
  | | |                              | here | | | |
  | | |                              +------+ | | |
  | | +---------------------------------------+ | |
  | +-------------------------------------------+ |
  +-----------------------------------------------+

#+end_src

** Tree
*** Complete tree (Javascript.Info)
Every *tree node* is an object.

Tags are *element nodes* (or just elements) and form the tree structure: ~<html>~ is at the root, then ~<head>~ and ~<body>~ are its children, etc.

The text inside elements forms *text nodes*, labelled as ~#text~. A text node contains only a string. It may not have children and is always a leaf of the tree.

*Spaces and newlines* are totally valid characters, like letters and digits. They form text nodes and become a part of the DOM. So, for instance, in the example below the ~<head>~ tag contains some spaces before ~<title>~, and that text becomes a ~#text~ node (it contains a newline and some spaces only).

There are only two top-level exclusions:
1. Spaces and newlines before ~<head>~ are ignored for historical reasons.
2. If we put something after ~</body>~, then that is automatically moved inside the ~body~, at the end, as the HTML spec requires that all content must be inside ~<body>~. So there can‚Äôt be any spaces after ~</body>~.

In other cases everything‚Äôs straightforward ‚Äì if there are spaces (just like any character) in the document, then they become text nodes in the DOM, and if we remove them, then there won‚Äôt be any.

#+begin_src html

  <!DOCTYPE HTML>
  <html>
    <head>
      <title>About elk</title>
    </head>
    <body>
      The truth about elk.
    </body>
  </html>

  +------+
  | HTML |
  +------+
    |    +------+
    ‚îú--->| HEAD |
    |    +------+
    |      |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    |      ‚îú--->‚îÇ #text ‚Üµ‚ê£‚ê£  ‚îÇ
    |      |    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    |      |    +-------+
    |      ‚îú--->| TITLE |
    |      |    +-------+
    |      |      |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    |      |      ‚îî--->‚îÇ #text About elk ‚îÇ
    |      |           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    |      |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    |      ‚îî--->‚îÇ #text ‚Üµ  ‚îÇ
    |           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îú--->‚îÇ #text ‚Üµ ‚îÇ
    |    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    |    +------+
    ‚îî--->| BODY |
         +------+
           |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îî--->‚îÇ #text ‚Üµ‚ê£‚ê£ The truth about elk.‚Üµ ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

  <!-- Output: -->
  The truth about elk.

  <!-- Please note the special characters in text nodes: -->
  <!-- a newline: ‚Üµ (in JavaScript known as \n) -->
  <!-- a space: ‚ê£ -->

#+end_src

Here are no space-only text nodes:

#+begin_src html

  <!DOCTYPE HTML>
  <html><head><title>About elk</title></head><body>The truth...</body></html>

  +------+
  | HTML |
  +------+
    |    +------+
    ‚îú--->| HEAD |
    |    +------+
    |      |    +-------+
    |      ‚îî--->| TITLE |
    |           +-------+
    |             |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    |             ‚îî--->‚îÇ #text About elk ‚îÇ
    |                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    |    +------+
    ‚îî--->| BODY |
         +------+
           |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îî--->‚îÇ #text The truth about elk.  ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

#+end_src

*Note*: Spaces at string start/end and space-only text nodes are usually hidden in tools

Browser tools that work with DOM usually do not show spaces at the start/end of the text and empty text nodes (line-breaks) between tags.

Developer tools save screen space this way.

Such spaces usually do not affect how the document is displayed.

*** Complete tree (Eloquent)
Think back to the syntax trees from Chapter 12 (Project: A Programming Language "Egg"). Their structures are strikingly similar to the structure of a browser‚Äôs document. Each *node* may refer to other nodes, *children*, which in turn may have their own children. This shape is typical of *nested* structures where elements can contain subelements that are similar to themselves.

We call a data structure a *tree* when it has a branching structure, has no cycles (a node may not contain itself, directly or indirectly), and has a single, well-defined root. In the case of the DOM, [[document.documentElement]] serves as the root.

A typical tree has different kinds of nodes. The syntax tree for the Egg language had identifiers, values, and application nodes. Application nodes may have children, whereas identifiers and values are leaves, or nodes without children.

In the DOM there are nodes for *elements*, *which represent HTML tags, determine the structure of the document*. These can have child nodes. An example of such a node is [[document.body]]. Some of these children can be leaf nodes, such as pieces of text or comment nodes.

Each DOM node object has a [[nodeType]] property, which contains a code (number) that identifies the type of node. Elements have code ~1~, which is also defined as the constant property ~Node.ELEMENT_NODE~. Text nodes, representing a section of text in the document, get code ~3~ (~Node.TEXT_NODE~). Comments have code ~8~ (~Node.COMMENT_NODE~).

#+begin_src html

  <!doctype html>
  <html>
    <head>
      <title>My home page</title>
    </head>
    <body>
      <h1>My home page</h1>
      <p>Hello, I am Marijn and this is my home page.</p>
      <p>I also wrote a book! Read it
        <a href="http://eloquentjavascript.net">here</a>.</p>
    </body>
  </html>

  +------+    +------+    +-------+    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  | html |--->| head |--->| title |--->‚îÇ My home page    ‚îÇ
  +------+ |  +------+    +-------+    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           |  +------+    +-------+    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îî->| body |--->| h1    |--->‚îÇ My home page    ‚îÇ
              +------+ |  +-------+    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       |  +-------+    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                       ‚îú->| p     |--->‚îÇ Hello! I am...  ‚îÇ
                       |  +-------+    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       |  +-------+    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                       ‚îî->| p     |--->‚îÇ I also wrote... ‚îÇ
                          +-------+ |  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    |  +-----+    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                    ‚îú->| a   |--->‚îÇ here ‚îÇ
                                    |  +-----+    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    |  ‚îå‚îÄ‚îÄ‚îÄ‚îê
                                    ‚îî->‚îÇ . ‚îÇ
                                       ‚îî‚îÄ‚îÄ‚îÄ‚îò

#+end_src

*** Example complex tree
*The Modern JavaScript Tutorial*
We may think ‚Äì why is a comment added to the DOM? It doesn‚Äôt affect the visual representation in any way. But there‚Äôs a rule ‚Äì if something‚Äôs in HTML, then it also must be in the DOM tree.

*Everything in HTML, even comments, becomes a part of the DOM.*

Even the ~<!DOCTYPE...>~ directive at the very beginning of HTML is also a DOM node. It‚Äôs in the DOM tree right before ~<html>~. Few people know about that.

The [[Document]] object that represents the whole document is, formally, a DOM node as well.

#+begin_src html

  <!DOCTYPE HTML>
  <html>
    <body>
      The truth about elk.
      <ol>
        <li>An elk is a smart</li>
        <!-- comment -->
        <li>...and cunning animal!</li>
      </ol>
    </body>
  </html>

  +------+
  | HTML |
  +------+
    |    +------+
    ‚îú--->| HEAD |
    |    +------+
    |    +------+
    ‚îî--->| BODY |
         +------+
           |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îú--->‚îÇ #text ‚Üµ‚ê£‚ê£The truth about elk.‚Üµ‚ê£‚ê£‚îÇ
           |    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           |    +----+
           ‚îú--->| OL |
           |    +----+
           |      |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           |      ‚îú--->‚îÇ #text ‚Üµ‚ê£‚ê£‚ê£‚ê£  ‚îÇ
           |      |    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           |      |    +----+
           |      ‚îú--->| LI |
           |      |    +----+
           |      |      |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           |      |      ‚îî--->‚îÇ #text An elk is a smart ‚îÇ
           |      |           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           |      |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           |      ‚îú--->‚îÇ #text ‚Üµ‚ê£‚ê£‚ê£‚ê£  ‚îÇ
           |      |    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           |      |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           |      ‚îú--->‚îÇ #comment comment ‚îÇ
           |      |    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           |      |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           |      ‚îú--->‚îÇ #text ‚Üµ‚ê£‚ê£‚ê£‚ê£  ‚îÇ
           |      |    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           |      |    +----+
           |      ‚îú--->| LI |
           |      |    +----+
           |      |       |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           |      |       ‚îî--->‚îÇ #text ...and cunning animal! ‚îÇ
           |      |            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           |      |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           |      ‚îî--->‚îÇ #text ‚Üµ‚ê£‚ê£  ‚îÇ
           |           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           |    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îî--->‚îÇ #text ‚Üµ‚ê£‚ê£‚ê£ ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

#+end_src

** Manipulating the node tree (data structure)
*** Moving through the tree
DOM nodes contain a wealth of links to other nearby nodes.

#+begin_src html

    <body>
      <h1>My home page</h1>
      <p>Hello, I am Marijn and this is my home page.</p>
      <p>I also wrote a book!</p>
    </body>

    ‚îå--------‚îê                 ‚îå--‚îê
    |        |  childNodes     |  | firsChild
    |     +--------------------|-------------+
    v     |  body              v             |
  +---+   |  +----------------------------+  |
  | 0 |---|->| h1                         |  |
  |   |   |  | My home page               |  |
  |   |   |  +----------------------------+  |
  |   |   |    ^                             |
  |   |   |    | previousSibling             |<-‚îê
  |   |   |  +----------------------------+  |  |
  | 1 |---|->| p                          |-----‚îò
  |   |   |  | Hello, I am Marijn...      |  |parentNode
  |   |   |  +----------------------------+  |
  |   |   |    | nextSibling                 |
  |   |   |    v                             |
  |   |   |  +----------------------------+  |
  | 2 |---|->| p                          |  |
  +---+   |  | I also wrote a book!       |  |
          |  +----------------------------+  |
          |                    ^             |
          +--------------------|-------------+
                            |  | lastChild
                            ‚îî--‚îò

#+end_src

Although the diagram shows only one link of each type, every node has a [[parentNode]] property that points to the node it is part of, if any. Likewise, every element node (node type 1) has a [[childNodes]] property that points to an *array-like object* holding its children.

In theory, you could move anywhere in the tree using just these parent and child links.

*Note*: For a first child, [[previousSibling]] will be ~null~, and for a last child, ~nextSibling~ will be ~null~.

There‚Äôs also the [[children]] property, which is like ~childNodes~ but contains only element (type 1) children, not other types of child nodes. This can be useful when you aren‚Äôt interested in text nodes.

The following example scans a document for text nodes containing a given string and returns ~true~ when it has found one:

#+begin_src javascript

  function talksAbout(node, string) {
      if (node.nodeType == Node.ELEMENT_NODE) {
          for (let child of node.childNodes) {
              if (talksAbout(child, string)) {
                  return true;
              }
          }
          return false;
      } else if (node.nodeType == Node.TEXT_NODE) {
          return node.nodeValue.indexOf(string) > -1;
      }
  }

  console.log(talksAbout(document.body, "book")); // ‚Üí true

#+end_src

*** Finding elements
All element nodes have a [[document.getElementsByTagName()]] method, which collects all elements with the given tag name that are descendants (direct or indirect children) of that node and returns them as an array-like object.

#+begin_src javascript

  let link = document.body.getElementsByTagName("a")[0];
  console.log(link.href);
  // http://eloquentjavascript.net/

#+end_src

To find a specific *single* node, you can give it an ~id~ attribute and use ~document.getElementById~ instead.

#+begin_src javascript

  <p>My ostrich Gertrude:</p>
  <p><img id="gertrude" src="img/ostrich.png"></p>

  <script>
    let ostrich = document.getElementById("gertrude");
    console.log(ostrich.src);
    // http://localhost:8000/img/ostrich.png
  </script>

#+end_src

A third, similar method is [[document.getElementsByClassName()]], which, like ~document.getElementsByTagName~, searches through the contents of an element node and retrieves all elements that have the given string in their ~class~ attribute.

*** Changing the document
Nodes have a [[remove()]] method to remove them from their current parent node.

To add a child node to an element node, we can use [[appendChild()]], which puts it at the end of the list of children, or [[insertBefore()]], which inserts the node given as the first argument before the node given as the second argument.

#+begin_src html

  <p>One</p>
  <p>Two</p>
  <p>Three</p>

  <script>
    let paragraphs = document.body.getElementsByTagName("p");
    document.body.insertBefore(paragraphs[2], paragraphs[0]);
  </script>

#+end_src

A node can exist in the document in only one place. Thus, inserting paragraph /Three/ in front of paragraph /One/ will first remove it from the end of the document and then insert it at the front, resulting in /Three/One/Two/. *All operations that insert a node somewhere will, as a side effect*, cause it to be removed from its current position (if it has one).

The [[replaceChild()]] method is used to replace a child node with another one. It takes as arguments two nodes: a new node and the node to be replaced. The replaced node must be a child of the element the method is called on.

*Note* that both ~replaceChild~ and ~insertBefore~ expect the *new* node as their first argument.

*** Creating nodes
*Text nodes* are created with the [[document.createTextNode()]] method.

Say we want to write a script that replaces all images (~<img>~ tags) in the document with the text held in their ~alt~ attributes, which specifies an alternative textual representation of the image.

#+begin_src javascript

  <p>The <img src="img/cat.png" alt="Cat"> in the
  <img src="img/hat.png" alt="Hat">.</p>

  <p><button onclick="replaceImages()">Replace</button></p>

  <script>
  function replaceImages() {
      let images = document.body.getElementsByTagName("img");
      for (let i = images.length - 1; i >= 0; i--) {
          let image = images[i];
          if (image.alt) {
              let text = document.createTextNode(image.alt);
              image.parentNode.replaceChild(text, image);
          }
      }
  }
  </script>
  // The loop that goes over the images starts at the end of the list. This
  // is necessary because the node list returned by a method like
  // getElementsByTagName (or a property like childNodes) is *live*.

#+end_src

To create *element nodes*, you can use the [[document.createElement()]] method. This method takes a tag name and returns a new empty node of the given type.

The following example defines a utility ~elt~, which creates an element node and treats the rest of its arguments as children to that node. This function is then used to add an attribution to a quote.

#+begin_src javascript

  <blockquote id="quote">
    No book can ever be finished. While working on it we learn
    just enough to find it immature the moment we turn away from it.
  </blockquote>

  <script>
  function elt(type, ...children) {
      let node = document.createElement(type);
      for (let child of children) {
          if (typeof child != "string") node.appendChild(child);
          else node.appendChild(document.createTextNode(child));
      }
      return node;
  }

  document.getElementById("quote").appendChild(
      elt("footer", "‚Äî",
          elt("strong", "Karl Popper"),
          ", preface to the second edition of ",
          elt("em", "The Open Society and Its Enemies"),
          ", 1950"));
  </script>

#+end_src

*** Attributes
Some element attributes, such as ~href~ for links, can be accessed through a property of the same name on the element‚Äôs DOM object.

But HTML allows you to set any attribute you want on nodes. This can be useful because it allows you to store extra information in a document. If you make up your *own attribute names*, though, such attributes *will not be present as properties on the element‚Äôs node*. Instead, you have to use the [[getAttribute()]] and [[setAttribute()]] methods to work with them.

*Note*: (specification)
[[Attr]] objects inherit the ~Node~ interface, but since *they are not actually child nodes of the element they describe*, the DOM does *not consider them part of the document tree*. Thus, the ~Node~ attributes ~parentNode~, ~previousSibling~, and ~nextSibling~ have a ~null~ value for ~Attr~ objects. The DOM takes the view that *attributes are properties of elements* rather than having a separate identity from the elements they are associated with; this should make it more efficient to implement such features as default attributes associated with all elements of a given type. Furthermore, ~Attr~ nodes may not be immediate children of a ~DocumentFragment~. However, they can be associated with Element nodes contained within a ~DocumentFragment~. In short, users and implementors of the DOM need to be aware that ~Attr~ nodes have some things in common with other objects inheriting the ~Node~ interface, but they also are quite distinct.

*Note*: remember the ‚Äúnode‚Äù attribute is not a node itself of the document DOM (is not part of the document tree), it cannot be retrieved by the usual methods. However, when they refer to the value as in the statement above, they refer to the value of the attribute *object*. (INS)

#+begin_src javascript

  <a href="https://www.example.com/" own="something"></a>

  <script>
    let a = document.body.getElementsByTagName("a")[0];
    console.log(a.href)
    console.log(a.getAttribute("href"))
    console.log(a.own)
    console.log(a.getAttribute("own"))
  </script>
  // https://www.example.com/
  // https://www.example.com/
  // undefine
  // something


  <p data-classified="secret">The launch code is 00000000.</p>
  <p data-classified="unclassified">I have two feet.</p>

  <script>
  let paras = document.body.getElementsByTagName("p");
  for (let para of Array.from(paras)) {
      if (para.getAttribute("data-classified") == "secret") {
          para.remove();
      }
  }
  </script>
  // It is recommended to prefix the names of such made-up attributes with
  // data- to ensure they do not conflict with any other attributes.

#+end_src

*Note*: There is a commonly used attribute, ~class~, which is a keyword in the JavaScript language. For historical reasons‚Äîsome old JavaScript implementations could not handle property names that matched keywords‚Äîthe property used to access this attribute is called ~className~. You can also access it under its real name, ~"class"~ , by using the ~getAttribute~ and ~setAttribute~ methods.

** Manipulating the layout (size, position)
*** Size and position (offsetWidth, clientWidth, ...)
The size and position of an element can be accessed from JavaScript. The ~offsetWidth~ and ~offsetHeight~ properties give you the space the element takes up in *pixels*.

Similarly, ~clientWidth~ and ~clientHeight~ give you the size of the space *inside* the element, ignoring border width.

#+begin_src javascript

  <p style="border: 3px solid red">
  I am boxed in
  </p>

  <script>
  let para = document.body.getElementsByTagName("p")[0];
  console.log("clientHeight:", para.clientHeight);
  console.log("offsetHeight:", para.offsetHeight);
  </script>

#+end_src

#+begin_src

     -----
       |
       |    ‚îå-----------------------------------------------------‚îê  --------
       |    |                                                     |      |
 ---------  |   ‚îå---------------------------------------------‚îê   |      |
     |      |   |                                         | ‚ñ≤ |   |      |
     |      |   |     padding                             |   |   |      |
     |      |   |                                         |   |   |      |
clientHeigh |   |          ‚îå------------------------------| ‚ïê |   |      |
     |      |   |          |         content area         |   |   | offsetHeigh
     |      |   |          |                              |   |   |      |
     |      |   |          |                              | ‚ñº |   |      |
 ---------  |   |-----------------------------------------+---|   |      |
       |    |   |‚óÄ                         ‚ïë‚ïë‚ïë           ‚ñ∂|   |   |      |
       |    |   ‚îî---------------------------------------------‚îò   |      |
       |    |  border                                             |      |
       |    ‚îî-----------------------------------------------------‚îò  --------
       |        |----------------clientWidth--------------|
       |    |----------------------offsetWidth--------------------|
       |        |---------------------------scrollWidth-----------------------|
   scrollHeight            ‚îÜ
       |                   ‚îÜ
       |                   ‚îÜ
       |                   ‚îÜ         content area
     -----                 ‚îî-------------------------------

#+end_src

#+begin_src

            ‚îå-----------------------------------------------------‚îê   --------
            | Firefox                                       _ x ‚ñ° |      |
            ‚îå-----------------------------------------------------‚îê      |
            |                                                     |      |
  -------   |   ‚îå---------------------------------------------‚îê   |      |
     |      |   |                                         | ‚ñ≤ |   |      |
     |      |   |     padding                             |   |   |      |
     |      |   |                                         |   |   |      |
     |      |   |          ‚îå------------------------------| ‚ïê |   |  outerHeigh
 innerHeigh |   |          |          content area        |   |   |      |
     |      |   |          |                              |   |   |      |
     |      |   |          |                              | ‚ñº |   |      |
     |      |   |-----------------------------------------+---|   |      |
     |      |   |‚óÄ                         ‚ïë‚ïë‚ïë           ‚ñ∂|   |   |      |
  -------   |   ‚îî---------------------------------------------‚îò   |      |
       |    |  border                                             |      |
       |    ‚îî-----------------------------------------------------‚îò  --------
       |        |----------------clientWidth--------------|
       |    |----------------------offsetWidth--------------------|
       |        |---------------------------scrollWidth-----------------------|
   scrollHeight            ‚îÜ
       |                   ‚îÜ
       |                   ‚îÜ
       |                   ‚îÜ          content area
     -----                 ‚îî-------------------------------

#+end_src

*** Find precise position (getBoundingClientRect, pageXOffset, ...)
The most effective way to find the precise position of an element on the *screen* is the [[getBoundingClientRect()][getBoundingClientRect]] method. It returns an object with ~top~, ~bottom~, ~left~, and ~right~ properties, indicating the pixel positions of the sides of the element relative to the top left of the screen. If you want them relative to the *whole document*, you must add the current scroll position, which you can find in the ~pageXOffset~ and ~pageYOffset~ bindings.

Laying out a document can be quite a lot of work. In the interest of speed, browser engines do not immediately re-layout a document every time you change it but wait as long as they can. When a JavaScript program that changed the document finishes running, the browser will have to compute a new layout to draw the changed document to the screen. When a program *asks* for the position or size of something by reading properties such as ~offsetHeight~ or calling ~getBoundingClientRect~, providing correct information also requires computing a layout.

A program that repeatedly alternates between reading DOM layout information and changing the DOM forces a lot of layout computations to happen and will consequently run very slowly. The following code is an example of this. It contains two different programs that build up a line of X characters 2,000 pixels wide and measures the time each one takes.

#+begin_src javascript

  <p><span id="one"></span></p>
  <p><span id="two"></span></p>

  <script>
    function time(name, action) {
        let start = Date.now(); // Current time in milliseconds
        action();
        console.log(name, "took", Date.now() - start, "ms");
    }

    time("naive", () => {
        let target = document.getElementById("one");
        while (target.offsetWidth < 2000) {
            target.appendChild(document.createTextNode("X"));
        }
     });
  // ‚Üí naive took 32 ms

  time("clever", function() {
      let target = document.getElementById("two");
      target.appendChild(document.createTextNode("XXXXX"));
      // calculate how many "X" we need to fill 2000 width
      let total = Math.ceil(2000 / (target.offsetWidth / 5));
      target.firstChild.nodeValue = "X".repeat(total);
  });
  // ‚Üí clever took 1 ms
  </script>

#+end_src

*** Manipulating styles (style property)
JavaScript code can directly manipulate the ~style~ of an element *through the element‚Äôs style property*. This property holds an object that has properties for all possible style properties. The values of these properties are strings, which we can write to in order to change a particular aspect of the element‚Äôs style.

#+begin_src javascript

  <p id="para" style="color: purple">
    Nice text
  </p>

  <script>
    let para = document.getElementById("para");
    console.log(para.style.color);
    para.style.color = "magenta";
  </script>

#+end_src

*Note*: some style property names contain hyphens, such as ~font-family~. Because such property names are awkward to work with in JavaScript (you‚Äôd have to say ~style["font-family"]~), the property names in the ~style~ object for such properties have their hyphens removed and the letters after them capitalized (~style.fontFamily~).

*Cascading styles*
Styles in a ~style~ attribute applied *directly* to the node have the highest precedence and always win.

The main reason I introduced *selector* syntax‚Äîthe notation used in style sheets to determine which elements a set of styles apply to‚Äîis that we can use this same mini-language as an effective way to find DOM elements.

*** Positioning and animating (requestAnimationFrame)
The ~position~ style property *influences layout in a powerful way*. By default it has a value of ~static~, meaning the element sits in its normal place in the document. When it is set to ~relative~, the element still takes up space in the document, but now the ~top~ and ~left~ style properties can be used to move it relative to that normal place.

When ~position~ is set to ~absolute~, the element is removed from the normal document flow‚Äîthat is, it no longer takes up space and may overlap with other elements. Also, its ~top~ and ~left~ properties can be used to absolutely position it relative to the top-left corner of the nearest enclosing element whose ~position~ property isn‚Äôt ~static~, or relative to the document if no such enclosing element exists.

We can use this to create an animation. The following document displays a picture of a cat that moves around in an ellipse:

#+begin_src javascript

  <p style="text-align: center">
    <img src="img/cat.png" style="position: relative">
  </p>

   <script>
    let cat = document.querySelector("img");
    let angle = Math.PI / 2;
    function animate(time, lastTime) {
        if (lastTime != null) {
            // from the second call onwards
            angle += (time - lastTime) * 0.001;
        }
        // Note that styles usually need units.
        cat.style.top = (Math.sin(angle) * 20) + "px";
        cat.style.left = (Math.cos(angle) * 200) + "px";
        requestAnimationFrame(newTime => animate(newTime, time));
    }
    requestAnimationFrame(animate);
  </script>
  // The animation function is passed the current time as an argument. To
  // ensure that the motion of the cat per millisecond is stable, it bases
  // the speed at which the angle changes on the difference between the
  // current time and the last time the function ran. If it just moved the
  // angle by a fixed amount per step, the motion would stutter if, for
  // example, another heavy task running on the same computer were to
  // prevent the function from running for a fraction of a second.

#+end_src

The script uses [[requestAnimationFrame()]] to schedule the ~animate~ function to run whenever the browser is ready to repaint the screen. The ~animate~ function itself again calls ~requestAnimationFrame~ to schedule the next update. When the browser window (or tab) is active, this will cause updates to happen at a rate of about 60 per second, which tends to produce a good-looking animation.

If we just updated the DOM in a loop, the page would freeze, and nothing would show up on the screen. *Browsers do not update their display while a JavaScript program is running, nor do they allow any interaction with the page*. This is why we need ~requestAnimationFrame~ ‚Äîit lets the browser know that we are done for now, and it can go ahead and do the things that browsers do, such as updating the screen and responding to user actions.

** Interfaces (data types)
*** Window
The ~Window~ interface represents a window containing a [[Document Object Model][DOM]] document; the ~document~ property points to the [[Document][DOM document]] loaded in that window.

A window for a given document can be obtained using the ~document.defaultView~ property.

A global variable, ~window~, representing the window in which the script is running, is exposed to JavaScript code.

The Window interface is home to a variety of functions, namespaces, objects, and constructors which are not necessarily directly associated with the concept of a user interface window. However, the Window interface is a suitable place to include these items that need to be globally available.

In a tabbed browser, each tab is represented by its own ~Window~ object; the global ~window~ seen by JavaScript code running within a given tab always represents the tab in which the code is running. That said, even in a tabbed browser, some properties and methods still apply to the overall window that contains the tab, such as ~resizeTo()~ and ~innerHeight~. Generally, anything that can't reasonably pertain to a tab pertains to the window instead.

#+begin_src

  +-------------+    +--------+
  | EventTarget |<---| Window |
  +-------------+    +--------+

#+end_src

*** Document
The ~Document~ interface represents any web page loaded in the browser and serves as an entry point into the web page's content, which is the [[Tree][DOM tree]].

The DOM tree includes elements such as ~<body>~ and ~<table>~, among many others. It provides functionality globally to the document, like how to obtain the page's URL and create new elements in the document.

#+begin_src

  +-------------+    +------+    +----------+
  | EventTarget |<---| Node |<---| Document |
  +-------------+    +------+    +----------+

#+end_src

The ~document~ and ~window~ objects are the objects whose interfaces you generally use most often in DOM programming. In simple terms, the ~window~ object represents something like the browser, and the ~document~ object is the root of the document itself. ~Element~ inherits from the generic ~Node~ interface, and together these two interfaces provide many of the methods and properties you use on individual elements. These elements may also have specific interfaces for dealing with the kind of data those elements hold.

This interface also inherits properties from the [[Node]] and [[EventTarget]] interfaces.

The following is a brief list of common APIs in web and XML page scripting using the DOM.

- [[document.querySelector()]]
- [[document.querySelectorAll()]]
- [[document.createElement()]]
- [[innerHTML][Element.innerHTML]]
- [[setAttribute()][Element.setAttribute()]]
- [[getAttribute()][Element.getAttribute()]]
- [[addEventListener()][EventTarget.addEventListener()]]
- [[HTMLElement: style][HTMLElement.style]]
- [[appendChild()][Node.appendChild()]]
- [[load event][window.onload]]
- [[window.scrollTo()]]

*** EventTarget
The ~EventTarget~ interface is implemented by objects that can receive events and may have listeners for them. In other words, any target of events implements the three methods associated with this interface.

[[Element]], and its children, as well as [[Document]] and [[Window]], are the most common event targets, but other objects can be event targets, too. For example ~IDBRequest~, ~AudioNode~, and ~AudioContext~ are also event targets.

Many [[Event handlers][event targets]] (including elements, documents, and windows) also support setting event handlers via ~onevent~ properties and attributes.

*** Node
Every object located within a document is a node of some kind. In an HTML document, an object can be an element node but also a text node or attribute node.

[[Attr][Note]]: ~Attr~ objects inherit the ~Node~ interface, but since *they are not actually child nodes of the element they describe*, the DOM *does not consider them part of the document tree*.

In addition, every kind of DOM node is represented by an interface based on ~Node~. These include ~Attr~, ~CharacterData~ (which ~Text~, ~Comment~, ~CDATASection~ and ~ProcessingInstruction~ are all based on), and ~DocumentType~.

An object that *participates* in a tree has a *parent*, which is either ~null~ or an object, and has children, which is an ordered set of objects.

~Node~ inherits *properties* from its parent, [[EventTarget]], like ~Node.baseURI~, ~Node.childNodes~, ~Node.firstChild~, ... and also ~Node~ inherits *methods* like ~Node.appendChild()~, ~Node.cloneNode()~, ~Node.insertBefore()~ and others.

The *DOM Node interface* is an abstract base class upon which many other DOM API objects are based, thus letting those object types to be used similarly and often interchangeably. As an abstract class, there is no such thing as a plain ~Node~ object. All objects that implement ~Node~ functionality are based on one of its subclasses. Most notable are ~Document~, ~Element~, and ~DocumentFragment~.

#+begin_src

  +-------------+    +------+
  | EventTarget |<---| Node |
  +-------------+    +------+

#+end_src

*** Element
~Element~ is the most general base class from which all element objects (i.e. objects that represent elements) in a [[Document]] inherit. It only has methods and properties common to all kinds of elements. More specific classes inherit from ~Element~.

For example, the ~HTMLElement~ interface is the base interface for any HTML elements. Similarly, the ~SVGElement~ interface is the basis for all SVG elements.

~Element~ inherits properties from its parent interface, [[Node]], and by extension that interface's parent, [[EventTarget]].

#+begin_src

  +-------------+    +------+    +---------+    +-------------+
  | EventTarget |<---| Node |<---| Element |<---| HTMLElement |
  +-------------+    +------+    +---------+    +-------------+

#+end_src

*** HTMLElement
The ~HTMLElement~ interface represents any HTML element. Some elements directly implement this interface, while others implement it via an interface that inherits it.

#+begin_src

  +-------------+    +------+    +---------+    +-------------+
  | EventTarget |<---| Node |<---| Element |<---| HTMLElement |
  +-------------+    +------+    +---------+    +-------------+

#+end_src

*** Attr
The ~Attr~ interface represents one of an element's attributes as an object. In most situations, you will directly retrieve the attribute value as a string (e.g., [[getAttribute()][Element.getAttribute()]]), but certain functions (e.g., ~Element.getAttributeNode()~) or means of iterating return ~Attr~ instances.

*Note*: ~Attr~ objects inherit the ~Node~ interface, but since *they are not actually child nodes of the element they describe*, the DOM *does not consider them part of the document tree*.

*Note*: remember the ‚Äúnode‚Äù attribute is not a node itself of the document DOM (is not part of the document tree), it cannot be retrieved by the usual methods. However, when they refer to the value as in the statement above, they refer to the value of the attribute *object*. (INS)

*NOTE*: because the ~Attr~ object is also a ~Node~, it inherits the ~Node~ object's properties and methods. However, *an attribute does not have a parent node and is not considered to be a child node of an element*, and will return ~null~ for many of the ~Node~ properties.

#+begin_src

  +-------------+    +------+    +------+
  | EventTarget |<---| Node |<---| Attr |
  +-------------+    +------+    +------+

#+end_src

The core idea of an object of type ~Attr~ is the association between a *name* and a *value*. An attribute may also be part of a namespace and, in this case, it also has a URI identifying the namespace, and a prefix that is an abbreviation for the namespace.

*Note*: (attr nodes)
~Attr~ nodes may not be immediate children of a ~DocumentFragment~. However, they can be associated with Element nodes contained within a ~DocumentFragment~. In short, users and implementors of the DOM need to be aware that ~Attr~ nodes have some things in common with other objects inheriting the ~Node~ interface, but they also are quite distinct.

*Note*:
When an ~attribute~ is returned by a member (e.g., by the ~createAttribute()~ method), it is an object reference that exposes a special (albeit small) interface for attributes. Attributes are nodes in the DOM just like elements are, though you may rarely use them as such.

*Note*: be careful, the attributes (HTML) are not necessarily the same as the properties. (INS)

*** DocumentFragment
The ~DocumentFragment~ interface represents a minimal document object that has no parent.

It is used as a lightweight version of [[Document]] that stores a segment of a document structure comprised of nodes just like a standard document. The key difference is due to the fact that the document fragment isn't part of the active document tree structure. Changes made to the fragment don't affect the document.

#+begin_src

  +-------------+    +------+    +------------------+
  | EventTarget |<---| Node |<---| DocumentFragment |
  +-------------+    +------+    +------------------+

#+end_src

*Note*: the [[content][HTMLTemplateElement.content]] property returns a ~<template>~ element's template contents (a ~DocumentFragment~).

A common use for ~DocumentFragment~ is to *create one*, assemble a DOM subtree within it, then append or insert the fragment into the DOM using [[Node]] interface methods.

#+begin_src javascript

  // <ul></ul>

  const ul = document.querySelector("ul");
  const fruits = ["Apple", "Orange", "Banana", "Melon"];

  const fragment = new DocumentFragment();

  for (const fruit of fruits) {
      const li = document.createElement("li");
      li.textContent = fruit;
      fragment.append(li);
  }

  ul.append(fragment);

  // - Apple
  // - Orange
  // - Banana
  // - Melon

#+end_src

*** ShadowRoot
The ~ShadowRoot~ interface of the Shadow DOM API is the root node of a DOM subtree that is rendered separately from a document's main DOM tree.

You can retrieve a reference to an element's shadow root using its ~Element.shadowRoot~ property, provided it was created using [[attachShadow()][Element.attachShadow()]] with the ~mode~ option set to ~open~.

#+begin_src

  +-------------+    +------+    +------------------+    +------------+
  | EventTarget |<---| Node |<---| DocumentFragment |<---| ShadowRoot |
  +-------------+    +------+    +------------------+    +------------+

#+end_src

*** HTMLInputElement
The ~HTMLInputElement~ interface provides special properties and methods for manipulating the options, layout, and *presentation of ~<input>~ elements*.

#+begin_src artist

  +-----------+   +----+   +-------+   +-----------+   +----------------+
  |EventTarget|<--|Node|<--|Element|<--|HTMLElement|<--|HTMLEInputlement|
  +-----------+   +----+   +-------+   +-----------+   +----------------+

#+end_src

*** HTMLCollection
The ~HTMLCollection~ interface represents a generic collection (*array-like object* similar to ~arguments~) of elements (in document order) and offers methods and properties for selecting from the list.

An ~HTMLCollection~ in the HTML DOM is live; it is automatically updated when the underlying document is changed. For this reason it is a good idea to make a copy (e.g., using [[Array.from]]) to iterate over if adding, moving, or removing nodes.

*Note*: This interface was an attempt to create an unmodifiable list and only continues to be supported to not break code that's already using it. Modern APIs use types that wrap around ECMAScript array types instead, so you can treat them like ECMAScript arrays, and at the same time impose additional semantics on their usage (such as making their items read-only).

*** FileReader
The ~FileReader~ interface lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using ~File~ or ~Blob~ objects to specify the file or data to read.

File objects may be obtained from a ~FileList~ object returned as a result of a user selecting files using the ~<input>~ element, or from a drag and drop operation's ~DataTransfer~ object.

~FileReader~ can only access the contents of files that the user has explicitly selected, either using an HTML ~<input type="file">~ element or by drag and drop. It cannot be used to read a file by pathname from the user's file system. To read files on the client's file system by pathname, use the File System Access API. To read server-side files, use ~fetch()~, with CORS permission if reading cross-origin.

#+begin_src

  +-------------+    +------------+
  | EventTarget |<---| FileReader |
  +-------------+    +------------+

#+end_src

* Handling Events
** Brief
[[Event handlers]] make it possible to detect and react to events happening in our web page. The [[addEventListener()]] method is used to register such a handler.

Each event has a type ( ~"keydown"~ , ~"focus"~ , and so on) that identifies it. Most events are called on a specific DOM element and then [[Propagation][propagate]] to that element‚Äôs ancestors, allowing handlers associated with those elements to handle them.

When an event handler is called, it is passed an [[Event objects][event object]] with additional information about the event. This object also has methods that allow us to stop further propagation ([[event.stopPropagation()]]) and prevent the browser‚Äôs [[Default actions][default handling]] of the event ([[event.preventDefault()]]).

Pressing a [[Key events][key]] fires ~"keydown"~ and ~"keyup"~ events. Pressing a [[Mouse clicks][mouse]] button fires ~"mousedown"~ , ~"mouseup"~ , and ~"click"~ events. [[Mouse motion][Moving]] the mouse fires ~"mousemove"~ events. [[Touch events][Touchscreen]] interaction will result in ~"touchstart"~ , ~"touchmove"~ , and ~"touchend"~ events.

[[Scroll events][Scrolling]] can be detected with the ~"scroll"~ event, and [[Focus events][focus]] changes can be detected with the ~"focus"~ and ~"blur"~ events. When the document finishes loading, a [[Load events]["load"]] event fires on the window.

Giving a node an ~onclick~ attribute has a similar effect than ~addEventListener("click",f)~. This works for most types of events‚Äîyou can attach a handler through the attribute whose name is the event name with ~on~ in front of it. But a node can have only one ~onclick~ attribute, so you can register only one handler per node that way.

Most event objects have a [[target]] property that refers to the *node where they originated*.

** Event handlers
There is a mechanism by which the system actively notifies our code when an event occurs. Browsers do this by allowing us to register functions as *handlers* for specific events.

#+begin_src javascript

 <p>Click this document to activate the handler.</p>

 <script>
   window.addEventListener("click", () => {
       console.log("You knocked?");
   });
  </script>

#+end_src

The ~window~ binding refers to a built-in object provided by the browser. It represents the browser window that contains the document. Calling its [[addEventListener()]] method registers the second argument to be called whenever the event described by its first argument occurs.

*Events and DOM nodes*
Each browser event handler is registered in a context. In the previous example we called [[addEventListener()]] on the ~window~ object to register a handler for the whole window. Such a method can also be found on DOM elements and some other types of objects. Event listeners are called only when the event happens in the context of the object they are registered on.

#+begin_src javascript

  <button>Click me</button>
  <p>No handler here.</p>

  <script>
    let button = document.querySelector("button");
    button.addEventListener("click", () => {
      console.log("Button clicked.");
    });
  </script>

#+end_src

Giving a node an ~onclick~ attribute has a similar effect. This works for most types of events‚Äîyou can attach a handler through the attribute whose name is the event name with ~on~ in front of it.

But a node can have only one ~onclick~ attribute, so you can register only one handler per node that way. The [[addEventListener()]] method allows you to add any number of handlers so that it is safe to add handlers even if there is already another handler on the element.

The [[removeEventListener()]] method, called with arguments similar to ~addEventListener~, removes a handler.

** Event objects
Event handler functions are passed an argument: the *event object*. This object holds additional information about the event. For example, if we want to know *which* mouse button was pressed, we can look at the event object‚Äôs ~button~ property.

The information stored in an event object differs per type of event. The object‚Äôs ~type~ property always holds a string identifying the event (such as ~"click"~ or ~"mousedown"~).

#+begin_src javascript

  <button>Click me any way you want</button>

  <script>
    let button = document.querySelector("button");
    button.addEventListener("mousedown", event => {
      if (event.button == 0) {
          console.log("Left button");
      } else if (event.button == 1) {
          console.log("Middle button");
      } else if (event.button == 2) {
          console.log("Right button");
      }
  });
  </script>

#+end_src

** Propagation
For most event types, *handlers registered on nodes with children will also receive events that happen in the children*. If a button inside a paragraph is clicked, event handlers on the paragraph will also see the click event.

But if both the paragraph and the button have a handler, the more specific handler‚Äîthe one on the button‚Äîgets to go first. The event is said to *propagate outward*, from the node where it happened to that node‚Äôs parent node and on to the root of the document. Finally, after all handlers registered on a specific node have had their turn, handlers registered on the whole window get a chance to respond to the event.

At any point, an event handler can call the [[event.stopPropagation()][stopPropagation]] method on the event object to prevent handlers further up from receiving the event. This can be useful when, for example, you have a button inside another clickable element and you don‚Äôt want clicks on the button to activate the outer element‚Äôs click behavior.

The following example registers ~"mousedown"~ handlers on both a button and the paragraph around it. When clicked with the right mouse button, the handler for the button calls ~stopPropagation~, which will prevent the handler on the paragraph from running. When the button is clicked with another mouse button, both handlers will run.

#+begin_src javascript


  <p>A paragraph with a <button>button</button>.</p>

  <script>
    let para = document.querySelector("p");
    let button = document.querySelector("button");
    para.addEventListener("mousedown", () => {
      console.log("Handler for paragraph.");
    });
    button.addEventListener("mousedown", event => {
        console.log("Handler for button.");
        if (event.button == 2) event.stopPropagation();
    });
  </script>

#+end_src

Most event objects have a [[target]] property that refers to the *node where they originated*. You can use this property to ensure that you‚Äôre not accidentally handling something that propagated up from a node you do not want to handle.

It is also possible to use the ~target~ property to cast a wide net for a specific type of event. For example, if you have a node containing a long list of buttons, it may be more convenient to register a single click handler on the outer node and have it use the ~target~ property to figure out whether a button was clicked, rather than register individual handlers on all of the buttons.

#+begin_src javascript

  <button>A</button>
  <button>B</button>
  <button>C</button>

  <script>
    document.body.addEventListener("click", event => {
        if (event.target.nodeName == "BUTTON") {
            console.log("Clicked", event.target.textContent);
        }
    });
  </script>

#+end_src

** Default actions
Many events have a default action associated with them. If you click a link, you will be taken to the link‚Äôs target. If you press the down arrow, the browser will scroll the page down. If you right-click, you‚Äôll get a context menu. And so on.

For most types of events, the JavaScript event handlers are called *before* the default behavior takes place. If the handler doesn‚Äôt want this normal behavior to happen, typically because it has already taken care of handling the event, it can call the [[event.preventDefault()][preventDefault]] method on the event object.

This can be used to implement your own keyboard shortcuts or context menu. It can also be used to obnoxiously interfere with the behavior that users expect. For example, here is a link that cannot be followed:

#+begin_src javascript

 <a href="https://developer.mozilla.org/">MDN</a>

 <script>
   let link = document.querySelector("a");
   link.addEventListener("click", event => {
     console.log("Nope.");
     event.preventDefault();
  });
  </script>

#+end_src

Depending on the browser, some events can‚Äôt be intercepted at all. On Chrome, for example, the keyboard shortcut to close the current tab (control-W or command-W) cannot be handled by JavaScript.

** Types of events
*** Key events
When a key on the keyboard is pressed, your browser fires a ~"keydown"~ event. When it is released, you get a ~"keyup"~ event.

#+begin_src javascript

  <p>This page turns violet when you hold the V key.</p>

  <script>
  window.addEventListener("keydown", event => {
      if (event.key == "v") {
          document.body.style.background = "violet";
      }
  });
  window.addEventListener("keyup", event => {
      if (event.key == "v") {
          document.body.style.background = "";
      }
  });
  </script>

#+end_src

Despite its name, ~"keydown"~ fires not only when the key is physically pushed down. When a key is pressed and held, the event fires again every time the key *repeats*. Sometimes you have to be careful about this. For example, if you add a button to the DOM when a key is pressed and remove it again when the key is released, you might accidentally add hundreds of buttons when the key is held down longer.

Modifier keys such as =shift= , =control= , =alt= , and =meta= generate key events just like normal keys. But when looking for key combinations, you can also find out whether these keys are held down by looking at the ~shiftKey~, ~ctrlKey~, ~altKey~, and ~metaKey~ properties of keyboard and mouse events.

#+begin_src javascript

  <p>Press Control-Space to continue.</p>

  <script>
    window.addEventListener("keydown", event => {
        if (event.key == " " && event.ctrlKey) {
            console.log("Continuing!");
        }
    });
  </script>

#+end_src

The DOM node where a key event originates depends on the element that has focus when the key is pressed. Most nodes cannot have focus unless you give them a ~tabindex~ attribute, but things like links, buttons, and form fields can. When nothing in particular has focus, ~document.body~ acts as the target node of key events.

To notice when something was typed, elements that you can type into, such as the ~<input>~ and ~<textarea>~ tags, fire [[Text fields]["input"]] events whenever the user changes their content. To get the actual content that was typed, it is best to directly read it from the focused field.

*Note*: The key names of the arrow keys are ~"ArrowUp"~ and ~"ArrowDown"~.

*** Pointer events
**** Mouse clicks
Pressing a mouse button causes a number of events to fire. The ~"mousedown"~ and ~"mouseup"~ events are similar to [[Key events]["keydown"]] and ~"keyup"~ and fire when the button is pressed and released. These happen on the DOM nodes that are immediately below the mouse pointer when the event occurs.

After the ~"mouseup"~ event, a ~"click"~ event fires on the most specific node that contained *both* the press and the release of the button. For example, if I press down the mouse button on one paragraph and then move the pointer to another paragraph and release the button, the ~"click"~ event will happen on the element that contains both those paragraphs.

If two clicks happen close together, a ~"dblclick"~ (double-click) event also fires, after the second click event.

To get precise information about the place where a mouse event happened, you can look at its ~clientX~ and ~clientY~ properties, which contain the event‚Äôs coordinates (in pixels) relative to the top-left corner of the window, or ~pageX~ and ~pageY~, which are relative to the top-left corner of the whole document (which may be different when the window has been scrolled).

The following implements a primitive drawing program. Every time you click the document, it adds a dot under your mouse pointer.

#+begin_src javascript

  // css
  <style>
    body {
        height: 200px;
        background: beige;
    }
    .dot {
        height: 8px; width: 8px;
        border-radius: 4px; /* rounds corners */
        background: blue;
        position: absolute;
    }
  </style>

  //js
  <script>
    window.addEventListener("click", event => {
        let dot = document.createElement("div");
        dot.className = "dot";
        dot.style.left = (event.pageX - 4) + "px";
        dot.style.top = (event.pageY - 4) + "px";
        document.body.appendChild(dot);
    });
  </script>

#+end_src

**** Mouse motion
Every time the mouse pointer moves, a ~"mousemove"~ event is fired. This event can be used to track the position of the mouse. A common situation in which this is useful is when implementing some form of mouse-dragging functionality.

As an example, the following program displays a bar and sets up event handlers so that dragging to the left or right on this bar makes it narrower or wider:

#+begin_src javascript

  <p>Drag the bar to change its width:</p>
  <div style="background: orange; width: 60px; height: 20px">
  </div>

  <script>
    let lastX; // Tracks the last observed mouse X position
    let bar = document.querySelector("div");
    bar.addEventListener("mousedown", event => { // Note that's "mousedown"
      if (event.button == 0) { // Note the singular: "button"
        lastX = event.clientX;
        window.addEventListener("mousemove", moved); // Note that's "mousedown"
        event.preventDefault(); // Prevent selection
      }
  });

  function moved(event) {
    if (event.buttons == 0) { // Note the pulural: "buttons"
      // Note that's "mousemove"
      window.removeEventListener("mousemove", moved);
    } else {
      let dist = event.clientX - lastX;
      let newWidth = Math.max(10, bar.offsetWidth + dist);
      bar.style.width = newWidth + "px";
      lastX = event.clientX;
    }
  }
  </script>

#+end_src

Note that the ~"mousemove"~ handler is registered on the whole window. Even if the mouse goes outside of the bar during resizing, as long as the button is held we still want to update its size.

We must stop resizing the bar when the mouse button is released. For that, we can use the ~buttons~ property (*note the plural*), which tells us about the buttons that are currently held down. When this is zero, no buttons are down. When buttons are held, its value is the sum of the codes for those buttons‚Äîthe left button has code 1, the right button 2, and the middle one 4. With the left and right buttons held, for example, the value of ~buttons~ will be 3.

Note that the order of these codes is different from the one used by ~button~, where the middle button came before the right one. As mentioned, consistency isn‚Äôt really a strong point of the browser‚Äôs programming interface.

**** Touch events
Mouse events cover touch interaction only in straightforward cases‚Äîif you add a ~"click"~ handler to a button, touch users will still be able to use it. But other things don't work on a touchscreen.

There are specific event types fired by touch interaction. When a finger starts touching the screen, you get a ~"touchstart"~ event. When it is moved while touching, ~"touchmove"~ events fire. Finally, when it stops touching the screen, you‚Äôll see a ~"touchend"~ event.

Because many touchscreens can detect multiple fingers at the same time, these events don‚Äôt have a single set of coordinates associated with them. Rather, their event objects have a ~touches~ property, which holds an array-like object of points, each of which has its own ~clientX~, ~clientY~, ~pageX~, and ~pageY~ properties.

You‚Äôll often want to call [[event.preventDefault()]] in touch event handlers to override the browser‚Äôs default behavior (which may include scrolling the page on swiping) and to prevent the mouse events from being fired, for which you may also have a handler.

#+begin_src javascript

  // Show red circles around every touching finger:
  <style>
    dot { position: absolute; display: block;
          border: 2px solid red; border-radius: 50px;
         height: 100px; width: 100px; }
  </style>
  <p>Touch this page</p>

  <script>
    function update(event) {
        for (let dot; dot = document.querySelector("dot");) {
            dot.remove();
        }
        // event.touches.length => # of fingers touching the screen
        for (let i = 0; i < event.touches.length; i++) {
            let {pageX, pageY} = event.touches[i];
            let dot = document.createElement("dot");
            dot.style.left = (pageX - 50) + "px";
            dot.style.top = (pageY - 50) + "px";
            document.body.appendChild(dot);
        }
  }
  window.addEventListener("touchstart", update);
  window.addEventListener("touchmove", update);
  window.addEventListener("touchend", update);
  </script>

  // Example of how it works: If there is a finger touching the screen a
  // "dot" is created, now if the finger keeps touching the screen and
  // another finger also touches the screen, the "update" function is
  // called again, removing the old "dot" and creating two new "dots".

#+end_src

*** Scroll events
Whenever an element is scrolled, a ~"scroll"~ event is fired on it. This has various uses, such as knowing what the user is currently looking at (for disabling off-screen animations or sending spy reports to your evil headquarters) or showing some indication of progress (by highlighting part of a table of contents or showing a page number).

#+begin_src javascript

  // The following example draws a progress bar above the document and
  // updates it to fill up as you scroll down:
  // css
  <style>
    #progress {
        border-bottom: 2px solid blue;
        width: 0;
        position: fixed;
        top: 0; left: 0;
    }
  </style>

  <div id="progress"></div>

  <script>
  // Create some content
  document.body.appendChild(document.createTextNode(
    "supercalifragilisticexpialidocious ".repeat(1000)));

  let bar = document.querySelector("#progress");
  window.addEventListener("scroll", () => {
      let max = document.body.scrollHeight - innerHeight;
      bar.style.width = `${(pageYOffset / max) * 100}%`;
  });
  </scrip>

#+end_src

The global ~innerHeight~ binding gives us the height of the window, which we have to subtract from the total scrollable height‚Äîyou can‚Äôt keep scrolling when you hit the bottom of the document. There‚Äôs also an ~innerWidth~ for the window width. By dividing ~pageYOffset~, the current scroll position, by the maximum scroll position and multiplying by 100, we get the percentage for the progress bar.

Calling [[event.preventDefault()][preventDefault]] on a scroll event does not prevent the scrolling from happening. In fact, the event handler is called only *after* the scrolling takes place.

*** Focus events
When an element gains focus, the browser fires a ~"focus"~ event on it. When it loses focus, the element gets a ~"blur"~ event.

Some events, like these two and ~"scroll"~, do not propagate. A handler on a parent element is not notified when a child element gains or loses focus.

The DOM node where a key event originates depends on the element that has focus when the key is pressed. Most nodes cannot have focus unless you give them a ~tabindex~ attribute, but things like links, buttons, and form fields can. When nothing in particular has focus, ~document.body~ acts as the target node of key events.

To notice when something was typed, elements that you can type into, such as the ~<input>~ and ~<textarea>~ tags, fire [[Text fields]["input"]] events whenever the user changes their content. To get the actual content that was typed, it is best to directly read it from the focused field.

The window object will receive "focus" and "blur" events when the user moves from or to the browser tab or window in which the document is shown.

#+begin_src javascript

  // Displays help text for the text field that currently has focus:
  <p>Name: <input type="text" data-help="Your full name"></p>
  <p>Age: <input type="text" data-help="Your age in years"></p>
  <p id="help"></p>

  <script>
    let help = document.querySelector("#help");
    let fields = document.querySelectorAll("input");
    for (let field of Array.from(fields)) {
        field.addEventListener("focus", event => {
            let text = event.target.getAttribute("data-help");
            help.textContent = text;
        });
        field.addEventListener("blur", event => {
            help.textContent = "";
        });
    }
  </script>

#+end_src

*** Load events
When a page finishes loading, the ~"load"~ event fires on the window and the document body objects. This is often used to schedule initialization actions that require the whole document to have been built. Remember that the content of ~<script>~ tags is run immediately when the tag is encountered. This may be too soon, for example when the script needs to do something with parts of the document that appear after the ~<script>~ tag.

Elements such as images and script tags that load an external file *also have* a ~"load"~ event that indicates the files they reference were loaded. Like the focus-related events, loading events do not propagate.

When a page is closed or navigated away from (for example, by following a link), a ~"beforeunload"~ event fires. The main use of this event is to prevent the user from accidentally losing work by closing a document. If you prevent the default behavior on this event *and* set the ~returnValue~ property on the event object to a string, the browser will show the user a dialog asking if they really want to leave the page. That dialog might include your string, but because some malicious sites try to use these dialogs to confuse people into staying on their page to look at dodgy weight loss ads, most browsers no longer display them.

*** Events and properties
**** Events table
***** Key

| /EVENT/      | /DESCRIPTION/                                     |
|------------+-------------------------------------------------|
| /keydown/    | fired when a key is pressed                     |
| /keyup/      | fired when a key is released                    |
|            |                                                 |
| /focus/      | when an element has received focus              |
| /blur/       | when an element has lost focus                  |
| /input/      | when the value of an <input>, <select>, or      |
|            | <textarea> element has been changed as a        |
|            | direct result of a user action                  |

***** Pointer

| /EVENT/      | /DESCRIPTION/                                     |
|------------+-------------------------------------------------|
| /click/      | when primary button is both pressed and         |
|            | released while the pointer is inside the ele    |
| /dblclick/   | fires when a pointing is double-clicked         |
|            |                                                 |
| /mousedown/  | fired at an Element when a pointing is pressed  |
|            | while the pointer is inside the element         |
| /mouseup/    | fired at an Element when a button on a pointing |
|            | is released while the pointer is located inside |
| /mousemove/  | fired at an element when a pointing is moved    |
|            | while the cursor's hotspot is inside it         |

***** Touch

| /EVENT/      | /DESCRIPTION/                                     |
|------------+-------------------------------------------------|
| /touchstart/ | fired when one/more touch points are placed     |
| /touchmove/  | fired when one/more touch points are moved      |
| /touchend/   | fires when one or more touch points are removed |
|            |                                                 |
| /touches/    | TouchList listing all the Touch objects         |
| /TouchList/  | object list of contact points on a touch        |

***** Misc

| /EVENT/        | /DESCRIPTION/                                 |
|--------------+---------------------------------------------|
| /scroll/       | when an element has been scrolled           |
| /load/         | fired when the whole page has loaded        |
| /beforeunload/ | the current window are about to be unloaded |

**** Properties table

| /PROPERTY/  | /DESCRIPTION/                                    |
|-----------+------------------------------------------------|
| /button/    | which button was pressed                       |
| /buttons/   | which buttons are pressed                      |
|           |                                                |
| /clientX/   | Xcoordinate within the application's viewport  |
| /x/         | alias for the clientX                          |
| /offsetX/   | Xoffset of the pointer between that event      |
|           | and the padding edge of the target node        |
| /pageX/     | X at which the mouse was clicked, relative to  |
|           | the left edge of the entire document           |
| /screenX/   | Xoffset of the pointer in screen coordinates   |
| /movementX/ | difference in the X of the pointer between the |
|           | given event and the previous mousemove event   |
|           |                                                |
| /ctrlKey/   | whether the ctrl key was pressed or not        |
| /altKey/    | whether the alt key was pressed or not         |
| /shiftKey/  | whether the shift key was pressed or not       |
| /metaKey/   | whether the meta key was pressed or not        |
|           |                                                |
| /tabindex/  | allows to make HTML elements focusable         |
| /ArrowUp/   | name of the up arrow key                       |
| /ArrowDown/ | name of the down arrow key                     |

**** Events properties table

| /PROPIEDAD/  | /DESCRIPCI√ìN/                                       |
|------------+---------------------------------------------------|
| /type/       | returns a string containing the event's type      |
| /target/     | reference to object on which event was dispatched |
|            |                                                   |
| /timeStamp/  | returns the time at which the event was created   |
| /bubbles/    | whether/not event bubbles up through the DOMtree  |
| /cancelable/ | whether the event can be canceled                 |
| /composed/   | which indicates whether/not event will propagate  |
|            | across the shadow DOM boundary in standard DOM    |
| /isTrusted/  | true when event was generated by the user agent   |

** Events and the event loop
In the context of the event loop, browser event handlers behave like other asynchronous notifications. They are scheduled when the event occurs *but must wait for other scripts that are running to finish before they get a chance to run*.

The fact that events can be processed only when nothing else is running means that, if the event loop is tied up with other work, any interaction with the page (which happens through events) will be delayed until there‚Äôs time to process it. So if you schedule too much work, either with long-running event handlers or with lots of short-running ones, the page will become slow and cumbersome to use.

For cases where you *really* do want *to do some time-consuming thing in the background without freezing* the page, browsers provide something called /web workers/. A worker is a JavaScript process that *runs alongside the main script*, on its *own timeline*.

Imagine that squaring a number is a heavy, long-running computation that we want to perform in a separate thread. We could write a file called ~code/squareworker.js~ that responds to messages by computing a square and sending a message back.

#+begin_src javascript

  addEventListener("message", event => {
      postMessage(event.data * event.data);
  });

#+end_src

To avoid the problems of having multiple threads touching the same data, workers do not share their global scope or any other data with the main script‚Äôs environment. Instead, you have to communicate with them by sending messages back and forth.

This code spawns a worker running that script, sends it a few messages, and outputs the responses.

#+begin_src javascript

  let squareWorker = new Worker("code/squareworker.js");
  squareWorker.addEventListener("message", event => {
      console.log("The worker responded:", event.data);
  });
  squareWorker.postMessage(10);
  squareWorker.postMessage(24);

#+end_src

The ~postMessage~ function sends a message, which will cause a ~"message"~ event to fire in the receiver. The script that created the worker sends and receives messages through the ~Worker~ object, whereas the worker talks to the script that created it by sending and listening directly on its global scope. Only values that can be represented as JSON can be sent as messages‚Äîthe other side will receive a *copy* of them, rather than the value itself.

** Timers
[[window.setTimeout()][setTimeout()]] function schedules another function to be called later, after a given number of milliseconds.

Sometimes you need to cancel a function you have scheduled. This is done by storing the value returned by ~setTimeout~ and calling [[window.clearTimeout()][clearTimeout()]] on it.

#+begin_src javascript

  let bombTimer = setTimeout(() => {
      console.log("BOOM!");
  }, 500);

  if (Math.random() < 0.5) { // 50% chance
      console.log("Defused.");
      clearTimeout(bombTimer);
  }

#+end_src

The ~cancelAnimationFrame~ function works in the same way as ~clearTimeout~ ‚Äîcalling it on a value returned by [[window.requestAnimationFrame()][requestAnimationFrame]] will cancel that frame (assuming it hasn‚Äôt already been called).

A similar set of functions, [[window.setInterval()][setInterval()]] and[[window.clearInterval()][clearInterval()]], are used to set timers that should *repeat* every X milliseconds.

#+begin_src javascript

  let ticks = 0;
  let clock = setInterval(() => {
      console.log("tick", ticks++);
      if (ticks == 10) {
          clearInterval(clock);
          console.log("stop.");
      }
  }, 200);

#+end_src

** Debouncing
Some types of events have the potential to fire rapidly, many times in a row (the ~"mousemove"~ and ~"scroll"~ events, for example). When handling such events, you must be careful not to do anything too time-consuming or your handler will take up so much time that interaction with the document starts to feel slow.

If you do need to do something nontrivial in such a handler, you can use [[window.setTimeout()][setTimeout()]] to make sure you are not doing it too often. This is usually called *debouncing* the event. There are several slightly different approaches to this.

In the first example, we want to react when the user has typed something, but we don‚Äôt want to do it immediately for every input event. When they are typing quickly, we just want to wait until a pause occurs. Instead of immediately performing an action in the event handler, we set a timeout. We also clear the previous timeout (if any) so that when events occur close together (closer than our timeout delay), the timeout from the previous event will be canceled.

#+begin_src javascript

  <textarea>Type something here...</textarea>

  <script>
    let textarea = document.querySelector("textarea");
    let timeout;
    textarea.addEventListener("input", () => {
        clearTimeout(timeout);
        timeout = setTimeout(() => console.log("Typed!"), 500);
    });
  </script>
  // Giving an undefined value to clearTimeout or calling it on a timeout
  // that has already fired has no effect. Thus, we don‚Äôt have to be
  // careful about when to call it, and we simply do so for every event.

#+end_src

We can use a slightly different pattern if we want to space responses so that they‚Äôre separated by at least a certain length of time but want to fire them *during* a series of events, not just afterward. For example, we might want to respond to ~"mousemove"~ events by showing the current coordinates of the mouse but only every 250 milliseconds.

#+begin_src javascript

  let scheduled = null;
  window.addEventListener("mousemove", event => {
      if (!scheduled) {
          setTimeout(() => {
              document.body.textContent =
                  `Mouse at ${scheduled.pageX}, ${scheduled.pageY}`;
              scheduled = null;
          }, 250);
      }
      scheduled = event;
  });

#+end_src

* Forms and fetch
** Forms
*** Brief
HTML can represent various types of *form fields*, such as text fields, checkboxes, multiple-choice fields, and file pickers.

Such fields can be inspected and manipulated with JavaScript. They fire the [["input", "change"]["change"]] event when changed, fire the [["input", "change"]["input"]] event when text is typed, and receive keyboard events when they have keyboard [[Focus, blur, tabindex][focus]]. Properties like [[value][value]] (for *text* and *select* fields) or [[Checkboxes and radio buttons][checked]] (for *checkboxes* and radio *buttons*) are used to read or set the field‚Äôs content.

When a form is submitted, a [["submit"]["submit"]] event is fired on it. A JavaScript handler can call ~preventDefault~ on that event to disable the browser‚Äôs default behavior. Form field elements may also occur outside of a form tag.

When the user has selected a file from their local file system in a file picker field, the [[File fields][FileReader]] interface can be used to access the content of this file from a JavaScript program.

The [[localStorage]] and ~sessionStorage~ objects can be used to save information in a way that survives page reloads. The first object saves the data forever (or until the user decides to clear it), and the second saves it until the browser is closed.

*** Form fields
The form elements are part of the DOM like the rest of the page, and the DOM *elements that represent form fields support a number of properties and events* that are not present on other elements. These make it possible to *inspect and control* such input fields with JavaScript programs and do things such as adding new functionality to a form or using forms and fields as building blocks in a JavaScript application.

A web form consists of any number of input fields grouped in a ~<form>~ tag. HTML allows several different styles of fields.

A lot of field *types* use the ~<input>~ tag. This tag‚Äôs ~type~ attribute is used to select the field‚Äôs style. The JavaScript interface for such elements differs with the type of the element.

- text            ::  A single-line text field
- password ::  Same as ~text~ but hides the text that is typed
- checkbox  ::  An on/off switch
- radio          ::  (Part of) a multiple-choice field
- file              ::  Allows the user to choose a file from their computer

Form fields do not necessarily have to appear in a ~<form>~ tag. You can put them anywhere in a page. Such form-less fields cannot be submitted (only a form as a whole can), but when responding to input with JavaScript, we often don‚Äôt want to submit our fields normally anyway.

*** Focus, blur, tabindex, disabled
**** focus(), blur(), document.activeElement
Unlike most elements in HTML documents, form fields can get *keyboard focus*. When clicked or activated in some other way, they become the currently active element and the recipient of keyboard input.

We can control focus from JavaScript with the ~focus~ and ~blur~ methods. The first *moves focus* to the DOM element it is called on, and the second *removes focus*. The value in ~document.activeElement~ corresponds to the currently focused element.

#+begin_src javascript

  <input type="text">

  <script>
    console.log(document.activeElement);
    // <body>...</body> // (element body)
    console.log(document.activeElement.tagName);
    // ‚Üí BODY
    document.querySelector("input").focus();
    console.log(document.activeElement.tagName);
    // ‚Üí INPUT
    document.querySelector("input").blur();
    console.log(document.activeElement.tagName);
    // ‚Üí BODY
  </script>

#+end_src

**** tabindex
Browsers traditionally also allow the user to move the focus through the document by pressing the =tab= key. We can influence the *order in which elements receive focus* with the ~tabindex~ attribute. The following example document will let the focus jump from the text input to the OK button, rather than going through the help link first:

#+begin_src html

  <input type="text" tabindex=1> <a href=".">(help)</a>
  <button onclick="console.log('ok')" tabindex=2>OK</button>

#+end_src

By default, most types of HTML elements cannot be focused. But you can add a ~tabindex~ attribute to any element that will make it focusable. A ~tabindex~ of ~-1~ makes tabbing skip over an element, even if it is normally focusable.

**** disabled
All form fields can be /disabled/ through their ~disabled~ attribute. It is an attribute that can be specified without value‚Äîthe fact that it is present at all *disables the element*.

#+begin_src html

  <button>I'm all right</button>
  <button disabled>I'm out</button>

#+end_src

Disabled fields cannot be focused or changed, and browsers make them look gray and faded.

When a program is in the process of handling an action caused by some button or other control that might require communication with the server and thus take a while, it can be a good idea to disable the control until the action finishes. That way, when the user gets impatient and clicks it again, they don‚Äôt accidentally repeat their action.

*** The form as a whole
**** form.elements
When a field is contained in a ~<form>~ element, its DOM element will have a ~form~ property *linking back to the form‚Äôs DOM element*. The ~<form>~ element, in turn, has a property called ~elements~ that *contains an array-like collection of the fields inside it*.

The ~name~ attribute of a form field determines the way its value *will be identified* when the form is submitted. It can also be used as a property [[name]] when accessing the form‚Äôs ~elements~ property, which acts both as an *array-like* object (accessible by number) and a *map* (accessible by name).

#+begin_src javascript

  <form action="example/submit.html">
    Name: <input type="text" name="name"><br>
    Password: <input type="password" name="password"><br>
    <button type="submit">Log in</button>
  </form>

  <script>
    let form = document.querySelector("form");
    console.log(form.elements[0].type);           // ‚Üí text
    console.log(form.elements[1].type);           // ‚Üí password
    console.log(form.elements.password.type);     // ‚Üí password
    console.log(form.elements.name.form == form); // ‚Üí true

    console.log(form.elements);  // [ input, input, button ]
    // HTMLFormControlsCollections(3) [ input, input, button,
    //                                   name: input, password: input ]
    console.log(form.elements.length); // 3
  </script>

#+end_src

**** "submit"
A button with a ~type~ attribute of ~submit~ will, when pressed, *cause the form to be submitted*. Pressing =ENTER= when a form field is focused has the same effect.

Submitting a form normally means that the browser navigates to the page indicated by the form‚Äôs ~action~ attribute, using either a ~GET~ or a ~POST~ request. But before that happens, a ~"submit"~ event is fired. You can handle this event with JavaScript and prevent this default behavior (don't send the request) by calling ~preventDefault~ on the event object.

#+begin_src javascript

  <form action="example/submit.html">
    Value: <input type="text" name="values">
    <button type="submit">Save</button>
  </form>

  <script>
    let form = document.querySelector("form");
    form.addEventListener("submit", event => {
        console.log("Saving value", form.elements.values.value);
        // if there's an error before here, the next line is not
        // executed and the "submit" event is fired.
        event.preventDefault();
    });
  </script>

#+end_src

Intercepting ~"submit"~ events in JavaScript has various uses. We can write code to verify that the values the user entered make sense and immediately show an error message instead of submitting the form. Or we can disable the regular way of submitting the form entirely, as in the example, and have our program handle the input, possibly using [[Fetch][fetch]] to send it to a server without reloading the page.

*** Text fields
**** value, selectionStart, selectionEnd
Fields created by ~<textarea>~ tags, or ~<input>~ tags with a type of ~text~ or ~password~, share a common interface. Their DOM elements have a [[value]] property that *holds their current content* as a string value. Setting this property to another string changes the field‚Äôs content.

*Note*: the ~value~ property differs from the other [[Difference in text properties][text properties]] in that the ~<input>~ tag specifies an *input field where the user can enter data*.

The ~selectionStart~ and ~selectionEnd~ properties of text fields give us information about the cursor and selection in the text. When *nothing is selected*, these two properties hold the same number, indicating the *position of the cursor*. For example, 0 indicates the start of the text, and 10 indicates the cursor is after the 10th character. *When part of the field is selected*, the two properties will differ, giving us the *start and end of the selected text*. Like ~value~, these properties may also be written to.

Imagine you are writing an article about Khasekhemwy but have some trouble spelling his name. The following code wires up a ~<textarea>~ tag with an event handler that, when you press =F2=, inserts the string ‚ÄúKhasekhemwy‚Äù for you.

#+begin_src javascript

  <textarea></textarea>

  <script>
    let textarea = document.querySelector("textarea");
    textarea.addEventListener("keydown", event => {
        // The key code for F2 happens to be 113
        if (event.keyCode == 113) {
            replaceSelection(textarea, "Khasekhemwy");
            event.preventDefault();
        }
  });
  function replaceSelection(field, word) {
      let from = field.selectionStart, to = field.selectionEnd;
      field.value = field.value.slice(0, from) + word +
          field.value.slice(to);
      // Put the cursor after the word
      field.selectionStart = from + word.length;
      field.selectionEnd = from + word.length;
  }
  </script>

  // Note:
  // textarea.value   = the current content (maybe change by user)
  // textarea.context = the content in html

#+end_src

**** "input", "change"
Whenever the value of a form field changes, it will fire a ~"change"~ event.

#+begin_src html

  <p><input type="text" value="abc"> (text)</p>
  <p><input type="password" value="abc"> (password)</p>
  <p><input type="checkbox" checked> (checkbox)</p>
  <p><input type="radio" value="A" name="choice">
     <input type="radio" value="B" name="choice" checked>
     <input type="radio" value="C" name="choice"> (radio)</p>
  <p><input type="file"> (file)</p>

  <!-- Multiline text fields have their own tag, <textarea>. Uses the text -->
  <!-- between those two tag, instead of the value attr, as starting text. -->
  <textarea>
    one
    two
    three
  </textarea>

  <!-- The <select> tag is used to create a field that allows the -->
  <!-- user to select from a number of predefined options. -->
  <select>
    <option>Pancakes</option>
    <option>Pudding</option>
    <option>Ice cream</option>
  </select>

#+end_src

The ~"change"~ event for a text field does not fire every time something is typed. Rather, it *fires when the field loses focus after its content was changed*. To respond immediately to changes in a text field, you should register a handler for the ~"input"~ event instead, which *fires for every time the user types a character*, *deletes* text, or otherwise manipulates the field‚Äôs content.

The following example shows a text field and a counter displaying the current length of the text in the field:

#+begin_src javascript

  <input type="text"> length: <span id="length">0</span>

  <script>
    let text = document.querySelector("input");
    let output = document.querySelector("#length");
    text.addEventListener("input", () => {
        output.textContent = text.value.length;
    });
  </script>

#+end_src

**** Example: A JavaScript workbench
Build an interface that allows people to type and run pieces of JavaScript code.

Put a button next to a ~<textarea>~ field that, when pressed, uses the ~Function~ to wrap the text in a function and call it. Convert the return value of the function, or any error it raises, to a string and display it below the text field.

#+begin_src javascript

  <!doctype html>
  <script src="code/chapter/18_http.js"></script>

  <textarea id="code">return "hi";</textarea>
  <button id="button">Run</button>
  <pre id="output"></pre>

  <script>
    document.querySelector("#button").addEventListener("click", () => {
        let code = document.querySelector("#code").value;
        let outputNode = document.querySelector("#output");
        try {
            let result = Function(code)();
            outputNode.innerText = String(result);
        } catch (e) {
            outputNode.innerText = "Error: " + e;
        }
    });
  </script>

#+end_src

*** Checkboxes and radio buttons
**** checkbox
A checkbox field is a *binary toggle*. Its value can be extracted or changed through its [[checked]] property, which holds a Boolean value.

#+begin_src javascript

  <label>
    <input type="checkbox" id="purple"> Make this page purple
  </label>

  <script>
    let checkbox = document.querySelector("#purple");
    checkbox.addEventListener("change", () => {
      document.body.style.background =
          checkbox.checked ? "mediumpurple" : "";
  });
  </script>

  // The <label> tag associates a piece of document with an input
  // field. Clicking anywhere on the label will activate the field, which
  // focuses it and toggles its value when it's a checkbox or radio button.

#+end_src

**** radio
A radio button is similar to a checkbox, but it‚Äôs implicitly *linked to other radio buttons* with the same ~name~ attribute so that only one of them can be active at any time.

#+begin_src javascript

  <label>
    <input type="radio" name="color" value="orange"> Orange
  </label>
    <label>
    <input type="radio" name="color" value="lightgreen"> Green
  </label>
    <label>
    <input type="radio" name="color" value="lightblue"> Blue
  </label>

  <script>
    let buttons = document.querySelectorAll("[name=color]");
    for (let button of Array.from(buttons)) {
        button.addEventListener("change", () => {
            document.body.style.background = button.value;
        });
    }
  </script>

  // The square brackets in the CSS query given to querySelectorAll are
  // used to match attrs. It selects elements whose name attr is "color".

#+end_src

*** Select fields (selected, options)
Select fields also have a variant that is more akin to a list of checkboxes, rather than radio boxes. When given the ~multiple~ attribute, a ~<select>~ tag will allow the user to select any number of options, rather than just a single option.

Each ~<option>~ tag has a value. This value can be defined with a [[value]] attribute. When that is not given, the text inside the option will count as its value. For a ~multiple~ field, though, this property doesn‚Äôt mean much since it will give the value of only *one* of the currently selected options.

The ~<option>~ tags for a ~<select>~ field can be *accessed as an array-like object through* the field‚Äôs ~options~ property. Each option has a property called ~selected~, which indicates *whether that option is currently selected*. The property can also be written to select or deselect an option.

This example extracts the selected values from a ~multiple~ select field and uses them to compose a binary number from individual bits. Hold =CONTROL= to select multiple options.

#+begin_src javascript

  <select multiple>
    <option value="1">0001</option>
    <option value="2">0010</option>
    <option value="4">0100</option>
    <option value="8">1000</option>
  </select> = <span id="output">0</span>

  <script>
    let select = document.querySelector("select");
    let output = document.querySelector("#output");
    select.addEventListener("change", () => {
        let number = 0;
        for (let option of Array.from(select.options)) {
            if (option.selected) {
                number += Number(option.value);
            }
        }
        output.textContent = number;
    });
  </script>

  // Note:
  // select.value = only the value attribute of the selected option
  // in the example: 1
  // select.context = the content of all options
  // in the example: 0010 0100 1000

#+end_src

*** File fields
**** files
Modern browsers provide a way to read files from JavaScript programs. The field acts as a kind of gatekeeper. The script cannot simply start reading private files from the user‚Äôs computer, but if the user selects a file in such a field, the browser interprets that action to mean that the script may read the file.

The ~files~ property of a file field element is *an array-like object* (not a real array) *containing the files chosen* in the field. It is initially empty. The reason there isn‚Äôt simply a ~file~ property is that file fields also support a ~multiple~ attribute, which makes it possible to select multiple files at the same time.

Objects in the ~files~ object have properties such as ~name~ (the filename), ~size~ (the file‚Äôs size in bytes), and ~type~ (the media type of the file).

#+begin_src javascript

  <input type="file">

  <script>
  let input = document.querySelector("input");
  input.addEventListener("change", () => {
      if (input.files.length > 0) {
          let file = input.files[0];
          console.log("You chose", file.name);
          if (file.type) console.log("It has type", file.type);
      }
  });
  </script>

#+end_src

**** Content of the file (readAsText)
The objects in ~files~ have properties such as ~name~, ~size~, and ~type~, but what it does not have is a property that contains the content of the file. Getting at that is a little more involved. Since reading a file from disk can take time, the interface ([[FileReader]] interface) must be [[Asynchronous][asynchronous]] to avoid freezing the document.

*Reading a file* is done by creating a ~FileReader~ object, registering a ~"load"~ event handler for it, and calling its [[readAsText]] method, giving it the file we want to read. Once loading finishes, the reader‚Äôs ~result~ property contains the file‚Äôs content.

#+begin_src javascript

 <input type="file" multiple>

 <script>
   let input = document.querySelector("input");
   input.addEventListener("change", () => {
      for (let file of Array.from(input.files)) {
          let reader = new FileReader();
          reader.addEventListener("load", () => {
              console.log("File", file.name, "starts with",
                          reader.result.slice(0, 20));
          });
          reader.readAsText(file);
      }
   });
  </script>

#+end_src

~FileReaders~ also fire an ~"error"~ event when reading the file fails for any reason. The error object itself will end up in the reader‚Äôs ~error~ property. This interface was designed before promises became part of the language. You could wrap it in a promise like this:

#+begin_src javascript

  function readFileText(file) {
      return new Promise((resolve, reject) => {
          let reader = new FileReader();
          reader.addEventListener(
              "load", () => resolve(reader.result));
          reader.addEventListener(
              "error", () => reject(reader.error));
          reader.readAsText(file);
      });
  }

#+end_src

*** Storing data client-side
**** localStorage
Simple HTML pages with a bit of JavaScript can be a great format for ‚Äúmini applications‚Äù‚Äîsmall helper programs that automate basic tasks. By connecting a few form fields with event handlers, you can do anything mini applications.

When such an application needs to remember something between sessions, you cannot use JavaScript bindings‚Äîthose are thrown away every time the page is closed. You could set up a server[link to server chapter 20]EOF, connect it to the Internet, and have your application store something there. But that‚Äôs a lot of extra work and complexity. Sometimes it is enough to just keep the data in the browser.

The ~localStorage~ object can be used to *store data in a way that survives page reloads*. This object allows you to file string values under names.

#+begin_src javascript

  localStorage.setItem("username", "marijn");
  console.log(localStorage.getItem("username"));
  // ‚Üí marijn
  localStorage.removeItem("username");

#+end_src

A value in ~localStorage~ sticks around until it is overwritten, it is removed with ~removeItem~, or the user clears their local data.

Sites from different domains get different storage compartments. That means data stored in ~localStorage~ by a given website can, in principle, be read (and overwritten) only by scripts on that same site.

Browsers do enforce a limit on the size of the data a site can store in ~localStorage~. That restriction, along with the fact that filling up people‚Äôs hard drives with junk is not really profitable, prevents the feature from eating up too much space.

There is another object, similar to ~localStorage~, called ~sessionStorage~. The difference between the two is that the content of ~sessionStorage~ is *forgotten at the end* of each session, which for most browsers means whenever the browser is closed.

**** Example note-taking application
The following code implements a crude note-taking application. It keeps a set of named notes and allows the user to edit notes and create new ones.

#+begin_src javascript

  Notes: <select></select> <button>Add</button><br>
  <textarea style="width: 100%"></textarea>

  <script>
    let list = document.querySelector("select");
    let note = document.querySelector("textarea");

  let state;
  function setState(newState) {
      list.textContent = "";
      for (let name of Object.keys(newState.notes)) {
          let option = document.createElement("option");
          option.textContent = name;
          if (newState.selected == name) option.selected = true;
          list.appendChild(option);
      }
      note.value = newState.notes[newState.selected];

      localStorage.setItem("Notes", JSON.stringify(newState));
      state = newState;
  }
  setState(JSON.parse(localStorage.getItem("Notes")) ?? {
      notes: {"shopping list": "Carrots\nRaisins"},
      selected: "shopping list"
  });

  list.addEventListener("change", () => {
      setState({notes: state.notes, selected: list.value});
  });
  note.addEventListener("change", () => {
      setState({
          notes: Object.assign({}, state.notes,
                               {[state.selected]: note.value}),
          selected: state.selected
      });
  });
  document.querySelector("button")
      .addEventListener("click", () => {
          let name = prompt("Note name");
          if (name) setState({
              notes: Object.assign({}, state.notes, {[name]: ""}),
              selected: name
          });
      });
  // This is the same as above but using  spread syntax:
  // note.addEventListener("change", () => {
  //   let {selected} = state;
  //   setState({
  //     notes: {...state.notes, [selected]: note.value},
  //     selected
  //   });
  // });
  // document.querySelector("button")
  //   .addEventListener("click", () => {
  //     let name = prompt("Note name");
  //     if (name) setState({
  //       notes: {...state.notes, [name]: ""},
  //       selected: name
  //     });
  //   });
  </script>

#+end_src

Reading a field that does not exist from ~localStorage~ will yield ~null~. Passing ~null~ to ~JSON.parse~ will make it parse the string ~"null"~ and return ~null~. Thus, the [[Nullish coalescing operator (??)][??]] operator can be used to provide a default value in a situation like this.

The use of [[Object.assign]] in the example is intended to create a new object that is a clone of the old ~state.notes~, but with one property added or overwritten. ~Object.assign~ takes its first argument and adds all properties from any further arguments to it. Thus, giving it an empty object will cause it to fill a fresh object. The square brackets notation in the third argument is used to create a property whose name is based on some dynamic value.

The [[Spread syntax][...]] syntax in the example is used to create a new object that is a clone of the old ~state.notes~, but with one property added or overwritten. It uses spread syntax to first add the properties from the old object, and then set a new property.

** Fetch
*** Brief
In the HTTP protocol a client sends a request, which contains a method (usually ~GET~) and a path that identifies a resource. The server then decides what to do with the request and responds with a status code and a response body. Both requests and responses may contain headers that provide additional information.

The interface through which browser JavaScript can make HTTP requests is called [[fetch interface][fetch]].

Browsers make ~GET~ requests to fetch the resources needed to display a web page. A page may also contain [[Forms][forms]], which allow information entered by the user to be sent as a request for a new page when the form is submitted.

#+begin_src javascript

  fetch("/18_http.html").then(r => r.text()).then(text => {
      console.log(`The page starts with ${text.slice(0, 15)}`);
  });

#+end_src

*** fetch interface
The interface through which browser JavaScript can make HTTP requests is called ~fetch~. Since it is relatively new, it conveniently uses promises (which is rare for browser interfaces).

Calling ~fetch~ returns a promise that resolves to a ~Response~ object holding information about the server‚Äôs response, such as *its status code and its headers*. The headers are wrapped in a ~Map~ -like object that treats its keys (the header names) as case insensitive because header names are not supposed to be case sensitive.

#+begin_src javascript

  fetch("example/data.txt").then(response => {
      console.log(response.status);
      // ‚Üí 200
      console.log(response.headers.get("Content-Type"));
      // ‚Üí text/plain
  });

  // Note that the promise returned by fetch resolves successfully even if
  // the server responded with an error code. It might also be rejected if
  // there is a network error or if the server that the request is
  // addressed to can‚Äôt be found.

#+end_src

When that URL doesn‚Äôt start with a protocol name (such as ~http:~), it is treated as relative, which means it is interpreted relative to the current document. When it starts with a slash ( ~/~ ), it replaces the current path, which is the part after the server name. When it does not, the part of the current path up to and including its last slash character is put in front of the relative URL.

*** Get content
To get at the actual content of a response, you can use its ~text~ method. Because the initial promise is resolved as soon as the response‚Äôs headers have been received and because reading the response body might take a while longer, this again returns a promise.

#+begin_src javascript

  fetch("example/data.txt")
      .then(resp => resp.text())
      .then(text => console.log(text));
  // ‚Üí This is the content of data.txt

#+end_src

A similar method, called ~json~, returns a promise that resolves to the value you get when parsing the body as JSON or rejects if it‚Äôs not valid JSON.

*** Fetch optional argument
By default, ~fetch~ uses the ~GET~ method to make its request and does not include a request body. You can configure it differently by passing an object with extra options as a second argument. For example, this request tries to delete ~example/data.txt~:

#+begin_src javascript

  fetch("example/data.txt", {method: "DELETE"}).then(resp => {
      console.log(resp.status);
      // ‚Üí 405
  });
  // The 405 status code means ‚Äúmethod not allowed‚Äù.

#+end_src

To add a request body, you can include a ~body~ option. To set headers, there‚Äôs the ~headers~ option.

For example, this request includes a ~Range~ header, which instructs the server to return only part of a response.

#+begin_src javascript

  fetch("example/data.txt", {headers: {Range: "bytes=8-19"}})
      .then(resp => resp.text())
      .then(console.log);
  // ‚Üí the content

#+end_src

The browser will automatically add some request headers, such as ‚ÄúHost‚Äù and those needed for the server to figure out the size of the body. But adding your own headers is often useful to include things such as authentication information or to tell the server which file format you‚Äôd like to receive.

*** Comunication JS client and server
A commonly used model is that of *remote procedure calls*. In this model, communication follows the patterns of normal function calls, except that the function is actually running on another machine. Calling it involves making a request to the server that includes the function‚Äôs name and arguments. The response to that request contains the returned value.

Another approach is to build your communication around the concept of resources and HTTP methods. Instead of a remote procedure called ~addUser~, you use a ~PUT~ request to ~/users/larry~. Instead of encoding that user‚Äôs properties in function arguments, you define a JSON document format (or use an existing format) that represents a user. The body of the ~PUT~ request to create a new resource is then such a document. A resource is fetched by making a ~GET~ request to the resource‚Äôs URL (for example, ~/user/larry~), which again returns the document representing the resource.

This second approach makes it easier to use some of the features that HTTP provides, such as support for caching resources (keeping a copy on the client for fast access).

*** Example: send requests to fetch all three formats
The URL https://eloquentjavascript.net/author is configured to respond with either plaintext, HTML, or JSON, depending on what the client asks for. These formats are identified by the standardized media types ~text/plain~ , ~text/html~ , ~application/json~, and ~application/rainbows+unicorns~ .

Send requests to fetch all three formats of this resource. Use the ~headers~ property in the options object passed to ~fetch~ to set the header named ~Accept~ to the desired media type.

#+begin_src javascript

  const url = "https://eloquentjavascript.net/author";
  const types = ["text/plain",
                 "text/html",
                 "application/json",
                 "application/rainbows+unicorns"];


  async function showTypes() {
      for (let type of types) {
          let resp = await fetch(url, {headers: {accept: type}});
          console.log(`${type}: ${await resp.text()}\n`);
      }
  }

  showTypes();

#+end_src

* Debugging and Modules
** Debugging
*** Types
Add a comment like the following before the function to describe its type:

#+begin_src javascript

  // (VillageState, Array) ‚Üí {direction: string, memory: Array}
  function goalOrientedRobot(state, memory) {
      // ...
  }

#+end_src

*** Testing
Tests usually take the form of little labeled programs that verify some aspect of your code. For example, a set of tests for the (standard, probably already tested by someone else) ~toUpperCase~ method might look like this:

#+begin_src javascript

  function test(label, body) {
      if (!body()) console.log(`Failed: ${label}`);
  }

  test("convert Latin text to uppercase", () => {
      return "hello".toUpperCase() == "HELLO";
  });
  test("convert Greek text to uppercase", () => {
      return "ŒßŒ±ŒØœÅŒµœÑŒµ".toUpperCase() == "ŒßŒëŒäŒ°ŒïŒ§Œï";
  });
  test("don't convert case-less characters", () => {
      return "ŸÖÿ±ÿ≠ÿ®ÿß".toUpperCase() == "ŸÖÿ±ÿ≠ÿ®ÿß";
  });

#+end_src

Writing tests like this tends to produce rather repetitive, awkward code. Fortunately, there exist pieces of software that help you build and run collections of tests (test suites) by providing a language (in the form of functions and methods) suited to expressing tests and by outputting informative information when a test fails. These are usually called test runners.

*** Debugging
Once you notice there is something wrong with your program because it misbehaves or produces errors, the next step is to figure out *what* the problem is.

When the program returns a strange output suggesting that it has a bug. You must resist the urge to start making random changes to the code to see whether that makes it better. Instead, *think*. Analyze what is happening and come up with a theory of why it might be happening. Then, make additional observations to test this theory‚Äîor, if you don‚Äôt yet have a theory, make additional observations to help you come up with one.

Putting a few strategic ~console.log~ calls into the program is a good way to get additional information about what the program is doing.

An alternative to using ~console.log~ to peek into the program‚Äôs behavior is to use the *debugger* capabilities of your browser. Browsers come with the ability to set a *breakpoint* on a specific line of your code.

Another way to set a breakpoint is to include a ~debugger~ statement (consisting of simply that keyword) in your program. If the developer tools of your browser are active, the program will pause whenever it reaches such a statement.

*** Error propagation
Not all problems can be prevented by the programmer, unfortunately. If your program communicates with the outside world in any way, it is possible to get malformed input, to become overloaded with work, or to have the network fail.

Say you have a function ~promptNumber~ that asks the user for a number and returns it. What should it return if the user inputs ‚Äúorange‚Äù?

One option is to make it return a special value. Common choices for such values are ~null~, ~undefined~, or ~-1~.

#+begin_src javascript

  function promptNumber(question) {
      let result = Number(prompt(question));
      if (Number.isNaN(result)) return null;
      else return result;
  }

  console.log(promptNumber("How many trees do you see?"));

#+end_src

In many situations, mostly when errors are common and the caller should be explicitly taking them into account, returning a special value is a good way to indicate an error. It does, however, have its downsides. First, what if the function can already return every possible kind of value? In such a function, you‚Äôll have to do something like wrap the result in an object to be able to distinguish success from failure.

#+begin_src javascript

  function lastElement(array) {
      if (array.length == 0) {
          return {failed: true};
      } else {
          return {element: array[array.length - 1]};
      }
  }

#+end_src

*** Exceptions
When a function cannot proceed normally, what we would *like* to do is just stop what we are doing and immediately jump to a place that knows how to handle the problem. This is what *exception handling* does.

Exceptions are a mechanism that makes it possible for code that runs into a problem to raise (or [[throw]]) an exception. An exception can be any value. Raising one somewhat resembles a super-charged return from a function: it jumps out of not just the current function but also its callers, all the way down to the first call that started the current execution. This is called *unwinding the stack*.

If exceptions always zoomed right down to the bottom of the stack, they would not be of much use. They‚Äôd just provide a novel way to blow up your program. Their power lies in the fact that you can set ‚Äúobstacles‚Äù along the stack to *catch* the exception as it is zooming down. Once you‚Äôve caught an exception, you can do something with it to address the problem and then continue to run the program.

*** Cleaning up after exceptions
The effect of an exception is another kind of control flow. Every action that might cause an exception, which is pretty much every function call and property access, might cause control to suddenly leave your code.

This means when code has several side effects, even if its ‚Äúregular‚Äù control flow looks like they‚Äôll always all happen, an exception might prevent some of them from taking place.

One way to address this is to use fewer side effects. Again, a programming style that computes new values instead of changing existing data helps. If a piece of code stops running in the middle of creating a new value, no one ever sees the half-finished value, and there is no problem.

But that isn‚Äôt always practical. So there is another feature that [[try...catch][try]] statements have. They may be followed by a [[finally]] block either instead of or in addition to a ~catch~ block. A ~finally~ block says ‚Äúno matter what happens, run this code after trying to run the code in the ~try~ block.‚Äù

*** Selective catching
When a ~catch~ body is entered, all we know is that *something* in our ~try~ body caused an exception. But we don‚Äôt know *what* did or *which* exception it caused.

JavaScript (in a rather glaring omission) doesn‚Äôt provide direct support for selectively catching exceptions: either you catch them all or you don‚Äôt catch any. This makes it tempting to *assume* that the exception you get is the one you were thinking about when you wrote the ~catch~ block.

But it might not be. Some other assumption might be violated, or you might have introduced a bug that is causing an exception. Here is an [[throw (selective catching)][example]] that *attempts* to keep on calling ~promptDirection~ until it gets a valid answer:

*** Assertions
Assertions are checks inside a program that verify that something is the way it is supposed to be. They are used *not to handle situations that can come up in normal operation but to find programmer mistakes*.

If, for example, ~firstElement~ is described as a function that should never be called on empty arrays, we might write it like this:

#+begin_src javascript

  function firstElement(array) {
      if (array.length == 0) {
          throw new Error("firstElement called with []");
      }
      return array[0];
  }

#+end_src

Now, instead of silently returning undefined (which you get when reading an array property that does not exist), this will loudly blow up your program as soon as you misuse it. This makes it less likely for such mistakes to go unnoticed and easier to find their cause when they occur.

** Modules
*** Definition
A module is a piece of program that specifies which other pieces it relies on and which functionality it provides for other modules to use (its *interface*).

*** Improvised modules
You can use JavaScript functions to create local scopes and objects to represent module interfaces.

This is a module for going between day names and numbers (as returned by ~Date~ ‚Äôs ~getDay~ method). Its interface consists of ~weekDay.name~ and ~weekDay.number~, and it hides its local binding ~names~ inside the scope of a function expression that is immediately invoked.

#+begin_src javascript

  const weekDay = function() {
      const names = ["Sunday", "Monday", "Tuesday", "Wednesday",
                     "Thursday", "Friday", "Saturday"];
      return {
          name(number) { return names[number]; },
          number(name) { return names.indexOf(name); }
      };
  }();

  console.log(weekDay.name(weekDay.number("Sunday")));
  // ‚Üí Sunday

#+end_src

This style of modules provides isolation, to a certain degree, but it does not declare dependencies. Instead, it just puts its interface into the global scope and expects its dependencies, if any, to do the same. For a long time this was the main approach used in web programming, but it is mostly obsolete now.

*** Evaluating data as code
There are several ways to take data (a string of code) and run it as part of the current program.

The most obvious way is the special operator ~eval~, which will execute a string in the *current* scope. This is usually a bad idea because it breaks some of the properties that scopes normally have, such as it being easily predictable which binding a given name refers to.

#+begin_src javascript

  const x = 1;
  function evalAndReturnX(code) {
      eval(code);
      return x;
  }
  ‚Äã
  console.log(evalAndReturnX("var x = 2"));  // ‚Üí 2
  console.log(x);  // ‚Üí 1

#+end_src

A less scary way of interpreting data as code is to use the ~Function~ constructor. It takes two arguments: a string containing a comma-separated list of argument names and a string containing the function body. It wraps the code in a function value so that it gets its own scope and won‚Äôt do odd things with other scopes.

#+begin_src javascript

  let plusOne = Function("n", "return n + 1;");
  console.log(plusOne(4)); // ‚Üí 5

#+end_src

This is precisely what we need for a module system. We can wrap the module‚Äôs code in a function and use that function‚Äôs scope as module scope.

*** CommonJS
The most widely used approach to bolted-on JavaScript modules is called CommonJS modules. Node.js uses it and is the system used by most packages on NPM.

The main concept in CommonJS modules is a function called ~require~. When you call this with the module name of a dependency, it makes sure the module is loaded and returns its interface.

Because the loader wraps the module code in a function, modules automatically get their own local scope. All they have to do is call ~require~ to access their dependencies and put their interface in the object bound to ~exports~.

This example module provides a date-formatting function. It uses two packages from ~NPM‚Äîordinal~ to convert numbers to strings like ~"1st"~ and ~"2nd"~ , and ~date-names~ to get the English names for weekdays and months. It exports a single function, ~formatDate~, which takes a ~Date~ object and a template string.

The template string may contain codes that direct the format, such as ~YYYY~ for the full year and ~Do~ for the ordinal day of the month. You could give it a string like ~"MMMM Do YYYY"~ to get output like ‚ÄúNovember 22nd 2017‚Äù.

#+begin_src javascript

  const ordinal = require("ordinal");
  const {days, months} = require("date-names");

  exports.formatDate = function(date, format) {
      return format.replace(/YYYY|M(MMM)?|Do?|dddd/g, tag => {
          if (tag == "YYYY") return date.getFullYear();
          if (tag == "M") return date.getMonth();
          if (tag == "MMMM") return months[date.getMonth()];
          if (tag == "D") return date.getDate();
          if (tag == "Do") return ordinal(date.getDate());
          if (tag == "dddd") return days[date.getDay()];
      });
  };
  // The interface of ordinal is a single function, whereas date-names
  // exports an object containing multiple things‚Äîdays and months are
  // arrays of names.

#+end_src

The module adds its interface function to ~exports~ so that modules that depend on it get access to it. We could use the module like this:

#+begin_src javascript

  const {formatDate} = require("./format-date");

  console.log(formatDate(new Date(2017, 9, 13),
                         "dddd the Do"));
  // ‚Üí Friday the 13th

#+end_src

*Note*: The interface of the ~ordinal~ package we saw before is not an object but a function. A quirk of the CommonJS modules is that, though the module system will create an empty interface object for you (bound to ~exports~), you can replace that with any value by overwriting ~module.exports~. This is done by many modules to export a single value instead of an interface object.

*** ECMAScript modules
ES modules, where ES stands for ECMAScript, are a different module system from CommonJS. The main concepts of dependencies and interfaces remain the same, but the details differ. For one thing, the notation is now integrated into the language. Instead of calling a function to access a dependency, you use a special ~import~ keyword.

#+begin_src javascript

  import ordinal from "ordinal";
  import {days, months} from "date-names";

  export function formatDate(date, format) { /* ... */ }

#+end_src

Similarly, the ~export~ keyword is used to export things. It may appear in front of a function, class, or binding definition (~let~, ~const~, or ~var~).

An ES module‚Äôs interface is not a single value but a set of named bindings. The preceding module binds ~formatDate~ to a function. When you import from another module, you import the *binding*, not the value, which means an exporting module may change the value of the binding at any time, and the modules that import it will see its new value.

When there is a binding named ~default~, it is treated as the module‚Äôs main exported value. If you import a module like ~ordinal~ in the example, without braces around the binding name, you get its ~default~ binding. Such modules can still export other bindings under different names alongside their ~default~ export.

To create a default export, you write ~export default~ before an expression, a function declaration, or a class declaration.

*Note*: Another important difference is that ES module imports happen before a module‚Äôs script starts running. That means import declarations may not appear inside functions or blocks, and the names of dependencies must be quoted strings, not arbitrary expressions.

#+begin_src javascript

  export default ["Winter", "Spring", "Summer", "Autumn"];

  // It is possible to rename imported bindings using the word "as".
  import {days as dayNames} from "date-names";
  console.log(dayNames.length);  // ‚Üí 7

#+end_src

* Regular Expressions
** Char characters

| /Char/     | /Description/                                            |
|----------+--------------------------------------------------------|
| /abc/      | A sequence of characters                               |
| /[ ]/      | Any characters between the brackets                    |
| /[ - ]/    | Range of chars (ordering is det by the char‚Äôs Unicode) |
| /[^ ]/     | Any character except the ones in the set (invert set)  |
| /[^]/      | Any character, and also a new line                     |
| /[abx-z]/  | One character of: a, b, or the range x-z               |
| /[^abc]/   | Any character not in a set of characters               |
| /[^abx-z]/ | One character except: a, b, or the range x-z           |
|          |                                                        |
| /?/        | May occur zero times or one time (optional)            |
| /x+/       | One or more occurrences of the pattern x               |
| /x+?/      | One or more occurrences, nongreedy                     |
| /x*/       | Zero or more occurrences of the patter x               |
| /x*?/      | Zero or more occurrences, nongreedy                    |
| /x?/       | Zero or one occurrence  of the patter x                |
| /x??/      | Zero or one occurrence, nongreedy                      |
| /{n}/      | Occur exactly 'n' times                                |
| /{n,m}/    | Occur at least 'n' and at most 'm' times               |
| /{n,}/     | 'n' or more times                                      |
|          |                                                        |
| /\d/       | Any digit character (/[0-9]/)                            |
| /\D/       | A character that is not a digit (/[^0-9]/)               |
| /\w/       | An alphanumeric character (‚Äúword character‚Äù)           |
| /\W/       | A nonalphanumeric character (/[^_a-zA-Z0-9]/)            |
| /\s/       | Any whitespace character (space,tab,newline,...)       |
| /\S/       | A nonwhitespace character                              |
| /./        | Any character except newlines                          |
|          |                                                        |
| /^/        | Matches the start of the input string (caret)          |
| /$/        | Matches the end of the input string                    |
| /\b/       | Starts/ends on a word boundary *                       |
| /¬¶/        | Choice between the pattern                             |
| /a¬¶b¬¶c/    | Any one of several patterns                            |
| /(abc)/    | A group                                                |
|          |                                                        |
| /\n/       | A newline                                              |
| /\t/       | A tab                                                  |

/*/  /\b/ marker matches /word boundaries/, positions that have a word character on one side, and a nonword character on the other. Unfortunately, these use the same simplistic concept of word characters as /\w/ and are therefore not very reliable.

** Definition and creation of RegExp
Regular expressions are *objects that represent patterns in strings*. They use their own language to express these patterns.

A regular expression is a type of object. It can be either constructed with the ~RegExp~ constructor or written as a literal value by enclosing a pattern in forward slash ( ~/~ ) characters.

#+begin_src javascript

  let re1 = new RegExp("abc");
  let re2 = /abc/;
  // a character followed by a b followed by a c


  // The following create the same regular expression object:
  const re = /ab+c/i;
  // literal notation
  const re = new RegExp("ab+c", "i");
  // constructor with string pattern as first argument
  const re = new RegExp(/ab+c/, "i");
  // constructor with regular expression literal as first argument


  // The following create the same regular expression object:
  let regexp  = new RegExp("\\b(harry)\\b", "gi");
  let literal = /\b(harry)\b/gi;

#+end_src

JavaScript ~RegExp~ objects are stateful when they have the ~global~ or ~sticky~ flags set (e.g., ~/foo/g~ or ~/foo/y~). They store a [[Property lastIndex][lastIndex]] from the previous match. Using this internally, ~test()~ can be used to *iterate* over multiple matches in a string of text (with capture groups).

#+begin_src javascript

  const str = 'table football';
  const regex = new RegExp('foo*');
  const globalRegex = new RegExp('foo*', 'g');

  console.log(regex.test(str));  //  true

  console.log(globalRegex.lastIndex);  //  0
  console.log(globalRegex.test(str));  //  true
  console.log(globalRegex.lastIndex);  //  9
  console.log(globalRegex.test(str));  //  false

  const globalRegex2 = new RegExp('foo*?', 'g');
  console.log(globalRegex2.test(str));  //  true
  console.log(globalRegex2.lastIndex);  //  8
  console.log(globalRegex2.test(str));  //  false

#+end_src

When using the ~RegExp~ constructor, the pattern is written as a normal string, so the usual rules apply for backslashes.

The slash notation, treats backslashes somewhat differently. First, since a forward slash ends the pattern, we need to put a backslash before any forward slash that we want to be part of the pattern. In addition, backslashes that aren‚Äôt *part* of special character codes (like ~\n~) will be *preserved*, rather than ignored as they are in strings, and change the meaning of the pattern. Some characters, such as question marks and plus signs, have special meanings in regular expressions and must be preceded by a backslash if they are meant to represent the character itself.

** Dynamically creating RegExp objects
Before regular expressions can be used, they have to be compiled. This process allows them to perform matches more efficiently.

The literal notation results in compilation of the regular expression *when* the expression is evaluated. On the other hand, the constructor of the ~RegExp~ object, ~new RegExp('ab+c')~ , results in runtime compilation of the regular expression.

Use a string as the first argument to the ~RegExp()~ constructor when you want to build the regular expression from dynamic input.

#+begin_src javascript

  let name = "harry";
  let text = "Harry is a suspicious character.";
  let regexp = new RegExp("\\b(" + name + ")\\b", "gi"); // /\b(harry)\b/gi
  console.log(text.replace(regexp, "_$1_"));
  // ‚Üí _Harry_ is a suspicious character.


  let name = "dea+hl[]rd";
  let text = "This dea+hl[]rd guy is super annoying.";
  let escaped = name.replace(/[\\[.+*?(){|^$]/g, "\\$&"); // \\ -> escape \
  let regexp = new RegExp("\\b" + escaped + "\\b", "gi");
  console.log(text.replace(regexp, "_$&_")); // $& -> whole match
  // ‚Üí This _dea+hl[]rd_ guy is super annoying.

#+end_src

** Flags
Regular expressions can have options, which are written after the closing slash. The ~i~ option makes the match case insensitive. The ~g~ option makes the expression *global*, which, among other things, causes the [[String.prototype.replace][replace]] method to replace all instances instead of just the first. The ~y~ option makes it sticky, which means that it will not search ahead and skip part of the string when looking for a match. The ~u~ option turns on Unicode mode, which fixes a number of problems around the handling of characters that take up two code units.

| /Flag/ | /Description/                                          |
|------+------------------------------------------------------|
| /d/    | Generate indices for substring matches               |
| /g/    | Global search                                        |
| /i/    | Case-insensitive search                              |
| /m/    | Allows ^ and $ to match newline characters           |
| /s/    | Allows . to match newline characters                 |
| /u/    | Treat a pattern as a sequence of Unicode code points |
| /v/    | An upgrade to the u mode with more Unicode features  |
| /y/    | Perform a "sticky" search that matches starting at   |
|      | the current position in the target string            |

*Note*: be cautious with global regular expressions. The cases where they are necessary‚Äîcalls to [[String.prototype.replace][replace]] and places where you want to explicitly use [[Property lastIndex][lastIndex]] ‚Äîare typically the only places where you want to use them.

The ~sticky~ flag indicates that the regular expression performs sticky matching in the target string by attempting to match starting at ~RegExp.prototype.lastIndex~.

#+begin_src javascript

  const str = "#foo#";
  const regex = /foo/y;

  regex.lastIndex = 1;
  regex.test(str); // true
  regex.lastIndex = 5;
  regex.test(str); // false (lastIndex is taken into account with sticky flag)
  regex.lastIndex; // 0 (reset after match failure)

  const regex2 = /foo/;
  regex.lastIndex = 1;
  regex.test(str); // true
  regex.lastIndex = 5;
  regex.test(str); // true

#+end_src

*The difference between the sticky flag and the global flag*:
When sticky is enabled, the match will succeed only if it *starts directly* at ~lastIndex~, whereas with global, it will search *ahead* for a position where a match can start.

#+begin_src javascript

  let global = /abc/g;
  console.log(global.exec("xyz abc"));
  // [ 'abc', index: 4, input: 'xyz abc', groups: undefined ]

  let sticky = /abc/y;
  console.log(sticky.exec("xyz abc"));
  // ‚Üí null
  sticky.lastIndex = 4;
  console.log(sticky.exec("xyz abc"));
  // [ 'abc', index: 4, input: 'xyz abc', groups: undefined ]

  const re = /\d/y;
  let r;
  while ((r = re.exec("123 456"))) {
      console.log(r, "AND re.lastIndex", re.lastIndex);
  }

  // [ '1', index: 0, input: '123 456', groups: undefined ] AND re.lastIndex 1
  // [ '2', index: 1, input: '123 456', groups: undefined ] AND re.lastIndex 2
  // [ '3', index: 2, input: '123 456', groups: undefined ] AND re.lastIndex 3
  //  ‚Ä¶ and no more match.

  // With the global flag g, all 6 digits would be matched, not just 3.

#+end_src

** Backtracking
The regular expression ~/\b([01]+b|[\da-f]+h|\d+)\b/~ matches either a binary number followed by a b, a hexadecimal number (that is, base 16, with the letters a to f standing for the digits 10 to 15) followed by an h, or a regular decimal number with no suffix character. This is the corresponding diagram:

#+begin_src

                 group #1
                 +--------------------------------------+
                 |             One of:                  |
                 |            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 |
                 |            ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îÇ                 |
                 |            ‚îÇ ‚îÇ"0"‚îÇ ‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îê       |
                 |  ‚îå------‚î¨--‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îÇ--‚î¨--‚îÇ"b"‚îÇ----‚îê  |
                 |  |      |  ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îÇ  |  ‚îî‚îÄ‚îÄ‚îÄ‚îò    |  |
                 |  |      ^  ‚îÇ ‚îÇ"1"‚îÇ ‚îÇ  |           |  |
                 |  |      |  ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îÇ  v           |  |
                 |  |      |  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  |           |  |
                 |  |      ‚îî------<------‚îò           |  |
    Star of line |  |                                |  |  End of line
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  |  |          One of:               |  |  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  *--‚îÇboundary‚îÇ--|--‚î§     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îú--|--‚îÇboundary‚îÇ--*
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  |  |     ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ            |  |  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 |  |     ‚îÇ   ‚îÇdigit‚îÇ   ‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îê  |  |
                 |  ‚îú--‚î¨--‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ--‚î¨--‚îÇ"h"‚îÇ--‚î§  |
                 |  |  |  ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îÇ  |  ‚îî‚îÄ‚îÄ‚îÄ‚îò  |  |
                 |  |  ^  ‚îÇ ‚îÇ"a"‚îÇ-‚îÇ"f"‚îÇ ‚îÇ  |         |  |
                 |  |  |  ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îÇ  v         |  |
                 |  |  |  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  |         |  |
                 |  |  ‚îî---------<---------‚îò         |  |
                 |  |         One of:                |  |
                 |  |         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                |  |
                 |  ‚îî------‚î¨--‚îÇdigit‚îÇ--‚î¨-------------‚îò  |
                 |         ^  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  v                |
                 |         ‚îî-----<-----‚îò                |
                 +--------------------------------------+

#+end_src

When matching this expression, it will often happen that the top (binary) branch is entered even though the input does not actually contain a binary number. When matching the string ~"103"~, for example, it becomes clear only at the 3 that we are in the wrong branch. The string *does* match the expression, just not the branch we are currently in.

So the matcher *backtracks*. When entering a branch, it remembers its current position (in this case, at the start of the string, just past the first boundary box in the diagram) so that it can go back and try another branch if the current one does not work out. For the string ~"103"~ , after encountering the 3 character, it will start trying the branch for hexadecimal numbers, which fails again because there is no ~h~ after the number. So it tries the decimal number branch. This one fits, and a match is reported after all.

The matcher stops as soon as it finds a full match. This means that if multiple branches could potentially match a string, only the first one (ordered by where the branches appear in the regular expression) is used.

Backtracking also happens for repetition operators like ~+~ and ~*~ . If you match ~/^.*x/~ against ~"abcxe"~ , the ~.*~ (match as much as it can) part will first try to consume the *whole string*. The engine will then realize that it needs an ~x~ to match the pattern. Since there is no ~x~ past the end of the string, the star operator tries to match *one character less*. But the matcher doesn‚Äôt find an ~x~ after ~abcx~ either, so it backtracks again, matching the star operator to just ~abc~. *Now* it finds an ~x~ where it needs it and reports a successful match from *positions* 0 to 4.

It is possible to write regular expressions that will do a lot of backtracking. This problem occurs when a pattern can match a piece of input in many different ways. For example, if we get confused while writing a binary-number regular expression, we might accidentally write something like ~/([01]+)+b/~ .

#+begin_src artist

                       Group #1
                       +---------------------+
                       |                     |
                       |       One of:       |
                       |      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      |
                       |      ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îÇ      |
                       |      ‚îÇ ‚îÇ"0"‚îÇ ‚îÇ      |      ‚îå‚îÄ‚îÄ‚îÄ‚îê
              *----‚î¨---|---‚î¨--‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îÇ--‚î¨---|---‚î¨--‚îÇ"b"‚îÇ----*
                   |   |   |  ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îÇ  |   |   |  ‚îî‚îÄ‚îÄ‚îÄ‚îò
                   |   |   |  ‚îÇ ‚îÇ"1"‚îÇ ‚îÇ  |   |   |
                   |   |   |  ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îÇ  |   |   |
                   |   |   |  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  |   |   |
                   |   |   ‚îî-------------‚îò   |   |
                   |   +---------------------+   |
                   ‚îî-----------------------------‚îò

#+end_src

If that tries to match some long series of zeros and ones with no trailing ~b~ character, the matcher first goes through the inner loop until it runs out of digits. Then it notices there is no ~b~, so it backtracks one position, goes through the outer loop once, and gives up again, trying to backtrack out of the inner loop once more. It will continue to try every possible route through these two loops. This means the amount of work *doubles* with each additional character. For even just a few dozen characters, the resulting match will take practically forever.

** Writing a regular expression pattern
*** Sets of characters
- ~[^]~ is a way to match any character. Is similar to ( ~.~ ) but with the difference that it does match new line while the period character does not match newline characters.

- As far as JavaScript‚Äôs regular expressions are concerned, a ‚Äúword character‚Äù is only one of the 26 characters in the Latin alphabet (uppercase or lowercase), decimal digits, and, for some reason, the underscore character. Things like √© or Œ≤, which most definitely are word characters, will not match ~\w~ (and will match uppercase ~\W~, the nonword category).

- By a strange historical accident, ~\s~ (whitespace) does not have this problem and matches all characters that the Unicode standard considers whitespace, including things like the nonbreaking space and the Mongolian vowel separator.

- Another problem is that, by default, regular expressions work on code units, not actual characters. This means characters that are composed of two code units behave strangely.

#+begin_src javascript

  console.log(/üçé{3}/.test("üçéüçéüçé")); // ‚Üí false
  console.log(/<.>/.test("<üåπ>"));     // ‚Üí false
  console.log(/<.>/u.test("<üåπ>"));    // ‚Üí true (u -> unicode)

  // The problem is that the üçé is treated as two code units, and the
  // {3} part is applied only to the second one. Similarly, the dot
  // matches a single code unit, not the two that make up the rose emoji

#+end_src

*** Repeating parts of a pattern
Something with a star ( ~*~ ) after it never prevents a pattern from matching‚Äîit‚Äôll just match zero instances if it can‚Äôt find any suitable text to match.

#+begin_src javascript

  console.log(/'\d+'/.test("'123'")); // ‚Üí true
  console.log(/'\d+'/.test("''"));    // ‚Üí false
  console.log(/'\d*'/.test("'123'")); // ‚Üí true
  console.log(/'\d*'/.test("''"));    // ‚Üí true

#+end_src

*** Greed
The repetition operators ( ~+~  , ~*~ , ~?~ , and ~{}~ ) are *greedy*, meaning they match as much as they can and backtrack from there. If you put a question mark after them ( ~+?~ , ~*?~ , ~??~ , ~{}?~ ), they become *nongreedy* and start by matching as little as possible, matching more only when the remaining pattern does not fit the smaller match.

A lot of bugs in regular expression programs can be traced to unintentionally using a greedy operator where a nongreedy one would work better. *When using a repetition operator, consider the nongreedy variant first*.

Example of a function that removes all comments from a piece of JavaScript code.

#+begin_src javascript

  function stripComments(code) {
      return code.replace(/\/\/.*|\/\*[^]*\*\//g, "");
  }
  console.log(stripComments("1 /* a */+/* b */ 1"));  // ‚Üí 1  1

  function stripComments(code) {
      return code.replace(/\/\/.*|\/\*[^]*?\*\//g, "");
  }
  console.log(stripComments("1 /* a */+/* b */ 1"));  // ‚Üí 1 + 1

#+end_src

*** Word, string boundaries
A word boundary can be the start or end of the string or any point in the string that has a *word character* (as in ~\w~) *on one side and a nonword character on the other*.

#+begin_src javascript

  console.log(/cat/.test("concatenate"));  // ‚Üí true
  console.log(/\bcat\b/.test("concatenate"));  // ‚Üí false


  console.log(/\b\d+ (pig|cow|chicken)s?\b/.test("15 pigs"));        // ‚Üí true
  console.log(/\b\d+ (pig|cow|chicken)s?\b/.test("15 pigchickens")); // ‚Üí false
  console.log(/\b\d+ (pig|cow|chicken)s?/.test  ("15 pigchickens")); // ‚Üí true

#+end_src

*** Choice
The matcher stops as soon as it finds a full match. This means that if multiple branches could potentially match a string, *only the first match* (ordered by where the branches appear in the regular expression) is used.

#+begin_src javascript

  let regexp = /\b([01]+b|[\da-f]+h|\d+)\b/;
  // It matches either a binary number followed by a b, a hexadecimal
  // number (that is, base 16, with the letters a to f standing for the
  // digits 10 to 15) followed by an h, or a regular decimal number with
  // no suffix character. In this case, if the expression matches the
  // binary number (the first branch), it won't macth the other two branches.

#+end_src

*** Grouping subexpressions
To use an operator like ~*~ or ~+~ on more than one element at a time, you have to use parentheses. A part of a regular expression that is enclosed in parentheses counts *as a single element* as far as the operators following it are concerned.

#+begin_src javascript

  let cartoonCrying  = /boo+(hoo+)+/i;
  console.log(cartoonCrying.test("Boohoooohoohooo"));  // ‚Üí true
  // The first and second + characters apply only to the second 'o' in boo
  // and hoo, respectively. The third + applies to the whole group (hoo+),
  // matching one or more sequences like that.

  console.log(cartoonCrying.exec("Boohoooohoohooo"))
  console.log(cartoonCrying.exec("Boohoooohohooo"))
  console.log(cartoonCrying.exec("Boohoooohoohooooooooooo"))
  console.log(cartoonCrying.exec("Boo7hoooohoohooo"))

  // [ 'Boohoooohoohooo'        , 'hooo'         ]
  // [ 'Boohoooo'               , 'hoooo'        ]
  // [ 'Boohoooohoohooooooooooo', 'hooooooooooo' ]
  // null

  console.log(/boo+(hoo)+/i.exec("Boohoooohoohooo"));
  // [ 'Boohoo'                 , 'hoo'          ]

#+end_src

* Miscellaneous
** Web Components
*** Web component
Web Components is a suite of different technologies allowing you to create *new custom ([[Custom elements]]) , reusable elements* (HTML tags) ‚Äî with their functionality *encapsulated* ([[Shadow DOM]]) away from the rest of your code ‚Äî and utilize them in your web apps.

Example of a component and the different DOMs:

#+begin_src javascript

  <script>
    customElements.define('user-card', class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = `
          <div>Name:
            <slot name="username"></slot>
          </div>
          <div>Birthday:
            <slot name="birthday"></slot>
          </div>
        `;
      }
    });
  </script>

  // host element
  <user-card>
    <span slot="username">John Smith</span>
    <span slot="birthday">01.01.2001</span>
  </user-card>
  // Name: John Smith
  // Birthday: 01.01.2001

#+end_src

*Shadow DOM*

#+begin_src html

  <!-- Light DOM   -->
  <user-card>  <!-- host element -->
    #shadow-root
      <!-- Shadow tree -->
      <div>Name:
        <slot name="username"></slot>
      </div>
      <div>Birthday:
        <slot name="birthday"></slot>
      </div>
    <!-- Light DOM   -->
    <span slot="username">John Smith</span>
    <span slot="birthday">01.01.2001</span>
  </user-card>

#+end_src

[[Named slots & flattened DOM][‚Äúflattened‚Äù DOM]]:

#+begin_src html

  <user-card>
    #shadow-root
      <div>Name:
        <slot name="username">
          <!-- slotted element is inserted into the slot -->
          <span slot="username">John Smith</span>
        </slot>
      </div>
      <div>Birthday:
        <slot name="birthday">
          <!-- slotted element is inserted into the slot -->
          <span slot="birthday">01.01.2001</span>
        </slot>
      </div>
  </user-card>

#+end_src

*** Custom elements
**** Brief
A set of JavaScript APIs that allow you to *define custom HTML elements and their behavior*, which can then be used as desired in your user interface.

We can create custom HTML elements, described by our class, with its own methods and properties, events and so on.

We can define them with a special *class*, and then use as if they were always a part of HTML.

There are two kinds of custom elements:
- Autonomous custom elements :: ‚Äúall-new‚Äù elements, extending the abstract [[HTMLElement]] class.
- Customized built-in elements :: extending built-in (existing) elements, like a customized button, based on ~HTMLButtonElement~ etc.

*Nota*: en los estilos globales del componente es necesario colocar un ~display~, ya que por defecto, un *componente tiene valor* ~display: inline~ y muchas propiedades no le afectan.

#+begin_src css

  app-element {
    display: block;
    background: indigo;
    margin: 5px;
  }

#+end_src

*Nota*: si un custom element es movido a otra parte del DOM, se desconectar√° y volver√° a conectarse al DOM, pasando por los m√©todos ~connectedCallback()~ y ~disconnectedCallback()~ correspondientes.

**** Autonomous custom elements
***** Create custom elements
To create a custom element, we need to tell the browser several details about it: how to show it, what to do when the element is added or removed to page, etc.

That‚Äôs done by making a class with special methods. That‚Äôs easy, as there are only few methods, and all of them are optional.

Here‚Äôs a sketch with the full list:

#+begin_src javascript

  class MyElement extends HTMLElement {
    // se ejecuta cuando se crea el custom element, y
    // previamente ha sido definido en el registro
    constructor() {
    // run each time a new class instance is created
    // (every time someone defines or creates a my-element label)
      super();
      // element created
    }

    // Se ejecuta cuando el custom element se ha insertado
    // en el documento HTML DOM (una especie de segundo constructor)
    connectedCallback() {
    // browser calls this method when the element is added to the document
    // (can be called many times if an element is repeatedly added/removed)
    }

    // Se ejecuta cuando el custom element se ha
    // eliminado del documento HTML (DOM)
    disconnectedCallback() {
    // browser calls this method when the element is removed from the doc
    // (can be called many times if an element is repeatedly added/removed)
    }

    static get observedAttributes() {
      return [/* array of attribute names to monitor for changes */];
    }

    // Se ejecuta cuando se ha modificado un atributo observado
    attributeChangedCallback(name, oldValue, newValue) {
      // called when one of attributes listed above is modified
    }

    // Se ejecuta cuando el custom element se ha
    // movido a un nuevo documento (ej: iframes)
    adoptedCallback() {
      // called when the element is moved to a new document
      // (happens in document.adoptNode, very rarely used)
    }

    // there can be other element methods and properties
  }

#+end_src

After that, we need to register the element:

#+begin_src javascript

  // let the browser know that <my-element> is served by our new class
  customElements.define("my-element", MyElement);

#+end_src

Now for any HTML elements with tag ~<my-element>~, an instance of ~MyElement~ is created, and the aforementioned methods are called. We also can ~document.createElement('my-element')~ in JavaScript.

In some [[Example: ‚Äútime-formatted‚Äù][examples]], element content is rendered (created) in ~connectedCallback~. Why not in the ~constructor~?

The reason is simple: when ~constructor~ is called, it‚Äôs yet too early. The element is created, but the browser did not yet process/assign attributes at this stage: calls to ~getAttribute~ would return ~null~. So we can‚Äôt really render there.

The ~connectedCallback~ triggers when the element is added to the document. Not just appended to another element as a child, but actually becomes a part of the page. So we can build detached DOM, create elements and prepare them for later use. They will only be actually rendered when they make it into the page.

El objetivo del *constructor* es hacer ciertas tareas de inicializaci√≥n r√°pidas o tareas iniciales, como la creaci√≥n del Shadow DOM. Es esencial que en el constructor del componente se hagan s√≥lo las tareas m√°s prioritarias y ligeras.

#+begin_src javascript

  // En este momento, el Custom Element ya es reconocido por el navegador
  customElements.define("app-element", AppElement);

  // En este momento, se ejecuta el constructor() del componente
  const component = document.createElement("app-element");

  // En este momento, se ejecuta el connectedCallback() del componente
  document.body.append(component);

#+end_src

*Note*: El m√©todo ~disconnectedCallback()~ puede ser realmente √∫til para realizar tareas importantes de finalizaci√≥n que, de lo contrario, estar√≠an consumiendo recursos respecto a ese elemento.

#+begin_src javascript

  // Localizamos un componente en el documento HTML
  const element = document.querySelector("app-element");

  // En este momento, se ejecuta el disconnectedCallback() del componente
  element.remove();

#+end_src

Ejemplo de renderizaci√≥n:

#+begin_src javascript

  <app-element>
    <div class="container">Contenido previo del elemento</div>
  </app-element>

  <script>
  class AppElement extends HTMLElement {
      connectedCallback() {
         this.innerHTML = "<div>Hello, friend!</div>";
      }
  };
  customElements.define("app-element", AppElement);
  </script>
  // 1. Renderiza la etiqueta <app-element> y muestra su contenido
  // 2. Carga el componente, y se modifica el contenido existente.

#+end_src

***** Example: ‚Äútime-formatted‚Äù
There already exists ~<time>~ element in HTML, for date/time. But it doesn‚Äôt do any formatting by itself.

Let‚Äôs create ~<time-formatted>~ element that displays the time in a nice, language-aware format:

#+begin_src javascript

  <script>
  class TimeFormatted extends HTMLElement {
      // The class has only one method.
      connectedCallback() {
        let date = new Date(this.getAttribute('datetime') || Date.now());

        this.innerHTML = new Intl.DateTimeFormat("default", {
              year: this.getAttribute('year') || undefined,
              month: this.getAttribute('month') || undefined,
              day: this.getAttribute('day') || undefined,
              hour: this.getAttribute('hour') || undefined,
              minute: this.getAttribute('minute') || undefined,
              second: this.getAttribute('second') || undefined,
              timeZoneName: this.getAttribute('time-zone-name') || undefined,
        }).format(date);
      }

  }

  // We need to register our new element.
  customElements.define("time-formatted", TimeFormatted);
  </script>

  // We can use it everywhere.
  <time-formatted datetime="2019-12-01"
    year="numeric" month="long" day="numeric"
    hour="numeric" minute="numeric" second="numeric"
    time-zone-name="short">
  </time-formatted>
  // November 30, 2019 at 8:00:00 PM GMT-4

#+end_src

When ~customElement.define~ is called, they are ‚Äúupgraded‚Äù: a new instance of ~TimeFormatted~ is created for each, and ~connectedCallback~ is called. They become ~:defined~.

In the example above, element content is rendered (created) in ~connectedCallback~. Why not in the ~constructor~?

The reason is simple: when ~constructor~ is called, it‚Äôs yet too early. The element is created, but the browser did not yet process/assign attributes at this stage: calls to ~getAttribute~ would return ~null~. So we can‚Äôt really render there.

Besides, if you think about it, that‚Äôs better performance-wise ‚Äì to delay the work until it‚Äôs really needed.

The ~connectedCallback~ triggers when the element is added to the document. Not just appended to another element as a child, but actually becomes a part of the page. So we can build detached DOM, create elements and prepare them for later use. They will only be actually rendered when they make it into the page.

***** Get the information about custom elements
To get the information about custom elements, there are methods:
- customElements.get(name) :: returns the class for a custom element with the given ~name~ ,
- customElements.whenDefined(name) :: returns a promise that resolves (without value) when a custom element with the given ~name~ becomes defined.

#+begin_src javascript

  console.log(customElements.get("time-formatted"));
  // class TimeFormatted extends HTMLElement {
  //     // The class has only one method.
  //     connectedCallback() {
  //       let date = new Date(this.getAttribute('datetime') || Date.now());
  //       this.innerHT‚Ä¶

#+end_src

***** Observing attributes
In the current implementation of [[Example: ‚Äútime-formatted‚Äù][<time-formatted>]], after the element is rendered, further attribute changes don‚Äôt have any effect.

We can observe attributes by providing their list in [[observedAttributes()]] static getter. For such attributes, ~attributeChangedCallback~ is called when they are modified. It doesn‚Äôt trigger for other, unlisted attributes (that‚Äôs for performance reasons).

Here‚Äôs a new ~<time-formatted>~, that auto-updates when attributes change:

#+begin_src javascript

  <script>
  class TimeFormatted extends HTMLElement {

      // The rendering logic is moved to render() helper method.
      render() {
          let date = new Date(this.getAttribute('datetime') || Date.now());

          this.innerHTML = new Intl.DateTimeFormat("default", {
              year: this.getAttribute('year') || undefined,
              month: this.getAttribute('month') || undefined,
              day: this.getAttribute('day') || undefined,
              hour: this.getAttribute('hour') || undefined,
              minute: this.getAttribute('minute') || undefined,
              second: this.getAttribute('second') || undefined,
              timeZoneName: this.getAttribute('time-zone-name') || undefined,
              }).format(date);
          }

          // We call it once when the element is inserted into page.
          connectedCallback() {
              if (!this.rendered) {
                  this.render();
                  this.rendered = true;
              }
          }

          // For a change of an attribute, listed in observedAttributes(),
          // attributeChangedCallback triggers. (observe changes in attbs)
          static get observedAttributes() {
              return ['datetime', 'year', 'month', 'day', 'hour',
                      'minute', 'second', 'time-zone-name'];
          }

          // ‚Ä¶and re-renders the element. (runs when it detects attb changes)
          attributeChangedCallback(name, oldValue, newValue) {
              this.render();
          }

      }

  customElements.define("time-formatted", TimeFormatted);
  </script>

  <time-formatted id="elem" hour="numeric" minute="numeric"
  second="numeric"></time-formatted>

  // At the end, we can easily make a live timer.
  <script>
    setInterval(() => elem.setAttribute('datetime', new Date()), 1000);
  </script>

#+end_src

ManzDev example:

#+begin_src javascript

  // This <show-hello> element hides its internal DOM in shadow tree:
  <script>
    customElements.define('show-hello', class extends HTMLElement {
        connectedCallback() {
            const shadow = this.attachShadow({mode: 'open'});
            shadow.innerHTML = `<p>
      Hello, ${this.getAttribute('name')}
    </p>`;
        }
    });
  </script>

  <show-hello name="John"></show-hello>
  // Hello, John

#+end_src

Another example:

#+begin_src javascript

  <app-element>Sin nickname establecido.</app-element>
  <button>Cambiar nickname</button>

  <script>
   const appElement = document.querySelector("app-element");
    const button = document.querySelector("button");

    button.addEventListener("click", () => {
        const nickname = "Usuario" + Math.floor(Math.random() * 255);
        appElement.setAttribute("name", nickname);
    });

    // Doesn't work. No change detected:
    // class AppElement extends HTMLElement {
    //   constructor() {
    //     super();
    //     this.textContent = `El nickname del usuario es
    //                       ${this.getAttribute("name")}.`;
    //   }
    // }

    class AppElement extends HTMLElement {
        static get observedAttributes() {
            return ["name"];
        }

        attributeChangedCallback(name, old, now) {
            this.innerHTML = `Nickname cambiado de
                <mark>${old}</mark> a <mark>${now}</mark>.`;
        }
    }

    customElements.define("app-element", AppElement);
  </script>

#+end_src

***** Rendering order
When HTML parser builds the DOM, elements are processed one after another, parents before children. That leads to important consequences for custom elements.

For example, if a custom element tries to access ~innerHTML~ in ~connectedCallback~, it gets nothing:

#+begin_src javascript

  <user-info>John</user-info>
  // If run here, the alert works, but it's because HTML doesn't know the
  // tag, and reads it as a standard html element (with text inside), so
  // connectedCallback will update the tag, and can get the innerHTML (INS)

  <script>
      customElements.define('user-info', class extends HTMLElement {

          connectedCallback() {
              alert(this.innerHTML); // empty (*)
          }

      });
  </script>

  <user-info>John</user-info>
  // If you run it, the alert is empty.

#+end_src

That‚Äôs exactly because there are no children on that stage, the DOM is unfinished. HTML parser connected the custom element ~<user-info>~, and is going to proceed to its children, but just didn‚Äôt yet.

If we‚Äôd like to pass information to custom element, we can use attributes. They are available immediately.

Or, if we really need the children, we can defer access to them with zero-delay ~setTimeout~.

#+begin_src javascript

  // This works:
  <script>
    customElements.define('user-info', class extends HTMLElement {

      connectedCallback() {
          setTimeout(() => alert(this.innerHTML)); // John (*)
      }

    });
  </script>

  <user-info>John</user-info>

#+end_src

Now the ~alert~ in line =(*)= shows ‚ÄúJohn‚Äù, as we run it [[Asynchronous timing][asynchronously]], after the HTML parsing is complete. We can process children if needed and finish the initialization.

On the other hand, this solution is also not perfect. If nested custom elements also use ~setTimeout~ to initialize themselves, then they queue up: the outer ~setTimeout~ triggers first, and then the inner one.

So the outer element finishes the initialization before the inner one.

#+begin_src javascript

  <script>
    customElements.define('user-info', class extends HTMLElement {
        connectedCallback() {
            alert(`${this.id} connected.`);
            setTimeout(() => alert(`${this.id} initialized.`));
        }
    });
  </script>

  <user-info id="outer">
    <user-info id="inner"></user-info>
  </user-info>

  // Output order:
  //   1. outer connected.
  //   2. inner connected.
  //   3. outer initialized.
  //   4. inner initialized.
  // We can clearly see that the outer element finishes initialization (3)
  // before the inner one (4).

#+end_src

There‚Äôs no built-in callback that triggers after nested elements are ready. If needed, we can implement such thing on our own. For instance, inner elements can dispatch events like ~initialized~, and outer ones can listen and react on them.

**** Customized built-in elements
***** Brief
New elements that we create, such as [[Example: ‚Äútime-formatted‚Äù][<time-formatted>]], don‚Äôt have any associated semantics. They are unknown to search engines, and accessibility devices can‚Äôt handle them.

We can extend and customize built-in HTML elements by inheriting from their classes.

For example, buttons are instances of ~HTMLButtonElement~, let‚Äôs build upon it.

1. Extend ~HTMLButtonElement~ with our class:

#+begin_src javascript

  class HelloButton extends HTMLButtonElement { /* custom element methods */ }

#+end_src

2. Provide the third argument to [[CustomElementRegistry.define()][customElements.define]], that specifies the tag:

#+begin_src javascript

  customElements.define('hello-button', HelloButton, {extends: 'button'});

#+end_src

There may be different tags that share the same DOM-class, that‚Äôs why specifying extends is needed.

3. At the end, to use our custom element, insert a regular ~<button>~ tag, but add ~is="hello-button"~ to it:

#+begin_src javascript

  <button is="hello-button">...</button>

#+end_src

***** Example
Our new button extends the built-in one. So it keeps the same styles and standard features like ~disabled~ attribute.

#+begin_src javascript

  <script>
    // The button that says "hello" on click
    class HelloButton extends HTMLButtonElement {
        constructor() {
            super();
            this.addEventListener('click', () => alert("Hello!"));
        }
    }

    customElements.define('hello-button', HelloButton, {extends: 'button'});
  </script>

  <button is="hello-button">Click me</button>
  <button is="hello-button" disabled>Disabled</button>

#+end_src

**** Using a custom element
Using a custom element is as simple as importing it, and using the new tags in an HTML document. For example, to use the ~paper-button~ element:

#+begin_src html

<script type="module" src="node_modules/@polymer/paper-button/paper-button.js">
</script>
  ...
<paper-button raised class="indigo">raised</paper-button>

#+end_src

Most elements today can be installed with NPM. NPM also handles installing the components' dependencies.

For example, the ~paper-button~ overview describes the install process with npm:

#+begin_src sh

  mkdir my-new-app && cd my-new-app
  npm install --save @polymer/paper-button

#+end_src

**** Custom element methods

| /M√âTODO (customElements)/ | /DESCRIPCI√ìN/                         |
|-------------------------+-------------------------------------|
| /.define(name,class)/     | Asocia custom element a una clase   |
| /.get(name)/              | Obtiene la clase del custom element |
| /.whenDefined(name)/      | Idem al anterior, pero as√≠ncrona    |
| /.upgrade(node)/          | Actualiza de forma manual           |

#+begin_src javascript

  // .define()
  class AppElement extends HTMLElement {
      constructor() {
          super();
      }
  }

  customElements.define("app-element", AppElement);


  // .get():
  class AppElement extends HTMLElement {
      /* ... */
  }
  customElements.define("app-element", AppElement);

  customElements.get("app-element") === AppElement; // true


  // .whenDefined()
  customElements.whenDefined("app-element").then((data) => {
      console.log("AppElement ha sido definido");
  });
  // data devolver√° la clase que implementa el Custom Element


  // .upgrade()
  // Normalmente, los custom elements son registrados al inicio de carga de
  // la p√°gina y se definen de forma autom√°tica. Sin embargo, podr√≠a darse
  // el caso en el que hemos creado una etiqueta HTML personalizada sin
  // conectarla al DOM, y antes de haber definido el custom element. En ese
  // caso, el elemento personalizado seguir√≠a siendo una etiqueta HTML y no
  // se habr√≠a actualizado a√∫n.
  // 1) Creamos en memoria una etiqueta personalizada <app-element>
  const element = document.createElement("app-element");

  // 2) Posteriormente, definimos el custom element
  class AppElement extends HTMLElement { /* ... */ }
  customElements.define("app-element", AppElement);

  // 3) La etiqueta a√∫n sigue siendo una etiqueta normal
  element.constructor === HTMLElement;   // true

  // 4) La actualizamos manualmente (HTMLElement -> AppElement)
  customElements.upgrade(element);

  element.constructor === HTMLElement;   // false
  element.constructor === AppElement;    // true
  // Estas situaciones pueden ocurrir cuando no se hace el
  // customElements.define() inmediatamente, o en situaciones as√≠ncronas
  // donde se crea primero el elemento antes de tener definido y registrado
  // el Custom Element.

#+end_src

*** Shadow DOM
**** Brief
A set of JavaScript APIs for attaching an *encapsulated* "shadow" DOM tree to an element ‚Äî which is rendered separately from the main document DOM ‚Äî and controlling associated functionality. In this way, you can *keep an element's features private*, so they can be scripted and styled without the fear of collision with other parts of the document.

Shadow DOM *create an internal DOM for the component* or some HTML tags, hidden from the others.

Shadow DOM serves for *encapsulation*. It allows a component to have its very own ‚Äúshadow‚Äù DOM tree, that can‚Äôt be accidentally accessed from the main document, may have local style rules, and more.

Shadow DOM is a way to create a component-local DOM.

1. shadowRoot = [[attachShadow()][elem.attachShadow({mode: open|closed})]] ‚Äì *creates shadow DOM* for ~elem~ . If ~mode="open"~ , then it‚Äôs accessible as ~elem.shadowRoot~ property.
2. We can populate ~shadowRoot~ using ~innerHTML~ or other DOM methods, such as ~append~.

Shadow DOM elements:

- Have their own ids space,
- Invisible to JavaScript selectors from the main document, such as ~querySelector~,
- *Use styles only from the shadow tree*, not from the main document.

Shadow DOM, if exists, is rendered by the browser instead of so-called ‚Äúlight DOM‚Äù (regular children).

*Nota*: Aunque se suele asociar a WebComponents, realmente el Shadow DOM es una caracter√≠stica independiente que se puede aplicar a un elemento HTML normal, sin necesidad de que sea un componente.

#+begin_src javascript

  <app-element>
    <div class="container">Contenido previo del elemento</div>
  </app-element>

  <script>
    customElements.define("app-element", class extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: "open" });
        }

        connectedCallback() {
            this.shadowRoot.innerHTML = "<div>Hello, friend!</div>";
            // careful this.shadowRoot.innerHTML modifica Shadow DOM
            // this.innerHTML modificar√≠a s√≥lo el Light DOM
        }
  });
  </script>
  // 1. Renderiza la etiqueta <app-element> y muestra su contenido
  // 2. Cream un Shadow DOM en el componente
  // 3. Se a√±ade el nuevo contenido HTML en el Shadow DOM
  // 4. Justo al crear el Shadow DOM, se muestra y se oculta el antiguo DOM
  // Cuando se adjunta un Shadow DOM, se oculta el Light DOM. Sin
  // embargo,aunque el Light DOM se oculta, sigue existiendo en la
  // p√°gina. No se ha modificado ni eliminado.
  // El contenido tanto del Shadow DOM como del Light DOM est√°n presentes
  // en el c√≥digo, sin embargo, el Shadow DOM por el mero hecho de existir,
  // ya oculta visualmente cualquier contenido del Light DOM.

  <app-element> // light DOM
    #shadow-root (open) // shadom DOM
      <div>Hello, friend!</div> // shadom DOM
    <div class="container">Contenido previo del elemento</div> // light DOM
  </app-element>

#+end_src

**** Built-in shadow DOM
Did you ever think how complex browser controls are created and styled? Such as ~<input type="range">~.

The browser uses DOM/CSS internally to draw them. That DOM structure is normally hidden from us, but we can see it in developer tools. E.g. in Chrome, we need to enable in Dev Tools ‚ÄúShow user agent shadow DOM‚Äù option.

Then ~<input type="range">~ looks like this:

#+begin_src html

  <input type="range">
      #shadow-root (user-agent) == $0
          <div>
              <div pseudo="-webkit-slider-runnable-track" id="track">
                  <div id="thumb"></div>
              </div>
          </div>
  </input>

#+end_src

What you see under ~#shadow-root~ is called ‚Äúshadow DOM‚Äù.

We can‚Äôt get built-in shadow DOM elements by regular JavaScript calls or selectors. These are not regular children, but a powerful encapsulation technique.

In the example above, we can see a useful attribute pseudo. It‚Äôs non-standard, exists for historical reasons. We can use it style subelements with CSS, like this:

#+begin_src css

  <style>
    /* make the slider track red */
    input::-webkit-slider-runnable-track {
      background: red;
    }
  </style>

  <input type="range">

#+end_src

Once again, ~pseudo~ is a non-standard attribute. Chronologically, browsers first started to experiment with internal DOM structures to implement controls, and then, after time, shadow DOM was standardized to allow us, developers, to do the similar thing.

**** Shadow tree & Light tree
A DOM element can have two types of DOM *subtrees*:
- Light tree :: a *regular DOM* subtree, made of HTML children.
- Shadow tree :: a *hidden DOM* subtree, not reflected in HTML.

If an element has both, then the browser renders only the shadow tree. But we can setup a kind of composition between shadow and light trees as well.

Shadow tree can be used in [[Custom elements]] to hide component internals and apply component-local styles.

*ManzDev*
*Light DOM*
Como su propio nombre sugiere, el Light DOM es la contrapartida del Shadow DOM. Es el nombre con el que se suele hacer referencia a la parte oculta del DOM principal que hemos tapado con el Shadow DOM.

Justo en el momento que ejecutamos un ~.attachShadow()~, creamos un Shadow DOM que pasar√° a ¬´ocultar¬ª o oscurecer (con su sombra) al *DOM que exist√≠a en el componente*, de modo que desaparece de la p√°gina mostrada al usuario. Este DOM que desaparece se suele denominar *Light DOM*.

Example using a simple HTML element:

#+begin_src javascript

  // This node is in HTML DOM. Supposedly this node belongs to the "light
  // DOM", however if styles like this 'style="background:red;height:50px;"'
  // are applied to it,and "attachShadow" is activated,the styles take effect
  <div id="container">
    // These child nodes are in HTML DOM, but are hidden once
    // the Shadow DOM is attached (Shadow DOM sombrea Light DOM).
    <div style="background:yellow; width:200px; height:50px;"></div>
    <div style="background:blue; width:200px; height:50px;"></div>
    <div style="background:red; width:200px; height:50px;"></div>
  </div>

  // This node is in HTML DOM.
  <div id="redBar" style="background:red; height:50px;"></div>

  // This node is in HTML DOM, but then it's attached to Shadow
  // DOM, so it moves from HTML DOM to the Shadow DOM.
  <div id="yellowBar" style="background:yellow; height:50px;"></div>

  <script>
    let container = document.querySelector("#container");
    let yellowBar = document.querySelector("#yellowBar");
    let blueBar = document.createElement("div");

    blueBar.style.background = "blue";
    blueBar.style.height = "50px";

    container.attachShadow({ mode: "open" });
    container.shadowRoot.appendChild(yellowBar);
    container.shadowRoot.appendChild(blueBar);
  </script>

#+end_src

Example using  [[Custom elements]].

#+begin_src javascript

  // This <show-hello> element hides its internal DOM in shadow tree:
  <script>
    customElements.define('show-hello', class extends HTMLElement {
        connectedCallback() {
            const shadow = this.attachShadow({mode: 'open'});
            shadow.innerHTML = `<p>
      Hello, ${this.getAttribute('name')}
    </p>`;
        }
    });
  </script>

  <show-hello name="John"></show-hello>
  // Hello, John

#+end_src

That‚Äôs how the resulting DOM looks in Chrome dev tools, all the content is under ~‚Äú#shadow-root‚Äù~:

#+begin_src html

  <show-hello name="John"> == $0
      #shadow-root (user-agent)
          <p> Hello, John </p>
  </show-hello>

#+end_src

First, the call to [[attachShadow()][elem.attachShadow({mode: ‚Ä¶})]] creates a shadow tree.

There are two limitations:
1. We can create only one shadow root per element.
2. The ~elem~ must be either a [[Custom elements]], or one of: ~article~ , ~aside~ , ~blockquote~ , ~body~ , ~div~ , ~footer~ , ~h1‚Ä¶h6~ , ~header~ , ~main~ ~nav~ , ~p~ , ~section~ , or ~span~ . Other elements, like ~<img>~, can‚Äôt host shadow tree.

The ~mode~ option sets the encapsulation level. It must have any of two values:

- "open" :: the shadow root is available as ~elem.shadowRoot~. Any code is able to access the shadow tree of ~elem~.
- "closed" ::  ~elem.shadowRoot~ is always ~null~. We can only access the shadow DOM by the reference returned by ~attachShadow~ (and probably hidden inside a class).

The shadow root, returned by ~attachShadow~, is like an element: we can use ~innerHTML~ or DOM methods, such as ~append~ , to populate it.

The element with a shadow root is called a ‚Äúshadow tree host‚Äù, and is available as the shadow root ~host~ property:

#+begin_src javascript

  // assuming {mode: "open"}, otherwise elem.shadowRoot is null
  alert(elem.shadowRoot.host === elem); // true


  // mode: "open"
  const div = document.createElement("div");
  const shadow = div.attachShadow({ mode: "open" });

  div.shadowRoot === shadow; // true (es el mismo elemento)

  // mode: "closed"
  const shadow = div.attachShadow({ mode: "closed" });

  div.shadowRoot === null; // true (no se guarda la referencia)

#+end_src

**** Encapsulation Shadow DOM
Shadow DOM is strongly delimited from the main document:

- Shadow DOM elements are not visible to ~querySelector~ from the light DOM. In particular, Shadow DOM elements may have ids that conflict with those in the light DOM. They must be unique only within the shadow tree.
- Shadow DOM has own stylesheets. Style rules from the outer DOM don‚Äôt get applied.

#+begin_src javascript

  <style>
    /* document style won't apply to the shadow tree inside #elem */
    p { color: red; }
  </style>

  <div id="elem"></div>

  <script>
    elem.attachShadow({mode: 'open'});
      // shadow tree has its own style
    elem.shadowRoot.innerHTML = `
      <style> p { font-weight: bold; } </style>
      <p>Hello, John!</p>
    `;

  // <p> is only visible from queries inside the shadow tree
  alert(document.querySelectorAll('p').length); // 0
  alert(elem.shadowRoot.querySelectorAll('p').length); // 1
  </script>

#+end_src

**** Slots, composition, flattened DOM
***** Brief
*ManzDev*
Los [[file:~/Documents/HTML-CSS-SEO.org::slot][<slot>]] son ¬´accesos directos¬ª que nos permiten enviar contenido HTML desde el [[Shadow tree & Light tree][Light DOM]] para reutilizarlo en el Shadow DOM del componente. Esto puede verse como un *hueco o ranura en el Shadow DOM que deja ver el contenido que est√° ¬´debajo¬ª en el Light DOM*. Es obligatorio tener un Shadow DOM en el componente para poder utilizar slots. De lo contrario, no funcionar√°n.

*Javascript.info*
Many types of components, such as tabs, menus, image galleries, and so on, need the content to render.

Just like built-in browser ~<select>~ expects ~<option>~ items, our ~<custom-tabs>~ may expect the actual tab content to be passed. And a ~<custom-menu>~ may expect menu items.

The code that makes use of ~<custom-menu>~ can look like this:

#+begin_src html

  <custom-menu>
    <title>Candy menu</title>
    <item>Lollipop</item>
    <item>Fruit Toast</item>
    <item>Cup Cake</item>
  </custom-menu>

#+end_src

‚Ä¶Then our component should render it properly, as a nice menu with given title and items, handle menu events, etc.

How to implement it?

We could try to analyze the element content and dynamically copy-rearrange DOM nodes. That‚Äôs possible, but if we‚Äôre moving elements to shadow DOM, then CSS styles from the document do not apply in there, so the visual styling may be lost. Also that requires some coding.

Luckily, we don‚Äôt have to. Shadow DOM supports ~<slot>~ elements, that are automatically filled by the content from light DOM.

*Summary*:
Usually, if an element has shadow DOM, then its light DOM is not displayed. Slots allow to show elements from light DOM in specified places of shadow DOM.

There are two kinds of slots:

- [[Named slots & flattened DOM]] :: ~<slot name="X">...</slot>~ ‚Äì gets light children with ~slot="X"~.
- [[Default slot: first unnamed][Default slot]] :: the first ~<slot>~ without a name (subsequent unnamed slots are ignored) ‚Äì gets unslotted light children.
- If there are many elements for the same slot ‚Äì they are appended one after another.
- The content of ~<slot>~ element is used as a fallback. It‚Äôs shown if there are no light children for the slot.

The process of rendering slotted elements inside their slots is called *‚Äúcomposition‚Äù*. The result is called a ‚Äú[[Named slots & flattened DOM][flattened DOM]]‚Äù.

*Warning*: Only top-level children may have ~slot="‚Ä¶"~ attribute

The ~slot="..."~ attribute is only valid for direct children of the shadow host. For nested elements it‚Äôs ignored.

Composition does not really move nodes, from JavaScript point of view the DOM is still same.

JavaScript can access slots using [[Slot API (track slot) (assignedSlot)][methods]]:

- ~slot.assignedNodes/Elements()~ ‚Äì returns nodes/elements inside the ~slot~.
- ~node.assignedSlot~ ‚Äì the reverse property, returns slot by a node.

If we‚Äôd like to know what we‚Äôre showing, we can track slot contents using:

[[Updating slots (slotchange event)][slotchange]] event ‚Äì triggers the first time a slot is filled, and on any add/remove/replace operation of the slotted element, but not its children. The slot is ~event.target~.

***** Slot fallback content
If we put something inside a ~<slot>~, it becomes the fallback, ‚Äúdefault‚Äù content. The browser shows it if there‚Äôs no corresponding filler in light DOM.

For example, in this piece of shadow DOM, ~Anonymous~ renders if there‚Äôs no ~slot="username"~ in light DOM.

#+begin_src html

  <div>Name:
    <slot name="username">Anonymous</slot>
  </div>

#+end_src

***** Named slots & flattened DOM
Shadow DOM supports [[file:~/Documents/html-css-seo.org::slot][<slot>]] elements, that are automatically filled by the content from light DOM.

Here, ~<user-card>~ shadow DOM provides two slots, filled from light DOM:

#+begin_src javascript

  <script>
    customElements.define('user-card', class extends HTMLElement {
        connectedCallback() {
            this.attachShadow({mode: 'open'});
            this.shadowRoot.innerHTML = `
              <div>Name:
                <slot name="username"></slot>
              </div>
              <div>Birthday:
                <slot name="birthday"></slot>
              </div>
           `;
        }
    });
  </script>

  <user-card>
    <span slot="username">John Smith</span>
    <span slot="birthday">01.01.2001</span>
  </user-card>
  // Name: John Smith
  // Birthday: 01.01.2001

#+end_src

In the shadow DOM, ~<slot name="X">~ defines an ‚Äúinsertion point‚Äù, a place where elements with ~slot="X"~ are rendered.

Then the browser performs ‚Äúcomposition‚Äù: it takes elements from the light DOM and renders them in corresponding slots of the shadow DOM. At the end, we have exactly what we want ‚Äì a component that can be filled with data.

Here‚Äôs the DOM structure after the script, not taking composition into account:

#+begin_src html

  <user-card>
      #shadow-root <!-- Shadow DOM -->
          <div>Name:
              <slot name="username"></slot>
          </div>
          <div>Birthday:
              <slot name="birthday"></slot>
          </div>
      <!-- Light DOM     -->
      <span slot="username">John Smith</span>
      <span slot="birthday">01.01.2001</span>
  </user-card>

#+end_src

We created the shadow DOM, so here it is, under ~#shadow-root~. Now the element has both light and shadow DOM.

For rendering purposes, for each ~<slot name="...">~ in shadow DOM, the browser looks for ~slot="..."~ with the same name in the light DOM. These elements are rendered inside the slots.

The result is called *‚Äúflattened‚Äù DOM*:

#+begin_src html

  <user-card>
    #shadow-root
      <div>Name:
        <slot name="username">
          <!-- slotted element is inserted into the slot -->
          <span slot="username">John Smith</span>
        </slot>
      </div>
      <div>Birthday:
        <slot name="birthday">
          <!-- slotted element is inserted into the slot -->
          <span slot="birthday">01.01.2001</span>
        </slot>
      </div>
  </user-card>


#+end_src

‚Ä¶But the *flattened DOM exists only for rendering* and event-handling purposes. It‚Äôs kind of ‚Äú *virtual* ‚Äù. That‚Äôs how things are shown. But the nodes in the document are actually not moved around!

That can be easily checked if we run ~querySelectorAll~: nodes are still at their places.

#+begin_src javascript

  // light DOM <span> nodes are still at the same place, under `<user-card>`
  alert( document.querySelectorAll('user-card span').length ); // 2

#+end_src

So, the flattened DOM is derived from shadow DOM by inserting slots. The browser renders it and uses for style inheritance, [[Events][event]] propagation. But JavaScript still sees the document ‚Äúas is‚Äù, before flattening.

*Warning*: Only top-level children may have ~slot="‚Ä¶"~ attribute

The ~slot="..."~ attribute is only valid for direct children of the shadow host (in our example, ~<user-card>~ element). For nested elements it‚Äôs ignored.

For example, the second ~<span>~ here is ignored (as it‚Äôs not a top-level child of ~<user-card>~):

#+begin_src html

  <user-card>
    <span slot="username">John Smith</span>
    <div>
      <!-- invalid slot, must be direct child of user-card -->
      <span slot="birthday">01.01.2001</span>
    </div>
  </user-card>

#+end_src

***** Default slot: first unnamed
The first ~<slot>~ in shadow DOM that doesn‚Äôt have a name is a ‚Äúdefault‚Äù slot. It gets all nodes from the light DOM that aren‚Äôt slotted elsewhere.

For example, let‚Äôs add the default slot to our ~<user-card>~ that shows all unslotted information about the user:

#+begin_src javascript

  <script>
  customElements.define('user-card', class extends HTMLElement {
      connectedCallback() {
          this.attachShadow({mode: 'open'});
          this.shadowRoot.innerHTML = `
          <div>Name:
            <slot name="username"></slot>
          </div>
          <div>Birthday:
            <slot name="birthday"></slot>
          </div>
          <fieldset>
            <legend>Other information</legend>
            <slot></slot>
          </fieldset>
          `;
          }
      });
  </script>

  <user-card>
    <div>I like to swim.</div>
    <span slot="username">John Smith</span>
    <span slot="birthday">01.01.2001</span>
    <div>...And play volleyball too!</div>
  </user-card>

  // Name: John Smith
  // Birthday: 01.01.2001
  // +--Other information------------------------------------+
  // |  I like to swim.                                      |
  // |  ...And play volleyball too!                          |
  // +-------------------------------------------------------+

#+end_src

The flattened DOM looks like this:

#+begin_src html

  <user-card>
    #shadow-root
      <div>Name:
        <slot name="username">
          <span slot="username">John Smith</span>
        </slot>
      </div>
      <div>Birthday:
        <slot name="birthday">
          <span slot="birthday">01.01.2001</span>
        </slot>
      </div>
      <fieldset>
        <legend>Other information</legend>
        <slot>
          <div>I like to swim.</div>
          <div>...And play volleyball too!</div>
        </slot>
      </fieldset>
  </user-card>

#+end_src

***** Menu example
We can use slots to distribute elements.

Here‚Äôs the markup for ~<custom-menu>~:

#+begin_src html

  <custom-menu>
    <span slot="title">Candy menu</span>
    <li slot="item">Lollipop</li>
    <li slot="item">Fruit Toast</li>
    <li slot="item">Cup Cake</li>
  </custom-menu>

#+end_src

The shadow DOM template with proper slots:

#+begin_src html

  <template id="tmpl">
    <style>
      ul {
        margin: 0;
        list-style: none;
        padding-left: 20px;
      }

    ::slotted([slot="title"]) {
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
    }

    ::slotted([slot="title"])::before {
      content: 'üìÇ';
      font-size: 14px;
    }

    .closed ::slotted([slot="title"])::before {
      content: 'üìÅ';
    }

    .closed ul {
      display: none;
    }
    </style>
    <div class="menu">
      <slot name="title"></slot>
      <ul><slot name="item"></slot></ul>
    </div>
  </template>

#+end_src

1. ~<span slot="title">~ goes into ~<slot name="title">~.
2. There are many ~<li slot="item">~ in the ~<custom-menu>~, but only one ~<slot name="item">~ in the template. So all such ~<li slot="item">~ are appended to ~<slot name="item">~ one after another, thus forming the list.

The flattened DOM becomes:

#+begin_src html

  <custom-menu>
    #shadow-root
    <style> /* menu styles */ </style>
    <div class="menu">
      <slot name="title">
        <span slot="title">Candy menu</span>
      </slot>
      <ul>
        <slot name="item">
          <li slot="item">Lollipop</li>
          <li slot="item">Fruit Toast</li>
          <li slot="item">Cup Cake</li>
        </slot>
      </ul>
    </div>
  </custom-menu>

#+end_src

One might notice that, in a valid DOM, ~<li>~ must be a direct child of ~<ul>~. But that‚Äôs flattened DOM, it describes how the component is rendered, such thing happens naturally here.

We just need to add a click handler to open/close the list, and the ~<custom-menu>~ is ready:

#+begin_src javascript

  customElements.define('custom-menu', class extends HTMLElement {
    connectedCallback() {
        this.attachShadow({mode: 'open'});

        // tmpl is the shadow DOM template (above)
        this.shadowRoot.append( tmpl.content.cloneNode(true) );

        // we can't select light DOM nodes, so let's handle clicks on the slot
        this.shadowRoot.querySelector('slot[name="title"]').onclick = () => {
        // open/close the menu
        this.shadowRoot.querySelector('.menu').classList.toggle('closed');
          };
      }
  });

  // üìÇ Candy menu    =>    üìÅ  Candy men
  //     Lollipop
  //     Fruit Toast
  //     Cup Cake

#+end_src

***** Updating slots (slotchange event)
What if the outer code wants to add/remove menu items dynamically?

*The browser monitors slots and updates the rendering if slotted elements are added/removed* (not modified).

Also, as light DOM nodes are not copied, but just rendered in slots, the changes inside them immediately become visible.

So we don‚Äôt have to do anything to update rendering. But if the component code wants to know about slot changes, then ~slotchange~ event is available.

For example, here the menu item is inserted dynamically after 1 second, and the title changes after 2 seconds:

#+begin_src javascript

  <custom-menu id="menu">
    <span slot="title">Candy menu</span>
  </custom-menu>

  <script>
  customElements.define('custom-menu', class extends HTMLElement {
      connectedCallback() {
          this.attachShadow({mode: 'open'});
          this.shadowRoot.innerHTML = `<div class="menu">
            <slot name="title"></slot>
            <ul><slot name="item"></slot></ul>
            </div>`;

           // shadowRoot can't have event handlers, so using the first child
           this.shadowRoot.firstElementChild.addEventListener('slotchange',
             e => alert("slotchange: " + e.target.name)
           );
         }
      });

  setTimeout(() => {
      menu.insertAdjacentHTML('beforeEnd', '<li slot="item">Lollipop</li>')
  }, 1000);

  setTimeout(() => {
      // doesn't trigger the event because just modifies the element
      menu.querySelector('[slot="title"]').innerHTML = "New menu";
  }, 2000);
  </script>

#+end_src

The menu rendering updates each time without our intervention.

There are two ~slotchange~ events here:

- At initialization :: ~slotchange: title~ triggers immediately, as the ~slot="title"~ from the light DOM gets into the corresponding slot.

- After 1 second :: ~slotchange: item~ triggers, when a new ~<li slot="item">~ is added.

*Note*: there‚Äôs no ~slotchange~ event after 2 seconds, when the content of ~slot="title"~ is modified. That‚Äôs because there‚Äôs no *slot* change. We modify the *content inside* the slotted element, that‚Äôs another thing.

*ManzDev*
El evento ~slotchange~ se dispara cuando detecta que una asociaci√≥n slot-elemento ha cambiado:
- un ~<slot>~ cambia su atributo ~name~, y por lo tanto apunta a otro elemento
- una etiqueta del Light DOM cambia su atributo ~slot~, y por lo tanto, es referencia de otro slot.

#+begin_src javascript

  const slot = document.querySelector("slot");
  slot.addEventListener("slotchange", () =>
      console.log("¬°El slot ha cambiado!"));

#+end_src

***** Slot API (track slot) (assignedSlot, assignedNodes)
As we‚Äôve seen before, JavaScript looks at the ‚Äúreal‚Äù DOM, without flattening. But, if the shadow tree has ~{mode: 'open'}~, then we can figure out which elements assigned to a slot and, vice-versa, the slot by the element inside it:

- ~node.assignedSlot~ ‚Äì returns the ~<slot>~ element that the ~node~ is assigned to.
- ~slot.assignedNodes({flatten: true/false})~ ‚Äì DOM nodes, assigned to the slot. The ~flatten~ option is ~false~ by default. If explicitly set to ~true~, then it looks more deeply into the flattened DOM, returning nested slots in case of nested components and the fallback content if no node assigned.
- ~slot.assignedElements({flatten: true/false})~ ‚Äì DOM elements, assigned to the slot (same as above, but only element nodes).

These methods are useful when we need not just show the slotted content, but also track it in JavaScript.

For example, if ~<custom-menu>~ component wants to know, what it shows, then it could track ~slotchange~ and get the items from ~slot.assignedElements~:

#+begin_src javascript

  <custom-menu id="menu">
    <span slot="title">Candy menu</span>
    <li slot="item">Lollipop</li>
    <li slot="item">Fruit Toast</li>
  </custom-menu>

  <script>
  customElements.define('custom-menu', class extends HTMLElement {
      // same as (this.items = []) although it isn't necessary (INS)
      items = []

      connectedCallback() {
          this.attachShadow({mode: 'open'});
          this.shadowRoot.innerHTML = `<div class="menu">
    <slot name="title"></slot>
    <ul><slot name="item"></slot></ul>
  </div>`;

    // triggers when slot content changes
    this.shadowRoot.firstElementChild.addEventListener('slotchange', e => {
        let slot = e.target;
        if (slot.name == 'item') {
          this.items = slot.assignedElements().map(elem => elem.textContent);
          alert("Items: " + this.items);
        }
      });
    }
  });

  // items update after 1 second
  setTimeout(() => {
        menu.insertAdjacentHTML('beforeEnd', '<li slot="item">Cup Cake</li>')
    }, 1000);
  </script>

#+end_src

**** Styling web component, Shadom DOM, slots
***** Brief
Shadow DOM may include both ~<style>~ and ~<link rel="stylesheet" href="‚Ä¶">~ tags. In the latter case, stylesheets are HTTP-cached, so they are not redownloaded for multiple components that use same template.

As a general rule, local styles work only inside the shadow tree, and document styles work outside of it. But there are few exceptions.

Local and document styles can affect:

*Local styles*
- *shadow tree*,
- *shadow host* with [[Pseudoclass :host][:host]] and [[Funcional pseudoclass :host(selector)][:host()]] pseudoclasses,
- *slotted elements* (coming from light DOM), [[Styling slotted content (::slotted(selector))][::slotted(selector)]] allows to select slotted elements themselves, but not their children.

*Document styles*
- *shadow host* (as it lives in the outer document)
- *slotted elements* and their *contents* (as that‚Äôs also in the outer document)

*Nota*: en los estilos globales del componente es necesario colocar un ~display~, ya que por defecto, un componente tiene valor ~display: inline~ y muchas propiedades no le afectan.

#+begin_src css

  app-element {
    display: block;
    background: indigo;
    margin: 5px;
  }

#+end_src

When CSS properties conflict, normally *document styles have precedence*, unless the property is labelled as ~!important~. Then local styles have precedence.

[[file:~/Documents/HTML-CSS-SEO.org::Custom properties (--*): CSS variables][CSS custom properties]] pierce through shadow DOM. They are used as ‚Äúhooks‚Äù to style the component:

1. The component uses a custom CSS property to style key elements, such as ~var(--component-name-title, <default value>)~.
2. Component author publishes these properties for developers, they are same important as other public component methods.
3. When a developer wants to style a title, they assign ~--component-name-title~ CSS property for the shadow host or above.
4. Profit!

***** Cascading
The shadow host (~<custom-dialog>~ itself) resides in the light DOM, so it‚Äôs affected by document CSS rules.

If there‚Äôs a property styled both in ~:host~ locally, and in the document, then the document style takes precedence.

For instance, if in the document we had:

#+begin_src js

  <style>
    custom-dialog {
      padding: 0;
      background: gray;
    }
  </style>

  <template id="tmpl">
    <style>
      /* the style will be applied from inside to the custom-dialog element */
      :host {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        display: inline-block;
        border: 1px solid red;
        padding: 10px;
        background: yellow;
      }
    </style>
    <slot></slot>
  </template>

  <script>
  customElements.define('custom-dialog', class extends HTMLElement {
    connectedCallback() {
      this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));
    }
  });
  </script>

  <custom-dialog>
    Hello!
  </custom-dialog>

#+end_src

‚Ä¶Then the ~<custom-dialog>~ would be without padding and gray color.

It‚Äôs very convenient, as we can setup ‚Äúdefault‚Äù component styles in its ~:host~ rule, and then easily override them in the document.

The exception is when a local property is labelled ~!important~, for such properties, local styles take precedence.

***** Styling elements inside the Shadom DOM
****** <style> tag
La estrategia preferida en WebComponents suele ser utilizar la etiqueta ~<style>~ en el marcado HTML del componente. De esta forma podremos escribir los estilos CSS que afectar√°n a toda la p√°gina en el ~index.css~ (global) y los estilos que afectan s√≥lo al componente en el bloque ~<style>~ de dicho componente con Shadow DOM.

#+begin_src javascript

  <h2>Titular global</h2>
  <app-element></app-element>

  <script>
  class AppElement extends HTMLElement {
      constructor() {
          super();
          this.attachShadow({ mode: "open" });
      }

      connectedCallback() {
          this.shadowRoot.innerHTML = /* html */`
           <style>
             h2 { color: indigo; }
             p { color: blueviolet; }
           </style>
           <div class="container">
             <h2>T√≠tular del componente</h2>
             <p>Texto y descripci√≥n del contenido del componente.</p>
           </div>
        `;
      }
  }

  customElements.define("app-element", AppElement);
  </script>

#+end_src

*CSS mediante estilos externos*

#+begin_src javascript

  <app-element></app-element>

  <script>
  class AppElement extends HTMLElement {
      constructor() {
          super();
          this.attachShadow({ mode: "open" });
       }

       connectedCallback() {
           this.shadowRoot.innerHTML = /* html */`
             <style>
               @import "./components/AppElement.css";
             </style>
             <div class="container">
               <h2>T√≠tular del componente</h2>
               <p>Texto y descripci√≥n del contenido del componente.</p>
             </div>
           `;
       }
   };

  customElements.define("app-element", AppElement);
  </script>

#+end_src

*CSS Constructables*

#+begin_src javascript

  <app-element></app-element>

  <script>
  import styles from "./AppElement.css" with { type: "css" };

  class AppElement extends HTMLElement {
      constructor() {
          super();
          this.attachShadow({ mode: "open" });
      }

      connectedCallback() {
          this.shadowRoot.adoptedStyleSheets.push(styles);
          this.shadowRoot.innerHTML = /* html */`
        <div class="container">
          <h2>T√≠tular del componente</h2>
          <p>Texto y descripci√≥n del contenido del componente.</p>
        </div>
      `;
      }
  }

  customElements.define("app-element", AppElement);
  </script>

  // Posteriormente, podr√≠amos utilizar la propiedad .adoptedStyleSheets
  // del Shadow DOM para incluir ese objeto CSSStyleSheet que acabamos de
  // importar en el componente. Se puede utilizar cualquiera de las dos
  // formas siguientes:
  this.shadowRoot.adoptedStyleSheets=[...document.adoptedStyleSheets, styles];
  this.shadowRoot.adoptedStyleSheets.push(styles);

#+end_src

****** CSS hooks with custom properties
How do we style internal elements of a component from the main document?

Selectors like [[Pseudoclass :host][:host]] apply rules to ~<custom-dialog>~ element or ~<user-card>~, but how to style shadow DOM elements inside them?

There‚Äôs no selector that can directly affect shadow DOM styles from the document. But just as we expose methods to interact with our component, we can expose CSS variables ([[file:~/Documents/HTML-CSS-SEO.org::Custom properties (--*): CSS variables][CSS custom properties]]) to style it.

*Custom CSS properties* exist on all levels, both in light and shadow.

For example, in shadow DOM we can use ~--user-card-field-color~ CSS variable to style fields, and the outer document can set its value:

#+begin_src css

  <style>
    .field {
      color: var(--user-card-field-color, black);
      /* if --user-card-field-color is not defined, use black color */
    }
  </style>
  <div class="field">Name: <slot name="username"></slot></div>
  <div class="field">Birthday: <slot name="birthday"></slot></div>

#+end_src

Then, we can declare this property in the outer document for ~<user-card>~:

#+begin_src css

  user-card {
    --user-card-field-color: green;
  }

#+end_src

Custom CSS properties pierce through shadow DOM, they are visible everywhere, so the inner ~.field~ rule will make use of it.

Here‚Äôs the full example:

#+begin_src javascript

  <style>
    user-card {
      --user-card-field-color: green;
    }
  </style>

  <template id="tmpl">
    <style>
      .field {
        color: var(--user-card-field-color, black);
      }
    </style>
    <div class="field">Name: <slot name="username"></slot></div>
    <div class="field">Birthday: <slot name="birthday"></slot></div>
  </template>

  <script>
  customElements.define('user-card', class extends HTMLElement {
    connectedCallback() {
      this.attachShadow({mode: 'open'});
      this.shadowRoot.append(document.getElementById('tmpl')
      .content.cloneNode(true));
    }
  });
  </script>

  <user-card>
    <span slot="username">John Smith</span>
    <span slot="birthday">01.01.2001</span>
  </user-card>

#+end_src

*ManzDev*
En el contexto de WebComponents, las Variables CSS son capaces de penetrar y filtrarse a trav√©s del Shadow DOM de un elemento, adem√°s tienen concepto de √°mbito en el DOM.

#+begin_src javascript

  <app-element></app-element>
  <app-element></app-element>
  <app-element></app-element>

  <style>
    app-element:first-of-type {
      --bgcolor: orangered;
    }
  </style>

  <script>
    class AppElement extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: "open" });
      }

      connectedCallback() {
        this.shadowRoot.innerHTML = /* html */`
          <style>
            .element {
              display: inline-block;
              padding: 6px 20px;
              background: var(--bgcolor, grey);
              color: white;
            }
            span {
              font-weight: bold;
              vertical-align: super;
              font-size: small;
              color: gold;
            }
          </style>
          <div class="element">
            AppElement <span>New!</span>
          </div>
        `;
      }
    };
    customElements.define("app-element", AppElement);
  </script>

#+end_src

****** Pseudoelement ::part()
En el contexto de componentes, tambi√©n tenemos un mecanismo para organizar y simplificar la forma en la que creamos partes de un componente que queremos que se le de estilo desde el exterior. La idea clave de este sistema, es identificar y exponer las partes de un componente, utilizando el atributo HTML part con el nombre que deseemos.

Adem√°s, esta especificaci√≥n tambi√©n brinda una API Javascript, para poder manejar las partes desde la l√≥gica de nuestro componente, permitiendo a√±adir, eliminar, reemplazar o conmutar a trav√©s de m√©todos como ~.add()~ , ~remove()~ , ~replace()~ o ~toggle()~ , o comprobar si existe mediante ~.contains()~ , similar a como se hace con la API [[classList]] de Javascript.

#+begin_src javascript

  <app-element></app-element>
  <app-element></app-element>
  <app-element></app-element>

  // Utilizamos el pseudoelemento CSS ::part(name) para indicar la parte
  // concreta de un componente a las que queremos dar estilo
  <style>
    app-element {
      --bgcolor: steelblue;
    }
    app-element::part(content) {
      font-size: 1.25rem;
      font-weight: bold;
      padding: 15px;
    }
    app-element::part(badge) {
      font-weight: bold;
      vertical-align: super;
      font-size: small;
      color: gold;
      background: black;
      padding: 10px;
    }
  </style>

  <script>
    class AppElement extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: "open" });
      }

      connectedCallback() {
        this.shadowRoot.innerHTML = /* html */`
          <style>
            :host {
              display: inline-block;
              padding: 6px 20px;
              background: var(--bgcolor, grey);
              color: white;
            }
          </style>
          <div class="element">
            <span part="content">AppElement</span>
            <span part="badge">New!</span>
          </div>
        `;
      }
    };
    // part="content" para el contenido del componente
    // part="badge" para las decoraciones del componente

    customElements.define("app-element", AppElement);
  </script>

#+end_src

***** Styling elements containing the shadow tree (web-component)
****** Pseudoclass :host
The ~:host~ selector allows to select the *shadow host* (*the element containing the shadow tree*). Its function is to style the custom element, for example, ~<custom-dialog>~ within the component.

For instance, we‚Äôre making ~<custom-dialog>~ element that should be centered. For that we need to style the ~<custom-dialog>~ element itself.

That‚Äôs exactly what ~:host~ does:

#+begin_src js

  <template id="tmpl">
    <style>
    /* the style will be applied from inside to the custom-dialog element */
       :host {
       /* it's necessary to change the display property since
          the default custom element is display inline and some
          properties wouldn't be applied */
         display: inline-block;
         position: fixed; /* or position: absolute; */
         left: 50%;
         top: 50%;
         transform: translate(-50%, -50%);
         border: 1px solid red;
         padding: 10px;
       }
    </style>
    <slot></slot>
  </template>

  <script>
  customElements.define('custom-dialog', class extends HTMLElement {
    connectedCallback() {
      this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));
    }
  });
  </script>

  <custom-dialog>
    Hello!
  </custom-dialog>

#+end_src

****** Funcional pseudoclass :host(selector)
*ManzDev*
En el caso de la pseudoclase funcional ~:host(selector)~, podemos indicar un selector, de modo que solo seleccionar√° los custom elements que encajen con dicho selector. Esto es √∫til para aplicar s√≥lo a componentes con ciertas clases o atributos espec√≠ficos.

*javascript.info*
Same as [[Pseudoclass :host][:host]], but applied only if the shadow host matches the ~selector~.

For example, we‚Äôd like to center the ~<custom-dialog>~ only if it has ~centered~ attribute:

#+begin_src javascript

  <template id="tmpl">
    <style>
      :host([centered]) {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        border-color: blue;
    }

    :host {
       display: inline-block;
       border: 1px solid red;
       padding: 10px;
     }
    </style>
    <slot></slot>
  </template>

  <script>
  customElements.define('custom-dialog', class extends HTMLElement {
    connectedCallback() {
     this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));
    }
  });
  </script>


  <custom-dialog centered>
    Centered!
  </custom-dialog>

  <custom-dialog>
    Not centered.
  </custom-dialog>

#+end_src

*ManzDev*

#+begin_src javascript

  <app-element></app-element>
  <app-element disabled></app-element>

  <script>
  class AppElement extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }

    connectedCallback() {
      this.shadowRoot.innerHTML = /* html */`
        <style>
          :host {
            display: inline-block;
            padding: 10px;
            background: steelblue;
            border: 5px outset #6666;
          }

          :host([disabled]) {
            background: grey;
            cursor: not-allowed;
          }
          :host([disabled]) span {
            color: black;
          }

          span {
            font-weight: bold;
            vertical-align: super;
            font-size: small;
            color: red;
          }
        </style>
        <div class="element">
          AppElement <span>New!</span>
        </div>
      `;
    }
  };

  customElements.define("app-element", AppElement);
  </script>

#+end_src

****** Funcional pseudoclass :host-context()
Selecciona los custom elements que se encuentren en un contexto que encajan con el selector especificado entre par√©ntesis, es decir, selecciona los componentes que est√©n dentro de los selectores indicados.

*Nota*: no esta ampliamente soportada en todos los navegadores.

#+begin_src javascript

  <app-element></app-element>
  <div class="dark">
    <app-element></app-element>
  </div>

  <script>
  class AppElement extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }

    connectedCallback() {
      this.shadowRoot.innerHTML = /* html */`
        <style>
          :host {
            display: block;
            background: indigo;
            color: white;
            padding: 10px;
            margin: 5px;
          }
          :host-context(.dark) {
            background: black;
          }
          span {
            font-weight: bold;
            vertical-align: super;
            font-size: small;
            color: gold;
          }
        </style>
        <div class="element">
          AppElement <span>New!</span>
        </div>
      `;
    }
  };

  customElements.define("app-element", AppElement);
  </script>

#+end_src

****** Pseudoclass :define
Aplicar estilos dependiendo de si el elemento ha sido o no definido en el navegador. Por ejemplo, en el proceso inicial de carga de la p√°gina pueden existir momentos en los que el navegador a√∫n no conoce el custom element que va a utilizar y no se encuentra cargado en el registro de custom elements del navegador.

#+begin_src css

  app-element:not(:defined) {
    display: block;
    height: 46px;
    background: linear-gradient(grey, lightgrey);
  }

  app-element:defined {
    display: block;
    border: 2px solid red;
  }
  /* estos estilos podr√≠an ir dentro del componente */

#+end_src

***** Styling slotted content (::slotted(selector))
Slotted elements come from light DOM, so they use document styles. Local styles do not affect slotted content.

In the example below, slotted ~<span>~ is bold, as per document style, but does not take ~background~ from the local style:

#+begin_src javascript

  <style>
    span { font-weight: bold }
  </style>

  <user-card>
    <div slot="username"><span>John Smith</span></div>
  </user-card>

  <script>
  customElements.define('user-card', class extends HTMLElement {
    connectedCallback() {
      this.attachShadow({mode: 'open'});
      this.shadowRoot.innerHTML = `
        <style>
        span { background: red; }
        </style>
        Name: <slot name="username"></slot>
      `;
    }
  });
  </script>

#+end_src

The result is bold, but not red.

If we‚Äôd like to style slotted elements in our component, there are two choices.

- *First*, we can style the ~<slot>~ itself and rely on CSS inheritance:

#+begin_src javascript

  <user-card>
    <div slot="username"><span>John Smith</span></div>
  </user-card>

  <script>
  customElements.define('user-card', class extends HTMLElement {
      connectedCallback() {
          this.attachShadow({mode: 'open'});
          this.shadowRoot.innerHTML = `
            <style>
            slot[name="username"] { font-weight: bold; }
            </style>
            Name: <slot name="username"></slot>
          `;
        }
      });
  </script>

#+end_src

Here ~<p>John Smith</p>~ becomes bold, because CSS inheritance is in effect between the ~<slot>~ and its contents. But in CSS itself not all properties are inherited.

- *Another option* is to use ~::slotted(selector)~ pseudo-class. It matches elements based on two conditions:

1. That‚Äôs a slotted element, that comes from the light DOM. Slot name doesn‚Äôt matter. Just any slotted element, but only the element itself, not its children.
2. The element matches the ~selector~.

In our example, ~::slotted(div)~ selects exactly ~<div slot="username">~, but not its children:

#+begin_src js

  <user-card>
    <div slot="username">
      <div>John Smith</div>
    </div>
  </user-card>

  <script>
     customElements.define('user-card', class extends HTMLElement {
        connectedCallback() {
            this.attachShadow({mode: 'open'});
            this.shadowRoot.innerHTML = `
              <style>
              ::slotted(div) { border: 1px solid red; }
              </style>
              Name: <slot name="username"></slot>
           `;
        }
    });
  </script>

#+end_src

*Note*:
- ~::slotted~ can only be used in CSS. We can‚Äôt use it in ~querySelector~.
- ~::slotted~ selector can‚Äôt descend any further into the slot. These selectors are invalid:

#+begin_src css

  ::slotted(div span) {
    /* our slotted <div> does not match this */
  }

  ::slotted(div) p {
    /* can't go inside light DOM */
  }

#+end_src

*ManzDev:*

#+begin_src javascript

  <app-element>
    <h2 slot="name">Manz</h2>
    <span slot="role">Developer</span>
  </app-element>

  <script>
  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <style>
        h2 {
          color: red;      /* No funciona */
        }
        ::slotted(h2) {    /* Funciona */
          color: green;
        }
      </style>
      <div class="card">
        <slot name="name"></slot>
        <slot name="role"></slot>
      </div>
    `;
  }
  </script>

#+end_src

**** Events Shadow DOM
***** Brief
*ManzDev*
Por defecto, cuando emitimos un evento, este no atraviesa el Shadow DOM, ya que recordemos que la finalidad principal del Shadow DOM es encapsular y aislar. Por lo tanto, si hacemos un [[dispatchEvent()]] desde el interior de un WebComponent, este no llegar√° a salir del mismo.

Si queremos que *atraviese el Shadow DOM* del componente, deberemos indicar el flag ~composed~ a ~true~ a la hora de crear el evento. De esta forma, al emitirlo, tiene la orden expresa de atravesar el Shadow DOM y continuar su propagaci√≥n (si tiene ~bubbles~ a ~true~).

*javascript.info*
The idea behind shadow tree is to encapsulate internal implementation details of a component.

Let‚Äôs say, a click event happens inside a shadow DOM of ~<user-card>~ component. But scripts in the main document have no idea about the shadow DOM internals, especially if the component comes from a 3rd-party library.

So, to keep the details encapsulated, the browser *retargets* the event.

Events that happen in shadow DOM *have the host element as the target, when caught outside of the component*.

#+begin_src javascript

  <user-card></user-card>

  <script>
    customElements.define('user-card', class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = `<p>
          <button>Click me</button>
        </p>`;
        this.shadowRoot.firstElementChild.onclick =
          e => alert("Inner target: " + e.target.tagName);
      }
    });

    document.onclick =
      e => alert("Outer target: " + e.target.tagName);
  </script>

#+end_src

If you click on the button, the messages are:

- Inner target :: ~BUTTON~ ‚Äì internal event handler gets the correct target, *the element inside shadow DOM*.
- Outer target :: ~USER-CARD~ ‚Äì document event handler gets *shadow host as the target*.

Event retargeting is a great thing to have, because the outer document doesn‚Äôt have to know about component internals. From its point of view, the event happened on ~<user-card>~.

*Retargeting does not occur if the event occurs on a slotted element*, that physically lives in the light DOM.

For example, if a user clicks on ~<span slot="username">~ in the example below, the event target is exactly this ~span~ element, for both shadow and light handlers:

#+begin_src javascript

  <user-card id="userCard">
    <span slot="username">John Smith</span>
  </user-card>

  <script>
  customElements.define('user-card', class extends HTMLElement {
      connectedCallback() {
          this.attachShadow({mode: 'open'});
          this.shadowRoot.innerHTML = `<div>
           <b>Name:</b> <slot name="username"></slot>
           </div>`;

              this.shadowRoot.firstElementChild.onclick =
                  e => alert("Inner target: " + e.target.tagName);
          }
      });

  userCard.onclick = e => alert(`Outer target: ${e.target.tagName}`);
  </script>

#+end_src

If a click happens on ~"John Smith"~ , for both inner and outer handlers the target is ~<span slot="username">~ . That‚Äôs an element from the light DOM, so no retargeting.

On the other hand, if the click occurs on an element originating from shadow DOM, e.g. on ~<b>Name</b>~ , then, as it bubbles out of the shadow DOM, its ~event.target~ is reset to ~<user-card>~ .

***** Bubbling, event.composedPath()
For purposes of event bubbling, flattened DOM is used.

So, if we have a slotted element, and an event occurs somewhere inside it, then it bubbles up to the ~<slot>~ and upwards.

The full path to the original event target, with all the shadow elements, can be obtained using ~event.composedPath()~. As we can see from the name of the method, that path is taken after the composition.

In the example above, the flattened DOM is:

#+begin_src html

  <user-card id="userCard">
    #shadow-root
    <div>
      <b>Name:</b>
      <slot name="username">
        <span slot="username">John Smith</span>
      </slot>
    </div>
  </user-card>

#+end_src

So, for a click on ~<span slot="username">~ , a call to ~event.composedPath()~ returns an array: [ ~span~ , ~slot~ , ~div~ , ~shadow-root~ , ~user-card~ , ~body~ , ~html~ , ~document~ , ~window~ ]. That‚Äôs exactly the parent chain from the target element in the flattened DOM, after the composition.

*Note*: Shadow tree details are only provided for ~{mode:'open'}~ trees. If the shadow tree was created with ~{mode: 'closed'}~ , then the composed path starts from the host: ~user-card~ and upwards.

That‚Äôs the similar principle as for other methods that work with shadow DOM. Internals of closed trees are completely hidden.

***** Property event.composed
Most events successfully bubble through a shadow DOM boundary. There are few events that do not.

This is governed by the ~composed~ event object property. If it‚Äôs ~true~ , then the event does cross the boundary. Otherwise, it only can be caught from inside the shadow DOM.

If you take a look at UI Events specification, most events have ~composed: true~ :

- ~blur~ , ~focus~ , ~focusin~ , ~focusout~ ,
- ~click~ , ~dblclick~ ,
- ~mousedown~ , ~mouseup mousemove~ , ~mouseout~ , ~mouseover~ ,
- ~wheel~ ,
- ~beforeinput~ , ~input~ , ~keydown~ , ~keyup~ .

All touch events and pointer events also have ~composed: true~ .

There are some events that have ~composed: false~ though:

- ~mouseenter~ , ~mouseleave~ (they do not bubble at all),
- ~load~ , ~unload~ , ~abort~ , ~error~ ,
- ~select~ ,
- ~slotchange~ .

These events can be caught only on elements within the same DOM, where the event target resides.

***** Custom events
When we dispatch custom events, we need to set both ~bubbles~ and ~composed~ properties to ~true~ for it to bubble up and out of the component.

For example, here we create ~div#inner~ in the shadow DOM of ~div#outer~ and trigger two events on it. Only the one with ~composed: true~ makes it outside to the document:

Please *note* that in case of nested components, one shadow DOM may be nested into another. In that case composed events bubble through all shadow DOM boundaries. So, if an event is intended only for the immediate enclosing component, we can also dispatch it on the shadow host and set ~composed: false~. Then it‚Äôs out of the component shadow DOM, but won‚Äôt bubble up to higher-level DOM.

#+begin_src javascript

  <div id="outer"></div>

  <script>
  outer.attachShadow({mode: 'open'});

  let inner = document.createElement('div');
  outer.shadowRoot.append(inner);

  /*
    div(id=outer)
    #shadow-dom
    div(id=inner)
  ,*/

  document.addEventListener('test', event => alert(event.detail));

  inner.dispatchEvent(new CustomEvent('test', {
      bubbles: true,
      composed: true,
      detail: "composed"
  }));

  inner.dispatchEvent(new CustomEvent('test', {
      bubbles: true,
      composed: false,
      detail: "not composed"
  }));
  </script>

#+end_src

**** Shadow DOM desde HTML
El  Shadow DOM declarativo permite crear Shadow DOM utilizando √∫nicamente HTML.

Se la etiqueta HTML ~<template>~ con el atributo ~shadowrootmode~ indicando la modalidad del Shadow DOM.

#+begin_src html

  <app-element>
    <template shadowrootmode="open">
      <style>
        h2 { color: red }
        ::slotted(h2) { color: purple }
      </style>
      <h2>Shadow DOM</h2>
      <slot></slot>
    </template>
    <h2>Light DOM</h2>
  </app-element>

  <h2>Global DOM</h2>

  <!-- Shadow DOM red, se aplica el estilo del h2 desde dentro -->
  <!-- del Shadow DOM -->
  <!-- Light DOM purple, se aplica el estilo del ::slotted() desde -->
  <!-- dentro del Shadow DOM -->
  <!-- Global DOM negro, no se aplica ninguno de los anteriores, -->
  <!-- debido al Shadow DOM -->

  <!-- En el caso de que el navegador no soporte este atributo -->
  <!-- shadowrootmode, s√≥lo se ver√≠a el texto Light DOM y -->
  <!-- Global DOM, ambos en color negro. -->

#+end_src

Si quieres ofrecer soporte a alg√∫n navegador que a√∫n no soporte Declarative Shadow Root, puedes utilizar este peque√±o fragmento de c√≥digo Javascript, ejecut√°ndolo al cargar una p√°gina. Esto buscar√° todas las etiquetas ~<template>~ con el atributo ~shadowrootmode~ y las eliminar√° creando una nueva con el Shadow DOM creado y adjuntado:

#+begin_src javascript

  const dsr = document.querySelectorAll("template[shadowrootmode]");
  dsr.forEach(template => {
      const mode = template.getAttribute("shadowrootmode");
      const shadowRoot = template.parentNode.attachShadow({ mode });
      shadowRoot.appendChild(template.content);
      template.remove();
  });

#+end_src

*** HTML templates
**** Brief
The [[file:~/Documents/html-css-seo.org::template][<template>]] and [[file:~/Documents/html-css-seo.org::slot][<slot>]] elements enable you to write markup templates that are not displayed in the rendered page. These can then be reused multiple times as the basis of a custom element's structure.

The HTML template element specification defines how *to declare fragments of markup that go unused at page load*, but can be *instantiated* later on at runtime.

A built-in ~<template>~ element serves as a storage for HTML markup templates. The browser ignores its contents, only checks for syntax validity, but we can access and use it in JavaScript, to create other elements.

In theory, we could create any invisible element somewhere in HTML for HTML markup storage purposes. What‚Äôs special about ~<template>~?

First, *its content can be any valid HTML*, even if it normally requires a proper enclosing tag.

#+begin_src html

  <!-- We can put there a table row <tr>: -->
    <template>
      <tr>
        <td>Contents</td>
      </tr>
    </template>

#+end_src

Usually, if we try to put ~<tr>~ inside, say, a ~<div>~, the browser detects the invalid DOM structure and ‚Äúfixes‚Äù it, adds ~<table>~ around. That‚Äôs not what we want. On the other hand, ~<template>~ keeps exactly what we place there.

We can put styles and scripts into ~<template>~ as well:

#+begin_src html

  <template>
    <style>
      p { font-weight: bold; }
    </style>
    <script>
      alert("Hello");
    </script>
  </template>

#+end_src

The browser considers ~<template>~ content ‚Äú *out of the document* ‚Äù (it doesn‚Äôt affect anything): styles are not applied, scripts are not executed, ~<video autoplay>~ is not run, etc.

The content becomes live (styles apply, scripts run etc) when we insert it into the document.

We can access ~template.content~ from JavaScript, clone it to reuse in a new component.

The ~<template>~ tag is quite unique, because:

- The browser checks HTML syntax inside it (as opposed to using a template string inside a script).
- ‚Ä¶But still allows use of any top-level HTML tags, even those that don‚Äôt make sense without proper wrappers (e.g. ~<tr>~).
- The content becomes interactive: scripts run, ~<video autoplay>~ plays etc, when inserted into the document.

The ~<template>~ element does not feature any iteration mechanisms, data binding or variable substitutions, but we can implement those on top of it.

**** Inserting template
The template content is available in its ~content~ property as a [[DocumentFragment]] ‚Äì a special type of DOM node.

We can treat it as any other DOM node, except one special property: when we insert it somewhere, its children are inserted instead.

#+begin_src javascript

  <template id="tmpl">
    <script>
      alert("Hello");
    </script>
    <div class="message">Hello, world!</div>
  </template>

  <script>
    let elem = document.createElement('div');

    // Clone the template content to reuse it multiple times
    elem.append(tmpl.content.cloneNode(true));

    document.body.append(elem);
    // Now the script from <template> runs
  </script>

#+end_src

Let‚Äôs rewrite a [[Shadow DOM]] using ~<template>~:

#+begin_src javascript

  <template id="tmpl">
    <style> p { font-weight: bold; } </style>
    <p id="message"></p>
  </template>

  <div id="elem">Click me</div>

  <script>
    elem.onclick = function() {
      elem.attachShadow({mode: 'open'});

      // when we clone and insert tmpl.content, as its DocumentFragment,
      // its children (<style>, <p>) are inserted instead.
      elem.shadowRoot.append(tmpl.content.cloneNode(true));

      elem.shadowRoot.getElementById('message').innerHTML =
                                           "Hello from the shadows!";
    };
  </script>

#+end_src

They form the shadow DOM:

#+begin_src html

  <div id="elem">
    #shadow-root
      <style> p { font-weight: bold; } </style>
      <p id="message"></p>
  </div>

#+end_src

*** Implementing a web component
The basic approach for implementing a web component generally looks something like this:

1. *Create a class* in which you specify your [[Create custom elements][web component functionality]], using the [[extends][class]] syntax. This JavaScript class extends the base [[HTMLElement]] .

#+begin_src javascript

  class AppDrawer extends HTMLElement {...}

#+end_src

2. *Register your new custom element* using the [[CustomElementRegistry.define()][CustomElementRegistry.define()]] method, passing it the element name to be defined, the class or function in which its functionality is specified, and optionally, what element it inherits from. With these two steps the component is created.

#+begin_src javascript

  window.customElements.define('app-drawer', AppDrawer);

  // To use the new tag (component):
  <app-drawer></app-drawer>

#+end_src

3. *If required, attach a* [[Shadow DOM][shadow DOM]] to the custom element using [[attachShadow()][Element.attachShadow()]] method. Add child elements, event listeners, etc., to the shadow DOM using regular DOM methods.

#+begin_src javascript

  const header = document.createElement('header');
  const shadowRoot = header.attachShadow({mode: 'open'});
  shadowRoot.innerHTML = '<h1>Hello Shadow DOM</h1>';
  // Could also use appendChild()

  // header.shadowRoot === shadowRoot // true
  // shadowRoot.host === header       // true

#+end_src

4. *If required, define an HTML template* using [[HTML templates][<template>]] and [[Slots, composition, flattened DOM][<slot>]]. Again use regular DOM methods to [[cloneNode()][clone]] the template and attach it to your shadow DOM.

5. *Use your custom element* ([[Web component][web component]]) wherever you like on your page, just like you would any regular HTML element.

*Note*: using a custom element is no different to using a ~<div>~ or any other element. Instances can be declared on the page, created dynamically in JavaScript, event listeners can be attached, etc.

#+begin_src javascript

  // Create with javascript
  var newDrawer = document.createElement('app-drawer');
  // Add it to the page
  document.body.appendChild(newDrawer);
  // Attach event listeners
  document.querySelector('app-drawer').addEventListener('open',
                                                        function() {...});

#+end_src

*** ManzDev web components
**** HTML en un componente
***** HTML a trav√©s de strings
La forma m√°s r√°pida de escribir HTML en nuestro componente es a√±adir el c√≥digo HTML en un string y luego insertarlo en el componente.

[[innerHTML][.innerHTML]] y [[outerHTML][.outerHTML]] se utilizan para reemplazar el *marcado HTML* de un componente, aunque ~.outerHTML~ no es demasiado pr√°ctico en los componentes, puesto que tambi√©n sustituye la propia etiqueta del componente.

[[textContent]] y [[HTMLElement: innerText][innerText]] se utilizan para obtener solo el *contenido textual*. Es mas conveniente usar ~.textContent~.

#+begin_src javascript

  <app-element></app-element>

  // .innerHTML para escribir c√≥digo HTML y renderizarlo en el componente
  <script>
    class AppElement extends HTMLElement {
      constructor() {
        super();
        this.innerHTML = /* html */`
          <div class="card">
            <h1>ManzDev</h1>
          </div>`;
      }
    }

    customElements.define("app-element", AppElement);
  </script>

#+end_src

***** HTML a trav√©s del DOM
A trav√©s de la API del [[DOM]], ofrece mejor rendimiento y organizaci√≥n. Algunos de los m√©todos m√°s comunes son:

- [[document.createElement()]]
- [[append()]]
- [[insertAdjacentHTML()]]
- [[insertAdjacentElement()]]

#+begin_src javascript

  <app-element></app-element>

  <script>
    class AppElement extends HTMLElement {
      constructor() {
        super();
        const card = document.createElement("div");
        card.classList.add("card");
        this.append(card);

        const heading = document.createElement("h1");
        heading.textContent = "ManzDev";
        card.append(heading);
      }
    }

    customElements.define("app-element", AppElement);
  </script>

#+end_src

***** HTML mediante templates
El lenguaje HTML incorpora una etiqueta [[HTML templates][<template>]] , que no es m√°s que una forma de definir una plantilla HTML de forma nativa. Con esta etiqueta podemos crear un fragmento de c√≥digo (de forma aislada e independiente del documento) que utilizaremos m√°s tarde, una o m√°s veces.

El navegador no procesa el contenido de una etiqueta ~<template>~ (ni carga sus recursos, como scripts o im√°genes). Adem√°s, si se define en el HTML, su rendimiento es mayor que otras alternativas como [[innerHTML]], ya que se evita todo el proceso din√°mico de parseo y an√°lisis de a marcado HTML.

Con ~<template>~ podemos utilizar esta caracter√≠stica para crear un c√≥digo HTML base, que posteriormente clonaremos y utilizaremos en nuestro componente.

#+begin_src html

  <template>
    <div class="card">
      <h1>ManzDev</h1>
    </div>
  </template>

#+end_src

Sin embargo, como estamos en un componente ~.js~, lo ideal ser√≠a crearlo en Javascript para no estar a√±adiendo m√°s archivos separados.

#+begin_src javascript

  <app-element></app-element>

  <script>
    const template = document.createElement("template");
    template.innerHTML = /* html */`
      <div class="card">
        <h1>ManzDev</h1>
      </div>`;

    // L√≥gica Javascript del componente
    class AppElement extends HTMLElement {
      connectedCallback() {
        const html = template.content.cloneNode(true);
        this.append(html);
      }
    }

    customElements.define("app-element", AppElement);
  </script>

#+end_src

***** HTML mediante librer√≠as
Otra forma de escribir HTML en nuestros componentes ser√≠a elegir una librer√≠a Javascript que nos permita crear plantillas de forma m√°s c√≥moda y r√°pida. Por ejemplo, utilizando la librer√≠a =lit-html=, librer√≠a independiente utilizada en la librer√≠a Lit.

#+begin_src javascript

  <app-element></app-element>

  <script>
    import { html, render } from "https://cdn.jsdelivr.net/npm/lit-html@3.1.2/+esm";
    const template = html`
      <div class="card">
        <h1>ManzDev</h1>
      </div>`;

    class AppElement extends HTMLElement {
    constructor() {
        super();
        render(template, this);
      }
    }

    customElements.define("app-element", AppElement);
  </script>
  // Se importa html y render de la librer√≠a lit-html.
  // html -> crea plantillas
  // render -> renderizar en el componente

#+end_src

**** Css en Custom Element
***** CSS interno y externo aislados
****** CSS con Shadow DOM
Todas las dem√°s modalidades tienen la misma desventaja: los estilos del componente afectan al resto del documento y viceversa.

*Ventajas*:
- HTML escrito dentro del componente (modular)
- funcionalidad escrita dentro del componente (modular)
- CSS escrito dentro del componente (modular)
- el CSS externo al componente no le afecta (aislado)
- el CSS interno del componente no afecta al exterior (aislado)
- tenemos mecanismos nativos de control de CSS para Shadow DOM

*Desventaja*:
- la curva de aprendizaje de Shadow DOM suele ser dura inicialmente

#+begin_src javascript

  <h2>Titular global</h2>
  <app-element></app-element>

  <script>
    class AppElement extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: "open" });
      }

      connectedCallback() {
        this.shadowRoot.innerHTML = /* html */`
          <style>
            h2 { color: indigo; }
            p { color: blueviolet; }
          </style>
          <div class="container">
            <h2>T√≠tular del componente</h2>
            <p>Texto y descripci√≥n del contenido del componente.</p>
          </div>
        `;
      }
    }

    customElements.define("app-element", AppElement);
  </script>

#+end_src

****** Formas no nativas
En los frameworks Javascript, se modifican las clases CSS mediante una librer√≠a Javascript. Este tipo de librer√≠as se encuentran dentro de una categor√≠a llamada *CSS-in-JS*.

*Desventajas*:
- Librer√≠a externa (no nativa), coste de descarga/parseo (rendimiento)
- El CSS se evalua de forma din√°mica, a√±adiendo clases CSS (rendimiento)

*Ventajas*:
- HTML escrito dentro del componente (modular)
- Funcionalidad escrita dentro del componente (modular)
- CSS escrito dentro del componente (modular)
- El CSS externo al componente no le afecta (aislado)
- El CSS interno del componente no afecta al exterior (aislado)

#+begin_src javascript

  <h2>Titular global</h2>
  <app-element></app-element>

  <script>
    // librer√≠a CSS-in-JS Emotion
    import { css } from "https://cdn.jsdelivr.net/npm/@emotion
                                           /css@11.11.2/+esm";

    // el c√≥digo CSS esta en un objeto style que utiliza el helper css de
    // Emotion. Este devolver√° una clase CSS autogenerada, como css-ck3uk3
    // , que a√±adiremos al componente mediante this.classList.add(styles).
    const styles = css`
      h2 {
        background: green;
        color: white;
      }
    `;

    class AppElement extends HTMLElement {
      constructor() {
        super();
        this.classList.add(styles);
        this.innerHTML = /* html */`
          <div class="container">
            <h2>T√≠tular del componente</h2>
            <p>Texto y descripci√≥n del contenido del componente.</p>
          </div>
        `;
      }
    }

    customElements.define("app-element", AppElement);
  </script>

#+end_src

***** CSS interno y externo no aislados
****** CSS en un string
Esta es la forma m√°s extendida actualmente de incluir estilos en un WebComponent, ya que es sencilla y no requiere peticiones adicionales.

*Desventajas*:
- el CSS externo al componente le afecta
- el CSS interno del componente afecta al exterior

*Ventajas*:
- HTML escrito dentro del componente (modular)
- funcionalidad escrita dentro del componente (modular)
- CSS escrito dentro del componente (modular)

A pesar de tener los estilos CSS escritos dentro del componente, la naturaleza del CSS sigue siendo global, por lo que esos estilos sobre el elemento ~<h2>~ no se aplicar√°n √∫nicamente al titular ~<h2>~ del componente como quiz√°s pensemos, sino que se va a aplicar a todos los elementos ~<h2>~ de la p√°gina, dentro y fuera del componente.

De la misma forma, podr√≠a afectar elementos del CSS global en el componente, dependiendo de la especificidad que tenga.

#+begin_src javascript

  <h2>Titular global</h2>
  <app-element></app-element>

  <script>
    class AppElement extends HTMLElement {
      constructor() {
        super();
        this.innerHTML = /* html */`
          <style>
            h2 {
              background: hotpink;
              color: white;
            }
          </style>
          <div class="container">
            <h2>T√≠tular del componente</h2>
            <p>Texto y descripci√≥n del contenido del componente.</p>
          </div>
        `;
      }
    }

    customElements.define("app-element", AppElement);
  </script>

#+end_src

****** CSS en fichero externo
Esta opci√≥n utiliza una etiqueta ~<link>~ o un ~@import~ en un bloque ~<style>~ que cargue un fichero ~.css~ externo.

*Desventajas*:
- el CSS externo al componente le afecta
- el CSS interno del componente afecta al exterior
- el navegador hace peticiones adicionales para descargar el CSS

*Ventajas*:
- HTML escrito dentro del componente (modular)
- funcionalidad escrita dentro del componente (modular)
- CSS escrito en un fichero a parte del componente (modular)

#+begin_src javascript

  <h2>Titular global</h2>
  <app-element></app-element>

  <script>
    class AppElement extends HTMLElement {
      constructor() {
        super();
        this.innerHTML = /* html */`
          <link rel="stylesheet" href="./AppElement.cdn.css">
          <div class="container">
            <h2>T√≠tular del componente</h2>
            <p>Texto y descripci√≥n del contenido del componente.</p>
          </div>
        `;
      }
    }

    customElements.define("app-element", AppElement);
  </script>

#+end_src

****** CSS global
El problema de este enfoque es que le estamos dando estilo a todos los elementos ~<h2>~ del documento y no s√≥lo al componente. Para evitarlo, podr√≠amos a√±adir una clase espec√≠fica, o utilizar metodolog√≠as o nomenclaturas CSS como BEM o similares.

Otro enfoque podr√≠a ser, a√±adir el nombre del componente ~<app-element>~ antes del ~h2~, de modo que s√≥lo le dar√° estilo si est√° dentro de un componente ~<app-element>.~ Este sistema puede servirnos para ejemplos peque√±os, pero es dif√≠cil de mantener si crece.

*Desventajas*:
- el CSS esta escrito fuera del componente
- el CSS externo al componente le afecta
- el CSS interno del componente afecta al exterior

*Ventajas*:
- HTML escrito dentro del componente (modular)
- Funcionalidad escrita dentro del componente (modular)

#+begin_src javascript

  <h2>Titular global</h2>
  <app-element></app-element>

  // First approach
  <style>
    h2 {
      color: red;
    }
  </style>

  // Secoond approach
  <style>
    app-element h2 {
      background: steelblue;
      color: white;
    }
  </style>

  <script>
    class AppElement extends HTMLElement {
      constructor() {
        super();
        this.innerHTML = /* html */`
          <div class="container">
            <h2>T√≠tular del componente</h2>
            <p>Texto y descripci√≥n del contenido del componente.</p>
          </div>
        `;
      }
    }

    customElements.define("app-element", AppElement);
  </script>

#+end_src

****** CSS constru√≠ble
Las *Constructables StyleSheet* son una forma nativa de importar ficheros ~.css~ desde el navegador y convertir su contenido a un objeto Javascript construible, que posteriormente se puede incorporar al documento.

*Desventajas*:
- el CSS externo al componente le afecta
- el CSS interno del componente afecta al exterior
- el soporte de import ~with~ / ~assert~ es irregular (compatibilidad)

*Ventajas*:
- HTML escrito dentro del componente (modular)
- funcionalidad escrita dentro del componente (modular)
- CSS escrito en un fichero a parte del componente (modular)
- el CSS se evalua de forma est√°tica, no din√°mica. (rendimiento)

#+begin_src javascript

  <h2>Titular global</h2>
  <app-element></app-element>

  <script>
    import styles from "./AppElement.cdn.css" assert { type: "css" };
    // import styles from "./AppElement.cdn.css" with { type: "css" };

    class AppElement extends HTMLElement {
      constructor() {
        super();
        // adoptar el contenido CSS en el documento actual
        document.adoptedStyleSheets.push(styles);
        this.innerHTML = /* html */`
          <div class="container">
            <h2>T√≠tular del componente</h2>
            <p>Texto y descripci√≥n del contenido del componente.</p>
          </div>
        `;
      }
    }

    customElements.define("app-element", AppElement);
  </script>
  // En el c√≥digo del componente se utiliz√≥ assert ya que es la palabra
  // clave que tiene soportado Chrome en la actualidad. En el futuro ser√°
  // reemplazada por with, pero no tiene soporte actualmente.

#+end_src

**** Ciclo de vida del Web component
***** Brief
Durante la carga de una p√°gina y mientras la utilizamos, los WebComponent pasan por una serie de fases que se conocen como el ciclo de vida del WebComponent.

1. Elemento creado ~document.createElement()~
2. Custom element ~<custom-element>~ componente creado, pero no insertado en el DOM ~constructor()~
3. Componente creado e insertado en el DOM ~connectedCallback()~
4. If necessary, attribute changed ~attributeChangedCallback()~
5. If necessary, move to other document ~adoptedCallback()~
6. If necessary, remove from DOM ~disconnectedCallback()~

Cuando creamos un [[Custom elements]], inicialmente el navegador lo considera un [[HTMLElement]], es decir, una etiqueta HTML est√°ndar. Sin embargo, si se cumple la condici√≥n de que est√° definida en el registro global de ~customElements~ del navegador, entonces intentar√° actualizarla a Custom Element.

El m√©todo ~constructor()~ de un WebComponent tiene la misma funci√≥n que en una clase de programaci√≥n. Se ejecutar√° cada vez que se cree un Custom Element particular, y que previamente haya sido definido en el registro global del navegador con ~customElements.define()~. Por lo tanto, si creamos varias etiquetas de un componente (instancias), se ejecutar√° una vez por cada una de ellas.

Esto ocurrir√° de forma autom√°tica si el custom element se cre√≥ despu√©s de haber sido registrado mediante ~customElements.define()~. Si se cre√≥ antes de registrarlo, tendremos que hacerlo de forma manual mediante ~customElements.upgrade()~.

El objetivo del *constructor* es hacer ciertas tareas de inicializaci√≥n r√°pidas o tareas iniciales, como la creaci√≥n del Shadow DOM. Es esencial que en el constructor del componente se hagan s√≥lo las tareas m√°s prioritarias y ligeras.

En el caso de incluir l√≥gica en el constructor que pueda llegar a modificar el DOM o los atributos de un componente, podr√≠a afectar al rendimiento o aparecernos errores.

Como norma general, aplaza todo lo que puedas al m√©todo ~connectedCallback()~.

***** Inserci√≥n en el DOM (connectedCallback)
El m√©todo ~connectedCallback()~ es una suerte de segundo constructor que se ejecuta cuando el custom element es *conectado al documento HTML* (DOM).

Por ejemplo, podemos crear un elemento HTML personalizado en una variable, que no est√© incluido en el documento HTML:

#+begin_src javascript

  // En este momento, el Custom Element ya es reconocido por el navegador
  customElements.define("app-element", AppElement);

  // En este momento, se ejecuta el constructor() del componente
  const component = document.createElement("app-element");

  // En este momento, se ejecuta el connectedCallback() del componente
  document.body.append(component);

#+end_src

Esta caracter√≠stica lo hace realmente √∫til para incluir, por ejemplo, tareas relacionadas con la renderizaci√≥n o dibujo visualmente. Por esta raz√≥n, tambi√©n resulta interesante desplazar a este m√©todo ciertas tareas que es posible que no lleguen a necesitarse de manera inmediata, mejorando as√≠ el rendimiento general.

Ten en cuenta que si un custom element es movido a otra parte del DOM, se desconectar√° y volver√° a conectarse al DOM, pasando por los m√©todos ~connectedCallback()~ y ~disconnectedCallback()~ correspondientes.

***** Eliminaci√≥n del DOM (disconnectedCallback)
El m√©todo ~disconnectedCallback()~ puede ser realmente √∫til para realizar tareas importantes de finalizaci√≥n que, de lo contrario, estar√≠an consumiendo recursos respecto a ese elemento.

#+begin_src javascript

  // Localizamos un componente en el documento HTML
  const element = document.querySelector("app-element");

  // En este momento, se ejecuta el disconnectedCallback() del componente
  element.remove();

#+end_src

***** Mover a otro documento (adoptedCallback)
El m√©todo ~adoptedCallback()~, de uso menos frecuente, tiene sentido cuando se trabaja en contextos multidocumento, y se dispara cuando un custom element se mueve de un documento HTML a otro documento HTML diferente. Para moverlo, se utiliza el m√©todo ~.adoptNode()~.

Este m√©todo es muy √∫til cuando se trabaja con elementos ~<iframe>~, por ejemplo.

**** Custom Events en componentes
***** Custom Event
Es un mecanismo que nos permite crear nuestros propios *objetos eventos* personalizados.

Para crear un evento personalizado se crea una instancia del objeto ~CustomEvent~, que recibe como par√°metros:

- string :: con el nombre que se le pondra al evento (en case sensitive y cuando sea necesario usar namespaces y un separador, por ejemplo, ~user:data-message~ (un evento de usuario ~user~, que recibe un ~data-message~) o ~user.data-message~ ).
- object :: especifica detalles en relaci√≥n con el comportamiento o contenido del evento.
  - ~detail~ objeto que contiene la informaci√≥n que queremos transmitir
  - ~bubbles~ indica si el evento debe burbujear en el DOM ¬´hacia la superficie¬ª
  - ~composed~ indica si la propagaci√≥n puede atravesar Shadow DOM
  - ~cancelable~ indica si el comportamiento se puede cancelar con ~.preventDefault()~

*Nota*: en lugar de ~CustomEvent~ tambi√©n se puede indicar simplemente ~Event~ (o alguno de sus objetos derivados). La diferencia radica en que CustomEvent se suele utilizar cuando queremos a√±adir datos personalizados.

#+begin_src javascript

  <div class="element">Here!</div>

  <script>
    // name of event user:data-message
    const MessageEvent = new CustomEvent("user:data-message", {
      // info
      detail: {
        from: "Manz",
        message: "Hello!"
      },
      // debe burbujear hacia arriba en el DOM
      bubbles: true,
      // puede atravesar Shadow DOM
      composed: true
    });

    // Emitimos el evento al elemento indicado
    const element = document.querySelector(".element");
    element.dispatchEvent(MessageEvent);
  </script>


  // Event no permite a√±adir informaci√≥n adicional al crear el objeto
  const event = new Event("click", { detail: 123 });
  event.detail    // undefined

  // CustomEvent permiten a√±adir informaci√≥n adicional al crear el objeto
  const event = new CustomEvent("super-click", { detail: 123 });
  event.detail    // 123

#+end_src

***** Proposito y ejemplo
En custom event nosotros podemos ¬´ *falsear* ¬ª un evento de navegador y crearlo nosotros mismos, simulando que ha sido realizado por un usuario real.

Normalmente los ~Event~ se usan solamente para eventos reales del navegador. Si necesitamos controlar alguna acci√≥n determinada utilizaremos ~CustomEvent~, asign√°ndole un nombre de evento y personalizando su funcionamiento.

En el siguiente ejemplo la etiqueta ~<span>~ se a√±ade un nuevo evento para cuando se mueva el rat√≥n sobre esa etiqueta, se cree un nuevo evento de ~click~ y lo envie al bot√≥n. De esta forma, se disparar√° el otro evento en escucha como si el usuario real hubiera hecho click en el bot√≥n.

#+begin_src javascript

  <button>Click me</button>
  <span class="text">Hover me</span>

  <script>
    const button = document.querySelector("button");
    const text = document.querySelector(".text");

   button.addEventListener("click", () => alert("Has pulsado el bot√≥n"));

    text.addEventListener("mouseenter", () => {
      const event = new Event("click");
      button.dispatchEvent(event);
    });
  </script>


  // Event no permite a√±adir informaci√≥n adicional al crear el objeto
  const event = new Event("click", { detail: 123 });
  event.detail    // undefined

  // CustomEvent permiten a√±adir informaci√≥n adicional al crear el objeto
  const event = new CustomEvent("super-click", { detail: 123 });
  event.detail    // 123

#+end_src

***** Propiedades o m√©todos de eventos (bubbles, composed, target, ...)
*Propiedades*
- .bubbles :: Indica si el evento se *propagar√°* hacia contenedores padres o se detendr√° en el elemento emitido.
- .composed :: Indica si el evento puede *atravesar un Shadow DOM* en su propagaci√≥n, o no. Si est√° desactivado, el evento se detendr√° al encontrar un Shadow DOM.

*Destino del evento*
- .target :: Indica el elemento objetivo (donde se hizo el ~dispatchEvent()~).
- .currentTarget :: Indica el elemento actual donde se ha escuchado el evento.

*M√©todo*
- .composedPath() :: Muestra el camino de elementos por donde se ha propagado el evento.

#+begin_src javascript

  // composedPath
  root.addEventListener("warning", (event) => {
      console.log("Evento click recibido en el root.");
      const path = event.composedPath();
      console.log(path);
  });

  // path = [button, div.child, div.parent, div.root,
  //         body, html, document, Window]

#+end_src

***** Emitir eventos usando dispatchEvent()
****** Emisi√≥n directa
Emitir el evento directamente a un elemento del DOM.

#+begin_src javascript

  <button>Click me</button>

  <script>
    const event = new CustomEvent("user:message", {
      detail: {
        from: "Manz",
        message: "Hello!"
      }
    });

    const button = document.querySelector("button");
    button.addEventListener("click", () => {
      button.dispatchEvent(event);
    });
    button.addEventListener("user:message", (e) => {
      console.log(e.detail);
    });
    // {from: 'Manz', message: 'Hello!'}
  </script>

#+end_src

****** Propagaci√≥n de eventos (bubbles)
Se define la opci√≥n ~bubbles~ a ~true~, por lo que el evento no s√≥lo se emitir√° al elemento indicado, sino que comenzar√° a emitirse sucesivamente a sus contenedores padres hasta llegar al tope.

#+begin_src javascript

  <div class="root" data-number="1">
    <div class="parent" data-number="2">
      <div class="child" data-number="3">
        <button data-number="4">Press me!</button>
      </div>
    </div>
  </div>

  <script>
    const root = document.querySelector(".root");
    const button = document.querySelector("button");

    button.addEventListener("click", () => {
      const event = new CustomEvent("user:message", {
        detail: { name: "Manz" },
        bubbles: true
      });
      button.dispatchEvent(event);
    });

    root.addEventListener("user:message", (event) => {
      const name = event.detail.name;
      const number = event.target.dataset.number;
      alert(`Message received from ${name} (${number})`);
    });
    // Message received from Manz (4)

  // El evento se emite en el <button> y se propaga as√≠ -> .child
  // -> .parent -> .root -> <body> -> <html> -> document -> Window
  </script>

#+end_src

****** Captura de eventos (capture)
Activa la fase de *captura*, que invierte el orden del burbujeo. Realmente, lo que hace es ir capturando todos los eventos en cada fase del burbujeo y cuando termina toda la trayectoria de propagaci√≥n, vuelve sobre sus pasos y realiza el mismo paso pero en orden inverso.

Para ello, se a√±ade un tercer par√°metro en el ~.addEventListener()~ que ser√° un objeto de opciones que contendr√° ~capture~ a ~true~.

#+begin_src javascript

  <div class="root" data-number="1">
    <div class="parent" data-number="2">
      <div class="child" data-number="3">
        <button data-number="4">Press me!</button>
      </div>
    </div>
  </div>

  <script>
    const root = document.querySelector(".root");
    const button = document.querySelector("button");

    button.addEventListener("click", () => {
      const event = new CustomEvent("user:message", {
        detail: { name: "Manz" },
        bubbles: true
      });
      button.dispatchEvent(event);
    });

    root.addEventListener("user:message", (event) => {
      const name = event.detail.name;
      const number = event.target.dataset.number;
      alert(`Message received from ${name} (${number})`);
    }, { capture: true });
  // De esta forma, el orden ser√≠a 1, 2, 3 en lugar de 3, 2, 1
  </script>

#+end_src

****** Emitir eventos hacia el exterior con handleEvent
Aplicando custom events y el m√©todo m√°gico ~handleEvent~ a un WebComponent para emitir informaci√≥n desde el componente hacia su exterior.

#+begin_src javascript

  <first-element></first-element>

  <script>
    class FirstElement extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: "open" });
      }

    // handleEvent para procesar los eventos
    handleEvent(event) {
      if (event.type === "click") {
        const messageEvent = new CustomEvent("user:data-message", {
          detail: { from: "Manz", message: "Hello!" },
          // bubbles: true, por lo que burbujear√° hacia arriba en el DOM
          bubbles: true,
          // composed: true, por lo que atravesar√° el Shadow DOM
          composed: true
        });
        this.dispatchEvent(messageEvent);
      }
    }

    connectedCallback() {
     this.shadowRoot.innerHTML = /* html */`<button>Send message!</button>`;
     this.shadowRoot.querySelector("button").addEventListener("click", this);
    }
  };
  customElements.define("first-element", FirstElement);
  </script>
  // Como se activa el flag bubbles, el evento se propagar√° a sus elementos
  // padres y el flag composed permite que atraviese los Shadow DOM en el
  // caso de encontrarlos. As√≠ pues, el evento personalizado se propagar√°
  // al elemento HTML contenedor de <first-element> y continuar√°
  // propag√°ndose hasta llegar a document, que es el elemento padre
  // superior.

#+end_src

****** Recibir eventos desde el exterior con handleEvent
~<first-element>~ componente que envia el evento, ~<second-element>~  componente encargardo de recibir el evento enviado por el primero.

#+begin_src javascript

  <first-element></first-element>
  <second-element></second-element>

  <script>
    class SecondElement extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: "open" });
        this.data = null;
      }

      handleEvent(event) {
        if (event.type === "user:data-message") {
          this.data = event.detail;
          this.render();
        }
      }

      connectedCallback() {
        document.addEventListener("user:data-message", this);
        this.render();
      }

      noMessages() {
        return /* html */`<div>No messages</div>`;
      }

      hasMessages() {
        return /* html */`<div class="container">
          From ${this.data.from}:
          <span style="color:red">${this.data.message}</span>
        </div>`;
      }

      // el m√©todo de clase render() es el que se llama cuando se
      // necesita pintar algo en el navegador
      render() {
        this.shadowRoot.innerHTML = this.data ?
                  this.hasMessages() :   this.noMessages();
      }
    };
    customElements.define("second-element", SecondElement);

  class FirstElement extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }

    // handleEvent para procesar los eventos
    handleEvent(event) {
      if (event.type === "click") {
        const messageEvent = new CustomEvent("user:data-message", {
          detail: { from: "Manz", message: "Hello!" },
          // bubbles: true, por lo que burbujear√° hacia arriba en el DOM
          bubbles: true,
          // composed: true, por lo que atravesar√° el Shadow DOM
          composed: true
        });
        this.dispatchEvent(messageEvent);
      }
    }

   connectedCallback() {
    this.shadowRoot.innerHTML = /* html */`<button>Send message!</button>`;
    this.shadowRoot.querySelector("button").addEventListener("click", this);
    }
  };
  customElements.define("first-element", FirstElement);
  </script>

#+end_src

***** Detectar fase del evento (eventPhase)
Si buscamos una forma m√°s directa de saber en que fase nos encontramos, podemos acceder a la propiedad ~.eventPhase~ del evento. Esta propiedad nos devolver√° un n√∫mero que nos dar√° la fase concreta:

~.eventPhase~	devuelve la fase en la que se encuentra el evento.

| /PROPIEDAD/               | /DESCRIPCI√ìN/                           |
|-------------------------+---------------------------------------|
| /Event.NONE 0/            | evento no est√° proces√°ndose           |
| /Event.CAPTURING_PHASE 1/ | emitido en modo captura (desciende)   |
| /Event.AT_TARGET 2/       | emitido sin ning√∫n modo (al elemento) |
| /Event.BUBBLING_PHASE 3/  | emitido en modo burbujeo (asciende)   |

En el caso de devolvernos un valor ~1~, significa que el evento fue escuchado con el flag ~capture~ a ~true~, si devuelve ~2~ es que el evento fue emitido directamente, y si devuelve ~3~ es que fue propagado con el flag ~bubbles~ a ~true~.

***** Detener la propagaci√≥n (cancelable, stopPropagation)
Por defecto, los eventos nativos tienen la propiedad ~.cancelable~ a ~true~. Esto significa que los eventos pueden cancelar su propagaci√≥n utilizando los m√©todos ~.stopPropagation()~ o ~.stopImmediatePropagation()~.

*Propiedad*
- .cancelable :: indica si es posible cancelar el evento.

*M√©todos*
- .Stoppropagation() :: detiene la propagaci√≥n en el evento en cuesti√≥n.
- .Stopimmediatepropagation() :: detiene la propagaci√≥n en todos los eventos del mismo tipo.

La diferencia de ~.stopPropagation()~ y ~.stopImmediatePropagation()~ es que este √∫ltimo detiene la propagaci√≥n en todos los eventos de su mismo tipo, mientras que el primero s√≥lo detiene el evento concreto donde lo escribimos. Recuerda que para que estos m√©todos funcionen, el evento debe tener el flag ~.cancelable~ a ~true~.

#+begin_src javascript

  <div class="root">
    <div class="parent">
      <div class="child">
        <button>Click me!</button>
      </div>
    </div>
  </div>

  <script>
    const root = document.querySelector(".root");
    root.addEventListener("warning", (event) => {
      console.log("Evento click recibido en el root.", event);
    });

    const parent = document.querySelector(".parent");
    parent.addEventListener("warning", (event) => {
      parent.stopPropagation();
      console.log("Recibido en parent");
    });
  </script>

#+end_src

** Drawing on canvas
*** Brief
A [[Canvas][canvas]] node represents an area in a document that our program may draw on. This drawing is done through a drawing context object, created with the ~getContext~ method.

The 2D drawing interface allows us to fill and stroke various shapes. The context‚Äôs [[Lines and surfaces][fillStyle]] property determines how shapes are filled. The ~strokeStyle~ and ~lineWidth~ properties control the way lines are drawn.

Rectangles and pieces of text can be drawn with a single method call. The [[Lines and surfaces][fillRect]] and ~strokeRect~ methods draw rectangles, and the ~fillText~ and ~strokeText~ methods draw text. To create custom shapes, we must first build up a path.

Calling [[Paths][beginPath]] starts a new path. A number of other methods add lines and curves to the current path. For example, ~lineTo~ can add a straight line. When a path is finished, it can be filled with the ~fill~ method or stroked with the ~stroke~ method.

Moving pixels from an image or another canvas onto our canvas is done with the [[drawImage]] method. By default, this method draws the whole source image, but by giving it more parameters, you can copy a specific area of the image. We used this for our game by copying individual poses of the game character out of an image that contained many such poses.

Transformations allow you to draw a shape in multiple orientations. A 2D drawing context has a current transformation that can be changed with the [[Transformation][translate]] , ~scale~ , and ~rotate~ methods. These will affect all subsequent drawing operations. A transformation state can be saved with the [[Storing and clearing transformations][save]] method and restored with the ~restore~ method.

When showing an animation on a canvas, the ~clearRect~ method can be used to clear part of the canvas before redrawing it.

*** SVG
This is an HTML document with a simple SVG picture in it:

#+begin_src html

  <p>Normal HTML here.</p>
  <svg xmlns="http://www.w3.org/2000/svg">
    <circle r="50" cx="50" cy="50" fill="red"/>
    <rect x="120" y="5" width="90" height="90"
          stroke="blue" fill="none"/>
  </svg>

#+end_src

The ~xmlns~ attribute changes an element (and its children) to a different XML *namespace*. This namespace, identified by a URL, specifies the dialect that we are currently speaking. The ~<circle>~ and ~<rect>~ tags, which do not exist in HTML, do have a meaning in SVG‚Äîthey draw shapes using the style and position specified by their attributes.

These tags create DOM elements, just like HTML tags, that scripts can interact with. For example, this changes the <circle> element to be colored cyan instead:

#+begin_src javascript

  let circle = document.querySelector("circle");
  circle.setAttribute("fill", "cyan");

#+end_src

*** Canvas
A canvas is a single DOM element that encapsulates a picture. It provides a programming interface for drawing shapes onto the space taken up by the node. The main difference between a canvas and an [[SVG]] picture is that in SVG the original description of the shapes is preserved so that they can be moved or resized at any time. A canvas, on the other hand, converts the shapes to pixels (colored dots on a raster) as soon as they are drawn and does not remember what these pixels represent. The only way to move a shape on a canvas is to clear the canvas (or the part of the canvas around the shape) and redraw it with the shape in a new position.

*The canvas element*:
Canvas graphics can be drawn onto a ~<canvas>~ element. You can give such an element ~width~ and ~height~ attributes to determine its size in pixels. A new canvas is empty, meaning it is entirely transparent and thus shows up as empty space in the document.

The ~<canvas>~ tag is intended to allow different styles of drawing. To get access to an actual drawing interface, we first need to create a context, an object whose methods provide the drawing interface. There are currently two widely supported drawing styles: "2d" for two-dimensional graphics and "webgl" for three-dimensional graphics through the OpenGL interface.

You create a context with the ~getContext~ method on the ~<canvas>~ DOM element.

*Note*: When no ~width~ or ~height~ attribute is specified, a canvas element gets a default ~width~ of 300 pixels and ~height~ of 150 pixels.

#+begin_src javascript

  <p>Before canvas.</p>
  <canvas width="120" height="60"></canvas>
  <p>After canvas.</p>

  <script>
    let canvas = document.querySelector("canvas");
    let context = canvas.getContext("2d");
    context.fillStyle = "red";
    context.fillRect(10, 10, 100, 50);
  </script>

  // After creating the context object, the example draws a red rectangle
  // 100 pixels wide and 50 pixels high, with its top-left corner at
  // coordinates (10,10).

  // Just like in HTML (and SVG), the coordinate system that the canvas
  // uses puts (0,0) at the top-left corner, and the positive y-axis goes
  // down from there.

#+end_src

*** Choosing a graphics interface
So when you need to generate graphics in the browser, you can choose between plain HTML, SVG, and canvas. There is no single best approach that works in all situations. Each option has strengths and weaknesses.

Plain *HTML* has the advantage of being simple. It also integrates well with *text*. Both SVG and canvas allow you to draw text, but they won‚Äôt help you position that text or wrap it when it takes up more than one line. In an HTML-based picture, it is much easier to include blocks of text.

*SVG* can be used to produce *crisp graphics that look good at any zoom* level. Unlike HTML, it is designed for drawing and is thus more suitable for that purpose.

Both *SVG* and *HTML* build up a data structure (the *DOM*) that represents your picture. This makes it possible to *modify elements after they are drawn*. If you need to repeatedly change a small part of a big picture in response to what the user is doing or as part of an animation, doing it in a canvas can be needlessly expensive. The DOM also allows us to register mouse event handlers on every element in the picture (even on shapes drawn with SVG). You can‚Äôt do that with canvas.

But *canvas‚Äôs* pixel-oriented approach can be an advantage when *drawing a huge number of tiny elements*. The fact that it does not build up a data structure but only repeatedly draws onto the same pixel surface gives canvas a lower cost per shape.

There are also effects, such as rendering a scene one pixel at a time (for example, using a ray tracer) or postprocessing an image with JavaScript (blurring or distorting it), that can be realistically handled only by a pixel-based approach.

In some cases, you may want to combine several of these techniques. For example, you might draw a graph with SVG or canvas but show textual information by positioning an HTML element on top of the picture.

*** Lines and surfaces
In the canvas interface, a shape can be *filled*, meaning its area is given a certain color or pattern, or it can be *stroked*, which means a line is drawn along its edge.

The ~fillRect~ and ~strokeRect~ methods takes the x- and y-coordinates of the rectangle‚Äôs top-left corner, then its width, and then its height. Neither method takes any further parameters. The color of the fill, thickness of the stroke, and so on, are not determined by an argument to the method (as you might reasonably expect) but rather by properties of the context object.

The ~strokeStyle~ property controls the way shapes are filled, and determines the color used for a stroked line. The width of that line is determined by the ~lineWidth~ property, which may contain any positive number.

The ~fillStyle~ property specifies the color, gradient, or pattern to use *inside shapes* (default black).

#+begin_src javascript

  <canvas></canvas>

  <script>
    let cx = document.querySelector("canvas").getContext("2d");
    cx.strokeStyle = "blue";
    // coordinates=(5,5), width=50, height=50
    cx.strokeRect(5, 5, 50, 50);
    cx.lineWidth = 5;
    cx.strokeRect(135, 5, 50, 50);
  </script>

#+end_src

*** Paths
**** beginPath
A path is a sequence of lines. The 2D canvas interface takes a peculiar approach to describing such a path. It is done entirely through side effects. Paths are not values that can be stored and passed around. Instead, if you want to do something with a path, you make a sequence of method calls to describe its shape.

#+begin_src javascript

  <canvas></canvas>

  <script>
    let cx = document.querySelector("canvas").getContext("2d");
    cx.beginPath();
    for (let y = 10; y < 100; y += 10) {
        cx.moveTo(10, y);
        cx.lineTo(90, y);
    }
    cx.stroke();
  </script>
      // Each segment created with lineTo starts at the path‚Äôs current
  // position. That position is usually the end of the last segment, unless
  // moveTo was called.

  // Output: This creates a path with 9 of horizontal line segments
  ---------------------
  ---------------------
  ---------------------
  ---------------------
  ---------------------
  ---------------------
  ---------------------
  ---------------------
  ---------------------

#+end_src

**** fill
When filling a path (using the ~fill~ method), each shape is filled separately. A path can contain multiple shapes‚Äîeach ~moveTo~ motion starts a new one. But the path needs to be *closed* (meaning its start and end are in the same position) before it can be filled. If the path is not already closed, a line is added from its end to its start, and the shape enclosed by the completed path is filled.

You could also use the ~closePath~ method to explicitly close a path by adding an actual line segment back to the path‚Äôs start. This segment is drawn when stroking the path.

#+begin_src javascript

  <canvas></canvas>

  <script>
    let cx = document.querySelector("canvas").getContext("2d");
    cx.beginPath();
    cx.moveTo(50, 10);
    cx.lineTo(10, 70);
    cx.lineTo(90, 70);
    cx.fill();
  </script>

  // Output: This example draws a filled triangle.
         /\
        /..\
       /....\
      /......\
     /________\

#+end_src

*** Curves
**** quadraticCurveTo
The ~quadraticCurveTo~ method draws a curve to a given point. To determine the curvature of the line, the method is given a control point as well as a destination point. Imagine this control point as *attracting* the line, giving it its curve. The line won‚Äôt go through the control point, but its direction at the start and end points will be such that a straight line in that direction would point toward the control point.

#+begin_src javascript

  <canvas></canvas>

  <script>
    let cx = document.querySelector("canvas").getContext("2d");
    cx.beginPath();
    cx.moveTo(10, 90);
    // control=(60,10) goal=(90,90)
    cx.quadraticCurveTo(60, 10, 90, 90);
    cx.lineTo(60, 10); // line segment going through control point
    cx.closePath();
    cx.stroke();
  </script>

  // Output: Quadratic curve.
  c(60,10)
             / \
            /   \
           / _   \
          /.    . \
         /.       .\
        /.         .\
     s(10,90)       e(90,90)

#+end_src

**** bezierCurveTo
The ~bezierCurveTo~ method draws a similar kind of curve. Instead of a single control point, this one has two‚Äîone for each of the line‚Äôs endpoints.

#+begin_src javascript

  <canvas></canvas>

  <script>
    let cx = document.querySelector("canvas").getContext("2d");
    cx.beginPath();
    cx.moveTo(10, 90);
    // control1=(10,10) control2=(30,10) goal=(50,90)
    cx.bezierCurveTo(10, 10, 30, 10, 50, 90);
    cx.lineTo(30, 10); // line segment going through control point
    cx.lineTo(10, 10); // line segment going through control point
    cx.closePath();
    cx.stroke();
  </script>
  // The two control points specify the direction at both ends of the
  // curve. The farther they are away from their corresponding point, the
  // more the curve will ‚Äúbulge‚Äù in that direction.

  // Output: Quadratic curve.
  c1(10,10)  c2(30,10)
         _____
        ¬¶      \
        ¬¶       \
        ¬¶   _    \
        ¬¶ .    .  \
        ¬¶.       . \
        ¬¶.         .\
     s(10,90)       e(50,90)

#+end_src

**** arc
The ~arc~ method is a way to draw a line that curves along the edge of a circle. It takes a pair of coordinates for the arc‚Äôs center, a radius, and then a start angle and end angle.

Those last two parameters make it possible to draw only part of the circle. The angles are measured in radians, not degrees. This means a full circle has an angle of ~2œÄ~, which is about ~6.28~. The angle starts counting at the point to the right of the circle‚Äôs center and goes clockwise from there. You can use a start of ~0~ and an end bigger than ~2œÄ~ to draw a full circle.

#+begin_src javascript

  <canvas></canvas>

  <script>
    let cx = document.querySelector("canvas").getContext("2d");
    cx.beginPath();
    // center=(50,50) radius=40 angle=0 to 7
    cx.arc(50, 50, 40, 0, 7);
    // center=(150,50) radius=40 angle=0 to ¬ΩœÄ
    cx.arc(150, 50, 40, 0, 0.5 * Math.PI);
    cx.stroke();
  </script>
  // The picture contains a line from the right of the full circle
  // (first call to arc) to the right of the quarter-circle (second call).

           -------
        --/       \--
       /             \
       |             |-------------|
       \             /            /
        --\       /--            .
           -------            --

#+end_src

**** Example: Drawing a pie chart
Draw a pie chart of a customer satisfaction survey results.

To draw a pie chart, we draw a number of pie slices, each made up of an ~arc~ and a pair of lines to the center of that ~arc~. We can compute the angle taken up by each ~arc~ by dividing a full circle (~2œÄ~) by the total number of responses and then multiplying that number (the angle per response) by the number of people who picked a given choice.

#+begin_src javascript

  <canvas width="200" height="200"></canvas>

  <script>
  const results = [
      {name: "Satisfied", count: 1043, color: "lightblue"},
      {name: "Neutral", count: 563, color: "lightgreen"},
      {name: "Unsatisfied", count: 510, color: "pink"},
      {name: "No comment", count: 175, color: "silver"}
  ];

  let cx = document.querySelector("canvas").getContext("2d");
  let total = results
      .reduce((sum, {count}) => sum + count, 0);
  // Start at the top
  let currentAngle = -0.5 * Math.PI;
  for (let result of results) {
      let sliceAngle = (result.count / total) * 2 * Math.PI;
      cx.beginPath();
      // center=100,100, radius=100
      // from current angle, clockwise by slice's angle
      cx.arc(100, 100, 100,
             currentAngle, currentAngle + sliceAngle);
      currentAngle += sliceAngle;
      cx.lineTo(100, 100);
      cx.fillStyle = result.color;
      cx.fill();
  }
  </script>

#+end_src

*** Text
A 2D canvas drawing context provides the methods ~fillText~ and ~strokeText~. The latter can be useful for outlining letters, but usually ~fillText~ is what you need. It will fill the outline of the given text with the current ~fillStyle~.

The last two arguments to ~fillText~ and ~strokeText~ provide the position at which the font is drawn. By default, they indicate the position of the start of the text‚Äôs alphabetic baseline, which is the line that letters ‚Äústand‚Äù on, not counting hanging parts in letters such as j or p. You can change the horizontal position by setting the ~textAlign~ property to ~"end"~ or ~"center"~ and the vertical position by setting ~textBaseline~ to ~"top"~ , ~"middle"~ , or ~"bottom"~ .

#+begin_src javascript

  <canvas></canvas>
  <script>
    let cx = document.querySelector("canvas").getContext("2d");
    cx.font = "28px Georgia";
    cx.fillStyle = "fuchsia";
    cx.fillText("I can draw text, too!", 10, 50);
  </script>

#+end_src

*** Images
**** drawImage
The ~drawImage~ method allows us to draw pixel data onto a canvas. This pixel data can originate from an ~<img>~ element or from another canvas. The following example creates a detached ~<img>~ element and loads an image file into it. But it cannot immediately start drawing from this picture because the browser may not have loaded it yet. To deal with this, we register a ~"load"~ event handler and do the drawing after the image has loaded.

By default, ~drawImage~ will draw the image at its original size. You can also give it two additional arguments to set a different width and height.

#+begin_src javascript

  <canvas></canvas>

  <script>
    let cx = document.querySelector("canvas").getContext("2d");
    let img = document.createElement("img");
    img.src = "img/hat.png";
    img.addEventListener("load", () => {
        for (let x = 10; x < 200; x += 30) {
            cx.drawImage(img, x, 10);
        }
    });
  </script>
  // It will draw 9 consecutive images separated by 30 pixels each.

#+end_src

**** Pack multiple sprites (subpicture)
When ~drawImage~ is given *nine* arguments, it can be used to draw only a fragment of an image. The second through fifth arguments indicate the rectangle (x, y, width, and height) in the *source image* that should be copied, and the sixth to ninth arguments give the rectangle (*on the canvas*) into which it should be copied.

This can be used to pack multiple *sprites* (image elements) into a single image file and then draw only the part you need. For example, we have a picture containing a game character in multiple poses.

By alternating which pose we draw, we can show an animation that looks like a walking character.

To animate a picture on a canvas, the ~clearRect~ method is useful. It resembles ~fillRect~, but instead of coloring the rectangle, it makes it transparent, removing the previously drawn pixels.

We know that each *sprite*, each subpicture, is 24 pixels wide and 30 pixels high. The following code loads the image and then sets up an interval (repeated timer) to draw the next frame:

#+begin_src javascript

  <canvas></canvas>

  <script>
    let cx = document.querySelector("canvas").getContext("2d");
    let img = document.createElement("img");
    img.src = "img/player.png";
    let spriteW = 24, spriteH = 30;
    img.addEventListener("load", () => {
        let cycle = 0;
        setInterval(() => {
            cx.clearRect(0, 0, spriteW, spriteH);
            cx.drawImage(img,
                         // source rectangle
                         cycle * spriteW, 0, spriteW, spriteH,
                         // destination rectangle
                         0,               0, spriteW, spriteH);
            cycle = (cycle + 1) % 8;
        }, 120);
    });
  </script>
  // The cycle binding tracks our position in the animation. For each
  // frame, it is incremented and then clipped back to the 0 to 7 range by
  // using the remainder operator. This binding is then used to compute the
  // x-coordinate that the sprite for the current pose has in the picture.

#+end_src

*** Transformation
**** scale
Calling the ~scale~ method will cause anything drawn after it to be scaled. This method takes two parameters, one to set a horizontal scale and one to set a vertical scale.

#+begin_src javascript

  <canvas></canvas>

  <script>
    let cx = document.querySelector("canvas").getContext("2d");
    cx.scale(3, .5);
    cx.beginPath();
    cx.arc(50, 50, 40, 0, 7);
    cx.lineWidth = 3;
    cx.stroke();
  </script>

#+end_src

**** scale (flip)
Scaling will cause everything about the drawn image, including the line width, to be stretched out or squeezed together as specified. Scaling by a negative amount will flip the picture around. The flipping happens around point (0,0), which means it will also flip the direction of the coordinate system. When a horizontal scaling of -1 is applied, a shape drawn at x position 100 will end up at what used to be position -100.

So to turn a picture around, we can‚Äôt simply add ~cx.scale(-1, 1)~ before the call to [[drawImage]] because that would move our picture outside of the canvas, where it won‚Äôt be visible. You could adjust the coordinates given to ~drawImage~ to compensate for this by drawing the image at x position -50 instead of 0. Another solution, which doesn‚Äôt require the code that does the drawing to know about the scale change, is to adjust the axis around which the scaling happens.

There are several other methods besides ~scale~ that *influence the coordinate system for a canvas* (*set a new coordinates system*). You can rotate subsequently drawn shapes with the ~rotate~ method and move them with the ~translate~ method. The interesting‚Äîand confusing‚Äîthing is that these transformations *stack*, meaning that each one happens relative to the previous transformations.

So if we translate by 10 horizontal pixels twice, everything will be drawn 20 pixels to the right. If we first move the center of the coordinate system to (50,50) and then rotate by 20 degrees (about 0.1œÄ radians), that rotation will happen *around* point (50,50).

But if we *first* rotate by 20 degrees and *then* translate by (50,50), the translation will happen in the rotated coordinate system and thus produce a different orientation. *The order in which transformations are applied matters*.

To flip a picture around the vertical line at a given x position, we can do the following:

#+begin_src javascript

  function flipHorizontally(context, around) {
      context.translate(around, 0);
      context.scale(-1, 1);
      context.translate(-around, 0);
  }

#+end_src

We move the y-axis to where we want our mirror to be, apply the mirroring, and finally move the y-axis back to its proper place in the mirrored universe.

We can now draw a mirrored character at position (100,0) by flipping the world around the character‚Äôs vertical center.

#+begin_src javascript

  <canvas></canvas>

  <script>
    let cx = document.querySelector("canvas").getContext("2d");
    let img = document.createElement("img");
    img.src = "img/player.png";
    let spriteW = 24, spriteH = 30;
    img.addEventListener("load", () => {
        flipHorizontally(cx, 100 + spriteW / 2);
        cx.drawImage(img, 0, 0, spriteW, spriteH,
                     100, 0, spriteW, spriteH);
    });
  </script>

#+end_src

*** Storing and clearing transformations
*Transformations stick around*. Everything else we draw after drawing that mirrored character would also be mirrored. That might be inconvenient.

The ~save~ and ~restore~ methods on the 2D canvas context do this transformation management. They conceptually keep a stack of transformation states. When you call ~save~, the current state is pushed onto the stack, and when you call ~restore~, the state on top of the stack is taken off and used as the context‚Äôs current transformation. You can also call ~resetTransform~ to *fully reset the transformation*.

The ~branch~ function in the following example illustrates what you can do with a function that changes the transformation and then calls a function (in this case itself), which continues drawing with the given transformation.

This function draws a treelike shape (actually is a fractal) by drawing a line, *moving the center of the coordinate system* to the end of the line, and calling itself twice‚Äîfirst rotated to the left and then rotated to the right. Every call reduces the length of the branch drawn, and the recursion stops when the length drops below 8.

#+begin_src javascript

 <canvas width="600" height="300"></canvas>

 <script>
  let cx = document.querySelector("canvas").getContext("2d");
  function branch(length, angle, scale) {
      cx.fillRect(0, 0, 1, length);
      if (length < 8) return;
      cx.save();
      cx.translate(0, length);
      cx.rotate(-angle); // rotates coordinate axis
      branch(length * scale, angle, scale);
      cx.rotate(2 * angle);
      branch(length * scale, angle, scale);
      cx.restore();
  }
  cx.translate(300, 0);
  branch(60, 0.5, 0.8);
  </script>

  // If the calls to save and restore were not there, the second recursive
  // call to branch would end up with the position and rotation created by
  // the first call. It wouldn‚Äôt be connected to the current branch but
  // rather to the innermost, rightmost branch drawn by the first call. The
  // resulting shape might also be interesting, but it is definitely not a
  // tree.

#+end_src

** Node package manager
*** NPM
Is a package manager for the JavaScript programming language. npm is the default package manager for the JavaScript runtime environment Node.js and is included as a recommended feature in the Node.js installer.

It consists of a command line client, also called npm, and an online database of public and paid-for private packages, called the npm registry. The registry is accessed via the client, and the available packages can be browsed and searched via the npm website.

Although "npm" is commonly understood to be an abbreviation of "Node Package Manager", it is officially a recursive backronym for "npm is not an acronym".

*** Create new project
**** Initialize the project

#+begin_src sh

  # Accedemos a la carpeta de todos nuestros proyectos
  cd /home/manz/workspace

  # Creamos la carpeta de nuestro proyecto
  mkdir frontend-project

  # Accedemos a su carpeta ra√≠z (carpeta inicial)
  cd frontend-project

  # Inicializamos el control de versiones
  git init

  # A√±adimos la URL de GitHub (u otro servicio) como repositorio remoto
  git remote add origin https://github.com/ManzDev/frontend-project.git

  # Crear .gitignore, indiqua carpetas a ignorar con git (node_modules/)
  touch .gitignore

  # Inicializamos el proyecto con NPM
  npm init -y
  # Recomendable crear primero el repositorio git y a√±adir el remote,
  # as√≠ el package.json tendr√° entradas repository , bugs y homepage.

#+end_src

**** Create the folder structure
Scaffolding.

#+begin_src sh

- frontend-project/    # ra√≠z del proyecto
  - .git/              # datos de git
  - node_modules/      # paquetes de Node/NPM
  - dist/              # c√≥digo generado (si se usan preprocesadores)
  - src/               # c√≥digo fuente (c√≥digo editable)
    - assets/          # est√°ticos (im√°genes, audio, video, fuentes...)
    - js/              # Javascript
      - index.js
    - css/             # CSS
      - index.css
    - index.html
  - package.json       # archivo del proyecto NPM
  - package-lock.json  # hist√≥rico de versiones de dependencias
  - .gitignore         # ficheros y carpetas a ignorar por git

#+end_src

#+begin_src sh

  # Creamos las carpetas src y subcarpetas
  mkdir -p src/{assets,js,css}

  # Creamos los ficheros HTML, CSS y Javascript
  touch src/index.html
  touch src/js/index.js
  touch src/css/index.css

#+end_src

**** Simple local server
Instalar ~live-server~ de forma *global*. Se utilizar√° para montar un servidor local y ver todo el contenido de la carpeta ~src~ en un navegador, con cambios en tiempo real.

Pulsando en la URL http://127.0.0.1:8080, deber√≠a aparecer la p√°gina que se tiene en ~index.html~.

#+begin_src sh

  npm install -g live-server

  live-server src
  # Serving "src" at http://127.0.0.1:8080
  # Ready for changes

#+end_src

**** Advanced local server
Los siguientes servidores locales de desarrollo est√°n preparados para tareas m√°s complejas y se adaptar√°n mejor a nuestros casos si comenzamos a utilizar herramientas complejas como *build tools*, tanto en la parte de *CSS* (LESS, Sass, PostCSS...) como en la parte de *Javascript* (Babel, TypeScript...).

- Vite :: Probablemente, uno de los mejores y m√°s r√°pidos automatizadores actuales.
- Parcel :: Automatizador moderno, orientado a build tools y preprocesamiento.
- Webpack DevServer :: El m√°s popular, extendido y utilizado, pero tambi√©n el m√°s complejo.

*** package.json
Is a key component in any Node.js project. It is used to define the metadata of a Node.js project, including its name, version, dependencies, scripts, and other configuration settings. This file is crucial for managing Node.js projects and their dependencies.

Here are some of the key elements typically found in a ~package.json~ file:

- name :: name of the package
- version :: version of the package
- dependencies/devdependencies :: list the dependencies required by the project. *Dependencies* are packages that the project needs to run, while *devDependencies* are packages needed during development but not in production.
- scripts :: set of scripts that can be run using ~npm~ or ~yarn~. For example, you can define scripts for running tests, building the project, starting the application, etc.
- main :: entry point of the package. When the package is imported, this file will be loaded (~index.js~ (node) or ~index.html~ (browser)).
- module :: same as above, but with respect to ES Modules instead of CommonJS.
- author :: author of the package.
- license ::  license under which the package is distributed.
- type :: module system to use. For module use ESM, otherwise use CommonJS.
- homepage :: url of the package's home page.
- repository :: url of the repository. Type (git, svn...) and url (path) must be specified.
- bugs :: url field containing the url of the project's issues page.

The ~package.json~ file is typically located at the root of a Node.js project and is used by package managers like ~npm~ or ~yarn~ to install dependencies, run scripts, and manage the project. It helps in ensuring that the project is set up correctly and that all dependencies are installed properly.

*** Semantic versioning (semver)

| /CODE STATUS/         | /STAGE/   | /RULE/                 | /EXAMPLE/ |
|---------------------+---------+----------------------+---------|
| First release       | New     | start with 1.0.0     |   1.0.0 |
|                     | product |                      |         |
|                     |         |                      |         |
| Backward compatible | Patch   | inc third digit      |   1.0.1 |
| *bug* fixes           | release |                      |         |
|                     |         |                      |         |
| Backward compatible | Minor   | inc middle digit and |   1.1.0 |
| new *features*        | release | reset last           |         |
|                     |         |                      |         |
| Changes that *break*  | Major   | inc first digit and  |   2.0.0 |
| backward compatibil | release | reset middle and las |         |

You can specify which update types your package can accept from dependencies in your package's ~package.json~ file.

For example, to specify acceptable version ranges up to ~1.0.4~, use the following syntax:

- Patch releases :: ~1.0~ or ~1.0.x~ or ~~1.0.4~
- Minor releases :: ~1~ or ~1.x~ or ~^1.0.4~
- Major releases :: ~*~ or ~x~

*ManzDev*

| /VERSI√ìN/ | /DESCRIPCI√ìN/                                       |
|---------+---------------------------------------------------|
|   1.2.4 | instala siempre la versi√≥n indicada 1.2.4         |
|  ~1.2.4 | instalar√° s√≥lo los parches, sin llegar a          |
|         | pasar a la versi√≥n 1.3. ni superiores             |
|  ^1.2.4 | instalar√° versi√≥n menor m√°s alta, sin llegar      |
|         | a pasar a la versi√≥n 2.x. ni superiores (default) |

*Nota*: para evitar depedencias rotas, ~npm~ incluye un ~^~ (circunflejo) antes del n√∫mero de versi√≥n de la dependencia (default cuando se instala un paquete). De esta forma, sabemos que versi√≥n se instal√≥ por primera vez, pero ~npm~ buscar√° la versi√≥n m√°s alta disponible, teniendo en cuenta s√≥lo parches y actualizaciones menores, pero nunca instalando actualizaciones mayores.

*** NPM scripts

| /COMANDO/        | /DESCRIPCI√ìN/                                |
|----------------+--------------------------------------------|
| /npm run start/  | tareas de inicio del proyecto              |
| /npm run dev/    | levantar servidores de desarrollo locales  |
| /npm run serve/  | idem al anterior                           |
| /npm run test/   | suele iniciar una bater√≠a de tests         |
| /npm run build/  | construye ficheros finales para producci√≥n |
| /npm run deploy/ | desplegar en la web de producci√≥n          |
|                | la webapp constru√≠da con build             |

#+begin_src js

  // Proyecto utilizando el automatizador parcel para desplegar en GitHub Pages
  "scripts": {
      "start": "parcel src/index.html",
      "build": "parcel build src/index.html -d build
               --public-url /frontend-project/",
      "deploy": "gh-pages -d build"
  }

#+end_src

A medida que vamos creando scripts, es posible que queramos realizar tareas concretas *antes* o *despu√©s* de ejecutar un script determinado. Esto es posible simplemente creando una tarea con el prefijo ~pre~ o el prefijo ~post~ respectivamente.

El script ~deploy~ del ejemplo sube a GitHub Pages el contenido de la carpeta ~build~. Como queremos que est√© actualizada, creamos un script ~predeploy~ (que se ejecutar√° antes) y que ejecutar√° ~parcel~ para generar el contenido de esa carpeta ~build~ antes de subirlo, y de este modo est√© todo actualizado. De la misma forma se podr√≠a hacer con el prefijo ~post~ para tareas posteriores de finalizaci√≥n.

** Automatizadores
*** Brief
Un automatizador es un sistema que permite organizar y estructurar una aplicaci√≥n web, agilizando tareas repetitivas y facilitando su creaci√≥n.

Antiguamente, cuando ten√≠amos que crear un nuevo sitio web, deb√≠amos crear manualmente una *carpeta para el proyecto*, las diferentes subcarpetas de las secciones de la web (im√°genes, css, js, etc...), configurar un servidor web (se sol√≠a usar XAMPP o similares), colocar y enlazar las diferentes librer√≠as CSS y/o Javascript que quer√≠amos utilizar, etc...

Con la evoluci√≥n del desarrollo web, hemos pasado a crear webs que *transpilan c√≥digo*. Esto es, tenemos una carpeta ~src/~ donde tenemos nuestro c√≥digo fuente y ese c√≥digo debe preprocesarse y traducirse a otro c√≥digo (en la carpeta ~dist/~) que es el que finalmente leer√° nuestro navegador. Mantener actualizado el c√≥digo fuente que escribimos con el que lee el navegador sin automatizarlo, es una tarea muy tediosa. De ah√≠ surgen los automatizadores.

Algunas de esas tareas podr√≠an ser las siguientes:

- Creaci√≥n del *proyecto* y su gesti√≥n (gestionado con NPM)
- Actualizaci√≥n y mantenimiento de *dependencias* (gestionado con NPM)
- *Servidor web local* de desarrollo
- *Minificaci√≥n* de c√≥digo
- *Optimizaci√≥n* de im√°genes
- *Preprocesar* o transpilar c√≥digo fuente
- *Despliegue* o subida del c√≥digo final al servidor

*** Bundle
Un bundle sirve para agrupar todos los ficheros de JavaScript en uno solo. As√≠ el navegador no necesita hacer varias peticiones HTTP.

Herramientas como Webpack, Parcel, Rollup, Babel o similar, buscan los ~require()~ (funci√≥n que importa m√≥dulos CommonJS que se exportaron con un ~module.exports~ desde otros archivos) y los sustituyen por el c√≥digo del fichero correspondiente, uniendo y empatando todos los archivos Javascript necesarios de nuestra aplicaci√≥n web en un s√≥lo archivo Javascript llamado bundle.

/Esbuild/ es un automatizador y bundler de Javascript extremadamente r√°pido, que permite hacer traducciones y transpilado de c√≥digo a una velocidad asombrosa. Podremos utilizarlo desde ~web-dev-server~ para convertir nuestro c√≥digo Javascript /ES2021/ en c√≥digo Javascript /ES2017/ o similar, y conseguir un mejor soporte en navegadores m√°s antiguos.

*** Rollup
Rollup is a module bundler for JavaScript which compiles small pieces of code into something larger and more complex, such as a library or application. It uses the new standardized format for code modules included in the ES6 revision of JavaScript, instead of previous idiosyncratic solutions such as CommonJS and AMD. ES modules let you freely and seamlessly combine the most useful individual functions from your favorite libraries. This will eventually be possible natively everywhere, but Rollup lets you do it today.

Developing software is usually easier if you break your project into smaller separate pieces, since that often removes unexpected interactions and dramatically reduces the complexity of the problems you'll need to solve, and simply writing smaller projects in the first place isn't necessarily the answer. Unfortunately, JavaScript has not historically included this capability as a core feature in the language.

This finally changed with the ES6 revision of JavaScript, which includes a syntax for importing and exporting functions and data so they can be shared between separate scripts. The specification is now fixed, but it is only implemented in modern browsers and not finalised in Node.js. Rollup allows you to write your code using the new module system, and will then compile it back down to existing supported formats such as CommonJS modules, AMD modules, and IIFE-style scripts. This means that you get to write future-proof code, and you also get the tremendous benefits of‚Ä¶

*** esbuild
Is an extremely fast bundler for the web. esbuild is used in [[Vite]], a front-end build-tool and development server.

esbuild is a module bundler and minifier for JavaScript. Written in Go instead of JavaScript, esbuild claims to be "10 to 100 times" faster than other bundlers by using parallelism and shared memory usage. It supports TypeScript, JSX, tree-shaking and is extensible through plugins.

*Major features*:

- Extreme speed without needing a cache
- JavaScript, CSS, TypeScript, and JSX built-in
- A straightforward API for CLI, JS, and Go
- Bundles ESM and CommonJS modules
- Bundles CSS including CSS modules
- Tree shaking, minification, and source maps
- Local server, watch mode, and plugins

*** Vite
**** Brief
*Wikipedia*:
Vite is a local development server. It has support for TypeScript and JSX. It uses [[Rollup]] and [[esbuild]] internally for bundling.

It monitors files as they're being edited and upon file save the web browser reloads the code being edited through a process called Hot Module Replacement (HMR) which works by just reloading the specific file being changed using ES6 modules (ESM) instead of recompiling the entire application.

Vite provides built-in support for server-side rendering (SSR). By default, it listens on TCP port 5173. It is possible to configure Vite to serve content over HTTPS and proxy requests (including WebSocket) to a back-end web server (such as Apache HTTP Server or lighttpd).

*Vite*:
Vite is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:

- A *dev server* that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).

- A *build command that bundles* your code with Rollup, pre-configured to output highly optimized static assets for production.

**** Why Vite
*The Problems*:
Before ES modules were available in browsers, developers had no native mechanism for authoring JavaScript in a modularized fashion. This is why we are all familiar with the concept of "bundling": using tools that crawl, process and concatenate our source modules into files that can run in the browser.

Over time we have seen tools like webpack, [[Rollup]] and Parcel, which greatly improved the development experience for frontend developers.

However, as we build more and more ambitious applications, the amount of JavaScript we are dealing with is also increasing dramatically. It is not uncommon for large scale projects to contain thousands of modules. We are starting to hit a performance bottleneck for JavaScript based tooling: it can often take an unreasonably long wait (sometimes up to minutes!) to spin up a dev server, and even with Hot Module Replacement (HMR), file edits can take a couple of seconds to be reflected in the browser. The slow feedback loop can greatly affect developers' productivity and happiness.

Vite aims to address these issues by leveraging new advancements in the ecosystem: the availability of native ES modules in the browser, and the rise of JavaScript tools written in compile-to-native languages.

**** Slow Server Start
When cold-starting the dev server, a bundler-based build setup has to eagerly crawl and build your entire application before it can be served.

Vite improves the dev server start time by first dividing the modules in an application into two categories: *dependencies* and *source code*.

-  dependencies :: are mostly plain JavaScript that do not change often during development. Some large dependencies (e.g. component libraries with hundreds of modules) are also quite expensive to process. Dependencies may also be shipped in various module formats (e.g. ESM or CommonJS). Vite pre-bundles dependencies using [[esbuild]].

- source code ::  often contains non-plain JavaScript that needs transforming (e.g. JSX, CSS or Vue/Svelte components), and will be edited very often. Also, not all source code needs to be loaded at the same time (e.g. with route-based code-splitting).

Vite serves source code over native ESM. This is essentially letting the browser take over part of the job of a bundler: Vite only needs to transform and serve source code on demand, as the browser requests it. Code behind conditional dynamic imports is only processed if actually used on the current screen.

**** Scaffolding for Vite's first project

#+begin_src sh

  npm create vite@latest

#+end_src

Then follow the prompts!

You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:

#+begin_src sh

  # npm 7+, extra double-dash is needed:
  npm create vite@latest my-vue-app -- --template vue

#+end_src

You can use ( ~.~ ) for the project name to scaffold in the current directory.

**** Crear un proyecto con Vite

#+begin_src sh

  # Crea un prorecto con una plantilla de vite (similar a npm init)
  npm create vite name-project
  # Need to install the following packages:
  #   create-vite
  # Ok to proceed? (y) y

#+end_src

Se nos advertir√° que es necesario instalar el paquete ~create-vite~ de no tenerlo instalado, que es el asistente encargado de crear la aplicaci√≥n web.

**** Manual Installation
In your project, you can install the *vite* CLI using:

#+begin_src sh

  npm install -D vite

#+end_src

And create an ~index.html~ file like this:

#+begin_src html

  <p>Hello Vite!</p>

#+end_src

Then run the appropriate CLI command in your terminal:

#+begin_src sh

  npx vite

#+end_src

The ~index.html~ will be served on http://localhost:5173.

**** Plantillas de Vite

#+begin_src sh

  # Ejemplo, para montar un proyecto de Vite + Vue
  # npm 7+, se requiere gui√≥n doble extra:
  npm create vite name-project -- --template vue
  # npm create vite@latest name-project -- --template vue

#+end_src

| /PLANTILLA/ | /DESCRIPCI√ìN/                      |
|-----------+----------------------------------|
| /vanilla/   | proyecto vanilla, sin frameworks |
| /vue/       | proyecto con el framework Vue    |
| /react/     | proyecto con la librer√≠a React   |
| /preact/    | proyecto con la librer√≠a Preact  |
| /lit/       | proyecto con la librer√≠a Lit     |
| /svelte/    | proyecto con la librer√≠a Svelte  |

Una vez hecho el proceso, comprobaremos que la tarea de creaci√≥n del proyecto es pr√°cticamente instant√°nea. Esto ocurre as√≠ porque Vite no realiza el proceso de instalaci√≥n de paquetes autom√°ticamente, por lo que tendremos que hacerlos nosotros manualmente de forma posterior:

#+begin_src sh

  cd name-project
  npm install

#+end_src

Con esto ya tendremos el proyecto listo para arrancarlo con el script ~npm run dev~ y comenzar a desarrollar. Ten en cuenta que en todos los proyectos que generes tendr√°s un script ~dev~ que lanza el *modo de desarrollo de Vite* y, por otro lado, tendr√°s un script ~build~ que lanza el *modo de producci√≥n de Vite*, que es el que genera la subida en la carpeta ~dist~, que es la que ir√° a producci√≥n.

**** El fichero vite.config.js
Es un fichero de configuraci√≥n donde puedes establecer algunos detalles del funcionamiento del empaquetador en el proyecto actual. La estructura general de este fichero es la siguiente:

#+begin_src javascript

  import { defineConfig } from "vite";

  export default defineConfig({
      root: "./",
      base: "/",
      publicDir: "public",
      build: {
          outDir: "dist",
          assetsDir: "assets"
      },
      plugins: []
  });
#+end_src

Dependiendo de la plantilla utilizada, este fichero de configuraci√≥n puede ser diferente o incluso no existir (como es en el caso de los proyectos de Javascript vanilla).

*** Linters
**** Brief
Linter (looking for problematic patterns) is a static code analysis tool used to flag programming errors, bugs, stylistic errors and suspicious constructs.

*Types of Checks Linters Provide*:
- *Syntax* Errors
- Code *Standards* Adherence
- *Potential* Problems (a.k.a. Code Smells)
- *Security* Checks

**** ESLint
ESLint statically analyzes your code to quickly find problems. It is built into most text editors and you can run ESLint as part of your continuous integration pipeline.

ESLint is an open source project that helps you find and fix problems with your JavaScript code. It doesn't matter if you're writing JavaScript in the browser or on the server, with or without a framework, ESLint can help your code live its best life.

- Find issues
- Fix problems automatically
- Configure everything

You can install and configure ESLint using this command:

#+begin_src sh

  npm init @eslint/config@latest

#+end_src

After that, you can run ESLint on any file or directory like this:

#+begin_src sh

  ./node_modules/.bin/eslint yourfile.js

#+end_src

**** eslint-config-dev
1. Instalar el linter y el paquete de configuraci√≥n:

#+begin_src sh

  npm install -D eslint eslint-config-manzdev

#+end_src

2. Crear un fichero de configuraci√≥n ~.eslintrc.json~ que lo utilice:

#+begin_src javascript

  {
      extends: "eslint-config-manzdev",
      rules: {
          /* ... */
      }
  }

#+end_src

**** Stylelint
A mighty CSS linter that helps you avoid errors and enforce conventions.

Avoid errors:
- invalid things, e.g. malformed grid areas
- valid things that are problematic, e.g. duplicate selectors
- unknown things, e.g. misspelled property names

Enforce conventions:
   - disallow things, e.g. specific units
   - enforce naming patterns, e.g. for custom properties
   - set limits, e.g. the number of ID selectors
   - specify notations, e.g. for modern color functions

   1. Use npm and our ~init~ tool to install Stylelint and the config:

#+begin_src sh

  npm init stylelint

#+end_src

   2. Run Stylelint on all the CSS files in your project:

#+begin_src sh

  npx stylelint "**/*.css"

#+end_src

   Once you're up and running, you can customize Stylelint.

*** Mkweb script
**** Brief
Sirve para generar r√°pidamente, la estructura de carpetas (scaffolding) de un proyecto HTML/CSS/Javascript base, con todo preparado para programar.

**** Features
- *Empaquetador* Javascript /Vite/. Ultrar√°pido, con live server integrado
- *Linter Javascript* /ESLint/ preconfigurado con ~eslint-config-manzdev~
- *Linter CSS* /StyleLint/ preconfigurado con ~stylelint-config-manzdev~
- Integraci√≥n de /gh-pages/ para despliegue autom√°tico en *GitHub Pages*
- Flag opcional para crear *videojuegos* con /Phaser/
- Flag opcional para crear *aplicaciones* web con /Lit/

**** Installation
Para instalar el script, simplemente se escribe desde una terminal:

#+begin_src sh

  sudo curl -s https://manz.dev/download/mkweb -o /usr/local/bin/mkweb
  sudo chmod ugo+rx /usr/local/bin/mkweb

#+end_src

**** Usage
Se ejecuta el script ~mkweb~ pas√°ndole por par√°metro el nombre de la carpeta del proyecto:

#+begin_src sh

  mkweb project-name
  cd project-name
  git remote add origin git@github.com:GITUSER/project-name.git
  npm install
  code . # (launch vscode)
  npm run dev

#+end_src

- Para crear un proyecto de /Phaser/, escribe: ~mkweb project-name --phaser~.
- Para crear un proyecto de /Lit/, escribe: ~mkweb project-name --lit~.
- Aunque puedes usar ~npm~, se recomienda usar ~pnpm~, compatible y mucho m√°s r√°pido.

**** Scaffolding
- Carpeta ~src/~ incluye el c√≥digo fuente del proyecto:
  - Carpeta ~assets/~ que puede incluir est√°ticos (hasheados).
  - Carpeta ~components/~ que puede incluir /WebComponents/.
  - Archivo /HTML/ ( ~index.html~ ) con la p√°gina principal.
  - Archivo /CSS/ ( ~index.css~ ) referenciado en el HTML anterior.
  - Archivo /Javascript/ ( ~index.js~ ) referenciado en el HTML anterior.
- Carpeta ~dist/~ creada tras un ~npm run build~ (lista para subir a producci√≥n).
- Carpeta ~public/~ con archivos est√°ticos similar a ~assets/~, pero a diferencia de esta, sus archivos son copiados a ~dist/~ manteniendo la estructura de carpetas y nombres de ficheros sin ser hasheados.

** ES2017-JS Universe
*** ECMAScript
ECMAScript is an object-oriented programming language with the prototype-based organization, having the concept of an [[Object concept][object]] as its core abstraction.

Here, we'll try to represent the *logical structure* of an ECMAScript program itself, and hopefully it clarified these details.

In this edition we focus on the newer abstractions, updated terminology, but still maintaining the very basic JS structures which stay consistent throughout the spec versions.

This article covers ES2017+ runtime system.

*** Object concept
An object is a *collection of properties*, and has a single [[Prototype concept][prototype]] object. The prototype may be either an object or the ~null~ value.

A prototype of an object is referenced by the internal ~[[Prototype]]~ property, which to user-level code is exposed via the ~__proto__~ property.

The prototype objects are used to implement inheritance with the mechanism of [[Delegation or dynamic dispatch][dynamic dispatch]].

#+begin_src js

  let point = {
      x: 10,
      y: 20,
  };

  // We have the structure with two explicit own properties and one
  // implicit __proto__ property, which is the reference to the prototype
  // of point.

  +----------------------+                   +-----------------+
  |       point          |      ‚îå----------->| point.__proto__ |
  +----------------------+      |            +-----------------+
  |     x     |    10    |      |            |       ...       |
  |----------------------|      |            | some properties |
  |     y     |    20    |      |            |       ...       |
  |----------------------|      |            +-----------------+
  | __proto__ |     ------------‚îò
  +----------------------+

#+end_src

*** Prototype concept
**** Brief
A prototype is a delegation object used to implement *prototype-based inheritance*.

Every object, when is created, receives its prototype. If the prototype is not set explicitly, objects receive default prototype as their inheritance object.

The prototype can be set explicitly via either the ~__proto__~ property, or ~Object.create~ method.

*Note*: by default objects receive ~Object.prototype~ as their inheritance object.

#+begin_src js

  // Base object.
  let point = {
      x: 10,
      y: 20,
  };

  // Inherit from `point` object.
  let point3D = {
      z: 30,
      __proto__: point,
  };

  console.log(
      point3D.x, // 10, inherited
      point3D.y, // 20, inherited
      point3D.z  // 30, own
  );

#+end_src

**** Prototype chain
A prototype chain is a finite chain of objects used to implement inheritance and shared properties.

Any object can be used as a prototype of another object, and the prototype itself can have its own prototype. If a prototype has a non-null reference to its prototype, and so on, it is called the prototype chain.

#+begin_src js

  // Base object.
  let point = {
      x: 10,
  };

  // Inherit from `point` object.
  let point3D = {
      z: 30,
      __proto__: point,
  };

  +---------+    +-------+    +------------------+
  | point3D |--->| point |--->| Object.prototype |---> null
  +---------+    +-------+    +------------------+

#+end_src

**** Delegation or dynamic dispatch
A mechanism used to resolve a property in the inheritance chain. The process happens at runtime, hence is also called dynamic dispatch.

If a property is not found in the object itself, there is an attempt to resolve it in the [[Prototype concept][prototype]]; in the prototype of the prototype, etc. ‚Äî until the whole [[Prototype chain][prototype chain]] is considered. Technically this mechanism is known as *dynamic dispatch* or *delegation*.

*Note*: in contrast with *static dispatch* when references are resolved at compile time, *dynamic dispatch* resolves the references at runtime.

And if a property eventually is not found in the prototype chain, the ~undefined~ value is returned:

#+begin_src javascript

  // An "empty" object.
  let empty = {};

  console.log(
      // function, from default prototype
      empty.toString, // [Function: toString]
      empty.x,        // undefined
  );

#+end_src

As we can see, a default object is actually never empty ‚Äî it always inherits something from the ~Object.prototype~. To create a prototype-less dictionary, we have to explicitly set its prototype to null:

#+begin_src javascript

  // Doesn't inherit from anything.
  let dict = Object.create(null);

  console.log(dict.toString); // undefined

#+end_src

The *dynamic dispatch* mechanism allows full mutability of the inheritance chain, providing an ability to change the delegation object.

*Note*: even though the ~__proto__~ property is standardized today, and is easier to use for explanations, on practice prefer using API methods for prototype manipulations, such as ~Object.create~, ~Object.getPrototypeOf~, ~Object.setPrototypeOf~, and similar on the ~Reflect~ module.

#+begin_src javascript

  let protoA = {x: 10};
  let protoB = {x: 20};

  // Same as `let objectC = {__proto__: protoA};`:
  let objectC = Object.create(protoA);
  console.log(objectC.x); // 10

  // Change the delegate:
  Object.setPrototypeOf(objectC, protoB);
  console.log(objectC.x); // 20

#+end_src

*** Class concept
**** Brief
A class is a formal abstract set which specifies initial state and behavior of its objects.

When several objects share the same initial state and behavior, they form a *classification*.

Technically a ‚Äúclass‚Äù is represented as a ‚Äú[[Constructor concept][constructor function]] + [[Prototype concept][prototype]]‚Äù pair. Thus, a constructor function creates objects, and also automatically sets the prototype for its newly created instances. This prototype is stored in the ~<ConstructorFunction>.prototype~ property.

In case we need to have multiple objects inheriting from the same prototype, we could of course create this one prototype, and explicitly inherit it from the newly created objects:

#+begin_src javascript

  // Generic prototype for all letters.
  let letter = {
      getNumber() {
          return this.number;
      }
  };

  let a = {number: 1, __proto__: letter};
  let b = {number: 2, __proto__: letter};
  // ...
  let z = {number: 26, __proto__: letter};

  console.log(
      a.getNumber(), // 1
      b.getNumber(), // 2
      z.getNumber(), // 26
  );

  +-------------------+
  |         a         |
  +-------------------+
  |   number  |   1   |
  |-------------------|
  | __proto__ |    -----------‚îê
  +-------------------+       |
                              |          +------------------------+
  +-------------------+       |    ‚îå---->|         letter         |
  |         b         |       |    |     +------------------------+
  +-------------------+       |    |     | getNumber | <function> |
  |   number  |   2   |       |    |     |------------------------|
  |-------------------|       |    |     | __proto__ |     |      |
  | __proto__ |    -----------‚îº----‚îò     +---------------  |  ----+
  +-------------------+       |                            v
                              |          +------------------------+
  +-------------------+       |          |    Object.prototype    |
  |         z         |       |          +------------------------+
  +-------------------+       |          |      <built-ins>       |
  |   number  |   26  |       |          |------------------------+
  |-------------------|       |          | __proto__ |    null    |
  | __proto__ |    -----------‚îò          +------------------------+
  +-------------------+

#+end_src

However, this is obviously cumbersome. And the class abstraction serves exactly this purpose ‚Äî being a syntactic sugar (i.e. a construct which semantically does the same, but in a much nicer syntactic form), it allows creating such multiple objects with the convenient pattern:

#+begin_src javascript

  class Letter {
      constructor(number) {
          this.number = number;
      }

      getNumber() {
          return this.number;
      }
  }

  let a = new Letter(1);
  let b = new Letter(2);
  // ...
  let z = new Letter(26);

  console.log(
      a.getNumber(), // 1
      b.getNumber(), // 2
      z.getNumber(), // 26
  );

#+end_src

*Note*: class-based inheritance in ECMAScript is implemented on top of the prototype-based delegation.

*Note*: a ‚Äúclass‚Äù is just a theoretical abstraction. Technically it can be implemented with the static dispatch as in Java or C++, or [[Delegation or dynamic dispatch][dynamic dispatch]] (delegation) as in JavaScript, Python, Ruby, etc.

**** Constructor concept
A constructor is a function which is used to create instances, and automatically set their [[Prototype concept][prototype]].

It is possible to use a constructor function explicitly. Moreover, before the [[Class concept][class abstraction]] was introduced, JS developers used to do so not having a better alternative (we can still find a lot of such legacy code allover the internets):

#+begin_src javascript

  function Letter(number) {
      this.number = number;
  }

  Letter.prototype.getNumber = function() {
      return this.number;
  };

  let a = new Letter(1);
  let b = new Letter(2);
  // ...
  let z = new Letter(6);

  console.log(
      a.getNumber(), // 1
      b.getNumber(), // 2
      z.getNumber(), // 6
  );

+---------------+
|       a       |
+---------------+         +----------------------+
|   number  | 1 |         |        Letter        |<--‚îê
|---------------|         +----------------------+   |   +------------------+
| __proto__ |  ----‚îê      | __proto__ |      ----------->|Function.prototype|
+---------------+  |      |----------------------|   |   +------------------+
                   |      | prototype |     |    |   |   |   <built-ins>    |
+---------------+  |      +---------------- | ---+   |   |------------------|
|       b       |  |                        v        |   | __proto__ |  |   |
+---------------+  |      +----------------------+   |   +------------- | --+
|   number  | 2 |  |  ‚îå-->|    Letter.prototype  |   |                  |
|---------------|  |  |   +----------------------+   |                  v
| __proto__ |  ----‚îº--‚îò   |constructor|      --------‚îò   +------------------+
+---------------+  |      |----------------------|       | Object.prototype |
                   |      | getNumber |<function>|       +------------------+
+---------------+  |      |----------------------|   ‚îå-->|   <built-ins>    |
|       z       |  |      | __proto__ |      --------‚îò   |------------------|
+---------------+  |      +----------------------+       | __proto__ | null |
|   number  | 6 |  |                                     +------------------+
|---------------|  |
| __proto__ |  ----‚îò
+---------------+

#+end_src

*Note*: the actual prototype of any object is always the ~__proto__~ reference. And the explicit ~prototype~ property on the constructor function is just a reference to the prototype of its instances; from instances it‚Äôs still referred by the ~__proto__~.

And while creating a single-level constructor was pretty easy, the inheritance pattern from parent classes required much more boilerplate. Currently this boilerplate is hidden as an implementation detail, and that exactly what happens under the hood when we create a class in JavaScript.

*Note*: constructor functions are just implementation details of the class-based inheritance.

*** Execution context concept
**** Definition
An execution context is a specification device that is used to track the runtime evaluation of the code.

There are several types of ECMAScript code: the global code, function code, ~eval~ code, and module code; each code is evaluated in its execution context. Different code types, and their appropriate objects may affect the structure of an execution context: for example, generator functions save their generator object on the context.

Let‚Äôs consider a recursive function call:

#+begin_src javascript

  function recursive(flag) {

      // Exit condition.
      if (flag === 2) {
          return;
      }

      // Call recursively.
      recursive(++flag);
  }

  // Go.
  recursive(0);

#+end_src

When a function is called, a *new execution context* is created, and *pushed* onto the stack ‚Äî at this point it becomes an *active execution context*. When a function returns, its context is *popped* from the stack.

A context which calls another context is called a *caller*. And a context which is being called, accordingly, is a *callee*. In our example the ~recursive~ function plays both roles: of a callee and a caller ‚Äî when calls itself recursively.

**** Execution context stacks
An execution context stack is a LIFO structure used to maintain control flow and order of execution.

The global context is always at the bottom of the stack, it is created prior execution of any other context.

#+begin_src javascript

  function recursive(flag) {

      // Exit condition.
      if (flag === 2) {
          return;
      }

      // Call recursively.
      recursive(++flag);
  }

  // Go.
  recursive(0);

 +--------------+  +--------------+  +--------------+  +--------------+
 |   EC stack   |->|   EC stack   |->|   EC stack   |->|   EC stack   |
 +--------------+  +--------------+  +--------------+  +--------------+
 |Global context|  |Global context|  |Global context|  |Global context|
 +--------------+  |--------------|  |--------------|  |--------------|
               ^   | recursive(0) |  | recursive(0) |  | recursive(0) |
                 \ +--------------+  |--------------|  |--------------|
                                 ^   | recursive(1) |  | recursive(1) |
                                   \ +--------------+  |--------------|
                                                   ^   | recursive(2) |
                                                     \ +--------------+

#+end_src

*** Environment concept
**** Lexical environment
Every execution context has an associated lexical environment. A lexical environment is a structure used to define association between identifiers appearing in the context with their values. Each environment can have a reference to an optional parent environment.

So an environment is a storage of variables, functions, and classes defined in a scope.

Technically, an environment is a pair, consisting of an *environment record* (an actual storage table which maps identifiers to values), and a *reference to the parent* (which can be ~null~).

Logically this reminds us of the prototype chain. And the rule for identifiers resolution is very similar: if a variable is not found in the own environment, there is an attempt to lookup it in the parent environment, in the parent of the parent, and so on ‚Äî until the whole environment chain is considered.

Similarly to prototypes, the same parent environment can be shared by several child environments: for example, two global functions share the same global environment.

The lexical environments is exactly the technique which is used in implementation of closures and the static scope in general.

#+begin_src javascript

  let x = 10;
  let y = 20;

  function foo(z) {
      let x = 100;
      return x + y + z;
  }

  foo(30); // 150

   +---------------+
   |    foo env    |
   +---------------+       +----------------+
   | Record |    --------->|   Foo EnvRec   |
   |--------|------+       +----------------+
   | Parent |   |  |       |  z  |    30    |
   +----------- | -+       |----------------|
                v          |  x  |   100    |
   +---------------+       +----------------+
   |  Global env   |
   +---------------+       +----------------+
   | Record |    --------->| Global EnvRec  |
   |--------|------+       +----------------+
   | Parent | null |       |  x  |    10    |
   +---------------+       |----------------|
                           |  y  |    20    |
                           |----------------|
                           | foo |<function>|
                           +----------------+

#+end_src

*Notes*:
 - in ES5 the concept of [[Variable object][variable object]] is replaced with lexical environments model.

  - in ES5 the concepts of variable object, and [[Activation object][activation object]] are combined into the lexical environments model.

  - differences between [[Execution context][execution context]] and lexical environments (INS):

#+begin_src artist

  +--------------------------------+     +-----------------------------+
  |       Execution context        |     |     Lexical Enviroment      |
  +--------------------------------+     +-----------------------------+
  |      VO     | { vars, fun dec, |     | Env Rec | { vars, func dec, |
  |             |   arguments... } |     |         |   arguments...}   |
  |--------------------------------| --> |-----------------------------|
  | Scope chain | [VO + all parent |     | Parent  |   parent scope    |
  |             |  scopes]         |     |         |                   |
  |--------------------------------|     +-----------------------------+
  | this Value  | Context object   |
  |             |                  |
  +--------------------------------+

#+end_src

**** Identifier resolution
The process of resolving a variable (binding) in an environment chain. An unresolved binding results to ~ReferenceError~.

Environment records (an actual storage table which maps identifiers to values) differ by type. There are *object* environment records and *declarative* environment records. On top of the declarative record there are also *function* environment records, and *module* environment records. Each type of the record has specific only to it properties. However, the generic mechanism of the identifier resolution is common across all the environments, and doesn‚Äôt depend on the type of a record.

An example of an object environment record can be the record of the global environment. Such record has also associated *binding object*, which may store some properties from the record, but not the others, and vice-versa. The binding object can also be provided as ~this~ value.

#+begin_src javascript

  // Legacy variables using `var`.
  var x = 10;

  // Modern variables using `let`.
  let y = 20;

  // Both are added to the environment record:
  console.log(
      x, // 10
      y, // 20
  );

  // But only `x` is added to the "binding object".
  // The binding object of the global environment
  // is the global object, and equals to `this`:

  console.log(
      this.x, // 10
      this.y, // undefined!
  );

  // Binding object can store a name which is not
  // added to the environment record, since it's
  // not a valid identifier:

  this['not valid ID'] = 30;

  console.log(
      this['not valid ID'], // 30
  );

   +---------------+
   |  Global env   |
   +---------------+       +-----------------------------+
   | Record |    --------->|        Global EnvRec        |
   |--------|------+       +-----------------------------+
   | Parent | null |       |         x         |   10    |
   +---------------+       |-----------------------------|
                           |         y         |   20    |
                           |-----------------------------|
                           | __BindingObject__ |    |    |
                           +----------------------- | ---+
                                                    v
                           +-----------------------------+
                           | Global EnvRec BindingObject |
                           +-----------------------------+
                           |         x         |   10    |
                           |-----------------------------|
                           |    not valid ID   |   30    |
                           +-----------------------------+

#+end_src

Notice, the binding object exists to cover legacy constructs such as ~var~ -declarations, and ~with~ -statements, which also provide their object as a binding object. These are historical reason when environments were represented as simple objects. Currently the environments model is much more optimized, however as a result we can‚Äôt access binding as properties anymore.

*** Closure concept
**** First-class function
Functions in ECMAScript are first-class. This concept is fundamental to functional programming, which aspects are supported in JavaScript.

*First-class function*: a function which can participate as a normal data:be created literally at runtime, be stored in a variable, passed as an argument, or returned as a value from another function.

#+begin_src javascript

  // create a function expression
  // dynamically at runtime and
  // bind it to "foo" identifier

  var foo = function () {
      console.log("foo");
  };

  // pass it to another function,
  // which in turn is also created
  // at runtime and called immediately
  // right after the creation; result
  // of this function is again bound
  // to the "foo" identifier

  foo = (function (funArg) {

      // activate the "foo" function
      funArg(); // "foo"

      // and return it back as a value
      return funArg;

  })(foo);

  // foo function is a ‚Äúfunarg‚Äù which is passed to the anonymous
  // higher-order function (it accepts foo ‚Äúfunarg‚Äù by the formal parameter
  // name funArg). This anonymous function in turn returns the functional
  // value ‚Äî and again the foo function itself. And all these functions are
  // grouped by the first-class functions definition.

#+end_src

**** Free variable
A *free variable* is a variable which is used by a function, but is neither a parameter, nor a local variable of the function.

In other words, a free variable is one that is placed not in the own environment, but probably in some surrounding environments.

#+begin_src javascript

  // Global environment (GE)

  var x = 10;

  function foo(y) {

      // environment of "foo" function (E1)

      var z = 30;

      function bar(q) {
          // environment of "bar" function (E2)
          return x + y + z + q;
      }

      // return "bar" to the outside
      return bar;

  }

  var bar = foo(20);

  bar(40); // 100

#+end_src

In this example we have three environments: ~GE~, ~E1~ and ~E2~, which correspond respectively to the global object, ~foo~ function and ~bar~ function.

Thus, for the ~bar~ function, ~x~, ~y~ and ~z~ variables are *free* ‚Äî they are neither formal parameters, nor local variables of ~bar~.

Notice, that ~foo~ function does not use free variables. However, since ~x~ variable is used inside the ~bar~ function, and because ~bar~ function is created during execution of the ~foo~ function, the later one should nevertheless save the bindings of the parent environment ‚Äî in order to pass the information about the ~x~ binding further to the deeper nested functions (to the ~bar~ in our case).

Correct and expected result ~100~ after the ~bar~ function activation means, that ~bar~ function somehow remembers the environment of the ~foo~ function activation (where internal ~bar~ function is created), even if the context of the ~foo~ is finished.

Obviously, if we allow nested inner functions and want to have the static (lexical) scope, and at the same time ‚Äî to have all these functions as first-class, we should save all free variables used by a function at the moment of the function‚Äôs creation.

**** Funarg problems
***** Upward funarg problem
The funarg problem is divided into two sub-problems which are directly related with concepts of scope, environments and closures.

*Upward funarg problem* corresponds to the complexity of returning an inner function to the outside (upward) ‚Äî i.e. how can we implement the returning of the function if this function uses free variables of the parent environment in which it‚Äôs created?

As we already know, the lexical scope with saving enclosing frame on the heap ‚Äî is the key and the answer. And the strategy of storing bindings on the stack (used in C) does not fit anymore. Let‚Äôs repeat again, this *saved code block and the environment* ‚Äî *is a closure*.

#+begin_src javascript

  (function (x) {
      return function (y) {
          return x + y;
      };
  })(10)(20); // 30

#+end_src

***** Downward funarg problem
Downward funarg problem corresponds to the ambiguity of the variable name resolution when we pass a function which uses free variables as an argument to another function. In which scope these free variables should be resolved ‚Äî in the scope of the function definition or in the scope of the function execution?

I.e. downward funarg problem relates to the choice of the static (lexical) and dynamic scopes. As we already know and said above ‚Äî again, the lexical (static) scope ‚Äî is the answer. We should save exactly the lexical variables to avoid such ambiguities. And again ‚Äî this *saved lexical variables and the code of our function* ‚Äî is what is called a closure.

#+begin_src javascript

  var x = 10;

  (function (funArg) {

      var x = 20;
      funArg(); // 10, not 20

  })(function () { // create and pass a funarg
      console.log(x);
  });

#+end_src

So what do we have at the end? Concepts of first-class functions, closures and lexical environments are very closely related. And the lexical environments is exactly the technique which is used in implementation of closures and the static scope in general.

**** Static scope
*Static scope*: a language implements static scope, if only by looking at the source code one can determine in which environment a binding is resolved.

The static scope sometimes is also called lexical scope, hence the [[Lexical environment][lexical environments]] naming.

Technically the static scope is implemented by *capturing the environment where a function is created*.

#+begin_src javascript

  let x = 10;

  function foo() {
      console.log(x);
  }

  function bar(funArg) {
      let x = 20;
      funArg(); // 10, not 20!
  }

  // Pass `foo` as an argument to `bar`.
  bar(foo);

   +---------------+
   |  Global env   |
   +---------------+       +-------------------------+
   | Record |    --------->|      Global EnvRec      |
   |--------|------+       +-------------------------+
   | Parent | null |       |     x    |      10      |
   +---------------+       |-------------------------|
            ^              |    foo   |       |      |
            |              +----------------- | -----+
            |                                 v
            |              +-------------------------+
            |              |           foo           |
            |              +-------------------------+
            |              |  code  | console.log(x) |
            |              |-------------------------|
            |              |   env  |       |        |
            |              +--------------- | -------+
            ‚îî-------------------------------‚îò

  // We can see that an environment references a function,
  // which in turn reference the environment back.

#+end_src

**** Closure concept
A closure is a *pair consisting of the function code and the environment in which the function is created*, i.e. a function which captures the environment where it‚Äôs defined. Further this [[Lexical environment][environment]] is used for [[Identifier resolution][identifier resolution]].

*Note*: a function is called in a fresh activation environment which stores local variables, and arguments. The parent environment of the activation environment is set to the closured environment of the function, resulting to the lexical scope semantics.

Closures are invented as a solution for the [[Funarg problems][funarg problem]].

Let‚Äôs see the example (*Upwards funarg problem*): The only difference with ‚Äúfunarg problem‚Äù here is that a capturing environment outlives the context which creates it.

#+begin_src javascript

  function foo() {
      let x = 10;

      // Closure, capturing environment of `foo`.
      function bar() {
          return x;
      }

      // Upward funarg.
      return bar;
  }

  let x = 20;

  // Call to `foo` returns `bar` closure.
  let bar = foo();

  bar(); // 10, not 20!

#+end_src

Again, technically it doesn‚Äôt differ from the same exact mechanism of capturing the definition environment. Just in this case, hadn‚Äôt we have the closure, the activation environment of ~foo~ would be destroyed. But we captured it, so it cannot be deallocated, and is preserved ‚Äî to support static scope semantics.

Often there is an incomplete understanding of closures ‚Äî usually developers think about closures only in terms of the upward funarg problem (and practically it really makes more sense). However, as we can see, the technical mechanism for the downwards and upwards funarg problem is exactly the same ‚Äî and is the mechanism of the [[Static scope][static scope]].

As we mentioned above, similarly to prototypes, the same parent environment can be shared across several closures. *This allows accessing and mutating the shared data*:

#+begin_src javascript

  function createCounter() {
      let count = 0;

      return {
          increment() { count++; return count; }, // Closure
          decrement() { count--; return count; }, // Closure
      };
  }

  let counter = createCounter();

  console.log(
      counter.increment(), // 1
      counter.decrement(), // 0
      counter.increment(), // 1
  );

  +-----------------+
  |    increment    |
  +-----------------+
  | code | count++; |
  |-----------------|      +-----------------+
  |  env |      -------‚îê   |createCounter env|
  +-----------------+  ‚îî-->+-----------------+
                           | Record |     -----‚îê  +--------------------+
  +-----------------+  ‚îå-->|-----------------| ‚îî->|createCounter EnvRec|
  |    decremet     |  |   | Parent |   |    |    +--------------------+
  +-----------------+  |   +----------- | ---+    |  count   |    0    |
  | code | count--; |  |                |         +--------------------+
  |-----------------|  |                v
  |  env |      -------‚îò              global
  +-----------------+

#+end_src

Since both closures, ~increment~ and ~decrement~, are created within the scope containing the ~count~ variable, they *share this parent scope*. That is, capturing always happens ‚Äúby-reference‚Äù ‚Äî meaning *the reference to the whole parent environment is stored*.

*Note*: implementations may optimize this step, and do not capture the whole environment. Capturing only used free-variables, they though still maintain invariant of mutable data in parent scopes.

*Note*: The following code defines a function, ~wrapValue~, that creates a local binding. It then returns a function that accesses and returns this local binding.

#+begin_src javascript

  function wrapValue(n) {
      let local = n;
      return () => local;
  }

  let wrap1 = wrapValue(1);
  let wrap2 = wrapValue(2);
  console.log(wrap1());
  // ‚Üí 1
  console.log(wrap2());
  // ‚Üí 2

#+end_src

This is allowed and works as you‚Äôd hope‚Äîboth instances of the binding can still be accessed. This situation is a good demonstration of the fact that local bindings are created a new for every call, and *different calls can‚Äôt trample on one another‚Äôs local bindings*.

With a slight change, we can turn the previous example into a way to create functions that multiply by an arbitrary amount.

#+begin_src javascript

  function multiplier(factor) {
      return number => number * factor;
  }

  let twice = multiplier(2);
  console.log(twice(5));
  // ‚Üí 10

#+end_src

*The explicit local binding from the wrapValue example isn‚Äôt really needed since a parameter is itself a local binding*.

Thinking about programs like this takes some practice. A good mental model is to think of *function values as containing both the code in their body and the environment in which they are created*. When called, the function body sees the environment in which it was created, not the environment in which it is called.

In the example, multiplier is called and creates an environment in which its factor parameter is bound to 2. The function value it returns, which is stored in twice, remembers this environment. So when that is called, it multiplies its argument by 2.

*** This concept
**** Brief
*This*: an implicit *context object* accessible from a code of an execution context ‚Äî in order to apply the same code for multiple objects.

The ~this~ value is a special object which is *dynamically and implicitly* passed to the code of a context. We can consider it as an *implicit extra parameter*, which we can access, but cannot mutate.

The purpose of the ~this~ value is to *execute the same code for multiple objects*.

The major use-case is the class-based OOP. An instance method (which is defined on the prototype) exists in one exemplar, but is shared across all the instances of this class.

#+begin_src javascript

  class Point {
      constructor(x, y) {
          this._x = x;
          this._y = y;
      }

      getX() {
          return this._x;
      }

      getY() {
          return this._y;
      }
  }

  let p1 = new Point(1, 2);
  let p2 = new Point(3, 4);

  // Can access `getX`, and `getY` from
  // both instances (they are passed as `this`).

  console.log(
      p1.getX(), // 1
      p2.getX(), // 3
  );

#+end_src

When the ~getX~ method is activated, a new environment is created to store local variables and parameters. In addition, function environment record gets the ~[[ThisValue]]~ passed, which is bound dynamically depending how a function is called. When it‚Äôs called with ~p1~, the ~this~ value is exactly ~p1~, and in the second case it‚Äôs ~p2~.

**** This in arrow function
The arrow functions are special in terms of ~this~ value: their ~this~ *is lexical (static), but not dynamic*. I.e. their function environment record does not provide ~this~ value, and it‚Äôs taken from the *parent environment*.

In the global context the ~this~ value is the global object (the binding object of the global environment record). Previously there was only one global object. In current version of the spec there might be multiple global objects which are part of code [[Realm][realms]].

#+begin_src javascript

  var x = 10;

  let foo = {
      x: 20,

      // Dynamic `this`.
      bar() {
          return this.x;
      },

      // Lexical `this`.
      baz: () => this.x,

      qux() {
          // Lexical this within the invocation.
          let arrow = () => this.x;

          return arrow();
      },
  };

  console.log(
      foo.bar(), // 20, from `foo`
      foo.baz(), // 10, from global
      foo.qux(), // 20, from `foo` and arrow
  );

#+end_src

*** Realm
*Realm*: A code realm is an object which encapsulates a separate global environment.

Before it is evaluated, all ECMAScript code must be associated with a realm. Technically a realm just provides a global environment for a context.

When an execution context is created it‚Äôs associated with a particular code realm, which provides the global environment for this context. This association further stays unchanged.

*Note*: a direct realm equivalent in browser environment is the ~iframe~ element, which exactly provides a custom global environment. In Node.js it is close to the sandbox of the vm module.

Current version of the specification doesn‚Äôt provide an ability to explicitly create realms, but they can be created implicitly by the implementations. There is a proposal though to expose this API to user-code.

Logically though, each context from the stack is always associated with its realm:

#+begin_src javascript

  //Let‚Äôs see the separate realms example, using the vm module:
  const vm = require('vm');

  // First realm, and its global:
  const realm1 = vm.createContext({x: 10, console});

  // Second realm, and its global:
  const realm2 = vm.createContext({x: 20, console});

  // Code to execute:
  const code = `console.log(x);`;

  vm.runInContext(code, realm1); // 10
  vm.runInContext(code, realm2); // 20

                             +-------------------------+
   +---------------+     ‚îå-->|         Realm 1         |
   |    EC stack   |     |   +-------------------------+
   +---------------+     |   | Global object | {x: 10} |
   |      EC1      |-----‚îò   +-------------------------+
   |---------------+
   |      EC2      |-----‚îê
   +---------------+     |   +-------------------------+
                         ‚îî-->|         Realm 2         |
                             +-------------------------+
                             | Global object | {x: 20} |
                             +-------------------------+

#+end_src

Now we‚Äôre getting closer to the bigger picture of the ECMAScript runtime. Yet however we still need to see the *entry point* to the code, and the *initialization process*. This is managed by the mechanism of [[Job][jobs]] and job /queues/.

*** Job
Some operations can be postponed, and executed as soon as there is an available spot on the execution context stack.

*Job*: A job is an abstract operation that initiates an ECMAScript computation when no other ECMAScript computation is currently in progress.

Jobs are enqueued on the /job queues/, and in current spec version there are two job queues: *ScriptJobs*, and *PromiseJobs*.

And /initial job/ on the /ScriptJobs/ queue is the *main entry point* to our program ‚Äî initial script which is loaded and evaluated: a [[Realm][realm]] is created, a global context is created and is associated with this realm, it‚Äôs pushed onto the stack, and the global code is executed.

Notice, the /ScriptJobs/ queue manages both, /scripts/ and /modules/.

Further this context can execute other contexts, or enqueue other jobs. An example of a job which can be spawned and enqueued is a promise.

When there is no running execution context and the execution context stack is empty, the ECMAScript implementation removes the first pending job from a job queue, creates an execution context and starts its execution.

*Note*: the job queues are usually handled by the abstraction known as the /Event loop/.

#+begin_src javascript

  // Enqueue a new promise on the PromiseJobs queue.
  new Promise(resolve => setTimeout(() => resolve(10), 0))
      .then(value => console.log(value));

  // This log is executed earlier, since it's still a
  // running context, and job cannot start executing first
  console.log(20);

  // Output: 20, 10

#+end_src

The async functions can await for promises, so they also enqueue promise jobs:

#+begin_src javascript

  async function later() {
      return await Promise.resolve(10);
  }

  (async () => {
      let data = await later();
      console.log(data); // 10
  })();

  // Also happens earlier, since async execution
  // is queued on the PromiseJobs queue.
  console.log(20);

  // Output: 20, 10

#+end_src

Now we‚Äôre very close to the final picture of the current JS Universe. We shall see now /main owners/ of all those components we discussed, the [[Agent][Agents]].

*** Agent
The concurrency and parallelism is implemented in ECMAScript using Agent pattern.

*Agent*: An agent is an abstraction encapsulating execution context stack, set of job queues, and code realms.

Implementation dependent an agent can run on the same thread, or on a separate thread. The ~Worker~ agent in the browser environment is an example of the Agent concept.

The agents are state isolated from each other, and can communicate by sending messages. Some data can be shared though between agents, for example ~SharedArrayBuffer~ s. Agents can also combine into agent clusters.

In the example below, the ~index.html~ calls the ~agent-smith.js~ worker, passing shared chunk of memory:

#+begin_src javascript

  // In the `index.html`:

  // Shared data between this agent, and another worker.
  let sharedHeap = new SharedArrayBuffer(16);

  // Our view of the data.
  let heapArray = new Int32Array(sharedHeap);

  // Create a new agent (worker).
  let agentSmith = new Worker('agent-smith.js');

  agentSmith.onmessage = (message) => {
      // Agent sends the index of the data it modified.
      let modifiedIndex = message.data;

      // Check the data is modified:
      console.log(heapArray[modifiedIndex]); // 100
  };

  // Send the shared data to the agent.
  agentSmith.postMessage(sharedHeap);

  //And the worker code:

  // agent-smith.js

  /**
   * Receive shared array buffer in this worker.
   */
  onmessage = (message) => {
      // Worker's view of the shared data.
      let heapArray = new Int32Array(message.data);

      let indexToModify = 1;
      heapArray[indexToModify] = 100;

      // Send the index as a message back.
      postMessage(indexToModify);
  };

#+end_src

So below is the picture of the ECMAScript runtime:

#+begin_src artist

  +------------------------------------+                 +-------------+
  | Agent 1                            |                 |             |
  |                                    |        ---------|   Agent 2   |
  |  +------------+    +------------+  |        |        |             |
  |  | JobQueue 1 |    | JobQueue 2 |  |<--------        +-------------+
  |  +------------+    +------------+  |                /            |
  |                                    |               v             |
  |                       +---------+  |      +-------------------+  |
  |  +----------+     ‚îå-->| Realm 1 |  |- - ->| SharedArrayBuffer |  |
  |  | EC stack |     |   +---------+  |      +-------------------+  |
  |  +----------+     |                |               ^             |
  |  |    EC1   |-----‚îò                |                \            v
  |  |----------+                      |                 +-------------+
  |  |    EC2   |-----‚îê                |                 |             |
  |  +----------+     |   +---------+  |                 |   Agent 3   |
  |                   ‚îî-->| Realm 2 |  |                 |             |
  |                       +---------+  |                 +-------------+
  |                                    |
  +------------------------------------+

#+end_src

And that is it; that‚Äôs what happens under the hood of the ECMAScript engine!

* References
- [[https://eloquentjavascript.net/][Eloquent JavaScript]]
- [[http://dmitrysoshnikov.com/][Dmitry S√≥shnikov]]
- [[https://developer.mozilla.org/en-US/docs/Web/JavaScript][MDN Web Docs]]
- [[https://www.w3schools.com/js/default.asp][W3Schools]]
- [[https://javascript.info/][Javascript.Info]]
- [[https://lenguajejs.com/][ManzDev]]
