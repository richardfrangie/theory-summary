#+title: Emacs Lisp
#+date: 2022-05-20

* Keybindings
** Org
*** Heading

| /M-RET/          | org-meta-return (new heading)      |
| /C-RET/          | org-insert-heading-respect-content |
| /M-left/right/   | org-do-promote                     |
| /M-S-left/right/ | org-promote-subtree                |
| /M-up/down/      | org-metaup/down(bullet)            |
| /M-S-up/down/    | org-shiftmetaup/down(line)         |
| /C-c C-x b/      | org-tree-to-indirect-buffer        |
|                |                                    |
| /C-c C-n/        | org-next-visible-heading           |
| /C-c C-p/        | org-previous-visible-heading       |
| /C-c C-u/        | outline-up-heading                 |
| /C-c C-f/        | org-forward-heading-same-level     |
| /C-c C-b/        | org-backward-heading-same-level    |
| /C-c C-j/        | org-goto                           |

# meand the number of level
| /TAB/         | org-cycle (expand header)  |
| /S-TAB/       | org-shifttab(expandHeader) |
| /M-# S-TAB/   | only headlines level #     |
| /S-TAB-TAB/   | outline-show-all           |
| /C-u C-u TAB/ | org-set-startup-visibility |

*** ToDo

| /M-S-RET/      | org-insert-todo-heading                 |
| /C-S-RET/      | org-insert-todo-heading-respect-content |
| /S-right/left/ | org-shiftright (cursor)                 |
| /S-up/down/    | org-priority (cursor)                   |
|              |                                         |
| /- [ ]/        | to create checkbox                      |
| /S-M-RET/      | create another checkbox                 |
| /C-c C-c/      | org-toggle-checkbox                     |
|              |                                         |
| /C-c ./        | org-time-stamp                          |

*** Agenda

|                | org-agenda                     |
| /C-c ./          | org-time-stamp (date)          |
| /C-u C-c ./      | org-time-stamp (datetime)      |
| /S-left / right/ | change date day (cursor)       |
| /S-up / down/    | change time (cursor)           |
| /C-c C-d/        | org-deadline                   |
| /C-c C-s/        | org-scheduled                  |
| /C-c C-q/        | org-set-tags-command           |
| /C-c C-q/        | org-match-sparse-tree          |
| /C-c C-t/        | org-todo     (change state)    |
| /C-c ,/          | org-priority                   |
|                | counsel-org-tags (add/remove)  |
|                |                                |
| /C-c C-c/        | Set tag (cursor)               |
| /S-left/right/   | change state org task (cursor) |
|                |                                |
| /C-c [/          | org-agenda-file-to-front       |
| /C-c ]/          | org-remove-file                |

*** Timer

| /C-c C-x C-i/   | org-clock-in         |
| /C-c C-x C-o/   | org-clock-out        |
| /C-c C-x C-x/   | org-clock-in-last    |
| /C-c C-x C-q/   | org-clock-cancel     |
| /C-c C-x C-j/   | org-clock-jump       |
|               | org-clock-report     |
|               |                      |
| /C-c C-x C-e/   | org-clock-modify-eff |
| /C-c C-x e 3/   | org-set-effort 3     |
| /C-c C-x p/     | org-set-property     |
| /C-c C-x C-d/   | org-clock-display    |
| /C-c C-c/       | set run cancel       |
|               |                      |
| /C-c C-x 0/     | org-timer-start      |
| /C-c C-x ,/     | org pause o continue |
| /C-u C-c C-x ,/ | stop timer           |
| /C-c C-x -/     | org-timer-item       |

*** Table

| /C-c ¦/     | org-table-create-or-convert-from     |
| /S-TAB/     | org-table-previous-field             |
| /S-RET/     | org-table-copy-down                  |
| /M-left/    | org-table-move-column-left           |
| /M-S-left/  | org-table-delete-column              |
| /M-S-right/ | org-table-insert-column              |
| /M-up/      | org-table-move-row-up                |
| /M-S-up/    | org-table-kill-row                   |
| /M-a/       | org-table-beginning-of-field         |
| /M-e/       | org-table-end-of-field               |
|           |                                      |
| /C-c SPC/   | org-table-blank-field                |
|           |                                      |
| /C-c ^ n/   | org-table-sort-lines numeric         |
| /C-c ^ N/   | org-table-sort-lines numeric reverse |
| /C-c ^ a/   | org-table-sort-lines alphabetic      |
| /C-c ^ A/   | org-table-sort-lines alphabetic reve |
|           |                                      |
| /C-c ~/     | org-table-create-with-table.el       |
| /C-c '/     | org-edit-special (inside table)      |
| /C-c C-c </ | adjusts the column width             |

*** Miscellaneous

| /C-c '/       | org-edit-speci(open bufer code) |
| /C-c C-c/     | org-ctrl-c (eval code)          |
| /C-x C-s/     | org-edit-src-save               |
|             |                                 |
| /C-c C-x C-f/ | org-emphasize                   |
| /C-c C-x C-b/ | org-toggle-inline-images        |
| /C-c C-e #/   | org-export-dispatch             |
| /C-c C-o/     | org-open-at-point (go to link)  |

** Files
*** Files

| /C-x C-f/      | find-file                            |
| /C-x C-r/      | find-file-read-ONLY                  |
| /C-x C-s/      | save-buffer                          |
| /C-x C-w/      | write-file (save-as)                 |
| /C-x s/        | save-many-buffer                     |
| /C-x C-q/      | mode-edit(change-only-read or edit)  |
| /C-x i/        | insert-file-in-buffer                |
|              |                                      |
| /C-x 4 f/      | find-file-other-window               |
| /C-x 4 b/      | switch-to-buffer-other-window        |
| /C-x 4 C-o/    | display-buffer(other window)         |
| /C-x 4 r/      | find-file-read-only-other-win        |
| /C-x 4 c/      | clone-inderect-buffer-other-window   |
| /C-x 4 0/      | kill-buffer-and-window               |
| /C-x 4 d/      | dired-other-window                   |
|              |                                      |
| /C-x d/        | dired (list all files)               |
|              | find-dire (list all file and subdir) |
|              |                                      |
| //sudo::/name/ | sudo open file                       |

*** Dired
**** Files

| /o/       | dired-find-file-other-window        |
| /C-o/     | dired-display-file                  |
| /v/       | dired-view-file (only read)         |
| /r/       | dired-single-buffer                 |
| /b/       | dired-single-up-directory           |
| '/!/      | dired-do-shell-command              |
| /&/       | dired-do-async-shell-command        |
| /C-x C-q/ | d-toggle-read-only (edi dire bufer) |
|         |                                     |
| /m/       | dired-mark                          |
| /u/       | dired-unmark                        |
| /U/       | dired-unmark-all-marks              |
| /% m/     | dired-mark-files-regexp             |
| /t/       | dired-toggle-marks                  |
| /Q/       | dired-do-query-replace-regexp       |

**** Navigate

| /r/     | dired-single-buffer       |
| /b/     | dired-single-up-directory |
| /RET/   | dired-find-file           |
| /g/     | revert-buffer (refresh)   |
| '/^/    | dired-up-directory        |
| />/     | dired-next-dirline        |
| /</     | dired-prev-dirline        |
| /z/     | dired-hide-dotfiles-mode  |
| /i/     | dired-maybe-insert-subdir |
| /s/     | dired-sort-toggle-or-edit |
| /j/     | dired-goto-file           |
| /%/ / /*/ | Prefix command            |

**** Copy - Rename - Delete - Compress

| /+/ | dired-create-directory       |
| /C/ | dired-do-copy                |
| /R/ | dired-do-rename              |
| /D/ | dired-do-delete              |
| /d/ | dired-flag-file-deletion     |
| /x/ | dired-do-flagged-deletion    |
| /k/ | dired-do-kill-lines          |
| /Z/ | dired-do-compress/decompress |
| /c/ | dired-to-compress-to         |

**** Group - Symlink - Load

| /M/ | dired-do-chmod   |
| /O/ | dired-do-chown   |
| /G/ | dired-do-chgrp   |
| /T/ | dired-do-touch   |
| /S/ | dired-do-symlink |
| /L/ | dired-do-load    |

*** Bookmarks

| /C-x r m/ | bookmark-set     |
| /C-x r b/ | bookmark-jump    |
| /C-x r l/ | list-bookmark    |
|         | bookmark-save    |
|         | in list bookmark |
| /D/       | mark             |
| /d/       | delete           |
| /s/       | save             |
| /r/       | rename           |
| /x/       | execute          |

** Window - Buffer - Frame
*** Window
# meand the number of window to wich the action will be aplied
| /C-x o/         | other-window                  |
| /C-x 0/         | delete-select-window          |
| /C-x 1/         | delete-all-other-window       |
| /C-x 2/         | split-window-below            |
| /C-x 3/         | split-window-right            |
| /C-c left/      | winner-undo                   |
| /C-c right/     | winner-redo                   |
|               |                               |
| /C-c b/         | windmove-left                 |
| /C-c n/         | windmove-down                 |
| /C-c p/         | windmove-up                   |
| /C-c f/         | windmove-right                |
| /C-u ace-w/     | swap windows                  |
| /C-u C-u ace-w/ | delete windows                |
|               |                               |
| /M-o m #/       | swap windows                  |
| /M-o x #/       | delete window                 |
| /M-o z/         | new frame with current window |
| /M-o/           | other-window (works only 2)   |
| /M-o M #/       | move windows                  |
| /M-o ?/         | show command bindings         |
|               |                               |
| /C-x ^/         | enlarge-window                |
|               | shrink-window                 |
| /C-x }/         | enlarge-window-horizontally   |
| /C-x {/         | shrink-window-horizontally    |
|               |                               |
| /C-x r w/       | window to-register            |
| /C-x r j/       | jump-to-register              |

*** Buffer

| /C-x k/   | kill-buffer          |
| /C-x b/   | switch-to-buffer     |
|         |                      |
| /C-x p/   | previous-buffer      |
| /C-x c/   | next-buffer          |

*** ibuffer

| /C-x C-b/ | ibuffer                         |
| /C-x d/   | dired (list all files)          |
|         | find-dire (all file and subdir) |
|         |                                 |
| /m/       | Mark                            |
| /u/       | Unmark                          |
| /* u/     | Mark unsaved                    |
| /S/       | Save marked buffer              |
| /D/       | Close marked buffers            |
| /i/       | list subdirectories (on a dir)  |
| /% m/     | mark all files by regexp        |
| /t/       | toogel                          |

*** Frames

| /C-x 5 o/ | switch-frame             |
| /C-x 5 0/ | delete-select-frame      |
| /C-x 5 1/ | delete-all-frames        |
| /C-x 5 2/ | make-frame-same-terminal |

** Cursor - Mark - Scroll
*** Mark

| /M-h/       | mark-paragraph                |
| /C-x h/     | mark-whole-buffer             |
|           |                               |
| /C-SPC-SPC/ | set-mark                      |
| /C-u C-SPC/ | return-to-point-mark          |
| /C-x C-x/   | exchange-point-and-mark       |
| /C-x C-SPC/ | pop-global-mark(other buffer) |

*** Cursor

| /C-</         | mc/previous-next(duplicat up) |
| /C->/         | mc/mark-next(duplicate down)  |
| /C-S-c C-S-c/ | mc/edit-lines(mark to cursor) |
| /C-u C-x =/   | what-cursor-position          |

*** Move cursor

| /^/            | /^/             |
| start-buffer | previous-line |
| /M-</          | /C-p/           |
|--------------+---------------|
| /v/            | /v/             |
| end-buffer   | next-line     |
| /M->/          | /C-n/           |


| /<-----/   | /<----/     | /<---/     | /<--/      | /<-/       |
| back ele | back-sent | beg line | back-wor | back-cha |
| /M-{/      | /M-a/       | /C-a/      | /M-b/      | /C-b/      |
|----------+-----------+----------+----------+----------|
| /----->/   | /---->/     | /--->/     | /-->/      | /->/       |
| forw ele | forw-sent | end line | forw-wor | forw-cha |
| /M-}/      | /M-e/       | /C-e/      | /M-f/      | /C-f/      |

*** Kill text

| /---->/       | /--->/        | /-->/         | /->/          |
| kill-sent f | kill line f | kill-word f | del char f  |
| /M-k/         | /C-k/         | /M-d/         | /C-d/         |
|-------------+-------------+-------------+-------------|
| /<-----/      | /<---/        | /<--/         | /<-/          |
| kill-region | kill line b | b kill word | del chart b |
| /C-w/         | /C-0-k/       | /M-DEL/       | /DEL/         |

*** Scroll

| /C-l/       | center-line-screen       |
| /C-M-l/     | reposition-window        |
| /C-u 7 M-</ | 70% position buffer      |

| /^/                | /^/           |
| scroll-other-w   | scroll-up   |
| /C-M-v/            | /M-v/         |
|------------------+-------------|
| /v/                | /v/           |
| scroll-other-w d | scroll-down |
| /C-M-S-v/          | /C-v/         |

*** Region

| /C-x n n/   | narrow-to-region              |
| /C-x n w/   | remove restrictions narrowing |

** Text
*** Text

| /M-w/       | kill-ring-save(copy)                 |
| /C-w/       | kill-region(cut)                     |
| /C-y/       | reinsert-text-last(paste)            |
| /M-y/       | reinsert-text-befores (paste others) |
| /C-//       | deshacer(undo)                       |
| /C-g C-//   | rehacer(redo)                        |
| /C-x r k/   | kill-rectangle(cut first n char)     |
|           |                                      |
| /M-S-down/  | duplicate-things                     |
| /M-up/down/ | drag-stuff-up/down(move line)        |
|           |                                      |
| /M-s h p/   | highlight-phrase                     |
| /M-s h u/   | unhilight-regexp                     |
| /C-x r s/   | copy-to-register                     |
| /C-x r i/   | insert-register                      |
| /M-%/       | query-replace                        |
| /C-q TAB/   | quoted-insert                        |
|           |                                      |
| /C-x r N/   | rectangle-number-lines               |
| /M-=/       | count-words-region                   |

*** Regexp

| /C-s/     | search (swiper)                  |
| /C-M-s/   | isearch-forw -regexp             |
| /C-s C-s/ | last searched                    |
|         |                                  |
| /Q/       | dired-do-query-replace-regexp    |
| /M-c/     | case conversion on\off           |
|         | regexp-builder                   |
|         |                                  |
|         | in minibuffer during search      |
| /C-q C-j/ | enter new line (interactive cmd) |
| /C-q TAB/ | enter new TAB (interactive cmd)  |
|         | toggle-case-fold-search          |

*** Spelling

| /M-$/                    | check spelling word, offers suggestions  |
| /M-x flyspell-mode/      | enabl/disabl Flyspell mode               |
| /M-x flyspell-prog-mode/ | enabl/disabl Flyspell comments, string   |
| /M-//                    | complete partial word (cursor position)  |
| /M-/                     | corrects misspelled word under cursor    |
| /M-x ispell-ch-dic/      | ispell-change-dictionary                 |
| /M-x ispell-region/buff/ | spellcheck active region or current buff |

| /x/      | quit spellcheck (ispell) moveback cursor start position  |
| /r word/ | replaces current word while spellchecking                |
| /?/      | display other options                                    |
| /i/      | accept spelling and add to dictionary                    |
| /q/      | quit                                                     |
| /a/      | accept spelling for all buffers for this session         |
| /X/      | halt at current location (will restart from there later) |

** Code
*** Sexpresions

| /C-M-f/      | paredit-forward      |
| /C-M-b/      | paredit-backward     |
| /C-M-u/up/   | backward-up-list     |
| /C-M-d/down/ | down-list            |
|            |                      |
| /C-M-k/      | kill-sexp            |
| /C-M-t/      | transpose-sexp       |
| /C-M-SPC/    | mark-sexp            |
| /C-M-z/      | paredit-wrap-sexp    |
| /C-=/        | er/expand-region     |
|            |                      |
| /M-s/        | paredit-splice-sexp  |
| /M-J/        | paredit-join-sexp    |
| /M-;/        | paredit-comment-dwim |

*** Programming

| /C-h e/       | view-echo messages           |
|             | fill-paragraph               |
|             |                              |
| /M-//         | evilnc-comment               |
| /C-M-\/       | indent-region                |
| /C-c l/       | prefix lsp                   |
| /C-M-i/       | completion-at-point          |
| /C-c ! l/     | flycheck-list-errors         |
| /C-x ESC ESC/ | repeat-complex-command       |

*** Eval

| /C-x C-e/        | eval-last-expression         |
| /C-u C-x C-e/    | eval-print-last-sexp         |
| /C-M-x/          | eval-defun (within)          |
| /M-:/            | eval-expression (print)      |
|                | eval-buffer                  |
| /ielm/           | emacs lisp shell (REPL)      |

*** Defun

| /C-M-h/ | mark-defun             |
| /C-M-e/ | end-of-defun           |
| /C-M-a/ | beginning-of-defun     |
| /C-M-x/ | eval-defun (cursor in) |

*** Debug

| /M-x debu func/  | debug-on-entry (d)           |
|                | cancel-debug-on-entry        |
| /M-x edebu func/ | edebug-defun(within/next to) |
| /C-x C-e/        | to revaluate & cancel edebug |

** Help - Terminal
*** Help

| /C-h f/   | describe-function            |
| /C-h v/   | describe-variable            |
| /C-h k/   | more-info-comand             |
| /C-h m/   | describe-mode                |
| /C-h b/   | describe-bindings            |
|         |                              |
| /C-h a/   | counsel-apropos(pattern)     |
| /C-h c/   | describe-key-briefly         |
| /C-h s/   | describe-syntax              |
| /C-h P/   | describe-package             |
| /C-h o/   | describe-symbol              |
|         |                              |
| /C-h C-h/ | help-for-help                |
| /cmd C-h/ | what valid keys follow cmd   |
| /M-./     | xref-find-definition(cursor) |

*** Minibuffer

| /C-M-m/   | ivy-call              | Run command, keep minibuffer |
| /M-o/     | ivy-dispatching-done  | Show actions current match   |
| /M-i/     | ivy-insert-current    | Insert match in the prompt   |
| /C-c C-o/ | ivy-occur             | List match in new buffer     |
| /C-p/     |                       | Focus in prompt              |
| /M-j/     | ivy-yank-word         | Put Word at point in minibu  |
| /S-SPC/   | ivy-restrict-to-match | Restrict list to prompt      |
| /C-SPC/   | ivy-restrict-to-match | My alias for the above       |

| /C-M-j/      | type RET in minibuffer            |
| /C-j/ / /RET/  | exit-minibuffer                   |
| /C-g/        | abort-recursive-edit              |
| /M-n/ / /down/ | next-history-element              |
| /M-p/ / /up/   | previous-history-element          |
| /M-s/        | next-matching-history-element     |
| /M-r/        | previous-matching-history-element |

*** shells

| eshell         |                      |
| /C-c C-n/        | go forward           |
| /C-c C-p/        | back forward         |
|                | counsel-esh-history  |
| /clear 1/        | command clean eshell |
| /C-2 M-x eshell/ | open second eshell   |
|                |                      |
| vterm          |                      |
| /C-n/            | next command         |
| /C-p/            | previous command     |
| /C-2 M-x vterm/  | open different vterm |
|                |                      |
| term           |                      |
| /C-c C-k/        | char-mode            |
| /C-c C-j/        | line-mode            |
| /C-2 M-x term/   | open different term  |

*** Terminal

| /emacs -q/              | open without load init file       |
| /emacs -q -l path/      | open with differen init file      |
| /emacs -nw/             | open in terminal                  |
| /emacs -Q -nw/          | open in terminal vanilla          |
| /emacs --user/          | open user diferent file           |
| /emacs --no-desktop/    | open without last session file    |
|                       |                                   |
| /emacs --no-site-file/  | dont load site-wide site-start.el |
| /emacs --load="path"/   | execute the elisp file at path    |
| /emacs --batch --load/  | dont launch emacs as a editor     |
| /emacs --script path/   | run like --batch with --load=path |
| /emacs --script nam.el/ | run emacs lisp script in shell    |
|                       |                                   |
| /M-!/                   | shell-command                     |
| /C-u M-!/               | shell cmd(sameBuffer)             |

** Miscellaneous
*** Mix

| /C-x C-c/   | finish-sesion           |
| /C-x -/ / /+/ | zoom-in / out           |
| /M-x/       | execute- extend-command |
|           |                         |
| /F10/       | menu-bar-open           |
| /ESC x/     | same /M-x/ in no GUI term |
|           |                         |
| /C-h e/     | view-echo-area-messages |
|           | auto-package-update-now |

*** Calc

| /E/   | exp(x)    |
| /Q/   | sqrt(x)   |
| /L/   | ln(x)     |
| /I C/ | arccos(x) |
| /S/   | sin(x)    |
| /B/   | log_b(x)  |

| /m d/     | degree mode    |
| /m r/     | radian mode    |
| /m a/     | numerical mode |
| /m s/     | symbolic mode  |
| /m f/     | fraction mode  |
| /m a/ / /'/ | algebraic mode |

| /P/   | pi number                 |
| /N/   | eval numerical aprox      |
| /$/   | reference index of stack  |
|     | 1: pi/6 -> sin($1) => 1/2 |
| /c r/ | convert degrees radians   |
| /c d/ | convert radians degrees   |

| /TAB/   | exchange order results |
| /=/     | eval expressions       |
| /M-RET/ | calc-last-args         |
| /t d/   | calc-trail-display     |
| /t y/   | calc-trail-yank        |
| /t p/   | calc-trail-previous    |
| /t n/   | calc-trail-next        |
| /t b/   | calc-trail-backwards   |
| /t f/   | calc-trail-forwards    |

*** Kmacro

| /F3/ \ /C-x(/   | kmacro-start-macro(sequence) |
| /F4/ \ /C-x)/   | kmacro-end-or-call-macro     |
| /C-x e/       | kmacro-end-and-call-macro    |
| /C-u 5 C-x e/ | repeat 5 times kmacro        |
|             | call-last-kbd-macro          |
|             | name-last-kbd-macro(save)    |
|             | insert-kbd-macro(call saved) |
|             |                              |
|             | Steps kmacro function cmmd   |
| /F3/          | start kmacro                 |
| /C-4 M-x/     | call eval-expresion          |
| /F4/          | end kmacro                   |

*** Register

| /C-x r SPC r/     | Position              |
| /C-x r s r/       | Text                  |
| /C-x r r r/       | Rectangle             |
| /C-x r w r/       | Window Config         |
| /C-u 7 C-x r n r/ | Number                |
| /C-x r i r/       | insert                |
| /C-x r + x/       | Increment number by 1 |

*** Characters

| /C-S-e <SPC>/ | emoticons                |
| /C-x 8 RET/   | insert-char              |
|             | describe-char (cursor)   |
|             |                          |
| /C-q/         | quoted-insert (literaly) |
| /C-q TAB/     | insert tab char          |
| /C-q C-i/     | insert tab char          |
| /C-q C-[/     | insert escape char       |
| /C-q C-m/     | insert carriage char     |
| /C-q C-j/     | insert Line Feed char    |


| /\n/          | newline                  |
| /\t/          | tab                      |
| /\r/          | carriage return          |
| /\b/          | backspace                |
| /\e/          | escape                   |
|             |                          |
| /\u3501/      | unicode 3501             |
| /\C-/         | control                  |
| /\M-/         | meta                     |
| /\M-\C-a/     | Control-Meta-A           |
|             |                          |
| /?x/          |                          |
| /?\n/         |                          |
| /?\"/         |                          |

*** Keys
**** Key overview

| /M-x/      | command by name     |
| /C-letter/ | frequently command  |
| /M-letter/ | less frequently cmd |
| /C-x .../  | globally command    |
| /C-c .../  | major-mode command  |
| /C-h .../  | help or info        |
| /C-M .../  | lisp coding command |

**** Avoid keybinding
Emacs has its quirks. It's best not to define the following keys.

| /C-?/        | due technical implementation         |
| /F1/ / /C-h/   | special status emacs help system     |
| /ESC/ / /C-[/  | ESC is tied C-[ complicated meanings |
| /C-S-letter/ | in text terminal cannot distinguish  |
| /C-m/ / /RET/  | these are tied together              |
| /C-j/ / /TAB/  | these are tied together              |

By official emacs documentation, the key space for users are the function keys ~F5~ to ~F9~, and ~C-c letter~. This is very restrictive.

*** Artist

|             | artist-mode                     |
| /C-c C-c/     | exits artis mode                |
| /C-c C-a p/   | art poly-line                   |
| /RET/         | artist-key-set-point            |
| /C-u RET/     | for final segment               |
|             |                                 |
| /C-c C-a C-o/ | artist-select-operation         |
| /C-c C-a C-f/ | artist-select-fill-char         |
| /C-c C-a C-l/ | artist-select-line-char         |
|             |                                 |
| /C-c C-a C-r/ | artist-toggle-rubber-banding    |
| /C-c C-a C-t/ | artist-toggle-trim-line-endings |
| /C-c C-a C-s/ | artist-toggle-borderless-shapes |
|             |                                 |
| />/           | set unset arrow begin           |
| /</           | set unset arrow end             |


| /C-c </ | move left  |
| /C-c >/ | move right |
| /C-c ^/ | move up    |
| /C-c ./ | move down  |

* Elisp
** Elisp
*** Proccesing
**** Summary
Whenever you give an editing command to Emacs Lisp, such as the command to move the cursor or to scroll the screen, you are evaluating an expression, the first element of which is a function. *This is how Emacs works*.

- Lisp programs are made up of expressions, which are lists or single atoms.
- Lists are made up of zero or more atoms or inner lists, separated by whitespace and surrounded by parentheses. A list can be empty.
- Atoms are multi-character symbols, like ~forward-paragraph~, single character symbols like ~+~, strings of characters between double quotation marks like ~"string"~ , or numbers ~4~.
- A number evaluates to itself.
- A string between double quotes also evaluates to itself.
- When you evaluate a symbol by itself, its value is returned.
- When you evaluate a list, the Lisp interpreter looks at the first symbol in the list and then at the function definition bound to that symbol. Then the instructions in the function definition are carried out.
- A single-quote ‘'’ tells the Lisp interpreter that it should return the following expression as written, and not evaluate it as it would if the quote were not there.
- Arguments are the information passed to a function. The arguments to a function are computed by evaluating the rest of the elements of the list of which the function is the first element.
- A function always returns a value when it is evaluated (unless it gets an error); in addition, it may also carry out some action that is a side effect. In many cases, a function’s primary purpose is to create a side effect.

**** Run a Program
A list in Lisp—any list—is a program ready to run. If you run it, the computer will do one of three things: do nothing except return to you the list itself; send you an error message; or, treat the first symbol in the list as a command to do something.

The single [[quote]], when it precedes a list, it tells Lisp to do nothing with the list, other than take it as it is written. But if there is no quote preceding a list, the first item of the list is special: it is a command for the computer to obey. (In Lisp, these commands are called functions.)

The list ~(+ 2 2)~ did not have a quote in front of it, so Lisp understands that the ~+~ is an instruction to do something with the rest of the list: add the numbers that follow.

**** The Lisp Interpreter
What the Lisp interpreter does when we command it to evaluate a list is, first it looks to see whether there is a [[quote]] before the list; if there is, the interpreter just gives us the list. On the other hand, if there is no quote, the interpreter looks at the first element in the list and sees whether it has a function definition. If it does, the interpreter carries out the instructions in the function definition. Otherwise, the interpreter prints an error message.

In addition to lists, the Lisp interpreter can evaluate a symbol that is not quoted and does not have parentheses around it. The Lisp interpreter will attempt to determine the symbol’s value as a [[Variable]].

If the function that the Lisp interpreter is looking at is not a special form, and if it is part of a list, the Lisp interpreter looks to see whether the list has a list inside of it. If there is an inner list, the Lisp interpreter first figures out what it should do with the inside list, and then it works on the outside list. If there is yet another list embedded inside the inner list, it works on that one first, and so on. It always works on the innermost list first. The *interpreter works on the innermost list first*, to evaluate the result of that list.

Otherwise, the *interpreter works left to right*, from one expression to the next.

*** Definitions
**** atoms
Es el objeto más simple de Emacs, se evalúan a sí mismos, por lo que evaluar estos objetos simplemente se devolverá a sí mismos.

Este término proviene del significado histórico de la palabra átomo, que significa *indivisible*. Es cualquier cosa  que no sea una [[cons cell]], por ejemplo, ~forward-paragraph~,  ~+~,  ~string~, ~1234~, entre otros.

#+begin_src artist

         cons
   atoms ---> cons cell ---> list

  "atoms" con la función "cons" crea "cons cell" y estos pueden crear "list"

 "a" "b" -> (cons "a" "b") = ("a" . "b") -> '("a" . ("b" . nil)) = ("a" "b")

#+end_src

**** Symbol
***** Definition
A symbol, like ~+~, is not itself the set of instructions for the computer to carry out. Instead, the symbol is used, perhaps temporarily, *as a way of locating the definition* or set of instructions. A symbol can have only one function definition attached to it at a time.

A symbol that has a function definition is called, simply, a function (although, properly speaking, the definition is the function and the symbol refers to it.)

You might imagine a symbol as being a chest of drawers. The function definition is put in one drawer,  the value in another, and so on (what is put in each drawer is the address). What is put in the drawer holding the value can be changed without affecting the contents of the drawer holding the function definition, and vice versa.

In addition to its name, symbol definition, and variable value, a symbol has a drawer for a property list which can be used to record other information.

#+begin_src artist

(setq bouquet '(rose violet buttercup))

Symbol bouquet

           Chest of Drawers            Contents of Drawers

            __   o0O0o   __
          /                 \
         ---------------------
        |    directions to    |            [map to]
        |     symbol name     |             bouquet
        |                     |
        +---------------------+
        |    directions to    |
        |  symbol definition  |             [none]
        |                     |
        +---------------------+
        |    directions to    |            [map to]
        |    variable value   |             (rose violet buttercup)
        |                     |
        +---------------------+
        |    directions to    |
        |    property list    |
        |                     |
        +---------------------+
        |/                   \|

#+end_src

***** The Concept of Symbols in Lisp (from ∑XAH)
LISP differs from most programing languages such as C, Java, Perl, Python, in that it deals with symbols, as opposed to just variables and values.

In practice, this means that in lisp, variables can be manipulated in its un-evaluated state. The situation is like the need for the “evaluate” command in many languages, where the programer can built code as strings and do ~evaluate(string)~ to achieve meta-programing. In lisp, variable's unevaluated form are always available. You just put a apostrophe in front of it. This is why lisp refers to variable or function names as “symbols”. This makes meta-programing more powerful.

For example, in most languages, once you defined ~x=3~, you cannot manipulate the variable “ ~x~ ” because it gets evaluated to 3 right away. If you want, you have to build a string "~x~" and manipulate this string, then finally use something like ~evaluate(string)~ to achieve the effect. In most languages, the use of ~evaluate()~ breaks down quickly because the language is not designed for doing it. It's slow, difficult to debug, and there lacks many facilities for such meta programing.

The ability to meta-program has many applications. For example, when you need to take user input as code (such as math formulas), or need to manipulate math expressions, or writing programs that modify itself at run-time. Lisp macros is a direct result of the ability to manipulate symbols.


Each lisp symbol has the following “cells” to store things:

  - “ *name* ” cell → a string, typically the same as the symbol.
  - “ *value* ” cell → stores the symbol's value, typically when the symbol is used as variable.
  - “ *function* ” cell → stores function definition object or lisp macros.
  - “ *property list* ” cell → typically hold a list of name/value pairs. It is used for syntax coloring strings, for function's state, etc.

A symbol's {value, function} cell may be empty, it's said to be “void”. When you try to get a cell's value that's void, it's a lisp error. (a empty cell is not the same as having value of nil.)

In normal coding, you don't need to worry about any of these. The only thing that's useful for most elisp code is property list, but many other higher-level functions do it for you. (i.e. add, remove, properties.)

Understanding Lisp Symbol cells is important when you do advanced lisp programing. ➢ for example: macros, create and calling functions at run-time, function inside functions, manipulate evaluation, implementing a language, or any sort of meta-programing. If you don't have a need, you should not exploit these facilities in your program. keep your program normal and simple.

**** cons cell
A cons cell is a data object that represents an ordered pair. That is, it has two slots, and each slot holds, or refers to, some Lisp object. One slot is known as the CAR "Contents of the Address part of Register number", and the other is known as the CDR "Contents of the Decrement part of Register number".

We say that “the CAR of this cons cell is” whatever object its CAR slot currently holds, and likewise for the CDR.

Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell. These objects are called [[atoms]].

The names CAR and CDR derive from the history of Lisp. The original Lisp implementation ran on an IBM 704 computer which divided words into two parts, the address and the decrement; CAR was an instruction to extract the contents of the address part of a register, and CDR an instruction to extract the contents of the decrement. By contrast, *cons cells are named for the function cons that creates them*, which in turn was named for its purpose, the construction of cells.

Aunque cons cell se puede usar para contener pares de datos ordenados, se usan más comúnmente para construir estructuras de datos compuestas más complejas, en particular listas y árboles binarios.

#+begin_src artist

 cons cell = (cons "abc" "def") = ("abc" . "def")

      car     cdr
   +-------+-------+
   | "abc" | "def" |
   +-------+-------+

      car     cdr           car     cdr
   +-------+-------+     +-------+-------+
   | "abc" |    -------> | "def" |  nil  |
   +-------+-------+     +-------+-------+

#+end_src

**** Dotted Pair Notation
Is a general syntax for cons cells that represents the CAR and CDR explicitly. In this syntax, ~(a . b)~ stands for a cons cell whose CAR is the object ~a~ and whose CDR is the object ~b~. Dotted pair notation is more general than list syntax because the CDR does not have to be a list. However, it is more cumbersome in cases where list syntax would work.

In dotted pair notation, the list ~(1 2 3)~ is written as ~(1 . (2 . (3 . nil)))~. For /nil/ *-terminated lists, you can use either notation*, but list notation is usually clearer and more convenient. When printing a list, the *dotted pair* notation *is only used if the CDR of a cons cell is not a* /list/.

Nota: al trabajar con dotted notation evaluando resultados se debe colocar [[quote]] antes ~'(rose . violet)~.

#+begin_src artist

 (rose . violet)

    --- ---
   |   |   |--> violet
    --- ---
     |
     |
      --> rose

#+end_src

You can *combine* dotted pair notation with list notation to represent conveniently a chain of cons cells with a *non-nil final CDR*. You write a dot after the last element of the list, followed by the CDR of the final cons cell.

#+begin_src artist

 (rose violet . buttercup) = (rose . (violet . buttercup))

    --- ---      --- ---
   |   |   |--> |   |   |--> buttercup
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet

 The syntax (rose . violet . buttercup) is invalid

#+end_src

The list ~(rose violet)~ is equivalent to ~(rose . (violet))~

#+begin_src artist

    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet

#+end_src

The three-element list ~(rose violet buttercup)~ = ~(rose . (violet . (buttercup)))~

#+begin_src artist

    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup

#+end_src

As a somewhat peculiar side effect of ~(a b . c)~ and ~(a . (b . c))~ being equivalent, for consistency this means that if you replace ~b~ here with the empty sequence, then it follows that ~(a . c)~ and ~(a . ( . c))~ are equivalent, too. This also means that ~( . c)~ is equivalent to ~c~, but this is seldom used.

**** S-expression
Is an expression, in a like-named notation, for nested list (tree-structured) data.

In the usual parenthesized syntax of Lisp, an S-expression is classically defined as

- an atom of the form ~x~, or
- an expression of the form ~(x . y)~ where ~x~ and ~y~ are S-expressions.

This definition reflects LISP's representation of a list as a series of "cells", each one an ordered pair. In plain lists, y points to the next cell (if any), thus forming a list. The recursive clause of the definition means that both this representation and the S-expression notation can represent any binary tree.

#+begin_src artist

Tree data structure representing the S-expression (* 2 (+ 3 4)).

     o
    / \
   *   o
      / \
     2   o
        / \
       o  nil
      / \
     +   o
        / \
       3   o
          / \
         4  nil

#+end_src

**** list
Lists in Lisp are not a primitive data type, they are built up from cons cells. A list is a series of [[cons cell]], linked together so that the CDR slot of each cons cell holds either the next cons cell or the empty list. The empty list is actually the symbol ~nil~.

Hence, the CDR of a proper list is always a proper list. The CDR of a nonempty proper list is a proper list containing all the elements except the first.

Upon reading, each object inside the parentheses becomes an element of the list. That is, a cons cell is made for each element. The CAR slot of the cons cell holds the element, and its CDR slot refers to the next cons cell of the list, which holds the next element in the list. The CDR slot of the last cons cell is set to hold ~nil~.

Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a list structure.

This forms the basis of a simple, singly linked list structure whose contents can be manipulated with ~cons~, ~car~, and ~cdr~. Note that ~nil~ is the only list that is not also a cons pair.

 A list is kept using a series of pairs of pointers. A pointer itself is quite simply the electronic address of what is pointed to. Hence, a list is kept as a series of electronic addresses.

#+begin_src artist

 (cons 1 (cons 2 (cons 3 nil))) = (list 1 2 3) = (1 2 3) = '(1 2 3)

 (1 . (2 . (3 . nil))) ---> Dotted Pair Notation

   +------+------+   +------+------+   +------+------+
   |  *   |   *----->|  *   |   *----->|  *   |   *-----> nil
   +--|---+------+   +--|---+------+   +--|---+------+
      |		     |		       |
      v		     v		       v
      1                 2                 3


In the computer, the electronic address of ‘1’ is recorded in a
segment of computer memory along with the address that gives the
electronic address of where the atom ‘2’ is located; and that address
(the one that tells where ‘2’ is located) is kept along with an
address that tells where the address for the atom ‘3’ is located.

              sketched in a different manner
    --------------       --------------       --------------
   | car  | cdr   |     | car  | cdr   |     | car  | cdr   |
   |  1   |   o-------->|  2   |   o-------->|  3   |  nil  |
   |      |       |     |      |       |     |      |       |
    --------------       --------------       --------------
  add of 1 add to 2     add of 2 add to 3    add of 3   nil
Each arrow points to what the address is the address of, either an
atom or another pair of addresses.

   *--*--*--nil
   |  |  |
   1  2  3

Binary tree
     *
    / \
   1   *
      / \
     2   *
        / \
       3  nil

#+end_src

A list with no elements in it is the empty list. Here is the list ~(A ())~, or equivalently ~(A nil)~

#+begin_src artist

    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> A        --> nil

#+end_src

Here is a more complex, the three-element list, ~((pine needles) oak maple)~, the first element of which is a two-element list:

#+begin_src artist

    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
     |             --> oak      --> maple
     |
     |     --- ---      --- ---
      --> |   |   |--> |   |   |--> nil
           --- ---      --- ---
            |            |
            |            |
             --> pine     --> needles


  sketched in a different manner
 --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   o   |   o------->| oak   |   o------->| maple |  nil |
|   |   |      |     |       |      |     |       |      |
 -- | ---------       --------------       --------------
    |
    |
    |        --------------       ----------------
    |       | car   | cdr  |     | car     | cdr  |
     ------>| pine  |   o------->| needles |  nil |
            |       |      |     |         |      |
             --------------       ----------------

#+end_src

#+begin_src emacs-lisp

(list
  (re-search-forward "The \\(cat \\)")
  (match-beginning 0)
  (match-beginning 1))
;;     => (t 9 13)
;;
;; ---------- Buffer: foo ----------
;; I read "The cat -!-in the hat comes back" twice.
;;         ^   ^
;;         9  13
;; ---------- Buffer: foo ----------

#+end_src

**** Association List Type
An association list or alist is a specially-constructed list whose elements are cons cells. In each element, the CAR is considered a key, and the CDR is considered an associated value. (In some cases, the associated value is stored in the CAR of the CDR.)

#+begin_src emacs-lisp

;; sets the variable alist-of-colors to an alist of three elements.
;; In the first element, rose is the key and red is the value.
(setq alist-of-colors
      '((rose . red) (lily . white) (buttercup . yellow)))

#+end_src

*Association Lists by Xah*

An association list, or alist for short, records a mapping from keys to values. It is a list of cons cells called associations: the CAR of each cons cell is the key, and the CDR is the associated value.

Here is an example of an alist. The key ~pine~ is associated with the value ~cones~; the key ~oak~ is associated with ~acorns~; and the key ~maple~ is associated with ~seeds~.

#+begin_src emacs-lisp

((pine . cones)
 (oak . acorns)
 (maple . seeds))

#+end_src

Both the values and the keys in an alist may be any Lisp objects. For example, in the following alist, the symbol ~a~ is associated with the number ~1~, and the string ~"b"~ is associated with the list ~(2 3)~, which is the CDR of the alist element:

#+begin_src emacs-lisp

((a . 1) ("b" 2 3))

#+end_src

Sometimes it is better to design an alist to store the associated value in the CAR of the CDR of the element. Here is an example of such an alist:

#+begin_src emacs-lisp

((rose red) (lily white) (buttercup yellow))

#+end_src

Here we regard ~red~ as the value associated with ~rose~. One advantage of this kind of alist is that you can store other related information—even a list of other items—in the CDR of the CDR. One disadvantage is that you cannot use ~rassq~ to find the element containing a given value. When neither of these considerations is important, the choice is a matter of taste, as long as you are consistent about it for any given alist.

The same alist shown above could be regarded as having the associated value in the CDR of the element; the value associated with ~rose~ would be the list ~(red)~.

Association lists are often used to record information that you might otherwise keep on a stack, since new associations may be added easily to the front of the list. When searching an association list for an association with a given key, the first one found is returned, if there is more than one.

In Emacs Lisp, it is not an error if an element of an association list is not a cons cell. The alist search functions simply ignore such elements. Many other versions of Lisp signal errors in such cases.

Note that property lists are similar to association lists in several respects. A property list behaves like an association list in which each key can occur only once.

**** Variable
A symbol can have a value attached to it just as it can have a function definition attached to it. The value of a symbol can be any expression in Lisp, such as a symbol, number, list, or string. A symbol that has a value is often called a variable.

The variable ~fill-column~ illustrates a symbol with a value attached to it, this symbol is set to some value, usually ~70~.

A symbol can have any value attached to it or, to use the jargon, we can *bind* the variable to a value: to a number, such as ~72~; to a string, ~"such as this"~ ; to a list, such as ~(spruce pine oak)~ ; we can even bind a variable to a function definition.

**** Macro
A macro is a construct defined in Lisp, which differs from a function in that it translates a Lisp expression into another expression that is to be evaluated in place of the original expression. For example, [[if]], [[when]], and so on.

Macros enable you to define new *control constructs* and other language features. A macro is defined much like a function, but instead of telling how to compute a value, it tells *how to compute another Lisp expression* which will in turn compute the value. We call this expression the expansion of the macro.

Macros can do this because they operate on the unevaluated expressions for the arguments, not on the argument values as functions do. They can therefore construct an expansion containing these argument expressions or parts of them.

Suppose we would like to define a Lisp construct to increment a variable value, much like the ~++~ operator in C. We would like to write ~(inc x)~ and have the effect of ~(setq x (1+ x))~. Here’s a macro definition that does the job:

#+begin_src emacs-lisp

(defmacro inc (var)
   (list 'setq var (list '1+ var)))

#+end_src

When this is called with ~(inc x)~, the argument var is the symbol ~x~ — *not the value of* ~x~, as it would be in a function. The body of the macro uses this to construct the expansion, which is ~(setq x (1+ x))~. Once the macro definition returns this expansion, Lisp proceeds to evaluate it, thus incrementing x.

**** Classification of Emacs Lisp Function
On a separate subject, Emacs Lisp functions are classified into several types.

  - *Function* = Most common. Written in elisp. Usually ~(defun …)~
  - *Primitive* = elisp function written in C. ➢ for example: {~list~, ~car~, ~append~, ~point~, ~defun~, …}. Typically the most fundamental ones.
  - *lambda expression* = ➢ for example: ~(lambda …)~. Usually temp functions.
  - *special for* m = a function that doesn't eval in the normal way. ➢ for example: {~if~, ~cond~, ~and~, ~or~, ~while~, ~progn~}. (normally, arguments to a function are all evaluated first.)
  - *macro* = Similar to “special form”, but user-defined. i.e. the arguments are not eval'd, and you can manipulate them and eval them.
  - *command* = functions that can be called by ~command-execute~. Typically, ~(defun …)~ with ~(interactive …)~ clause. All functions you can call by ~M-x~ are commands.

**** Vector
***** Introduction
Emacs lisp has a ~vector~ datatype.

  - Vector has constant random access time.
  - Elements cannot be added or removed.
  - Element's value can be changed.
  - Vector elements can be any other lisp object.

***** List vs Vector
Lisp's ~list~ and ~vector~ both are subtypes of the “sequences” datatype. Many functions, such as {~elt~, ~mapcar~}, work on any sequence type. Here's their primary differences:

  - *Vector*: Access time to any element is constant.
  - Vector's length cannot change. (if you create a new copy of a vector, the time required is proportional to the vector's length)

  - *List*: Access time to a element is proportional to the distance of the element's position in the list.
  - List's length can grow by prepending with ~cons~, and can have the first element dropped by ~cdr~. These operations have constant time.

Lisp culture is to almost always use list. I recommend using vector as much as possible. Use list ONLY IF you need to constantly grow the lis.

#+begin_src artist
     _____________________________________________
    |                                             |
    |          Sequence                           |
    |  ______   ________________________________  |
    | |      | |                                | |
    | | List | |             Array              | |
    | |      | |    ________       ________     | |
    | |______| |   |        |     |        |    | |
    |          |   | Vector |     | String |    | |
    |          |   |________|     |________|    | |
    |          |  ____________   _____________  | |
    |          | |            | |             | | |
    |          | | Char-table | | Bool-vector | | |
    |          | |____________| |_____________| | |
    |          |________________________________| |
    |_____________________________________________|

#+end_src

**** Dynamic vs lexical binding
***** Dynamic binding
By default, the local variable bindings made by Emacs are dynamic bindings. When a variable is *dynamically bound,* its current binding at any point in the execution of the Lisp program is simply *the most recently-created dynamic local binding* for that symbol, or the global binding if there is no such local binding.

#+begin_src emacs-lisp

(defvar x -99)  ; x receives an initial value of -99.

(defun getx ()
  x)            ; x is used free in this function.

(let ((x 1))    ; x is dynamically bound.
  (getx))       ; => 1

;; After the let form finishes, x reverts to its
;; previous value, which is -99.

(getx)          ; =>  -99

#+end_src

Note: Converting to Lexical Binding
Converting an Emacs Lisp program to lexical binding is easy. First, add a file-local variable setting of lexical-binding to t in the header line of the Emacs Lisp source file. Second, check that every variable in the program which needs to be dynamically bound has a variable definition, so that it is not inadvertently bound lexically.

***** Lexical binding
A *lexically-bound* variable has lexical scope, meaning that any reference to the variable must be located textually *within the binding construct*.

#+begin_src emacs-lisp

(let ((x 1))    ; x is lexically bound.
  (+ x 3))      ; => 4

(defun getx ()
  x)            ; x is used free in this function.

(let ((x 1))    ; x is lexically bound.
  (getx))       ; => error→ Symbol's value as variable is void: x

#+end_src

Here, the variable ~x~ has no global value. When it is lexically bound within a ~let~ form, it can be used in the textual confines of that ~let~ form. But it can not be used from within a ~getx~ function called from the ~let~ form, since the function definition of ~getx~ occurs outside the ~let~ form itself.

Each binding construct defines a lexical environment, specifying the variables that are bound within the construct and their local values. When the Lisp evaluator wants the current value of a variable, it looks first in the lexical environment; if the variable is not specified in there, it looks in the symbol’s value cell, where the dynamic value is stored.

(Internally, the lexical environment is an alist of symbol-value pairs, with the final element in the alist being the symbol t rather than a cons cell. Such an alist can be passed as the second argument to the eval function, in order to specify a lexical environment in which to evaluate a form. Most Emacs Lisp programs, however, should not interact directly with lexical environments in this way; only specialized programs like debuggers.)

Lexical bindings have indefinite extent. Even after a binding construct has finished executing, its lexical environment can be “kept around” in Lisp objects called closures. A [[closure]] is created when you define a named or anonymous function with lexical binding enabled.

When a closure is called as a function, any lexical variable references within its definition use the retained lexical environment. Here is an example:

#+begin_src emacs-lisp

(defvar my-ticker nil)   ; We will use this dynamically bound
                         ; variable to store a closure.

(let ((x 0))             ; x is lexically bound.
  (setq my-ticker (lambda ()
                    (setq x (1+ x)))))
   ;; (closure ((x . 0) t) ()
     ;;   (setq x (1+ x)))

(funcall my-ticker) ;; => 1

(funcall my-ticker) ;; => 2

(funcall my-ticker) ;; => 3

x                        ; Note that x has no global value.
;; => error→ Symbol's value as variable is void: x

#+end_src

The ~let~ binding defines a lexical environment in which the variable ~x~ is locally bound to ~0~. Within this binding construct, we define a lambda expression which increments ~x~ by one and returns the incremented value. This lambda expression is automatically turned into a closure, in which the lexical environment lives on even after the ~let~ binding construct has exited. Each time we evaluate the closure, it increments ~x~, using the binding of ~x~ in that lexical environment.

Note that unlike dynamic variables which are tied to the symbol object itself, the relationship between lexical variables and symbols is only present in the interpreter (or compiler). Therefore, functions which take a symbol argument (like symbol-value, boundp, and set) can only retrieve or modify a variable’s dynamic binding (i.e., the contents of its symbol’s value cell).

***** Using Lexical Binding
When loading an Emacs Lisp file or evaluating a Lisp buffer, lexical binding is enabled if the buffer-local variable lexical-binding is non-nil:

Variable: lexical-binding
    If this buffer-local variable is non-nil, Emacs Lisp files and buffers are evaluated using lexical binding instead of dynamic binding. (However, special variables are still dynamically bound.) If nil, dynamic binding is used for all local variables. This variable is typically set for a whole Emacs Lisp file, as a file local variable. Note that unlike other such variables, this one must be set in the first line of a file.

When evaluating Emacs Lisp code directly using an eval call, lexical binding is enabled if the lexical argument to eval is non-nil.

Even when lexical binding is enabled, certain variables will continue to be dynamically bound. These are called special variables. Every variable that has been defined with ~defvar~, ~defcustom~ or ~defconst~ is a special variable. All other variables are subject to lexical binding.

Using ~defvar~ without a value, it is possible to bind a variable dynamically just in one file, or in just one part of a file while still binding it lexically elsewhere. For example:

#+begin_src emacs-lisp

(let (_)
  (defvar x)      ; Let-bindings of x will be dynamic within this let.
  (let ((x -99))  ; This is a dynamic binding of x.
    (defun get-dynamic-x ()
      x)))

(let ((x 'lexical)) ; This is a lexical binding of x.
  (defun get-lexical-x ()
    x))

(let (_)
  (defvar x)
  (let ((x 'dynamic))
    (list (get-lexical-x)
          (get-dynamic-x))))
    ;; =>  (lexical dynamic)

#+end_src

Note that since this is a function, it can only return non-nil for variables which are permanently special, but not for those that are only special in the current lexical scope.

*** Variables
**** setq-default
You can set any Lisp variable with ~setq~, but with certain variables ~setq~ won’t do what you probably want in the init file. Some variables automatically become buffer-local when set with ~setq~; what you want in the init file is to set the default value, using ~setq-default~.

#+begin_src emacs-lisp

;; Hace que el modo texto sea el predeterminado para los nuevos buffers
(setq-default major-mode 'text-mode)

#+end_src

**** set-variable
You could use the ~set-variable~ command to change the value of ~shell-command-default-error-buffer~ temporarily. However, options set using ~set-variable~ are set only for the duration of your editing session. The new values are not saved between sessions.

For me, the major use of the ~set-variable~ command is to suggest variables that I might want to set in my ~.emacs~ file. You can press ~TAB~ after calling the ~M-x set-variable~ command to see the list of variables.

**** defcustom
Is designed for variables that people customize.

You can specify variables using ~defcustom~ so that you and others can then use Emacs’s ~customize~ feature to set their values.

The ~customize~ feature depends on the ~defcustom~ macro. Although you can use ~defvar~ or ~setq~ for variables that users set, the ~defcustom~ macro is designed for the job.

- The first argument to ~defcustom~ is the name of the variable.
- The second argument is the variable’s initial value, if any; and this value is set only if the value has not already been set.
- The third argument is the documentation.
- The fourth and subsequent arguments to defcustom specify types and options; these are not featured in defvar. (These arguments are optional.)

Incidentally, to be more complete concerning defines:
~defsubst~ defines an inline function. The syntax is just like that of defun.
~defconst~ defines a symbol as a constant.

#+begin_src emacs-lisp

;; the customizable user option variable text-mode-hook looks like this:
(defcustom text-mode-hook nil
  "Normal hook run when entering Text mode and many related modes."
  :type 'hook ;; tells Emacs the kind of data to which text-mode-hook
              ;; should be set and how to display the value in a
              ;; Customization buffer.
  :options '(turn-on-auto-fill flyspell-mode) ;; specifies a suggested list
                                              ;; of values for the variable.
                                              ;; Usually, applies to a hook.
  :group 'wp) ;; tells command in which group the variable is located.

#+end_src

**** customize-set-variable
Some customizable minor mode variables do special things to enable the mode when you set them with Customize, but ordinary ~setq~ won’t do that; to enable the mode in your init file, call the minor mode command. Finally, a few customizable user options are initialized in complex ways, and these have to be set either via the customize interface or by using ~customize-set-variable~.

** Definitions
*** point
**** point
Is the current position of the cursor. The expression ~(point)~ returns a number that tells you where the cursor is located as a count of the number of characters from the beginning of the buffer up to point.

**** point-min
Is somewhat similar to ~point~, but it returns the value of the minimum permissible value of point in the current buffer. This is the number ~1~ unless narrowing is in effect.

**** point-max
Returns the value of the maximum permissible value of point in the current buffer.

*** mark
Like [[point]] the ~mark~ is another position in the buffer; its value can be set, for the purpose of making a text selection with a command such as ~(set-mark-command)~ linked to ~C-SPC~, this value is kept as a marker. The mark can be considered a number—the number of characters the location is from the beginning of the buffer.

In lisp code, you should call ~push-mark~ or ~set-mark~.

If a mark has been set, you can use the command ~(exchange-point-and-mark)~ linked to ~C-x C-x~ to cause the cursor to jump to the mark and set the mark to be the previous position of point.

In addition, if you set another mark, the position of the previous mark is saved in the mark ring. Many mark positions can be saved this way. You can jump the cursor to a saved mark by typing ~C-u C-SPC~ one or more times.

*** region
Is the part of the buffer between point and mark. Numerous commands work on the region, including ~center-region~, ~count-words-region~, ~kill-region~, and ~print-region~.

Once a user sets a mark in a buffer, a region exists. So, almost always, there exists a region in a buffer.

Emacs has a minor mode called [[transient-mark-mode]]. When on, it will highlight the region when it's active.

*Caution*:
*region* => The last marked position to the current cursor position.
*Active Region* => Because a region exists once a user sets a mark, and always having a section of text highlighted to the cursor position is annoying, so there's a new concept of Active Region. A Region is Active when the variable ~mark-active~ is true.

Note:
Emacs's concept of “active region” is practically the same as the modern term “Text Selection”.

Text Selection = when region is active, and is not empty.

*** prefix argument
A prefix argument is passed to an [[interactive]] function by typing the ~META~ key followed by a number, for example, ~M-3 M-x command~ , or through ~universal-command~ this way ~C-u 3 M-x command~ .

- ~C-u~ is bound to ~universal-argument~.
- if you type ~C-u~ without a number, it defaults to ~4~.

To make your command aware of universal argument, there are 3 simple ways:

- The global variable ~current-prefix-arg~ holds the value of universal argument.
- Add ~(interactive "P")~ to your function.
- Add ~(interactive "p")~ to your function.

Can be raw prefix argument or can be numerical prefix argument, to see the difference [[Raw vs Numerical Prefix Arg]].

The following table shows the possible values of current-prefix-arg.

| /KEY INPUT/ | /current-prefix-arg/ | /VALUE/ |
|-----------+--------------------+-------|
| No called | nil                |     1 |
| /C-u -/     | Symbol -           |    -1 |
| /C-u - 2/   | Number -2          |    -2 |
| /C-u 1/     | Number 1           |     1 |
| /C-u 4/     | Number 4           |     4 |
| /C-u/       | List '(4)          |     4 |
| /C-u C-u/   | List '(16)         |    16 |

Raw vs Numerical Prefix Arg

#+begin_src emacs-lisp

(defun print-raw-prefix-arg (arg)
  "Print the current raw prefix argument value."
  (interactive "P")
  (insert (message "%S" arg)))
;; "M-x         print-raw-prefix-arg => nil
;; "C-u M-x     print-raw-prefix-arg => (4)
;; "C-u C-u M-x print-raw-prefix-arg => (16)
;; "C-u 3 M-x   print-raw-prefix-arg => 3
;; "M-- M-x     print-raw-prefix-arg => -

(defun print-numeric-prefix-arg (arg)
  "Print the current numeric prefix argument value."
  (interactive "p")
  (insert (message "%S" arg)))
;; "M-x         print-numeric-prefix-arg =>  1
;; "C-u M-x     print-numeric-prefix-arg =>  4
;; "C-u C-u M-x print-numeric-prefix-arg => 16
;; "C-u 3 M-x   print-numeric-prefix-arg =>  3
;; "M-- M-x     print-numeric-prefix-arg => -1

#+end_src

*** \\[...]
Tells the Lisp interpreter to substitute whatever key is currently bound to the ~[...]~.

#+begin_src emacs-lisp

\\[universal-argument]
In the case of "universal-argument", that is usually "C-u", but it might be different.

#+end_src

*** narrowing
Is a feature of Emacs that makes it possible for you to focus on a specific part of a buffer, and work without accidentally changing other parts. Narrowing is normally disabled since it can confuse novices.

*** kill ring
The kill ring is called a “ring” rather than just a “list”. However, the actual data structure that holds the text is a list.

*** kill-ring-yank-pointer
Is a variable, just as kill-ring is a variable. It points to something by being bound to the value of what it points to.

The variable ~kill-ring~ and the variable ~kill-ring-yank-pointer~ are pointers.

#+begin_src emacs-lisp

;; If the value of the kill ring is:

("some text" "a different piece of text" "yet more text")

;; and the kill-ring-yank-pointer points to the second clause
;; the value of kill-ring-yank-pointer is:

("a different piece of text" "yet more text")

kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---> |   |   |  --> |   |   |    |   |   |
          |___|___|----> |___|___|--> |___|___|--> nil
            |              |            |
            |              |            |
            |              |             --> "yet more text"
            |              |
            |               --> "a different piece of text"
            |
             --> "some text"

#+end_src

*** predicate
Is a function that determines whether some property is true or false.

It's used for example in the ~(sort SEQ PREDICATE)~ function. The ~sort~ function takes two arguments, the list to be sorted, and a predicate that determines whether the first of two list elements is less than the second  ~(sort '(4 8 21 17 33 7 21 7) '<)~.

PREDICATE is called with two elements of SEQ, and should return non-nil if the first element should sort before the second.

** Set variables
*** let
Declare that a list of variables is for use within the body of the ~let~ and give them an initial value; then evaluate the rest of the expressions in the body of the let and return the value of the last one. Inside the body of the ~let~, the Lisp interpreter does not see the values of the variables of the same names that are bound outside of the ~let~.

A ~let~ expression is a list of three parts.
- The first part is the symbol ~let~.
- The second part is a list, called a /varlist/, each element of which is either a symbol by itself or a two-element list, the first element of which is a symbol.
- The third part of the let expression is the body of the let.

The symbols in the varlist have the initial value of ~nil~.

#+begin_src emacs-lisp

(let varlist body…)


;; varlist composed of two-element lists
(let ((variable value)
     (variable value)
      …)
  body…)


(let ((zebra "stripes")
      (tiger "fierce"))
  (message "One kind of animal has %s and another is %s."
           zebra tiger))
;; "One kind of animal has stripes and another is fierce."


(let ((birch 3)
      pine
      fir
      (oak 'some))
  (message
   "Here are %d variables with %s, %s, and %s value."
   birch pine fir oak))
;; "Here are 3 variables with nil, nil, and some value."

#+end_src

*** let*
It enables Emacs to set each variable in its varlist in *sequence*, one after another. Its critical feature is that variables later in the varlist can make use of the values to which Emacs set variables earlier in the varlist.

#+begin_src emacs-lisp

(let* ((foo 7)
       (bar (* 3 foo)))
  (message "`bar' is %d." bar)) ;; => "‘bar’ is 21."

#+end_src

*** set
To set the value of a symbol, Emacs lisp uses the ~set~ function which return and sets the value as a side effect. The symbol (which can be viewed as a variable) is bound to the value.

Note also, that when you use ~set~, you need to quote both arguments to ~set~, unless you want them evaluated. When you use ~set~ without quoting its first argument, the first argument is evaluated before anything else is done.

#+begin_src emacs-lisp

(set 'flowers '(rose violet daisy buttercup))
;; => (rose violet daisy buttercup)

#+end_src

*** setq
Sets the value of its first argument to the value of the second argument. Is just like [[set]] except that the first argument is quoted automatically, so you don’t need to type the quote mark yourself.

Also, ~setq~ can be used to assign different values to different variables. The first argument is bound to the value of the second argument, the third argument is bound to the value of the fourth argument, and so on.

In summary, when a Lisp variable is set to a value, it is provided with the address of the list to which the variable refers.

#+begin_src emacs-lisp

(setq x 1)
;; => x = 1

(setq a 3 b 2 c 7)
;; a=3, b=2, c=7

(setq flor '(rosa violeta))
;; flor = (rosa violeta)

(setq trees '(pine fir oak maple)
      herbivores '(gazelle antelope zebra))
;; trees = (pine fir oak maple)
;; herbivores = (gazelle antelope zebra)

(setq flor (list 'rosa 'violeta))
;; flor = (rosa violeta)

#+end_src

When a variable is set to a list, it stores the address of the first box in the variable.

#+begin_src artist

(setq bouquet '(rose violet buttercup))

bouquet
     |
     |     ___ ___      ___ ___      ___ ___
      --> |___|___|--> |___|___|--> |___|___|--> nil
            |            |            |
            |            |            |
             --> rose     --> violet   --> buttercup

#+end_src

Symbols consist of more than pairs of addresses, but the structure of a symbol is made up of addresses. Indeed, the symbol bouquet consists of a group of address-boxes, one of which is the address of the printed word ~bouquet~, a second of which is the address of a function definition attached to the symbol, if any, a third of which is the address of the first pair of address-boxes for the list ~(rose violet buttercup)~, and so on. Here we are showing that the symbol’s third address-box points to the first pair of address-boxes for the list.

#+begin_src artist

(setq flowers (cdr bouquet))

bouquet        flowers
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --> |   |   |  --> |   |   |    |   |   |
       |___|___|----> |___|___|--> |___|___|--> nil
         |              |            |
         |              |            |
          --> rose       --> violet   --> buttercup

#+end_src

*** defvar
Is similar to [[setq]] in that it sets the value of a variable. It is unlike ~setq~ in two ways: first, it only sets the value of the variable if the variable *does not* already have a value. If the variable already has a value, ~defvar~ does not override the existing value (this is actually useful: packages can define their variables with ~defvar~ and you can set values for them before the package gets loaded! Your settings will not be overridden by the default value). Second, ~defvar~ has a documentation string.

Note: When you specified a variable using the ~defvar~ special form, you could distinguish a variable that a user might want to change from others by typing an asterisk, ~*~, in the first column of its documentation string ~(defvar variable "*Buffer name ...")~.

#+begin_src emacs-lisp

;; kill-ring is defined by defvar
(defvar kill-ring nil "...")


;; variable defined with a conditional construction
(defvar X-axis-label-spacing
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank))
    5)
  "Number of units from one X axis label to next."
)

#+end_src

*** fset
Set SYMBOL's function definition to DEFINITION, and return DEFINITION.

Emacs Lisp maintains different namespaces for variables and functions so ~fset~ must be used for functions.

#+begin_src emacs-lisp

;; Since lambdas are literals and we can assign variable names to
;; literals we can set the lambda function.
(fset 'cube (lambda (x) (* x x x))) (lambda (x) (* x x x))
(cube 5) ;; => 125


;; Sets the function symbol yes-or-or-no-p to the definition y-or-n-p
;; and returns the definition y-or-n-p
(fset 'yes-or-no-p 'y-or-n-p)

#+end_src

** Special forms
*** progn
Evaluate each argument in sequence and then return the value of the last.

Sometimes you need to group several expressions together as one single expression. This can be done with ~progn~.

The purpose of ~(progn …)~ is similar to a block of code ~{…}~ in C-like languages. It is used to group together a bunch of expressions into one single parenthesized expression.

The preceding expressions are evaluated only for the side effects they perform. The values produced by them are discarded.

#+begin_src emacs-lisp

(progn
  body…)


(progn 1 2 3 4) ;; => 4


;; Most of the time it's used inside “if”. For example:
(if something
    (progn ; true
    …
    )
    (progn ; else
    …
    )
)

#+end_src

*** save-excursion
Record the values of *point and the current buffer* before evaluating the body of this special form. Restore the value of point and buffer afterward.

~save-excursion~ restores the value of point even if something goes wrong in the code inside of it.

#+begin_src emacs-lisp

(save-excursion
  first-expression-in-body
  second-expression-in-body
  third-expression-in-body
   …
  last-expression-in-body)


;; often occurs within the body of a let expression
(let varlist
  (save-excursion
    body…))


(message "We are %d characters into this buffer."
         (- (point)
            (save-excursion
              (goto-char (point-min)) (point))))

#+end_src

*** save-restriction
Record whatever narrowing is in effect in the current buffer, if any, and restore that narrowing after evaluating the arguments.

When the Lisp interpreter meets with ~save-restriction~, it executes the code in the body of the ~save-restriction~ expression, and then undoes any changes to narrowing that the code caused.

Note: when you use both ~save-excursion~ and ~save-restriction~, one right after the other, you should use ~save-excursion~ outermost. If you write them in reverse order, you may fail to record narrowing in the buffer to which Emacs switches after calling ~save-excursion~.

#+begin_src emacs-lisp

(save-restriction
  body… )


;; when written together should be written like this
(save-excursion
  (save-restriction
    body…))

#+end_src

*** widen
 This function undoes any [[narrowing]] the current buffer.

*** quote
This special form quote returns object, as written, without evaluating it. This provides a way to include constant symbols and lists, which are not self-evaluating objects, in a program. (It is not necessary to quote self-evaluating objects such as numbers, strings, and vectors.)

Because quote is used so often in programs, Lisp provides a convenient read syntax for it. An apostrophe character ~'~ followed by a Lisp object (in read syntax) expands to a list whose first element is quote, and whose second element is the object. Thus, the read syntax ~'x~ is an abbreviation for ~(quote x)~.

#+begin_src emacs-lisp

(quote (+ 1 2)) ;; => (+ 1 2)
(quote foo)     ;; => foo
'foo            ;; => foo

;; Although the expressions both yield lists equal
(list '+ 1 2) ;; => (+ 1 2) ;; is a freshly-minted mutable list
'(+ 1 2)      ;; => (+ 1 2) ;; is a list built from conses that might
                            ;; be shared and shouldn't be modified

#+end_src

*** nil
Is both a symbol (false) ~nil~ and an empty list ~()~. In Emacs Lisp, any value that is not ~nil~ —is not the empty list—is considered true.

For convenience, the symbol ~nil~ is considered to have ~nil~ as its CDR (and also as its CAR).

** Booleans
*** or
Evaluate each argument in sequence, and return the value of the first argument that is not ~nil~; if none return a value that is not ~nil~, return ~nil~.

#+begin_src emacs-lisp

(or   1 2) ;; => 1
(or nil 2) ;; => 2

#+end_src

*** and
Evaluate each argument in sequence, and if any are ~nil~, return ~nil~; if none are ~nil~, return the value of the last argument.

*** not
Is a function that returns true if its argument is ~false~ and false if its argument is ~true~.

** Comparing
*** <,>,<=,>=
Tests whether its first argument is smaller than its second argument. Its behavior is similar to these, ~>~, ~<=~, ~>=~ and ~=~. In all cases, both arguments must be numbers or markers.

*** /=
Not equal. It is for comparing *numbers only*.

*** equal
It tests if two values have the same datatype and value.

Test whether two *objects* are the same. ~equal~ uses one meaning of the word “same” and [[eq]] uses another: ~equal~ returns true if the two objects have a similar structure and contents, such as two copies of the same book. On the other hand, ~eq~, returns true if both arguments are actually the same object.

The ~eq~ function is similar to the ~equal~ function in that it is used to test for equality, but differs in that it determines whether two representations are actually the same object inside the computer, but with different names. ~equal~ determines whether the structure and contents of two expressions are the same.

Compara recursivamente el contenido de los objetos si son enteros, cadenas, marcadores, vectores, vectores bool, objetos de función de código de bytes, tablas de caracteres, registros u objetos de fuente.

| /a/     | /b/     | /eq/  | /equal/ | /=/     | /string=/ |
|-------+-------+-----+-------+-------+---------|
| 5     | 5     | t   | t     | t     | error   |
| 5     | 5.0   | nil | nil   | t     | error   |
| “a”   | “a”   | nil | t     | error | t       |
| “a”   | ‘a    | nil | nil   | error | t       |
| a     | a     | t   | t     | error | error   |
| “a”   | “A”   | nil | nil   | error | nil     |
| (1 2) | (1 2) | nil | t     | error | error   |

#+begin_src emacs-lisp

(equal 3 3)   ;; => t
(equal 3 3.0) ;; => nil
(eq 3 3)      ;; => t
(eq 3 3.0)    ;; => nil

(equal '(1 (2 (3))) '(1 (2 (3)))) ; => t
(eq    '(1 (2 (3))) '(1 (2 (3)))) ; => nil

(equal (point-marker) (point-marker)) ; => t
(eq    (point-marker) (point-marker)) ; => nil

;; General way to test inequality.
(not (equal 3 4)) ; ⇒ t

;; example of testing a "string"
(equal "stringHere" ((substring (car variable) -1))) ;; variable may be string

;; example of testing a "t"
(eq t (car someVariable)) ;; variable may be "t"

#+end_src

*** eq
Test whether two *objects* are the same.

 ~eq~ uses one meaning of the word “same” and [[equal]] uses another: ~eq~, returns true if both arguments are actually the same object. On the other hand, ~equal~ returns true if the two objects have a similar structure and contents, such as two copies of the same book.

The ~eq~ function is similar to the ~equal~ function in that it is used to test for equality, but differs in that it determines whether two representations are actually the same object inside the computer, but with different names. ~equal~ determines whether the structure and contents of two expressions are the same.

Dos argumentos con el mismo contenido o elementos no son necesariamente equivalentes entre sí, son equivalentes solo si son el mismo objeto, lo que significa que un cambio en los contenidos de uno se reflejará en el mismo cambio en los contenidos del otro.

| /a/     | /b/     | /eq/  | /equal/ | /=/     | /string=/ |
|-------+-------+-----+-------+-------+---------|
| 5     | 5     | t   | t     | t     | error   |
| 5     | 5.0   | nil | nil   | t     | error   |
| “a”   | “a”   | nil | t     | error | t       |
| “a”   | ‘a    | nil | nil   | error | t       |
| a     | a     | t   | t     | error | error   |
| “a”   | “A”   | nil | nil   | error | nil     |
| (1 2) | (1 2) | nil | t     | error | error   |

#+begin_src emacs-lisp

(eq    '(1 (2 (3))) '(1 (2 (3)))) ; => nil
(equal '(1 (2 (3))) '(1 (2 (3)))) ; => t

(eq    (point-marker) (point-marker)) ; => nil
(equal (point-marker) (point-marker)) ; => t

#+end_src

*** string-lessp
Tests whether its first argument is smaller than the second argument. A shorter, alternative name for the same function (a defalias) is ~string<~.

The arguments to ~string-lessp~ must be strings or symbols; the ordering is lexicographic, so case is significant. The print names of symbols are used instead of the symbols themselves.

An empty string, ~""~, a string with no characters in it, is smaller than any string of characters.

*** string-equal
Provides the corresponding test for equality. Its shorter, alternative name is ~string=~.

Can be used to compare string and symbol.

#+begin_src emacs-lisp

(string-equal "abc" 'abc) ; ⇒ t

#+end_src

** Conditionals
*** if
Evaluate the first argument to the function; if it is true, evaluate the second argument; else evaluate the third argument, if there is one.

#+begin_src emacs-lisp

(if true-or-false-test
    action-to-carry-out-if-test-is-true)


(if (> 5 4)                             ; if-part
    (message "5 is greater than 4!"))   ; then-part

#+end_src

*** if–then–else
An [[if]] expression may have an optional third argument, called the else-part, for the case when the true-or-false-test returns false.

#+begin_src emacs-lisp

(if true-or-false-test
    action-to-carry-out-if-the-test-returns-true
  action-to-carry-out-if-the-test-returns-false)


(if (> 4 5)                               ; if-part
    (message "4 falsely greater than 5!") ; then-part
  (message "4 is not greater than 5!"))   ; else-part


;; example of doing nothing when "if" is true but doing
;; something when we have "else" part
(if (> 4 5)
    () ;; then do nothing
  (message "4 is not greater than 5!"))

#+end_src

*** when
Is an [[if]] without the possibility of an else clause. In your mind, you can replace ~when~ with ~if~ and understand what goes on. That is what the Lisp interpreter does. Technically speaking, ~when~ is a Lisp [[Macro]].

#+begin_src emacs-lisp

(when test expr1 expr2 …)


;; Its meaning is the same as
(if test (progn expr1 expr2 …)).

#+end_src

*** unless
If COND yields nil, do BODY, else return nil.

Is an [[if]] without a then-part clause, just the else-part. (unless = si no)

#+begin_src emacs-lisp

(unless nil
  5) ;; => 5
(unless t
  5) ;; => nil

#+end_src

*** cond
Try each clause until one succeeds.

Each clause looks like ~(CONDITION BODY...)~.  ~CONDITION~ is evaluated and, if the value is ~non-nil~, this clause succeeds: then the expressions in ~BODY~ are evaluated and the last one's value is the value of the ~cond-form~. If a clause has one element, as in ~(CONDITION)~, then the ~cond-form~ returns ~CONDITION's~ value, if that is ~non-nil~. If no clause succeeds, cond returns ~nil~.

#+begin_src emacs-lisp

(cond CLAUSES...)


(cond ( (> 5 10) 55)
      ( (< 5 10) 100)
      ( (= 5 5) 200) ) ;; 100

#+end_src

*** condition-case
Es usada para manejar condicionalmente errores que pueden surgir al aplicar otras funciones, por ejemplo, al ejecutar la función kill-region en un buffer de solo lectura, ella maneja el error no cortando la información (no puede al ser buffer read-only) pero si copiandola para agregarla al kill-ring.

It takes three arguments.

The first is the var argument, is sometimes bound to a variable that contains information about the error. However, if that argument is nil, that information is discarded.

The second argument determines what should happen when everything works correctly.

If an error occurs, among its other actions, the function generating the error signal will define one or more error condition names.

The third argument is an error handler. An error handler has two parts, a condition-name and a body. If the condition-name part of an error handler matches a condition name generated by an error, then the body part of the error handler is run.

#+begin_src emacs-lisp

(condition-case
  var              ;; information
  bodyform         ;; If no errors, run only this code
  error-handler…)  ;; but, if errors, run this other code

#+end_src

** Loops & recursion
*** while
The ~while~ special form tests whether the value returned by evaluating its first argument is true or false. If the value returned by evaluating the first argument is ~false~, the Lisp interpreter skips the rest of the expression and does not evaluate it. If the value is ~true~, the Lisp interpreter evaluates the body of the expression and then again tests whether the first argument to while is ~true~ or ~false~, repeating the prccess.

#+begin_src emacs-lisp

(while true-or-false-test
  body…)


; Incrementing Loop
set-count-to-initial-value
(while (< count desired-number) ; true-or-false-test
  body…
  (setq count (1+ count)))      ; incrementer
; the expression (1+ count) is te same (+ 1 count)


;; Printing a list
(setq animals '(gazelle giraffe lion tiger))
(defun print-elements-of-list (list)
  "Print each element of LIST on a line of its own."
  (while list
    (print (car list))
    (setq list (cdr list))))
(print-elements-of-list animals)
;; => gazelle
;;    giraffe
;;    lion
;;    tiger
;;    nil

#+end_src

*** dolist
Automatically shortens the list each time it loops—takes the ~cdr~ of the list—and binds the ~car~ of each shorter version of the list to the first of its arguments.

#+begin_src emacs-lisp

;; Evaluate BODY with VAR bound to each car from LIST, in turn.
;; Then evaluate RESULT to get return value, default nil.
;; RESULT is optional
(dolist (var list [result])
  body)


(defun reverse-list-with-dolist (list)
  "Using dolist, reverse the order of LIST."
  (let (result)  ; make sure list starts empty
    (dolist (var list result)
      (setq result (cons var result)))))


;; the same function using while
(defun reverse-list-with-while (list)
  "Using while, reverse the order of LIST."
  (let (result)
    (while list
      (setq result (cons (car list) result))
      (setq list (cdr list)))
    result))

#+end_src

*** dotimes
Loops a specific number of times: you specify the number. ~dotimes~ is useful when you want to go thru a list with a index.

#+begin_src emacs-lisp

(dotimes (var n) body) ;; run body, with var set to 0 to n-1


(dotimes (var n result) body) ;; returns result


(dotimes (number 5)
  (insert (message "%d" number)))
;; => 01234nil (supongo que de último imprime nil porque dotimes
;; viene del ciclo while que imprime nil cuando no se cumple la
;; condicion tru-false)


(let (value)      ; otherwise a value is a void variable
  (dotimes (number 3)
    (setq value (cons number value)))
  value)
;; =>  (2 1 0)

#+end_src

*** Recursive
A recursive function typically contains a conditional expression which has three parts:

- A ~true-or-false-test~ that determines whether the function is called again, here called the ~do-again-test~.
- The name of the function. When this name is called, a new instance of the function is created and told what to do.
- An expression that returns a different value each time the function is called, here called the ~next-step-expression~. Consequently, the argument (or arguments) passed to the new instance of the function will be different from that passed to the previous instance. This causes the conditional expression, the ~do-again-test~, to test false after the correct number of repetitions.

*Note* that although we say that the function “calls itself”, what we mean is that the Lisp interpreter assembles and instructs a *new instance* of the program. The new instance is a clone of the first, but is a separate individual.

#+begin_src emacs-lisp

(defun name-of-recursive-function (argument-list)
  "documentation…"
  (if do-again-test
    body…
    (name-of-recursive-function
         next-step-expression)))


(defun print-elements-recursively (list)
  "Print each element of LIST on a line of its own.
Uses recursion."
  (when list                            ; do-again-test
        (print (car list))              ; body
        (print-elements-recursively     ; recursive call
         (cdr list))))                  ; next-step-expression

(print-elements-recursively '(1 2 3 4)) ;; => 1 2 3 4


(defun rf/sum-list-recursivly (list)
  "Return the sum of the numbers in a LIST."
  (let ((result 0)) ;; VARIABLE para poder entregar el resultado
                    ;; si no se se coloca, el último resultado sería el "nil"
                    ;; que arroja el condicional "if" al fallar el último valor
                    ;; que rompe la recursividad
    (if (not (eq (car list) nil))    ;; CONDICIONAL que rompe la recursividad
        (setq result
              (+ (car list) (rf/sum-list-recursivly (cdr list)))))
                    ;; FUNCIÓN que llama la recursividad variando el parámetro
    result))

(rf/sum-list-recursivly '(1 2 3 4)) ;; => 10


(defun sum-nfirst-number-recursively (number)
  "Return the sum of the numbers 1 through NUMBER inclusive."
  (if (= number 1)                    ; do-again-test
      1                               ; then-part
    (+ number                         ; else-part
    (sum-nfirst-number-recursively    ; recursive call
        (1- number)))))               ; next-step-expression

(sum-nfirst-number-recursively 4) ;; => 10

#+end_src

*** Recursive Patterns
**** every
In the every recursive pattern, an action is performed on every element of a list.

The pattern is:

If a list be empty, return ~nil~.
Else, act on the beginning of the list (the ~car~ of the list)
 - through a recursive call by the function on the rest (the ~cdr~) of the list,
 - and, optionally, combine the acted-on element, using ~cons~, with the results of acting on the rest.

 #+begin_src emacs-lisp

(defun square-each (list)
  "Square each of a LIST, recursively."
  (if (not list)                 ; do-again-test
      nil
    (cons
     (* (car list) (car list))
     (square-each (cdr list))))) ; next-step-expression

(square-each '(1 2 3)) ;; => (1 4 9)


(defun rf/square-each (list)
  (if (not (eq (car list) nil))
      (cons (* (car list) (car list))
            (rf/square-each  (cdr list)))))

 #+end_src

**** accumulate
In the accumulate recursive pattern, an action is performed on every element of a list and the result of that action is accumulated with the results of performing the action on the other elements.

The pattern is:

If a list be empty, return ~zero~ or some other constant.
Else, act on the beginning of the list (the ~car~ of the list),
  - and combine that acted-on element, using ~+~ or some other combining function, with
  - a recursive call by the function on the rest (the ~cdr~) of the list.

#+begin_src emacs-lisp

(defun add-elements (list)
  "Add the elements of LIST together."
  (if (not list)
      0
    (+ (car list) (add-elements (cdr list)))))

(add-elements '(1 2 3 4)) ;; => 10

#+end_src

**** keep
In the keep recursive pattern, each element of a list is tested; the element is acted on and the results are kept only if the element meets a criterion.

The pattern has three parts:

If a list be empty, return ~nil~.
Else, if the beginning of the list (the ~car~ of the list) passes a test
   - act on that element and combine it, using ~cons~ with
   - a recursive call by the function on the rest (the ~cdr~) of the list.
 Otherwise, if the beginning of the list (the ~car~ of the list) fails the test
   - skip on that element,
   - and, recursively call the function on the rest (the ~cdr~) of the list.

#+begin_src emacs-lisp

(defun keep-three-letter-words (word-list)
  "Keep three letter words in WORD-LIST."
  (cond
   ;; First do-again-test: stop-condition
   ((not word-list) nil)
   ;; Second do-again-test: when to act
   ((eq 3 (length (symbol-name (car word-list))))
    ;; combine acted-on element with recursive call on shorter list
    (cons (car word-list) (keep-three-letter-words (cdr word-list))))
   ;; Third do-again-test: when to skip element;
   ;;   recursively call shorter list with next-step expression
   (t (keep-three-letter-words (cdr word-list)))))

(keep-three-letter-words '(one two three four five six))
  ;; => (one two six)


(defun rf/numbers-above-5 (number)
  "Keep NUMBER that are above 5."
  (cond ;; ((not number) nil) ;; se puede omitir
        ((< (car number) 5) (name (cdr number)))
        ((> (car number) 5) (cons (car number) (name (cdr number))))
        )
  )

(rf/numbers-above-5 '(1 9 3 7)) (9 7)


#+end_src

**** No Deferment Solution
The solution to the problem of deferred operations is to write in a manner that does not defer operations. This requires writing to a different pattern, often one that involves writing two function definitions, an initialization function and a helper function.

The initialization function sets up the job; the helper function does the work.

Here are the two function definitions for adding up numbers. They are so simple, I find them hard to understand.

#+begin_src emacs-lisp

(defun triangle-initialization (number)
  "Return the sum of the numbers 1 through NUMBER inclusive.
This is the initialization component of a two function
duo that uses recursion."
  (triangle-recursive-helper 0 0 number))


(defun triangle-recursive-helper (sum counter number)
  "Return SUM, using COUNTER, through NUMBER inclusive.
This is the helper component of a two function duo
that uses recursion."
  (if (> counter number)
      sum
    (triangle-recursive-helper (+ sum counter)  ; sum
                               (1+ counter)     ; counter
                               number)))        ; number
(triangle-initialization 7)
;; (triangle-recursive-helper  0    1       7) ;; Immediately call
;; (triangle-recursive-helper  1    2       7) ;; Immediately call
;; (triangle-recursive-helper  3    3       7)
;; (triangle-recursive-helper  6    4       7)
;; (triangle-recursive-helper 10    5       7)
;; (triangle-recursive-helper 15    6       7)
;; (triangle-recursive-helper 21    7       7)
;; (triangle-recursive-helper 28    8       7)
;; => 28


;; The same recursion function without Deferments
(defun triangle-recursively (number)
  "Return the sum of the numbers 1 through NUMBER inclusive.
Uses recursion."
  (if (= number 1)                    ; do-again-test
      1                               ; then-part
    (+ number                         ; else-part
       (triangle-recursively          ; recursive call
        (1- number)))))               ; next-step-expression

(triangle-recursively 7)
;; (+ 7 (triangle-recursively 6)) ;; Wait for a new value.
;; (+ 7 6 (triangle-recursively 5)) ;; Wait of wait for a new value.
;; (+ 7 6 5 (triangle-recursively 4))
;; (+ 7 6 5 4 (triangle-recursively 4))
;; (+ 7 6 5 4 3 (triangle-recursively 4))
;; (+ 7 6 5 4 3 2 (triangle-recursively 4))
;; (+ 7 6 5 4 3 2 1)
;; => 28

#+end_src

** Functions
*** defun
In Lisp, a symbol such as ~mark-whole-buffer~ has code attached to it that tells the computer what to do when the function is called. This code is called the function definition and is created by evaluating a Lisp expression that starts with the symbol ~defun~.

A function definition has up to five parts following the word ~defun~:

- The name of the symbol to which the function definition should be attached.
- A list of the arguments that will be passed to the function. If no arguments will be passed to the function, this is an empty list, ~()~.
- Documentation describing the function. (optional)
- An expression to make the function interactive so you can use it by typing ~M-x~ and then the name of the function. (optional)
- The code that instructs the computer what to do: the body of the function definition.

It is helpful to think of the five parts of a function definition as being organized in a template, with slots for each part:

#+begin_src emacs-lisp

(defun function-name (arguments…)
 "One sentence summary of what this command do, no more than 67 chars.

More details here. Be sure to mention the return value if relevant.
Lines here should not be longer than 70 chars,
and don't indent them.

• ARG1 is…. Parameters should be all caps.
• See URL `http://example.com/' (clickable url)
• See `dired' (clickable command name)
• See `(emacs) Dired'. (link to info doc)
• Type \\[dired] to go into dired. (key of a command.)
• clickable list of all keys of a given keymap name.
\\{c-mode-map}
• \\<c-mode-map> No visible effect. Tell emacs to use this keymap for
displaying keys in the rest of this inline doc."
  (interactive argument-passing-info)     ; optional
  body…)


(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))

#+end_src

#+begin_src emacs-lisp

(defun triangulo (numero)
  "Devuelve la suma de números desde el 1 hasta e incluyendo a NUMERO."
  (let ((total 0))
    (while (> numero 0)
      (setq total (+ total numero))
      (setq numero (1- numero)))
    total))


(defun cuadrado-de-cada-uno (lista-de-numeros)
  "El cuadrado de cada elemento en LISTA DE NUMEROS, recursivamente."
  (if (not lista-de-numeros)		; prueba-hazlo-de-nuevo
      nil
     (cons
      (* (car lista-de-numeros) (car lista-de-numeros))
      (cuadrar-cada-uno (cdr lista-de-numeros))))) ; expresion-del-siguiente-paso

#+end_src

*** Parameters
Emacs's function parameter's features and syntax is very basic. It is simply a list of items. If you want optional parameters, just add ~&optional~. Any parameter after that will be optional.

#+begin_src emacs-lisp

;; defining a function with 2 optional params named cc and dd
(defun myfun (aa bb &optional cc dd)
""
   (let ((varOptional (or cc 5))))) ;; if send cc, put it on, if not, do not
;; When you call, a and b are required, c and d are optional.
;; When a optional parameter is not given, its value is nil.

#+end_src

If you want to give a argument to some optional parameters but not all, use ~nil~ for those you don't care.

#+begin_src emacs-lisp

;; calling a function with 3rd parameter omitted
(myfun "mya" "myb" nil "myd")

#+end_src

If a function received a ~nil~ as argument for one of its optional parameter, there is no way for a function to know if it is specified by user or omitted.

Elisp also support the *unspecified number of parameters*. It is done by adding ~&rest~ similar to ~&optional~. You can have both ~&optional~ and ~&rest~, in that order.

*** interactive
Declare to the interpreter that the function can be used interactively (by typing ~M-x~ and then the name of the function).

This special form may be followed by a string with one or more parts that pass the information to the arguments of the function, in sequence. These parts may also tell the interpreter to prompt for information. Parts of the string are separated by newlines,  ~\n~ (can be use with a [[prefix argument]] like this ~C-u 3 M-x multiply-by-seven~).

The ~(interactive …)~ is used to fill out the parameters, when your function is called by user interactively (as opposed to from a lisp program).

- p :: The *numeric prefix argument*. It will pass converted numerical value of ~current-prefix-arg~ to your function's first argument. Prefix arg converted to number. Does not do I/O.
- P :: *Prefix arg in raw* form. It will pass the value of ~current-prefix-arg~ to your function's first argument. Does not do I/O.
- b :: The *name* of an existing *buffer*.
- f :: The *name* of an existing *file*.
- r :: *Point and the mark*, as two numeric arguments, smallest first. This is the only code letter that specifies two successive arguments rather than one.
- s :: Any *string*.  Does not inherit the current input method.

Tech detail: In emacs, “commands” are a subset of “functions”. Commands are functions that can be called interactively (by typing ~M-x~). A function is a command when its definition contains the ~(interactive …)~ clause.

#+begin_src emacs-lisp

(defun multiply-by-seven (number)       ; Interactive version.
  "Multiply NUMBER by seven."
  (interactive "p") ;; current-prefix-arg
  (message "The result is %d" (* 7 number)))
;; "C-u 3 M-x multiply-by-seven" => 21
;; 1 if universal-argument isn't called


(defun f (x)
  "print argument received"
  (interactive "P")
  (message "%s" x)) ;; value of x is from universal argument
;; nil if universal-argument isn't called


(defun multiple-hello (someone num)
  "Say hello to SOMEONE via M-x hello, for NUM times."
;;(interactive "code_letter_and_promp_string")
  (interactive "sWho do you want to say hello to? \nnHow many times?")
;; "s" prompt user for a string as argument.
;; "n" prompt user for a number as argument.
;; "\n" part that separates the arguments.
  (dotimes (i num)
    (insert (message "Hello %s!\n" someone))))
;; "s" is any string "n" number read using minibuffer
;; "M-x multiple-hello Carlos 2"
;; => Hello Carlos!
;;    Hello Carlos!


;;The following is a basic function definition taking region as arg.
(defun myFunction (myStart myEnd)
  "Prints region start and end positions"
  (interactive "r")
;; "r" for commands that takes 2 arguments, the beginning and
;; ending positions of the current region..
  (message "Region begin at: %d, end at: %d" myStart myEnd))

#+end_src

One way to use the ~interactive~ function is for it to return a list. This list's element will be fed to the function as arguments.

#+begin_src emacs-lisp

;; Interesting quick example of the behavior of the interactive function
(defun xah/wrap-html-tag (tagName &optional className ξid)
;;(interactive (list …))
  (interactive '(1 2 3))
  (message "uno %s dos %s tercer %s" tagName className ξid))
;; => 1 dos 2 tercer 3

#+end_src

Sometimes you do not want your function's parameter spec to explicitly contain universal argument, because it is not relevant to the function. So, ~(interactive "P")~ is not appropriate.

Example of a command that we want to create a HTML tag like this:

#+begin_src html

cat
   ↓
<div>cat</div>
or
<div class="xyz">cat</div>
or
<div id="id8295" class="xyz">cat</div>

#+end_src

#+begin_src emacs-lisp

(defun xah/wrap-html-tag (tagName &optional className ξid)
  "Add a HTML tag to beginning and ending of current word or text selection.

When preceded with `universal-argument',
no arg = prompt for tag, class.
2 = prompt for tag, id.
any = prompt for tag, id, class.

When called interactively,
Default id value is 「id‹random number›」.
Default class value is 「xyz」.

When called in lisp program, if className is nil or empty string, don't add the attribute. Same for ξid."
  (interactive
   (cond
    ((equal current-prefix-arg nil)     ; universal-argument not called
     (list
      (read-string "Tag (span):" nil nil "span") ))
    ((equal current-prefix-arg '(4))    ; C-u
     (list
      (read-string "Tag (span):" nil nil "span")
      (read-string "Class (xyz):" nil nil "xyz") ))
    ((equal current-prefix-arg 2)       ; C-u 2
     (list
      (read-string "Tag (span):" nil nil "span")
      (read-string "id:" nil nil (format "id%d" (random (expt 2 28 ))))
      ))
    (t                                  ; all other cases
     (list
      (read-string "Tag (span):" nil nil "span")
      (read-string "Class (xyz):" nil nil "xyz")
      (read-string "id:" nil nil (format "id%d" (random (expt 2 28 )))))))))
  ;; now, all the parameters of your function is filled.
  ;; code body here

#+end_src

*** lambda
Is the symbol for an anonymous function, a function without a name. Every time you use an anonymous function, you need to include its whole body. It let you define a function in the middle of your code.

The read syntax ~#'~ is a short-hand for using ~function~.

#+begin_src emacs-lisp

(lambda (arg-variables)
  [documentation-string]
  [interactive-declaration]
  body-forms)


(lambda (x y) (+ x y))
;; is a function that takes two arguments, x and y, and returns their sum.

;; these are some of the ways of calling the function
(funcall (lambda (x y) (+ x y)) 5 3) ;; => 8
((lambda (x y) (+ x y)) 5 3) ;; => 8


;; If we want to multiply 3 by 7, we can write:
(multiply-by-seven 3)
 \_______________/ ^
         |         |
      function  argument
;; Similarly, we can write:
((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      anonymous function     argument


;; We had a function multiply-by-seven; it multiplied its argument by 7.
(defun multiply-by-seven (number)
  (* 7 number))
;; The anonymous equivalent of multiply-by-seven is:
(lambda (number) (* 7 number))


;; The following forms are all equivalent:
(lambda (x) (* x x))
(function (lambda (x) (* x x)))
#'(lambda (x) (* x x))

;; Note:
;; function (aka #') is used to quote functions, whereas quote (aka ')
;; is used to quote data.

#+end_src

*** funcall
~funcall function &rest arguments~

Call first argument as a function, passing remaining ARGUMENTS to it, and returns whatever FUNCTION returns.

Since funcall is a function, all of its ARGUMENTS, including FUNCTION, are evaluated before funcall is called. This means that you can use any expression to obtain the function to be called. It also means that funcall does not see the expressions you write for the arguments, only their values. These values are not evaluated a second time in the act of calling function; the operation of funcall is like the normal procedure for calling a function, once its arguments have already been evaluated.

The argument FUNCTION must be either a Lisp function or a primitive function. Special forms and macros are not allowed, because they make sense only when given the unevaluated argument expressions. funcall cannot provide these because, as we saw above, it never knows them in the first place.

#+begin_src emacs-lisp

(setq f 'list)          ;; => list
(funcall f 'x 'y 'z)    ;; => (x y z)
(funcall f 'x 'y '(z))  ;; => (x y (z))

(funcall 'and t nil)    ;; => error→ Invalid function: #<subr and>(special form)

(apply 'max '(1 2 3 4)) ;; => 4
(funcall 'max '(1 2 3 4))
;; => error because "funcall" would pass that argument to the function "max"
;; which precisely cannot recive the list as an argument while "apply" does,
;; "apply" passes each value of the list as an individual argument.

#+end_src

*** apply
~apply~ calls function with arguments, just like [[funcall]] but with one difference: the last of arguments is a list of objects, which are passed to function as separate arguments, rather than a single list. We say that apply spreads this list so that each individual element becomes an argument.

~apply~ with a single argument is special: the first element of the argument, which must be a non-empty list, is called as a function with the remaining elements as individual arguments. Passing two or more arguments will be faster.

~apply~ returns the result of calling function. As with funcall, function must either be a Lisp function or a primitive function; special forms and macros do not make sense in apply.

#+begin_src emacs-lisp

(setq f 'list)     ;; => list
(apply f 'x 'y 'z) ;; => error→ Wrong type argument: listp, z


(apply '+ 1 2 '(3 4)) ;; => 10
(apply '+ '(1 2 3 4)) ;; => 10


(apply 'append '((a b c) nil (x y z) nil)) ;; => (a b c x y z)
;; append sends each argument as an individual argument in itself.
(apply '(+ 3 4)) ;; => 7
(apply '(lambda (x) (+ x 5)) '(6)) ;; => 11


(apply 'max '(1 2 3 4)) ;; => 4
(funcall 'max '(1 2 3 4))
;; => error because "funcall" would pass that argument to the function "max"
;; which precisely cannot recive the list as an argument while "apply" does,
;; "apply" passes each value of the list as an individual argument.

#+end_src

*** High-order
Functions that take other functions as arguments.

#+begin_src emacs-lisp

(defun transform-unless-zero (fn n)
  (if (= n 0) 0
  (funcall fn n)))


(transform-unless-zero (lambda (n) (+ 1 n)) 7) ;; => 8

#+end_src

*** closure
Emacs can optionally enable lexical binding of variables. When lexical binding is enabled, any named function that you create (e.g., with ~defun~), as well as any anonymous function that you create using the ~lambda~ macro or the function special form or the ~#'~ syntax, is automatically converted into a *closure*.

A closure is a function that also carries a record of the lexical environment that existed when the function was defined. When it is invoked, any lexical variable references within its definition use the retained lexical environment. In all other respects, closures behave much like ordinary functions; in particular, they can be called in the same way as ordinary functions.

Currently, an Emacs Lisp closure object is represented by a list with the symbol closure as the first element, a list representing the lexical environment as the second element, and the argument list and body forms as the remaining elements:

#+begin_src emacs-lisp

;; lexical binding is enabled.
(lambda (x) (* x x))
     ;; => (closure (t) (x) (* x x))

#+end_src

However, the fact that the internal structure of a closure is exposed to the rest of the Lisp world is considered an internal implementation detail. For this reason, we recommend against directly examining or altering the structure of closure objects.

#+begin_src emacs-lisp

(defvar my-ticker nil)   ; We will use this dynamically bound
                         ; variable to store a closure.


(let ((x 0))             ; x is lexically bound.
  (setq my-ticker (lambda ()
                    (setq x (1+ x)))))
   ;; (closure ((x . 0) t) ()
     ;;   (setq x (1+ x)))

(funcall my-ticker) ;; => 1
(funcall my-ticker) ;; => 2
(funcall my-ticker) ;; => 3

x                        ; Note that x has no global value.
;; => error→ Symbol's value as variable is void: x

#+end_src

** List Processing
*** Get
**** car
Return the first item in the list.

~car~ does not remove the first item from the list; it only reports what it is. ~car~ is “non-destructive”.

Thus, in Lisp, to get the ~car~ of a list, you get the address of the first element of the list.

#+begin_src emacs-lisp

(car '(first second third)) ;; => first

#+end_src

**** nth
Takes the ~car~ of the result returned by [[nthcdr]]. It returns the Nth element of the list. The function is “non-destructive”.

Note that the elements are numbered from zero, not one. That is to say, the first element of a list, its ~car~ is the zeroth element.

#+begin_src emacs-lisp

(nth 0 '(zero first second third)) ;; => zero
(nth 1 '(zero first second third)) ;; => first

#+end_src

**** elt
This function returns the element of sequence indexed by index. Legitimate values of index are integers ranging from 0 up to one less than the length of sequence. If sequence is a list, out-of-range values behave as for [[nth]].

#+begin_src emacs-lisp

(elt [1 2 3 4] 2) ;; => 3

(elt '(1 2 3 4) 2) ;; => 3

;; We use string to show clearly which character elt returns.
(string (elt "1234" 2)) ;; => "3"

(elt [1 2 3 4] 4) ;; error→ Args out of range: [1 2 3 4], 4

#+end_src

**** last
Return the last link of LIST.  Its car is the last element.

#+begin_src emacs-lisp

(last '(1 4 7)) ;; => (7)

#+end_src

**** cdr
Returns the second and subsequent elements of a list.

~cdr~ does not remove any elements from the list—it just returns a report of what the second and subsequent elements are.  ~cdr~ is “non-destructive”

Thus, in Lisp, to get the ~cdr~ of a list, you just get the address of the next cons cell in the series.

#+begin_src emacs-lisp

(cdr '(first second third)) ;; => (second third)

(cdr (cdr '(zero first second third))) ;; => (second third)
 (nthcdr 2 '(zero first second third)) ;; => (second third)

#+end_src

**** nthcdr
Return the result of taking [[cdr]] ~n~ times on a list. The “rest of the rest”.

Is associated with the ~cdr~ function. What it does is take the ~cdr~ of a list repeatedly. The function is “non-destructive”.

#+begin_src emacs-lisp

 (nthcdr 2 '(zero first second third)) ;; => (second third)

(cdr (cdr '(zero first second third))) ;; => (second third)

#+end_src

**** seq-take
This function returns the first N (an integer) elements of SEQUENCE. If N is negative or zero, the result is nil.

#+begin_src emacs-lisp

(seq-take '(1 2 3 4) 3)  ;; => (1 2 3)

(seq-take [1 2 3 4] 0)   ;; =>  []

#+end_src

**** pop
This macro provides a convenient way to examine the CAR of a list, and take it off the list, all at once. It operates on the list stored in LISTNAME. It removes the first element from the list, saves the CDR into listname, then returns the removed element. *It changed the list*.

#+begin_src emacs-lisp

(pop listname)
; In the simplest case, listname is an unquoted symbol naming a list
; in that case, this macro is equivalent to
(prog1 (car  listname)
       (setq listname (cdr listname)))


x       ;; => (a b c)
(pop x) ;; => a
x       ;; => (b c)

; More generally, listname can be a generalized variable.
; In that case, this macro saves into listname using setf.

#+end_src

**** seq-drop-while
This function returns the members of SEQUENCE in order, starting from the first one for which PREDICATE returns nil.

#+begin_src emacs-lisp

(seq-drop-while (lambda (x) (> x 0)) '(1 2 3 -1 -2))
;; => (-1 -2)

(seq-drop-while (lambda (x) (< x 0)) [1 4 6])
;; => [1 4 6]

#+end_src

*** Add
**** cons
Return a new list, with new element added to front. (prepend)

Constructs a list by prepending its first argument to its second argument. ~cons~ does not change an existing list, but creates a new one. ~cons~ is “non-destructive”.

- ~cons~ must have a list to attach to. You cannot start from absolutely nothing. If you are building a list, you need to provide at least an empty list at the beginning.
- ~cons~, can put together or construct a list, but not an array.

The function ~cons~ adds a new pair of addresses to the front of a series of addresses. Thus, to ~cons~ a new element on a list, you add a new cons cell to the front of the list.

#+begin_src emacs-lisp

(cons 'zero '(first second third)) ;; => (zero first second third)

(cons 'born ()) ;; => (born)

(cons 'born 'now) ;; => (born . now) ;; build cons cell

#+end_src

**** append
Return a new list, join two lists.

#+begin_src emacs-lisp

(append '(1 2 3 4) '(5 6 7 8))
;; => (1 2 3 4 5 6 7 8)


;; The results contrast with cons, which constructs a new list in which
;; the first argument to cons becomes the first element of the new list:
(cons '(1 2 3 4) '(5 6 7 8))
;; => ((1 2 3 4) 5 6 7 8)

#+end_src

**** push
Add new element to the list *stored* in the generalized variable. Like [[cons]] but *this does changed the list*.

#+begin_src emacs-lisp

(push value list)

;; it's the same that
(add-to-list list value)
;; and
(setq list (cons value list))

;; example
(setq list '(1 2 3 4)) ;; =>   (1 2 3 4)
(push 5 list)          ;; => (5 1 2 3 4)
list                   ;; => (5 1 2 3 4)

#+end_src

*Caution*: Si a ~push~ se le pasa una lista modificada (por ejemplo, la cola de la lista), solo cambiará esa parte de la lista (o sea, la cola) la primera parte quedará exactamente igual.

#+begin_src emacs-lisp

(setq list '(1 2 3 4))              ;; => (1 2 3 4)
(push (car list) (cdr (cdr list)))  ;; => (1 3 4)
list                                ;; => (1 2 1 3 4)

#+end_src

*** Remove
**** pop
Remove first element from the variable. Returns the removed element. The argument must be a generalized variable whose value is a list.

#+begin_src emacs-lisp

(setq mylist '(7 4 2 1 0)) ;; => (7 4 2 1 0)
(pop mylist)               ;; => 7

#+end_src

**** butlast
Return a copy of LIST with the *last N elements removed*. It *doesn't change the list*.

#+begin_src emacs-lisp

(butlast '(1 3 5 7 9) 2)  ;; => (1 3 5)

(butlast '("a" "b" "c"))  ;; => ("a" "b")

#+end_src

**** nbutlast
Modify LIST to *remove the last N elements*. It *changed the list*.

#+begin_src emacs-lisp

(nbutlast '(1 3 5 7 9) 2)  ;; => (1 3 5)

#+end_src

**** seq-drop
Returns all but the first ~n~ (an integer) elements of SEQUENCE. If ~n~ is negative or zero, the result is SEQUENCE.

#+begin_src emacs-lisp

(seq-drop [1 2 3 4 5 6] 3)  ;; => [4 5 6]

(seq-drop "hello world" -4) ;; => "hello world"

#+end_src

**** delq
~(delq ELT LIST)~
Delete members of LIST which are [[eq]] to ELT, and return the result.

#+begin_src emacs-lisp

(delq   "b" '("a" "b" "c" "b")) ;; => ("a" "b" "c" "b")
(delete "b" '("a" "b" "c" "b")) ;; => ("a" "c")

(delq   2 '(1 2 3 2 4)) ;; => (1 3 4)
(delete 2 '(1 2 3 2 4)) ;; => (1 3 4)

(delq   '(0) '(1 (0) 2 3 (0) 4 5 6)) ;; => (1 (0) 2 3 (0) 4 5 6)
(delete '(0) '(1 (0) 2 3 (0) 4 5 6)) ;; => (1 2 3 4 5 6)

#+end_src

**** delete
~(delete ELT SEQ)~
Delete members of SEQ which are [[equal]] to ELT, and return the result.

#+begin_src emacs-lisp

(delete "b" '("a" "b" "c" "b")) ;; => ("a" "c")
(delq   "b" '("a" "b" "c" "b")) ;; => ("a" "b" "c" "b")

(delete 2 '(1 2 3 2 4)) ;; => (1 3 4)
(delq   2 '(1 2 3 2 4)) ;; => (1 3 4)

(delete '(0) '(1 (0) 2 3 (0) 4 5 6)) ;; => (1 2 3 4 5 6)
(delq   '(0) '(1 (0) 2 3 (0) 4 5 6)) ;; => (1 (0) 2 3 (0) 4 5 6)

#+end_src

*** Replace
**** setcar
Changes the first element of a list.

Set the [[car]] of a list to a new value.

~setcar~ did not add a new element to the list as ~cons~ would have; it replaced first element of the list with new value; *it changed the list*.

The result we are interested in is the side effect, which we can see by evaluating the variable what will change.

#+begin_src emacs-lisp

;; first set value of a variable to the list
(setq numbers (list 'first 'second 'third 'fourth))
numbers ;; =>  (first second third fourth)

;; apply the function setcar to set a new first value
(setcar numbers 'new)
;; evaluted the variable to check result
numbers ;; =>  (new second third fourth)

#+end_src

**** setcdr
Changes the second and subsequent elements of a list.

Set the [[cdr]] of a list to a new value.

~setcdr~ did not add elements to the list as ~cons~ would have; it replaced the second and subsequent elements of the list with new values; *it changed the list*.

The result we are interested in is the side effect, which we can see by evaluating the variable what will change.

#+begin_src emacs-lisp

;; first set value of a variable to the list
(setq numbers (list 'first 'second 'third 'fourth))
numbers ;; =>  (first second third fourth)

;; apply the function setcar to set a new first value
(setcdr numbers '(2 3))
;; evaluted the variable to check result
numbers ;; =>  (first 2 3)

#+end_src

#+begin_src emacs-lisp

;; Ejemplo de acortar una lista se debe poneniendo
;; el último valor con nil
(setq numbers (list 'first 'second 'third 'fourth))
;; numbers => (first second third fourth)

(setcdr (nthcdr 2 numbers) nil)
;; (nthcdr 2 numbers) no altera la lista, solo trabaja
;; temporalmente entregando (third fourt) y luego
;; setcdr la altera (third fourt) => (third nil)
;; numbers => (first second third)
;; SE PUEDE VER MEJOR USANDO LAS DIRECCIONES DE LISTA, I.E.
;; CADA CONS CELL TIENE LA DIRECCIÓN PROPIA Y LA DE EL PUNTERO
;; AL SIGUIENTE VALOR

#+end_src

*** Misc
**** length
Return the length of vector, list or string.

#+begin_src emacs-lisp

(length '(first second third)) ;; => 3

(length "first") ;; => 5

(length (make-bool-vector 5 nil)) ;; => 5

#+end_src

**** sort
This function sorts SEQUENCE stably. Note that this function doesn’t work for all sequences; it may be used only for lists and vectors. If SEQUENCE is a list, it is modified *destructively*. This functions returns the sorted SEQUENCE and compares elements using PREDICATE. A stable sort is one in which elements with equal sort keys maintain their relative order before and after the sort. Stability is important when successive sorts are used to order elements according to different criteria.

*WARNING*: The destructive aspect of ~sort~ for lists is that it rearranges the cons cells forming SEQUENCE by changing CDRs. A nondestructive sort function would create new cons cells to store the elements in their sorted order. If you wish to make a sorted copy without destroying the original, copy it first with [[copy-sequence]] and then sort.

#+begin_src emacs-lisp

(setq nums (list 1 3 2 6 5 4 0)) ;; => (1 3 2 6 5 4 0)
(sort nums #'<)                  ;; => (0 1 2 3 4 5 6)
nums                             ;; => (1 2 3 4 5 6)

;;Most often we store the result back into the variable
;;that held the original list:
(setq nums (sort nums #'<))


;; to sort the list in alphabetical order
(sort
 (files-in-below-directory "/some/path/")
 'string-lessp)

#+end_src

**** copy-sequence
This function returns a copy of its ARGUMENT, which should be either a sequence or a record. The copy is the same type of object as the original, and it has the same elements in the same order. However, if ARGUMENT is empty, like a string or a vector of zero length, the value returned by this function might not be a copy, but an empty object of the same type and identical to ARGUMENT.

*Storing a new element into the copy does not affect the original ARGUMENT, and vice versa. However, the elements of the copy are not copies; they are identical (eq) to the elements of the original. Therefore, changes made within these elements, as found via the copy, are also visible in the original.*

This function does not work for dotted lists. Trying to copy a circular list may cause an infinite loop.

#+begin_src emacs-lisp

(setq x '(1 2 3))       ;; => (1 2 3)
(setq y (copy-sequence x))  ;; => (1 2 3)

(eq x y)     ;; => nil
(equal x y)  ;; => t

(eq (nth 1 x) (nth 1 y)) ;; => t

#+end_src

**** mapcar
Apply FUNCTION to each element of SEQUENCE, and make a list of the results. SEQUENCE may be a list, a vector, a bool-vector, or a string.

Contrast this with [[apply]], which applies its first argument to all the remaining.

The ‘map’ part of the name comes from the mathematical phrase, “mapping over a domain”, meaning to apply a function to each of the elements in a domain. The mathematical phrase is based on the metaphor of a surveyor walking, one step at a time, over an area he is mapping. And ‘car’, of course, comes from the Lisp notion of the first of a list.

#+begin_src emacs-lisp

; add one to each list member
(mapcar '1+ (list 1 2 3 4)) ; (2 3 4 5)
; same, but using the "lambda" function created inline
(mapcar
 (lambda (x) (+ x 1))
 (list 1 2 3 4)) ;; => (2 3 4 5)


; take the 1st element of each
(mapcar 'car '((1 2) (3 4) (5 6))) ; (1 3 5)


;; take the 2nd element of each
(mapcar (lambda (x) (nth 1 x))
        '((1 2) (3 4) (5 6))) ;; => (2 4 6)

#+end_src

**** mapc
Apply FUNCTION to each element of SEQUENCE *for side effects only*. Like [[mapcar]], but returns ~nil~.

#+begin_src emacs-lisp

;; apply a file processing function to a list of files
(mapc 'my-update-html-footer
      (list
       "~/web/file1.html"
       "~/web/file2.html"
       "~/web/file3.html"))

#+end_src

**** reverse
Creates a new sequence whose elements are the elements of SEQUENCE, but in reverse order. The original argument sequence *is not altered*. Note that char-tables cannot be reversed.

#+begin_src emacs-lisp

(setq x '(1 2 3 4)) ;; => (1 2 3 4)
(reverse x)         ;; => (4 3 2 1)
x                   ;; => (1 2 3 4)


(setq x [1 2 3 4]) ;; => [1 2 3 4]
(reverse x)        ;; => [4 3 2 1]
x                  ;; => [1 2 3 4]

(setq x "xyzzy") ;; => "xyzzy"
(reverse x)      ;; => "yzzyx"
x                ;; => "xyzzy"

#+end_src

**** nreverse
This function reverses the order of the elements of SEQUENCE. Unlike [[reverse]] the original SEQUENCE may be *modified*.

Note that unlike ~reverse~, this function doesn’t work with strings. Although you can alter string data by using ~aset~, it is strongly encouraged to treat strings as immutable even when they are mutable.

#+begin_src emacs-lisp

(setq list '(1 3 5 7))   ;; => (1 3 5 7)
(nreverse list)          ;; => (7 5 3 1)
list                     ;; => (1)

;; To avoid confusion, we usually store the result of nreverse back in
;; the same variable which held the original list:
(setq x (nreverse x))


;; For the vector, it is even simpler because you don’t need setq
(setq x (copy-sequence [1 2 3 4])) ;; => [1 2 3 4]
(nreverse x)                       ;; => [4 3 2 1]
x                                  ;; => [4 3 2 1]

#+end_src

**** make-list
Return a newly created list of length LENGTH, with each element being INIT.

#+begin_src emacs-lisp

(make-list 8 0) ;; => (0 0 0 0 0 0 0 0)

(make-list 3 'pigs) ;; => (pigs pigs pigs)

#+end_src

**** number-sequence
Return a sequence of numbers from FROM to TO (both inclusive) as a list.

#+begin_src emacs-lisp

(number-sequence 5 20 5) ;; (5 10 15 20)

#+end_src

**** seq-random-elt
This function returns an ELEMENT of sequence taken at random.

#+begin_src emacs-lisp

(seq-random-elt [1 2 3 4]) ;; => 2

(seq-random-elt [1 2 3 4]) ;; => 3

#+end_src

**** seqp
This function returns non-nil if object is a sequence (a list or array), or any additional type of sequence defined via seq.el generic functions. This is an extensible variant of ~sequencep~.

#+begin_src emacs-lisp

(seqp [1 2])  ;; => t

(seqp 2)      ;; => nil

#+end_src

** Useful functions
*** buffer-
**** current-buffer
Return the buffer in which Emacs is active; it may not be the buffer that is visible on the screen.

**** buffer-name
Without an argument, return the name of the buffer, as a string.

**** buffer-file-name
Without an argument, return the name of the file the buffer is visiting.

**** other-buffer
Return the most recently selected buffer.

**** switch-to-buffer
Select a buffer for Emacs to be active in and display it in the current window so users can look at it.

**** find-file-noselect
Reads the named file into a buffer and returns the buffer.

Útil para cuando se le pasa el nombre de un archivo como argumento a una función y esta retorna el nombre del buffer, con este nombre se puede setear el buffer con la función  [[set-buffer]] y así trabajar temporalmente en ese buffer.

#+begin_src emacs-lisp

(defun lengths-list-file (filename)
  "Return list of definitions' lengths within FILE.
The returned list is a list of numbers.
Each number is the number of words or
symbols in one function definition."

  (message "Working on `%s' ... " filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)
      (goto-char (point-min))
      (while (re-search-forward "^(defun" nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))

(lengths-list-file
 "/usr/share/emacs/27.1/lisp/emacs-lisp/lisp.el.gz")
;; => (110 42 118 112 39 50 80 255 239 278 285 37 ...)

#+end_src

**** set-buffer
Switch the attention of Emacs to another buffer, but does not redisplay it on the screen.

Para trabajar temporalmente en otro buffer, cambia la atencion al buffer que
se le indique pero no lo muestra en pantalla, trabaja en segundo plano por así decirlo.

**** get-buffer
Find a named buffer or create one if a buffer of that name does not exist. The get-buffer function returns nil if the named buffer does not exist.

**** get-buffer-create
Return the buffer specified by BUFFER-OR-NAME, creating a new one if needed.

**** save-buffer
Save current buffer in visited file if modified.

#+begin_src emacs-lisp

;; Example:
;; Given a file of many lines, like this:

;; at_target(integer tnum, vector targetpos, vector ourpos)

;; For each line, create a file of the same name as first part of the line ➢ for example: 〔at_target.txt〕
;; The file content should be the whole line, with other static text, like this:

;; # --
;; at_target(integer tnum, vector targetpos, vector ourpos)
;; {
;; $0
;; }


;; First, we define few global vars.
;; input file
(setq inputFile "xx_event_forms.txt")

;; other vars
(setq splitPos 0) ;; cursor position of split, for each line
(setq fName "")
(setq restLine "")
(setq moreLines t ) ;; whether there are more lines to parse

;; Now, we open the file, like this:
;; open the file
(find-file inputFile)
(goto-char 1) ;; needed in case the file is already open.

;; Now, we loop thru the lines, like this:
(while moreLines
  (search-forward "(")

  (setq splitPos (1- (point)))
  (beginning-of-line)
  (setq fName (buffer-substring-no-properties (point) splitPos))

  (end-of-line)
  (setq restLine (buffer-substring-no-properties splitPos (point) ))

  ;; create the file
  (find-file fName)
  (insert "# --\n")
  (insert fName restLine "\n{\n$0\n}" )
  (save-buffer)
  (kill-buffer (current-buffer)) ;; close the input file

  (setq moreLines (= 0 (forward-line 1))))

#+end_src

**** with-current-buffer
Temporarily sets a buffer as current to work with. Execute the forms in BODY with BUFFER-OR-NAME temporarily current

Notes: ~find-file~, ~write-file~, or any function that visits a file has many unwanted side-effects, and it can be up to 40 times slower. Here's example of side-effects:

  - It keeps undo info.
  - It syntax color the buffer.
  - It displays the file. (very slow if you have ~global-linum-mode~, etc.)
  - It may have tons of hooks added by others. (~desktop-save-mode~, ~recentf-mode~, ~tabbar-mode~, ~snippet-mode~ (~yasnippet~), …)
  - It may do backup.

#+begin_src emacs-lisp

(with-current-buffer "xyz"
  ;; do something here. delete/insert text, etc.
)

#+end_src

**** with-temp-buffer
Create a temporary buffer, and evaluate BODY there like progn.

Elisp has a buffer data type that's powerful and flexible, and you have over 3 thousand functions that acts on text in a buffer. When you have a string, and you need to do more than just getting substring or number of chars, put it in a temp buffer.

Notes:
- with temp buffer, emacs doesn't do syntax-coloring (which is very slow), disables undo, or any other thing emacs normally do when opening a file for interactive edit.
- I think the difference between ~with-temp-buffer~ and ~with-output-to-temp-buffer~ is that latter works inside the buffer and then outputs the result in that buffer while the other just works inside the buffer but then kills the buffer.

#+begin_src emacs-lisp

;; process string in a temp buffer
(setq myStr "some big string here you need to process")
(setq myStrNew
      (with-temp-buffer
        (insert myStr)
        ;; code to manipulate your string as buffer text
        ;; …
        (buffer-string))) ; get result


;; read-only processing a file without user interaction
(defun my-process-file (fPath)
  "Process the file at path FPATH …"
  (with-temp-buffer fPath
    (insert-file-contents fPath)
    ;; process it …
    ) )

;; write to file ONLY when you actually changed the file
(defun my-process-file (fPath)
  "Process the file at path FPATH …"
  (let ((fileChanged-p nil))
    (with-temp-buffer
      (insert-file-contents fPath)

      ;; process text
      ;; set fileChanged-p to t or nil

      (when fileChanged-p (write-region 1 (point-max) fPath)))))

#+end_src

**** with-output-to-temp-buffer
Bind standard-output to buffer BUFNAME, eval BODY, then show that buffer.

Note: I think the difference between ~with-temp-buffer~ and ~with-output-to-temp-buffer~ is that latter works inside the buffer and then outputs the result in that buffer while the other just works inside the buffer but then kills the buffer.

#+begin_src emacs-lisp

;; Example script

;; -*- coding: utf-8 -*-
;; 2010-11-03
;; add 「title="product title"」 to amazon links on a HTML page.


;; Example:
;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20">amazon</a>
;; =>
;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20" title="Dr. Strangelove; movie">amazon</a>


;; rough steps:
;; find amazon link of the form
;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20">amazon</a>

;; find a Wikipedia link above it, of this form
;; <a href="http://en.wikipedia.org/wiki/Dr._Strangelove">Dr. Strangelove</a>
;; extract the movie title

;; insert the attribute
;; title="…"
;; into the amazon link. Like this
;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20" title="Dr. Strangelove; movie">amazon</a>

(setq outputBuffer "*xah output*" )
(with-output-to-temp-buffer outputBuffer

  (find-file "~/web/xahlee_org/Periodic_dosage_dir/skina/nelci_skina.html" )
  (goto-char 1)

  (while
      (search-forward-regexp "<a class=\"amz\" href=\"http://www.amazon.com/dp/[^\"]+?\">amazon</a>"  nil t)

    (progn
      ;; set points for amazon link
      (backward-char 11)
      (setq amzLinkInsertPoint (point) )

      ;; get title from preceding Wikipedia link
      (search-backward-regexp "<a href=\"http://...wikipedia.org/wiki/[^\"]+?\">\\([^<]+?\\)</a>")
      (setq titleText (match-string 1 ) )

      (when (yes-or-no-p titleText)
        (goto-char amzLinkInsertPoint)
        (insert (concat " title=\"" titleText "; movie\"")) )
      )

    (progn (print "not found"))
    )

  (princ "Done deal!")
  )

#+end_src

**** buffer-size
Return the number of characters in the current buffer.

**** buffer-string
This function returns the contents *of the entire accessible portion* of the current buffer, as a string.

#+begin_src emacs-lisp

(defun get-string-from-file (filePath)
  "Return filePath's file content."
  (with-temp-buffer
    (insert-file-contents filePath)
    (buffer-string)))

#+end_src

**** buffer-substring
Return the contents of part of the current buffer as a string.

#+begin_src emacs-lisp

;; ---------- Buffer: foo ----------
;; This is the contents of buffer foo
;;
;; ---------- Buffer: foo ----------

(buffer-substring 1 10)
;; => "This is t"

(buffer-substring (point-max) 10)
;; => "he contents of buffer foo\n"

#+end_src

If the text being copied has any text properties, these are copied into the string along with the characters they belong to. However, overlays (see Overlays) in the buffer and their properties are ignored, not copied.

For example, if Font-Lock mode is enabled, you might get results like these:

#+begin_src emacs-lisp

(buffer-substring 1 10)
;; => #("This is t" 0 1 (fontified t) 1 9 (fontified t))

#+end_src

**** buffer-substring-no-properties
Emacs's string can have text properties for the purposes of syntax coloring, button, clickable link, etc. if you are doing text processing, usually you don't need text properties.

The ~buffer-substring-no-properties~ function just return a plain string without these properties.

Note: most function that take string as argument can also accept a string that has properties. The function simply ignore the properties.

#+begin_src emacs-lisp

;; get the string from buffer
(setq myStr (buffer-substring-no-properties startPos endPos))

(defun xah/html-get-html-file-title (fname)
  "Return FNAME <title> tag's text.
Assumes that the file contains the string
“<title>…</title>”."
  (with-temp-buffer
    (insert-file-contents fname nil nil nil t)
    (goto-char 1)
    (buffer-substring-no-properties
     (search-forward "<title>") (- (search-forward "</title>") 8))))

#+end_src

**** insert-buffer-substring
Copy a region of text from a buffer that is passed to the function as an
argument and insert the region into the current buffer.

**** mark-whole-buffer
Mark the whole buffer as a region.

**** buffer-modified-p
Return t if BUFFER was modified since its file was last read or saved.

**** ibuffer
Begin using Ibuffer to edit a list of buffers.

**** bufferp
Return t if its argument is a buffer; otherwise return nil.

*** string-
**** message
Print a message in the echo area. The first argument is a string that can contain ~%s~, ~%d~, or ~%c~ to print the value of arguments that follow the string.

- %s :: must be a string or a symbol
- %d :: must be a number
- %c :: must be an ASCII code number; it will be printed as the character with that ASCII code

If there is more than one ~%s~ in the quoted string, the value of the first argument following the quoted string is printed at the location of the first ~%s~ and the value of the second argument is printed at the location of the second ~%s~ and so on.

 #+begin_src emacs-lisp

(message "The name of this buffer is: %s." (buffer-name))
;; => "The name of this buffer is: Emacs.org."


(message "There are %d %s in the office!"
         (- fill-column 14) "pink elephants")
;; => "There are 56 pink elephants in the office!"


(message "%s has %d line%s, %d word%s, and %d character%s."
   str
   lines (if (= lines 1) "" "s")
   words (if (= words 1) "" "s")
   chars (if (= chars 1) "" "s"))
;; => "Region has 5 lines, 26 words, and 167 characters."

 #+end_src

**** format
How a lisp object is converted to string for printing is done by the ~format~ function. It takes a input string, and several other arguments of lisp objects, and output a string.

#+begin_src emacs-lisp

;; print a date format in yyyy-mm-dd, padding with leading “0”
;; format yyyy-mm-dd, ISO 8601 format
(print (format "%04d-%02d-%02d" 2012 4 10))
;; -> "2012-04-10"

;; %x means print a number in hex.
(format "%04x" 1) ;; => "0001"
(format "%02x" 1) ;; => "01"
(format "%01x" 1) ;; => "1"
(format "%x"   1) ;; => "1"
(format "%1x"  1) ;; => "1"
(format "%2x"  1) ;; => " 1"
(format "%4x"  1) ;; => "   1"

(defun xah/insert-random-uuid ()
  "Insert a random UUID.
Example of a UUID: 1df63142-a513-c850-31a3-535fc3520c3d

WARNING: this is a simple implementation. The chance of generating the same UUID is much higher than a robust algorithm.."
  (interactive)
  (insert
   (format "%04x%04x-%04x-%04x-%04x-%06x%06x"
           (random (expt 16 4))
           (random (expt 16 4))
           (random (expt 16 4))
           (random (expt 16 4))
           (random (expt 16 4))
           (random (expt 16 6))
           (random (expt 16 6)))))


(defun wikipedia-url-to-link (url)
  "Return the URL as HTML link string.
Example:
 http://en.wikipedia.org/wiki/Emacs%20Lisp
becomes
 <a href=\"http://en.wikipedia.org/wiki/Emacs%20Lisp\">Emacs Lisp</a>
"
  (let ((linkText url))
    ;; ...
    (format "<a href=\"%s\">%s</a>" url linkText)))

#+end_src

**** print
Output the printed representation of OBJECT, with newlines around it.

The “OBJECT” is any elisp object you want to print. It can be any lisp datatype, such as string, number, list, buffer, frame, …, etc.

Note: output can be read back by function ~read~.

There're also other similar functions:
~prin1~ like ~print~, but does not add newline at end.
~princ~ print without newline nor delimiters. For human reading.

#+begin_src emacs-lisp

(print '("x" "y")) ;; => ("x" "y")
(princ '("x" "y")) ;; => (x y)
(prin1 '("x" "y")) ;; => ("x" "y")

#+end_src

**** princ
Output the printed representation of OBJECT, any Lisp object.

#+begin_src emacs-lisp

;; -*- coding: utf-8 -*-
;; 2011-07-15
;; go thru a file, check if all brackets are properly matched.
;; ➢ for example: good: (…{…}… “…”…)
;; bad: ( [)]
;; bad: ( ( )

(setq inputFile "xx_test_file.txt" ) ; a test file.
(setq inputDir "~/web/xahlee_org/p/time_machine/") ; must end in slash

(defvar matchPairs '() "a alist. For each pair, the car is opening char, cdr is closing char.")
(setq matchPairs '(
                   ("(" . ")")
                   ("{" . "}")
                   ("[" . "]")
                   ("“" . "”")
                   ("‹" . "›")
                   ("«" . "»")
                   ("【" . "】")
                   ("〖" . "〗")
                   ("〈" . "〉")
                   ("《" . "》")
                   ("「" . "」")
                   ("『" . "』")
                   )
      )

(defvar searchRegex "" "regex string of all pairs to search.")
(setq searchRegex "")
(mapc
 (lambda (mypair) ""
   (setq searchRegex (concat searchRegex (regexp-quote (car mypair)) "|" (regexp-quote (cdr mypair)) "|") )
   )
 matchPairs)

(setq searchRegex (substring searchRegex 0 -1)) ; remove the ending “|”

(setq searchRegex (replace-regexp-in-string "|" "\\|" searchRegex t t)) ; change | to \\| for regex “or” operation

(defun my-process-file (fPath)
  "Process the file at FPATH …"
  (let (myBuffer myStack ξchar ξpos)

    (setq myStack '() ) ; each entry is a vector [char position]
    (setq ξchar "") ; the current char found

    (when t
      ;; (not (string-match "/xx" fPath)) ; in case you want to skip certain files

      (setq myBuffer (get-buffer-create " myTemp"))
      (set-buffer myBuffer)
      (insert-file-contents fPath nil nil nil t)

      (goto-char 1)
      (while (search-forward-regexp searchRegex nil t)
        (setq ξpos (point)  )
        (setq ξchar (buffer-substring-no-properties ξpos (- ξpos 1))  )

        ;; (princ (format "-----------------------------\nfound char: %s\n" ξchar) )

        (let ((isClosingCharQ nil) (matchedOpeningChar nil) )
          (setq isClosingCharQ (rassoc ξchar matchPairs))
          (when isClosingCharQ (setq matchedOpeningChar (car isClosingCharQ) ) )

          ;; (princ (format "isClosingCharQ is: %s\n" isClosingCharQ) )
          ;; (princ (format "matchedOpeningChar is: %s\n" matchedOpeningChar) )

          (if
              (and
               (car myStack) ; not empty
               (equal (elt (car myStack) 0) matchedOpeningChar )
               )
              (progn
                ;; (princ (format "matched this top item on stack: %s\n" (car myStack)) )
                (setq myStack (cdr myStack) )
                )
            (progn
              ;; (princ (format "did not match this top item on stack: %s\n" (car myStack)) )
              (setq myStack (cons (vector ξchar ξpos) myStack) ) )
            )
          )
        ;; (princ "current stack: " )
        ;; (princ myStack )
        ;; (terpri )
        )

      (when (not (equal myStack nil))
        (princ "Error file: ")
        (princ fPath)
        (print (car myStack) )
        )
      (kill-buffer myBuffer)
      )
    ))

(require 'find-lisp)

(let (outputBuffer)
  (setq outputBuffer "*xah match pair output*" )
  (with-output-to-temp-buffer outputBuffer
    ;; (my-process-file inputFile) ; use this to test one one single file
    (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$")) ; do all HTML files
    (princ "Done deal!")))

#+end_src

**** insert
Insert the arguments, either strings or characters, at point.

#+begin_src emacs-lisp

;; insert string at current cursor position
(insert "i ♥ cats")

#+end_src

**** insert-char
Insert COUNT copies of CHARACTER.

**** delete-char
Delete the following N characters (previous if N is negative).

**** concat
Links together or unites two or more strings of text to produce a string. The arguments are strings.

#+begin_src emacs-lisp

(concat "a" "b") ;; => "ab"

#+end_src

**** substring
The function returns a substring of the first argument. This function takes three arguments. Its first argument is the string of characters, the second and third arguments are numbers that indicate the beginning (inclusive) and end (exclusive) of the substring.

You can think of the substring function as a kind of atom smasher since it takes an otherwise indivisible atom (string) and extracts a part.

#+begin_src emacs-lisp

(substring "The quick brown fox jumped." 16 19) ;; => "fox"

#+end_src

**** split-string
Split STRING into substrings bounded by matches for SEPARATORS.

#+begin_src emacs-lisp

(defun read-lines (filePath)
  "Return a list of lines of a file at filePath."
  (with-temp-buffer
    (insert-file-contents filePath)
    (split-string (buffer-string) "\n" t)))

;; Once you have a list, you can use mapcar to process each element in
;; the list. If you don't need the resulting list, use mapc.

;; Note: in elisp, it's more efficient to process text in a buffer than
;; doing complicated string manipulation with string data type. But, if
;; your lines are all short and you don't need to know the text that
;; comes before or after current line, then, list of lines can be easier
;; to work with.

#+end_src

**** string-match
Returns the *index* of the start of the first match for the regular expression regexp in string, or ~nil~ if there is no match. If start is non-~nil~, the search starts at that index in string.

#+begin_src emacs-lisp

(string-match
 "quick" "The quick brown fox jumped quickly.")   ;; => 4

(string-match
 "quick" "The quick brown fox jumped quickly." 8) ;; => 27

(defun xah/drop-last-slashed-substring (path)
  "Drop the last path separated by “/”.
For example:
“/a/b/c/d” → “/a/b/c”
“/a/b/c/d/” → “/a/b/c/d”
“/” → “”
“//” → “/”
“” → “”"
  (if (string-match "\\(.*/\\)+" path)
      (substring path 0 (1- (match-end 0)))
    path))

#+end_src

**** search-forward
Search for a *string*, and if the string is found, *move point*. With a regular expression, use the similar [[re-search-forward]].

~search-forward~ and ~re-search-forward~ take four arguments:

1. The string or regular expression to search for.
2. Optionally, the limit of the search.
3. Optionally, what to do if the search fails, return nil or an error message.
4. Optionally, how many times to repeat the search; if negative, the search goes backwards.

Note: Due the way computers are built, the Lisp interpreter may treat a single character as being different from a string of characters. Inside the computer, a single character has a different electronic format than a string of one character. (A single character can often be recorded in the computer using exactly one byte; but a string may be longer, and the computer needs to be ready for this.)

In emacs buffer, newline char is ~\n~. So, you can use ~(search-forward "\n")~ if you really need to find the end of line character.

#+begin_src emacs-lisp

(search-forward "target-string"
                limit-of-search
                what-to-do-if-search-fails
                repeat-count)


;; idiom for string replacement in current buffer;
(let ((case-fold-search t)) ; or nil

  (goto-char (point-min))
  (while (search-forward "myStr1" nil t) (replace-match "myReplaceStr1"))

  (goto-char (point-min))
  (while (search-forward "myStr2" nil t) (replace-match "myReplaceStr2"))
  ;; repeat for other string pairs
)
;; if you need regexp, use search-forward-regexp


;; You want to do more than one pair of find/replace strings
;;    & → &amp;
;;    < → &lt;
;;    > → &gt;
(defun replace-html-chars-region (begin end)
  "Replace “<” to “&lt;” etc in region."
  (interactive "r")
  (save-restriction
    (narrow-to-region begin end)

    (goto-char (point-min))
    (while (search-forward "&" nil t) (replace-match "&amp;" nil t))

    (goto-char (point-min))
    (while (search-forward "<" nil t) (replace-match "&lt;" nil t))

    (goto-char (point-min))
    (while (search-forward ">" nil t) (replace-match "&gt;" nil t))))

#+end_src

**** search-backward
Search backward from point for STRING. Move cursor to the location of a string, returns the new position.

**** current-word
This function returns the symbol (or word) at or near point, as a string. The return value includes no text properties.

**** symbol-name
Return SYMBOL's name, a string.

**** thing-at-point
Return the thing around or next to point, as a string.

The argument thing is a symbol which specifies a kind of syntactic entity (symbol, list, sexp, defun, filename, url, word, sentence, whitespace, line, page, and others).

~thing-at-point~ does have some annoyances. For example, when getting a line, it'll normally include the newline char "\n", but not if the line is at the end of buffer.

Note: emacs's concept of “symbol” is like a “identifier”. It usually includes a to z, 0 to 9, underscore “_”, and sometimes hyphen “-”. The exact charset of “symbol” depends on current major mode's Syntax Table.

#+begin_src emacs-lisp

;; ---------- Buffer: foo ----------
;; Gentlemen may cry ``Pea∗ce! Peace!,''
;; but there is no peace.
;; ---------- Buffer: foo ----------

(thing-at-point 'word)
;; => "Peace"
(thing-at-point 'line)
;; => "Gentlemen may cry ``Peace! Peace!,''\n"
(thing-at-point 'whitespace)
;; => nil

(defun xah/print-current-word-and-line ()
  "print current word and line."
  (interactive)
  (message "%s and %s" (thing-at-point 'word))
                       (thing-at-point 'line))

;; Without thing-at-point
(defun xah/print-current-word-2 ()
  "print current word."
  (interactive)
  (let (p1 p2)
    (save-excursion
      (skip-chars-backward "-a-z0-9")
      (setq p1 (point))
      (skip-chars-forward "-a-z0-9")
      (setq p2 (point))
      (message "%s" (buffer-substring-no-properties p1 p2)))))

;; grab the current “symbol”.
(setq myStr (thing-at-point 'symbol))

;; If you are writing PHP reference lookup command, and the cursor is on
;; p in print_r($y);, you want to grab the whole “print_r” not just
;; “print”.

;; Here's a example of PHP reference lookup command that grabs by
;; “symbol” if there's no active region.
(defun xah/php-lookup ()
  "Look up current word in PHP ref site in a browser.

If a region is active (a phrase), lookup that phrase."
  (interactive)
  (let (myWord myUrl)
    (setq myWord
          (if (use-region-p)
              (buffer-substring-no-properties (region-beginning) (region-end))
            (thing-at-point 'symbol)))
    (setq myUrl
          (concat "http://us.php.net/" myWord))
    (browse-url myUrl)))

#+end_src

**** make-string
Return a newly created string of length LENGTH, with INIT in each element.

#+begin_src emacs-lisp

(make-string 3 65) ;; => "AAA"

(make-string 3 ? ) ;; => "   "

#+end_src

**** char-equal
Return t if two characters match, optionally ignoring case.

**** char-before
Return character in current buffer preceding position POS.

Similar functions is ~char-after~.

**** gnus-url-unhex-string
Remove %XX, embedded spaces, etc in a url.

#+begin_src emacs-lisp

(require 'gnus-util) ; for gnus-url-unhex-string

(defun xah/wikipedia-url-to-link (url)
  "Return the URL as HTML link string.
Example:
 http://en.wikipedia.org/wiki/Emacs%20Lisp
becomes
 <a href=\"http://en.wikipedia.org/wiki/Emacs%20Lisp\">Emacs Lisp</a>
"
  (let ((linkText url))
    ; decode percent encoding. ➢ for example: %20
    (setq linkText (gnus-url-unhex-string linkText nil))
    ; get last part
    (setq linkText (car (last (split-string linkText "/"))))
    ; low line → space
    (setq linkText (replace-regexp-in-string "_" " " linkText ))
    (format "<a href=\"%s\">%s</a>" url linkText)))

#+end_src

*** regexp-
**** looking-at
Return t for true if the text directly following *point* matches the argument, which should be a regular expression.

This function does not move point, but it updates the match data, which you can access using [[match-beginning]] and [[match-end]].

#+begin_src emacs-lisp

(looking-at "The cat in the hat$") ;; => t
;; The cat in the hat comes back" twice.

#+end_src

**** re-search-forward
Search for a *pattern* (regular expression), and if the pattern is found, *move point* to rest just after it. With a string, use the similar [[search-forward]].

~search-forward~ and ~re-search-forward~ take four arguments:

  1. A regular expression that specifies the pattern to search for. (Remember to put quotation marks around this argument!)
  2. Optionally, the limit of the search.
  3.  Optionally, what to do if the search fails, return nil or an error message.
  4. Optionally, how many times to repeat the search; if negative, the search goes backwards.

#+begin_src emacs-lisp

(re-search-forward "\*+ *" nil t)
;; This function moves ahead of the match string
;; (1 or more * and 0 or more blanks) and returns the
;; point number or nil in case of no match, instead of error.


;; This lets you select current block of text. (a block here is text
;; between empty lines.)
(defun xah/select-current-block ()
  "Select the current block of text between blank lines.
URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2016-07-22"
  (interactive)
  (let (-p1)
    (progn
      (if (re-search-backward "\n[ \t]*\n" nil "move")
          (progn (re-search-forward "\n[ \t]*\n")
                 (setq -p1 (point)))
        (setq -p1 (point)))
      (re-search-forward "\n[ \t]*\n" nil "move"))
    (set-mark -p1)))


(defun xah/select-block ()
  "Select the current/next block of text between blank lines.
If region is active, extend selection downward by block.
URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2016-07-22"
  (interactive)
  (if (region-active-p)
      (re-search-forward "\n[ \t]*\n" nil "move")
    (xah-select-current-block)))


;; Sometimes when you you write text, you duplicate words—as with “you
;; you” near the beginning of this sentence. I call the function for
;; detecting duplicated words, the-the.
(defun the-the ()
  "Search forward for for a duplicated word."
  (interactive)
  (message "Searching for for duplicated words ...")
  (push-mark)

  ;; This regexp is not perfect
  ;; but is fairly good over all:
  (if (re-search-forward
       "\\b\\([^@ \n\t]+\\)[ \n\t]+\\1\\b" nil 'move)
      (message "Found duplicated word.")
    (message "End of buffer")))

#+end_src

**** search-forward-regexp
Put your cursor to the right of the closing parenthesis, then call ~eval-last-sexp~. If your regex matches, it'll move cursor to the last char of the matched text. If you get a lisp error saying search failed, then your regex didn't match. If you get a lisp syntax error, then you probably screwed up on the backslashs.

One interesting aspect about ~search-forward-regexp~ is that you must use 2 backslashes to represent one backslash. This is because backslash in emacs string needs a backslash to represent it. Then, this string is passed to emacs's regex engine.

#+begin_src emacs-lisp

(defun xah/clean-Mathematica-graphics-buffer ()
  "Remove whitespace, truncate numbers, of current buffer of Mathematica graphics file.
This command does several find/replace on the current buffer.
Removing spaces, removing new lines, truncate numbers to 3 decimals,
e.g., 0.123456 -> 0.123.
\
\\
The goal of these replacement is to reduce the file size of a Mathematica Graphics file (.mgs) that are read over the net by JavaView."
  (interactive)

  (goto-char 1)
  (while (search-forward "\n" nil t) (replace-match "" nil t))

  (goto-char 1)
  (while (search-forward-regexp "  +" nil t) (replace-match " " nil t))

  (goto-char 1)
  (while (search-forward ", " nil t) (replace-match "," nil t))

  (goto-char 1)
  (while (search-forward-regexp "\\([0-9]\\)\\.\\([0-9][0-9][0-9]\\)[0-9]+" nil t) (replace-match "\\1.\\2" t nil)))

#+end_src

**** match-beginning
Return the *position* of the start of the text found by the *last* regular expression search.

#+begin_src emacs-lisp

(let ((case-fold-search nil) p1 p2)
  (re-search-forward "\\([0-9]+\\)")
  (setq p1 (match-beginning 1))
  (setq p2 (match-end 1))
  (buffer-substring-no-properties p1 p2))
;; lots sample text 123 abc
;; "123"

#+end_src

**** match-end
Return *position* of end of text matched by *last* search.

#+begin_src emacs-lisp

(string-match "\\(qu\\)\\(ick\\)"
              "The quick fox jumped quickly.") ;; => 4

(match-end 1)             ; The end of the match
;;   => 6                 ;   with `qu' is at index 6.

(match-end 2)             ; The end of the match
;;   => 9                 ;   with `ick' is at index 9.

#+end_src

**** match-data
Return a list describing what the last search matched.

**** perform-replace
This function is the guts of ~query-replace~ and related commands. It searches for occurrences of from-string and *replaces* some or all of them. If query-flag is ~nil~, it replaces all occurrences; otherwise, it asks the user what to do about each one.

**** replace-match
This function *replaces* the buffer text matched by the last search, with replacement. It applies only to buffers; you can't use ~replace-match~ to replace a substring found with [[string-match]].

To control letter case of the replacement, use the optional arguments in your ~replace-match~ function. To control the letter case of search, locally set ~case-fold-search~ to ~t~ or ~nil~.

#+begin_src emacs-lisp

(defun replace-greek-region (start end)
  "Replace “alpha” to “α” and other greek letters in current region."
  (interactive "r")
  (save-restriction
    (narrow-to-region start end)
    (goto-char (point-min))
    (while (search-forward " alpha" nil t) (replace-match " α" nil t))
    (goto-char (point-min))
    (while (search-forward " beta" nil t) (replace-match " β" nil t))
    (goto-char (point-min))
    (while (search-forward " gamma" nil t) (replace-match " γ" nil t))))

;; remove js links in html file
    (while (search-forward "<script src=\"http://...</script>" nil t)
      (replace-match ""))

#+end_src

**** replace-regexp-in-string
Replace all matches for REGEXP with REP in STRING.

#+begin_src emacs-lisp

;; replace that
;; <img src="my_cat.png" alt="" width="832" height="513">
;; with that
;; <img src="my_cat.png" alt="my cat" width="832" height="513">

;; give regex search pattern
;; (let regexp "<img src=\"\\([^\"]+?\\)\" alt=\"\" width=\"\\([0-9]+\\)\" height=\"\\([0-9]+\\)\">")

(search-forward-regexp regexp nil t)

(concat
 "<img src=\""(match-string 1)"\"

 alt=\""(replace-regexp-in-string ".png" ""
    (replace-regexp-in-string "_" " " (match-string 1)))"\"

 width=\""(match-string 2)"\"

 height=\""(match-string 3)"\">"
 )

;; To replace this but in all files of a directory do this

;; List and Mark Files in Subdirectories

;; Call find-dired, then give the dir name, then give -name "*html". The
;; result is all HTML files in that dir and subdir. (open files)

;; Now, mark the files you want, by calling dired-mark-files-regexp 【%
;; m】. Then give the pattern \.html. This marks all HTML files.  Dired
;; Query Replace by Regexp (mark files)

;; To do regexp replace on dired marked files, call
;; dired-do-query-replace-regexp.

#+end_src

**** regexp-quote
This function returns a *regular expression string* that matches exactly string and nothing else. This allows you to request an exact string match when calling a function that wants a regular expression.

#+begin_src emacs-lisp

(regexp-quote "^The cat$")
;; => "\\^The cat\\$"

#+end_src

One use of ~regexp-quote~ is to combine an exact string match with context described as a regular expression. For example, this searches for the string which is the value of string, surrounded by whitespace:

#+begin_src emacs-lisp

(re-search-forward
 (concat "\\s " (regexp-quote string) "\\s "))

#+end_src

**** skip-chars-forward
Move point forward, stopping before a char not in STRING, or at pos LIM. Returns the distance traveled.

*NOTE:* STRING is like the inside of a [...] in a regular expression except that ] is never special and \ quotes ^, - or \ (but not at the end of a range; quoting is never needed there).
Thus, *with arg "a-zA-Z", this skips letters stopping before first nonletter. With arg "^a-zA-Z", skips nonletters stopping before first letter*.

#+begin_src emacs-lisp

;; Placing point (24) just after the expession
(skip-chars-forward "h")hhhh hhhh
;; => 4 (jump first 4 h)
(skip-chars-forward "h") hhhh hhhh
;; => 0 (no match)
(skip-chars-forward "^h")hhhh hhhh
;; => 0 (no match)
(skip-chars-forward "^h") hhhh hhhh
;; => 1 (jump first 1 space)


(defun xah/select-inside-quotes ()
  "Select text between double straight quotes
on each side of cursor."
  (interactive)
  (let (p1 p2)
;; p1 is set to the position of the double quote to the left of cursor
    (skip-chars-backward "^\"")
    (setq p1 (point))
    (skip-chars-forward "^\"")
    (setq p2 (point))

    (goto-char p1)
    (push-mark p2)
    (setq mark-active t)))


(defun xah/delete-enclosed-text ()
  "Delete texts between any pair of delimiters."
  (interactive)
  (save-excursion
    (let (p1 p2)
      (skip-chars-backward "^([<>“") (setq p1 (point))
      (skip-chars-forward "^)]<>”") (setq p2 (point))
      (delete-region p1 p2))))

#+end_src

**** skip-chars-backward
Move point backward, stopping after a char not in STRING, or at pos LIM.

#+begin_src emacs-lisp

;; turn on highlight selection
(transient-mark-mode 1)

(defun xah/select-current-word ()
  "Select the word under cursor.
“word” here is considered any alphanumeric sequence with “_” or “-”."
  (interactive)
  (let (pt)
    (skip-chars-backward "-_A-Za-z0-9")
    (setq pt (point))
    (skip-chars-forward "-_A-Za-z0-9")
    (set-mark pt)))

#+end_src

**** string-match
~(string-match REGEXP STRING &optional START)~

Return index of start of first match for REGEXP in STRING, or nil.

#+begin_src emacs-lisp

(string-match "i" (system-name)) ;; => 3

(system-name) ;; => "debian"

#+end_src

**** match-string
Return string of text matched by last search.

Whenever you call regex functions such as [[re-search-forward]], [[string-match]], [[replace-regexp-in-string]], [[search-forward-regexp]], the captured text is stored in ~match-string~.

 NUM an is integer.

 - 0 means the whole matched text.
 - 1 means first captured group.
 - 2 means second captured group.
    etc.

#+begin_src emacs-lisp

(setq xx "swimming in sea")

(string-match "\\([a-z]+?ing\\) " xx)

(match-string 1 xx)
;; => "swimming"

#+end_src

#+begin_src html

<!-- Suppose you have thousands of links like this: -->

<a href="…/this_and_that">this_and_that</a>

<!-- you want to change the link text so that _ is replaced by space,
like this: -->

<a href="…/this_and_that">this and that</a>

<!-- First, you need to use regex find / replace to match the
links. Then, you need a function to to transform the matched
pattern. -->

#+end_src

*Call Function in Replacement String*

You can use a function as your replacement string.

In the replace string prompt, give ~\,(function_name)~, where ~function_name~ is your elisp function.

The function needs no argument. Its return value is used as the replacement string.

The task here is to write the replacement function.

#+begin_src emacs-lisp

;; So, with this function written, we can call query-replace-regexp, then give this pattern:

;; >\([_A-Za-z0-9]+\)</a>

;; And the replacement expression would be:

;; \,(ff)

;; Here's a example where i need to find all Wikipedia links and change the link text to use space instead of _.

(defun xah/wikipedia-link-replacement ()
  "Returns a canonical form of Wikipedia link from a regex match.

The regex to be used for this function is:

 <a href=\"http://\\(..\\)\\.wikipedia.org/wiki/\\([^\"]+\\)\">\\(\\([-.A-Za-z0-9]+_\\)+[-.A-Za-z0-9]+ ?\\)</a>

To use this function, call `query-replace-regexp', then in the replacement prompt give:
 \\,(wikipedia-link-replacement)
"
  (let (langCode articlePath linkText linkText2 returnText)
    (setq langCode (match-string 1)) ;; \\(..\\)
    (setq articlePath (match-string 2)) ;; \\([^\"]+\\)
    (setq linkText (match-string 3))
    (setq linkText2 (replace-regexp-in-string "_" " " articlePath))
    (setq returnText
          (concat "<a href=\"http://"
                  langCode ".wikipedia.org/wiki/"
                  articlePath "\">" linkText2 "</a>" ))
    returnText ) )

;; The (match-string 1) gives you the first captured string. (“1” is for
;; 1st captured pattern, “2” for 2nd captured pattern. “0” is the entire
;; match.).

#+end_src

**** match-string-no-properties
Same as [[match-string]] but without Text Properties.

#+begin_src emacs-lisp

(let ((case-fold-search nil))
  (re-search-forward "\\([0-9]+\\)")
  ;; lots text 123 abc
  (match-string-no-properties 1))
; "123"

#+end_src

**** highlight-lines-matching-regexp
Highlight all lines that match REGEXP using FACE.

#+begin_src emacs-lisp

;; This example shows you how to make lines containing the words “ERROR:”
;; or “NOTE:” highlighted, whenever a file ending in “log” is opened.

(defun highlite-it ()
  "Highlight certain lines…"
  (interactive)
  (if (equal "log" (file-name-extension (buffer-file-name)))
      (progn
        (highlight-lines-matching-regexp "ERROR:" 'hi-red-b)
        (highlight-lines-matching-regexp "NOTE:" 'hi-blue-b))))

(add-hook 'find-file-hook 'highlite-it)

;; The add-hook line will make emacs call “highlite-it” whenever a file
;; is opened. It works by adding the function “highlite-it” to the list
;; in the variable find-file-hook.

;; find-file is the function that open files. find-file-hook is a
;; variable containing list of functions that will run when find-file is
;; run.

#+end_src

*** point-
**** point
Return the value of the current position of the cursor, as an integer counting the number of characters from the beginning of the buffer.

**** point-min
Return the minimum permissible value of point in the current buffer. This is 1, unless narrowing is in effect.

**** point-max
Return the value of the maximum permissible value of point in the current buffer. This is the end of the buffer, unless narrowing is in effect.

**** goto-char
Set point to the location specified by the value of the argument.

**** line-beginning-position
Return the character position of the first character on the current line.

**** line-end-position
Return the character position of the last character on the current line.

**** forward-char
Move point N characters forward (backward if N is negative).

**** backward-char
Move point N characters backward (forward if N is negative).

**** bounds-of-thing-at-point
Determine the start and end buffer locations for the THING at point.

Often you want a command that works on the current word (or line, paragraph), but if there is a text selection, take the text selection as input. Here's a template for this and other examples.

Sometimes, you need to not just grab current word, but do other things such as delete the word. You need to know the beginning and ending positions of the region you are interested. Use ~bounds-of-thing-at-point~.


#+begin_src emacs-lisp

(defun xah/downcase-word-or-region ()
  "Downcase current word or region."
(interactive)
(let (pos1 pos2 bds)
  (if (use-region-p)
     (setq pos1 (region-beginning) pos2 (region-end))
    (progn
      (setq bds (bounds-of-thing-at-point 'symbol))
      (setq pos1 (car bds) pos2 (cdr bds))))

  ;; now, pos1 and pos2 are the starting and ending positions of the
  ;; current word, or current text selection if exist.
  (downcase-region pos1 pos2)))


(defun xah/get-boundary-and-thing ()
  "Returns the boundary positions of the text unit under cursor."
  (interactive)
  (let (bounds pos1 pos2 mything)
    (setq bounds (bounds-of-thing-at-point 'symbol))
    (setq pos1 (car bounds))
    (setq pos2 (cdr bounds))
    (setq mything (buffer-substring-no-properties pos1 pos2))

    (message
     "thing begin at [%s], end at [%s], thing is [%s]"
     pos1 pos2 mything)))


(defun ake/html-table-string (textblock delim)
  "Turn a text string into a HTML table.
See make-html-table."
  (let ()
    (setq textblock (replace-regexp-in-string delim "</td><td>" textblock))
    (setq textblock (replace-regexp-in-string "\n" "</td></tr>\n<tr><td>" textblock))
    (setq textblock (substring textblock 0 -8)) ;; delet the beginning “<tr><td>” in last line
    (concat "<table border=\"1\" cellpadding=\"5\" cellspacing=\"0\">\n<tr><td>" textblock "</table>")
    ))

(defun make-html-table (sep)
  "Turn the current paragraph into a HTML table.

The “current paragraph” is defined as having empty lines before and
after the block of text the cursor is on.

For example:

a*b*c
1*2*3
this*and*that

with “*” as separator, becomes

<table border=\"1\" cellpadding=\"5\" cellspacing=\"0\">
<tr><td>a</td><td>b</td><td>c</td></tr>
<tr><td>1</td><td>2</td><td>3</td></tr>
<tr><td>this</td><td>and</td><td>that</td></tr>
</table>"
  (interactive "sEnter string pattern for column separation:")
  (let (bds p1 p2 myStr)
    (setq bds (bounds-of-thing-at-point 'paragraph))
    (setq p1 (+ (car bds) 1))
    (setq p2 (cdr bds))
    (setq myStr (buffer-substring-no-properties p1 p2))
    (delete-region p1 p2)
    (insert (make-html-table-string myStr sep) "\n")))

#+end_src

**** eobp
Return t for true if point is at the end of the accessible part of a buffer. The end of the accessible part is the end of the buffer if the buffer is not narrowed; it is the end of the narrowed part if the buffer is narrowed.

*** mark-
**** push-mark
Sets a mark at the current position of the cursor.

**** set-mark-command
Set the mark where point is, and activate it; or jump to the mark.

When ~set-mark-command~ is called, the region becomes active (highlighted). When a command is called, it typically set the region status to inactive.

This means, when you set mark using the keyboard or the mouse, text selection become highlighted, then after you called some command, the region returns to inactive again (and the highlighting goes away).

**** transient-mark-mode
Toogle transient mark mode. When enabled, the *region is highlighted* with the region face whenever the mark is active.

~transient-mark-mode~ is on by default, and many command's behavior changed. If there is a text selection, the command acts on it, else it acts on the current word, line, paragraph, buffer (or whatever is its default input).

**** mark-active
Variable. Non-nil means the mark and region are currently active in this buffer.

#+begin_src emacs-lisp

(defun xar/select-line ()
  "Select current line."
  (interactive)
  (let (p1 p2)
    (setq p1 (line-beginning-position))
    (setq p2 (line-end-position))
    (goto-char p1)
    (push-mark p2)
    (setq mark-active t)))

#+end_src

*** region-
**** region-beginning
Return the integer value of point or mark, whichever is smaller.

**** region-end
Return the integer value of point or mark, whichever is larger.

**** delete-region
Delete the text between START and END.

**** use-region-p
Return t if the region is active and it is appropriate to act on it.

The function ~use-region-p~ basically checks 3 things:
- ~transient-mark-mode~ is on.
- ~mark-active~ is true.
- region isn't empty by checking ~use-empty-active-region~.


#+begin_src emacs-lisp

;; Often you want a command that works on the current word (or line,
;; paragraph), but if there is a text selection, take the text selection
;; as input.
(defun xah/downcase-word-or-region ()
  "Downcase current word or region."
(interactive)
(let (pos1 pos2 bds)
  (if (use-region-p)
     (setq pos1 (region-beginning) pos2 (region-end))
    (progn
      (setq bds (bounds-of-thing-at-point 'symbol))
      (setq pos1 (car bds) pos2 (cdr bds))))

  ;; now, pos1 and pos2 are the starting and ending positions of the
  ;; current word, or current text selection if exist.
  (downcase-region pos1 pos2)))

#+end_src

**** kill-region
Cuts the text between point and mark from the buffer and stores that text in the kill ring, so you can get it back by yanking.

#+begin_src emacs-lisp

;; cut text between buffer positions and push it to kill-ring.
(kill-region 247 528)

#+end_src

**** kill-ring-save
Save the region as if killed, but don't kill it.

#+begin_src emacs-lisp

;; copy text between buffer positions and push it to kill-ring.
(kill-ring-save 247 528)

#+end_src

**** kill-new
Make STRING the latest kill in the kill ring.

[[kill-ring-save]] copy text between buffer positions and push it to ~kill-ring~ if you already have a string, use ~kill-new~

#+begin_src emacs-lisp

;; push a string into kill-ring
(kill-new "dragon dragon")

(defun xah/copy-all ()
  "Put the whole buffer content into the `kill-ring'.
(respects `narrow-to-region')
URL `http://ergoemacs.org/emacs/elisp_cut_copy_yank_kill-ring.html'
Version 2015-05-06"
  (interactive)
  (kill-new (buffer-string))
  (message "Buffer content copied."))

#+end_src

**** kill-append
Append STRING to the end of the latest kill in the kill ring.

**** narrow-to-region
Restrict editing in this buffer to the current region.

Whenever you work in a region, remember that the boundaries of the text that you are interested is changed when you add or remove text in that region. Don't just call ~(something-region p1 p2)~ again, because ~p2~ is no longer the correct boundary. Use ~save-restriction~ and ~narrow-to-region~.

#+begin_src emacs-lisp

;; idiom for string replacement within a region
(save-restriction
  (narrow-to-region pos1 pos2)

  (goto-char (point-min))
  (while (search-forward "myStr1" nil t) (replace-match "myReplaceStr1"))

  ;; repeat for other string pairs
)

#+end_src

**** copy-region-as-kill
Copies the text between point and mark into the kill ring, from which you can get it by yanking. The function does not cut or remove the text from the buffer.

**** delete-and-extract-region
Removes the text between point and mark from the buffer and throws it away. You cannot get it back. (This is not an interactive command.)

**** widen
Remove restrictions (narrowing) from current buffer.

 This function is usually not needed—Emacs creates a fresh buffer if none already exists; but if a buffer visiting the file already exists Emacs returns that one. In this case, the buffer may be narrowed and must be widened.

*** file-
**** write-region
Write current region into specified file.

Modify Files: If you want to write to file ONLY when you actually changed the file, you can create flag variable and call write-region, like this:

#+begin_src emacs-lisp

(defun my-process-file (fPath)
  "Process the file at path FPATH …"
  (let ((fileChanged-p nil))
    (with-temp-buffer
      (insert-file-contents fPath)

      ;; process text
      ;; set fileChanged-p to t or nil

      (when fileChanged-p (write-region 1 (point-max) fPath)))))

#+end_src

**** with-temp-file
Create a new buffer, evaluate BODY there, and write the buffer to FILE.

when doing batch text processing of thousands of files, don't use ~find-file~, use ~with-temp-buffer~ or ~with-temp-file~ instead. (use the latter when you need to make changes to the file.

**** insert-file-contents
Insert contents of file FILENAME after point.

#+begin_src emacs-lisp

(defun get-string-from-file (filePath)
  "Return filePath's file content."
  (with-temp-buffer
    (insert-file-contents filePath)
    (buffer-string)))

#+end_src

**** append-to-file
Append the contents of the region to the end of file FILENAME.

**** file-name-directory
Return the directory component in file name FILENAME.

**** file-name-nondirectory
Return file name FILENAME sans its directory.

**** file-name-extension
Get suffix.

**** file-name-sans-extension
Return FILENAME sans final "extension".

**** file-relative-name
Get relative path.

**** expand-file-name
Convert filename NAME to absolute, and canonicalize it. The function employs the name of the directory in which the function is called.

#+begin_src emacs-lisp

;; if expand-file-name is called when Emacs is visiting
;; the /usr/local/share/emacs/22.1.1/lisp/emacs-lisp/

(expand-file-name "debug.el")
;; => /usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el

#+end_src

**** dired-get-marked-files
Return the marked files' names as list of strings.

#+begin_src emacs-lisp

;; To apply a function to marked files in dired

;; idiom for processing a list of files in dired's marked files

;; suppose myProcessFile is your function that takes a file path
;; and do some processing on the file

(defun dired-myProcessFile ()
  "apply myProcessFile function to marked files in dired."
  (interactive)
  (require 'dired)
  (mapc 'myProcessFile (dired-get-marked-files)))

#+end_src

**** rename-file
Rename FILE as NEWNAME.  Both args must be strings.

**** copy-file
Copy FILE to NEWNAME.  Both args must be strings.

#+begin_src emacs-lisp

(defun xah/make-backup ()
  "Make a backup copy of current buffer's file.
Create a backup of current buffer's file.
The new file name is the old file name with trailing “~”, in the same dir.
If such a file already exist, append more “~”.
If the current buffer is not associated with a file, its a error."
  (interactive)
  (let (fName backupName)
    (setq fName (buffer-file-name))
    (setq backupName (concat fName "~"))

    (while (file-exists-p backupName)
      (setq backupName (concat backupName "~")))

    (copy-file fName backupName t)
    (message (concat "Backup saved as: " (file-name-nondirectory backupName)))))

#+end_src

**** delete-file
Delete file named FILENAME.  If it is a symlink, remove the symlink.

#+begin_src emacs-lisp

(defun xah/delete-current-file ()
  "Delete the file associated with the current buffer.
Delete the current buffer too.
If no file is associated, just close buffer without prompt for save."
  (interactive)
  (let (currentFile)
    (setq currentFile (buffer-file-name))
    (when (yes-or-no-p (concat "Delete file?: " currentFile))
      (kill-buffer (current-buffer))
      (when (not (equal currentFile nil))
        (delete-file currentFile) ) ) ) )

#+end_src

**** file-exists-p
Return t if file FILENAME exists (whether or not you can read it).

#+begin_src emacs-lisp

(defun xah/make-backup ()
  "Make a backup copy of current buffer's file.
Create a backup of current buffer's file.
The new file name is the old file name with trailing “~”, in the same dir.
If such a file already exist, append more “~”.
If the current buffer is not associated with a file, its a error."
  (interactive)
  (let (fName backupName)
    (setq fName (buffer-file-name))
    (setq backupName (concat fName "~"))

    (while (file-exists-p backupName)
      (setq backupName (concat backupName "~")))

    (copy-file fName backupName t)
    (message (concat "Backup saved as: " (file-name-nondirectory backupName)))))

#+end_src

**** set-file-modes
Set mode bits of file named FILENAME to MODE (an integer).

*** dir-
**** directory-files
Return a list of names of files in DIRECTORY.

No recurse into sub-directories, for using recursive directories you can try these functions, find-lisp-find-files, find-lisp-find-files-internal from find-lisp package.

**** make-directory
Create the directory DIR and optionally any nonexistent parent dirs.

Non existent paren dirs will be created.

**** delete-directory
Delete the directory named DIRECTORY.  Does not follow symlinks.

Whole dir.

**** copy-directory
Copy DIRECTORY to NEWNAME.  Both args must be strings.

Whole dir.

*** math-
**** random
Elisp's random function can be called in 3 ways:

  - ~(random t)~. Set a random seed based on current time and PID (process ID).
  - ~(random n)~. Returns a random number between ~0~ and ~n-1~, including possible ~0~ and ~n-1~.
  - ~(random)~. Returns a random number between ~0~ and ~2^29-1~, inclusive.

**** expt
Return the exponential ARG1 ** ARG2.

**** truncate
This returns number, converted to an integer by rounding towards zero.

#+begin_src emacs-lisp

(truncate  1.2)  ;; =>  1
(truncate  1.7)  ;; =>  1
(truncate -1.2)  ;; => -1
(truncate -1.7)  ;; => -1

#+end_src

**** floor
This returns number, converted to an integer by rounding downward (towards negative infinity).

If divisor is specified, this uses the kind of division operation that corresponds to mod, rounding downward.

#+begin_src emacs-lisp

(floor  1.2) ;; =>  1
(floor  1.7) ;; =>  1
(floor -1.2) ;; => -2
(floor -1.7) ;; => -2

(floor 5.99 3) ;; => 1
(floor 6.01 3) ;; => 2

#+end_src

**** ceiling
This returns number, converted to an integer by rounding upward (towards positive infinity).

#+begin_src emacs-lisp

(ceiling  1.2) ;; =>  2
(ceiling  1.7) ;; =>  2
(ceiling -1.2) ;; => -1
(ceiling -1.7) ;; => -1

#+end_src

**** round
This returns number, converted to an integer by rounding towards the nearest integer. Rounding a value equidistant between two integers returns the even integer.

#+begin_src emacs-lisp

(round  1.2) ;; =>  1
(round  1.7) ;; =>  2
(round -1.2) ;; => -1
(round -1.7) ;; => -2

#+end_src

**** max
Return largest of all the arguments (which must be numbers or markers).

#+begin_src emacs-lisp

(max 5 9 6 3 48) ;; => 48

;; max into a list
(apply 'max '(1 2 3 4)) ;; => 4
(funcall 'max '(1 2 3 4))
;; => error because "funcall" would pass that argument to the function "max"
;; which precisely cannot recive the list as an argument while "apply" does,
;; "apply" passes each value of the list as an individual argument.

#+end_src

**** zerop
Return t if NUMBER is zero.

**** /
The division operation approximates immediately by default, to change this behavior, the dividend must be placed in decimal notation.

#+begin_src emacs-lisp

(/ 21 4)   ;; => 5
(/ 21 4.0) ;; => 5.25

#+end_src

*** lines-
**** beginning-of-line
Move cursor to beginning of current line.

Better than ~(goto-char (line-beginning-position))~.

Do not use ~move-beginning-of-line~ or ~move-end-of-line~. Because these are designed for interactive use.

Do not use ~(search-forward "\n")~ for moving cursor to end of line. Because you'll have special cases if the line is at the end of buffer and doesn't have a newline char. It is also slower.

#+begin_src emacs-lisp

(transient-mark-mode 1)

(defun xah/select-current-line ()
  "Select the current line"
  (interactive)
  (end-of-line) ; move to end of line
  (set-mark (line-beginning-position)))

#+end_src

**** end-of-line
Move cursor to end of current line.

Better than ~(goto-char (line-end-position))~.

Do not use ~move-beginning-of-line~ or ~move-end-of-line~. Because these are designed for interactive use.

Do not use ~(search-forward "\n")~ for moving cursor to end of line. Because you'll have special cases if the line is at the end of buffer and doesn't have a newline char. It is also slower.

**** line-beginning-position
Return line beginning's position.

#+begin_src emacs-lisp

;; grab current line
(setq myLine
      (buffer-substring-no-properties
       (line-beginning-position)
       (line-end-position)))
;; Do not use (thing-at-point 'line). Normally, thing-at-point will
;; include the newline char, but if the line is at the end of buffer,
;; then it won't.

#+end_src

**** line-end-position
Return line end's position.

**** count-lines
Return number of lines between START and END.
**** forward-line
Move cursor to previous(-1) or next line(1). Cursor will be at beginning of line.

Do not use ~next-line~ , ~previous-line~ or ~goto-line~ because these are for interactive use, ~forward-line~ is better opcion. Their behavior changes depending on the variable ~line-move-visual~.

*** ring-
**** kill-append
  Append STRING  argument to the end of the latest kill in the kill ring.

**** kill-new
Make STRING argument the latest kill in the kill ring.

**** current-kill
Rotate the yanking point by N places, and then return that kill.

**** yank
Reinsert ("paste") the last stretch of killed text.

**** yank-pop
Replace just-yanked stretch of killed text with a different stretch.

**** rotate-yank-pointer
Rotate the yanking point in the kill ring.

*** variable-
**** buffer-read-only
Útil para setear momentaneamente un buffer con solo lectura, cuando hay posibilidad de que el buffer cambie al aplicar una función que se esta ejecutando y no sea eso lo que se quiera o mientras se experimenta con funciones que puedan alterar el buffer o en archivos delicados (archivos fuente) que por más seguro que se este que la función no modificará el buffer es mejor estar seguro.

**** line-move-visual
Is variable that controls whether ~next-line~ and ~previous-line~ move by newline char or screen.

Note: there's also a function named ~line-move-visual~. It doesn't have inline doc. It's for moving cursor by visual lines.

**** default-directory
Get the current dir.

**** case-fold-search
Non-nil if searches and matches should ignore case.

#+begin_src emacs-lisp

(defun search-for-abc ()
  "Search for the string \"abc\", ignoring case differences."
  (let ((case-fold-search t))
    (re-search-forward "abc")))


;; -*- coding: utf-8 -*-
;; 2011-03-21
;; report the line number of a occurrences of string, of a given dir
;; script

(setq inputDir "~/web/ergoemacs_org/emacs/" )

;; add a ending slash if not there
(when (not (string= "/" (substring inputDir -1)))
  (setq inputDir (concat inputDir "/")))

(defun my-process-file (fPath)
  "process the file at fullpath fPath …"
  (let (myBuffer (ii 0) searchStr)

    (when (not (string-match "/xx" fPath)) ; skip dir starting with xx

      (setq myBuffer (get-buffer-create " myTemp"))
      (set-buffer myBuffer)
      (insert-file-contents fPath nil nil nil t)

      (setq case-fold-search nil) ; remember to set case sensitivity here

      (setq searchStr "<style>" )

      (goto-char 1)
      (while (search-forward searchStr nil t) ;for regex, re-search-forward
        (princ (format "this many: %d %s\n"
                  (line-number-at-pos (point)) fPath)))

      (kill-buffer myBuffer))))

(require 'find-lisp)

(let (outputBuffer)
  (setq outputBuffer "*xah occur output*" )
  (with-output-to-temp-buffer outputBuffer
    (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
    (princ "Done deal!")))

#+end_src

**** boundp
Return t if SYMBOL's value is not void.

Check if a variable is defined.

The ~boundp~ checks a symbol's value cell. Similarly, the [[fboundp]] actually check a symbol's function cell.

#+begin_src emacs-lisp

(boundp 'auto-mode-alist)       ; t
(boundp 'xyz)                   ; nil

#+end_src

**** Notes

#+begin_src emacs-lisp

;; input dir
(setq inputDir "~/web/" ) ; In elisp, dir path should end with a slash

;; set output buffer
(setq outputBuffer "*my occur output*" )

#+end_src

*** misc-
**** this-command
Normally, whenever a function is executed, Emacs sets the value of this-command to the function being executed.

#+begin_src emacs-lisp

;; check if the command is being called repeatedly
(if (not (eq last-command this-command))
…
)
;; the “this-command” and “last-command” are built-in variables. They
;; store the command currently called or last called.

#+end_src

**** last-command
Normally, whenever a function is executed, Emacs sets the value of this-command to the function being executed. At the same time, Emacs sets the value of last-command to the previous value of this-command.

#+begin_src emacs-lisp

;; check if the command is being called repeatedly
(if (not (eq last-command this-command))
…
)
;; the “this-command” and “last-command” are built-in variables. They
;; store the command currently called or last calle.

#+end_src

**** prefix-numeric-value
    Convert the raw prefix argument produced by (interactive "P") to a numeric value.

**** y-or-n-p
Ask user a "y or n" question.

Return t if answer is "y" and nil if it is "n".

#+begin_src emacs-lisp

(if (y-or-n-p "Do it?")
    (progn
      ;; code to do something here
    )
  (progn
    ;; code if user answered no.
  ))


;; -*- coding: utf-8 -*-
;; 2011-07-03
;; replace image tags to use HTML5's “figure”  and “figcaption” tags.

;; Example. This:
;; <div class="img">…</div>
;; should become this
;; <figure>…</figure>

;; do this for all files in a dir.

;; rough steps:
;; find the <div class="img">
;; use sgml-skip-tag-forward to move to the ending tag.
;; save their positions.
;; ask user whether to replace, if so, delete them and insert new string

(defun xah/my-process-file (fPath)
  "Process the file at FPATH …"
  (let (myBuff p1 p2 p3 p4 )
    (setq myBuff (find-file fPath))

    (widen)
    (goto-char 1) ;; in case buffer already open

    (while (search-forward "<div class=\"img\">" nil t)
      (progn
        (setq p2 (point) )
        (backward-char 17) ; beginning of “div” tag
        (setq p1 (point) )

        (forward-char 1)
        (sgml-skip-tag-forward 1) ; move to the closing tag
        (setq p4 (point) )
        (backward-char 6) ; beginning of the closing div tag
        (setq p3 (point) )
        (narrow-to-region p1 p4)

        (when (y-or-n-p "replace?")
          (progn
            (delete-region p3 p4 )
            (goto-char p3)
            (insert "</figure>")

            (delete-region p1 p2 )
            (goto-char p1)
            (insert "<figure>")
            (widen) ) ) ) )

    (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff))))

(require 'find-lisp)


(let (outputBuffer)
  (setq outputBuffer "*xah img/figure replace output*" )
  (with-output-to-temp-buffer outputBuffer
    (mapc 'my-process-file (find-lisp-find-files "~/web/xahlee_org/emacs/" "\\.html$"))
    (princ "Done deal!")))

#+end_src

**** read-from-minibuffer
Read a string from the minibuffer, prompting with string PROMPT.

~read-from-minibuffer~ is the most general command for get user input, but there are others such as ~read-string~, ~read-file-name~, read ~-directory-name~, ~read-regexp~.

#+begin_src emacs-lisp

(defun ff ()
  "Prompt user to enter a file name, with completion and history support."
  (interactive)
  (let ((x (read-file-name "Enter file name:")))
    (message "String is %s." x)))

(defun ff (arg)
  "Prompt user to enter a string, with input history support."
  (interactive
   (list
    (read-string "Enter your name:")))
  (message "String is %s." arg))

#+end_src

**** shell-command
Execute string COMMAND in inferior shell; display output, if any.

#+begin_src emacs-lisp

;; copy file
(shell-command "cp /somepath/myfile.txt  /somepath")

;; gzip file
;; ...
(when gzip-it-p
   (shell-command (concat "gzip " filePath)))

;; copy dir recursively
;; ...
(make-directory toDir t)
(shell-command (concat "cp -R " fromDir " " toDir))

#+end_src

**** shell-command-to-string
Execute shell command COMMAND and return its output as a string.

Idiom for calling a shell command and get its output.

#+begin_src emacs-lisp

(shell-command-to-string "ls")

#+end_src

**** start-process
Start a program in a subprocess.  Return the process object for it.

Call a shell command, but don't wait for it to finish before continuing, use ~start-process~ or ~start-process-shell-command~.

#+begin_src emacs-lisp

;; open files in Linux desktop
(mapc
 (lambda (fPath)
   (let ((process-connection-type nil))
     (start-process "" nil "xdg-open" fPath)) )
 myFileList)

#+end_src

**** require
If feature FEATURE is not loaded, load it from FILENAME.

When writing a elisp script that does batch processing, it's best to print to your own buffer.

For example, suppose you have a elisp batch script that do find and replace on all files in a dir. For each file visited, it prints out the file path. If you use (message …), it prints to the “*Messages*” buffer, which automatically roll off the top if you have more than a hundred lines. Also, it may intermix your script's output with output from other emacs activities.

Here's a example of printing to your own buffer:

#+begin_src emacs-lisp

(require 'find-lisp)
(with-output-to-temp-buffer "*my output*"
  (mapc 'my-process-file (find-lisp-find-files "~/" "\\.html$"))
  (princ "Done.\n")
  (switch-to-buffer "*my output*")
  )

;; In the above example, any call to print in “my-process-file” is output
;; to your temp buffer.

#+end_src

**** catch throw
Use ~catch~ and ~throw~ to exit loop, function or map.

To exit a function, just put ~throw 'tagname value~ where you want to, and, wrap your function body with a ~catch 'tagname~.

~(catch 'tagname body)~ => evaluates ~body~ and return ~body~'s last expression, but if ~body~ contains ~(throw …)~ and it is called, return the value throw passes.

~(throw tagName passValue)~ => jump to a outer ~(catch 'tagName)~ and continue there, passing the value of ~passValue~ to it. Both ~tagName passValue~ are evaluated.

#+begin_src emacs-lisp

(defun test-exit-f ()
  "example. using catch/throw to exit function"
  (interactive)
  (catch 'aaa
    (if (y-or-n-p "exit?")
        (progn
          (message "existing")
          (throw 'aaa 3) ; if yes, exit right away, return 3 to catch
          )
      (progn ; else, go on
        (message "went on")
        4)))) ; return 4


;; Exit a map
(let ((myList [0 1 2 3 4 5]))
  ;; map lambda onto a list. If value 3 is found, return 3, else nil
  (catch 'bbb
    (mapc
     (lambda (x)
       (message "%s" x)
       (when (equal x 3) (throw 'bbb x)))
     myList)
    nil))


;; Here's a sample of setting flag:
(let ((myList [0 1 2 3 4 5] )
      (foundFlag-p nil )
      (i 0))

  (while (and
          (not foundFlag-p)
          (<= i (length myList)))

    ;; if found, set foundFlag-p
    (when (equal (elt myList i) 3)
      (setq foundFlag-p t ))

    (message "value: %s" i)
    (setq i (1+ i))))

#+end_src

**** error
Use ~error~ or ~user-error~ to signal a error and exit.

You can exit by calling ~error~ or ~user-error~.

#+begin_src emacs-lisp

(defun test-exit-f ()
  "example"
  (interactive)
  (if (y-or-n-p "invoke user-error to exit?")
      (user-error "Error, because: %s" "you said so!")
    (progn ; else, go on
      (message "went on"))))

#+end_src

**** fill-paragraph
Fill paragraph at or after point.

#+begin_src emacs-lisp

;; This example shows how to temporarily change a pre-defined variable's
;; value, then call a function whose behavior depends on the var.
(defun remove-line-breaks ()
  "Remove line endings in current paragraph."
  (interactive)
  (let ((fill-column (point-max)))
    (fill-paragraph nil)))

#+end_src

**** highlight-phrase
Set face of each match of phrase REGEXP to FACE.

Another similar function is ~highlight-lines-matching-regexp~.

#+begin_src emacs-lisp

(highlight-phrase "\\bKing\\b" (quote hi-blue))

(highlight-lines-matching-regexp "^#" (quote hi-blue-b))

;; You can set a file to automatically eval elisp code when the file
;; opens.  add this to the end of file:

/* Local Variables: */
/* eval: (highlight-phrase "\\bJane\\b" (quote hi-pink)) */
/* eval: (highlight-phrase "\\bKing\\b" (quote hi-blue)) */
/* eval: (highlight-lines-matching-regexp "^#" (quote hi-blue-b)) */
/* End: */

#+end_src

**** benchmark-run
Time execution of FORMS.

**** sgml-skip-tag-forward
Skip to end of tag or matching closing tag if present.

**** sit-for
Redisplay, then wait for SECONDS seconds.  Stop when input is available.

This expression makes the graph printing operation more interesting to watch than it would be otherwise. The expression causes Emacs to sit or do nothing for a zero length of time and then redraw the screen. Placed here, it causes Emacs to redraw the screen column by column. Without it, Emacs would not redraw the screen until the function exits.

#+begin_src emacs-lisp

;; Example of use (sit-for 0)
(defun graph-body-print (numbers-list)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values."

  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)


    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)

      ;; Draw graph column by column.
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))

    ;; Place point for X axis labels.
    (forward-line height)
    (insert "\n")))


;; other functions and variables of this graph if you wish to test the
;; above function.
(defvar graph-symbol "*"
  "String used as symbol in graph, usually an asterisk.")


(defvar graph-blank " "
  "String used as blank in graph, usually a blank space.
graph-blank must be the same number of columns wide
as graph-symbol.")


;;; Second version.
(defun column-of-graph (max-graph-height actual-height)
  "Return MAX-GRAPH-HEIGHT strings; ACTUAL-HEIGHT are graph-symbols.

The graph-symbols are contiguous entries at the end
of the list.
The list will be inserted as one column of a graph.
The strings are either graph-blank or graph-symbol."


  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))


    ;; Fill in graph-symbols.
    (while (> actual-height 0)
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))


    ;; Fill in graph-blanks.
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; Return whole list.
    insert-list))

#+end_src

**** null
Return t if OBJECT is nil, and return nil otherwise.

#+begin_src emacs-lisp

(null '()) ; => t

#+end_src

**** sequencep
This function returns t if object is a list, vector, string, bool-vector, or char-table, nil otherwise.

**** functionp
Return t if OBJECT is a function.

Note that ~functionp~ returns ~t~ for symbols that are function names and returns ~nil~ for special forms. It is also possible to find out how many arguments an arbitrary function expects.

**** fboundp
Check if a function is defined.

The ~fboundp~ actually check a symbol's *function* cell. Similarly, the [[boundp]] checks a symbol's *value* cell.

#+begin_src emacs-lisp

(fboundp 'info)     ; t
(fboundp 'xyz)      ; nil

#+end_src

**** featurep
Check if a “feature” is loaded.

#+begin_src emacs-lisp

;; check if a “feature” (package) has been loaded
(featurep 'ibuffer)

#+end_src

** Regexp
*** Regexp
Regular expressions have a syntax in which a few characters are *special constructs* and the rest are *ordinary*. An ordinary character matches that same character and nothing else. The special characters are ~$^.*+?[\~ .

*** Special Characters
**** . , * , + , ?
***** .
Is a special character that matches *any single* character *except a newline*.

~a.b~ matches any three-character string that begins with ~a~ and ends with ~b~.

***** *
Is not a construct by itself; it is a postfix operator that means to match the *preceding regular expression* repetitively *any number of times*, as many times as possible. Thus, ~o*~ matches any number of ~o~ s, *including no* ~o~ s.

~*~ always applies to the smallest possible preceding expression. Thus, ~fo~ has a repeating ~o~, not a repeating ~fo~. It matches ~f~, ~fo~, ~foo~, and so on.

*Nota*: cuando se está realizando una busqueda con alguna función regex y el programa destaca (highlight) las expresiones que coinciden, se debe tener cuidado en no confundir cuando el programa resalta todas las coincidencias señalando varias coincidencias independientes como si fuera una sola coincidencia, por ejemplo:

~fo*~ destacará (highlight) ~fofofofofo~ pero no es que realmente coincida con todo este string junto, si no que destaca ~fo~ repetidas veces, es decir, la coincidencia es ~fo~ otro ~fo~ otro ~fo~ pero no el string completo ~fofofofofo~ .

The matcher processes a ~*~ construct by matching, immediately, as many repetitions as can be found. Then it continues with the rest of the pattern. If that fails, backtracking occurs, discarding some of the matches of the ~*~-modified construct in case that makes it possible to match the rest of the pattern. For example, in matching ~ca*ar~ against the string ~caaar~, the ~a*~ first tries to match all three ~a~ s; but the rest of the pattern is ~ar~ and there is only ~r~ left to match, so this try fails. The next alternative is for ~a*~ to match only two ~a~ s. With this choice, the rest of the regexp matches successfully.

*Nota*: la regex ~ca*ar~ enlaza con ~car~ de la siguiente manera:
Enlazando con la ~c~ del principio que es fija y con el ~ar~ del final que también es fijo, esto es lo que realmente enlaza con ~car~. La ~a*~ no enlaza ya que esta puede ser o bien la cantidad de ~a~ que sea o ninguna ~a~ , lo cual es este caso, es decir 1 ~c~ + 0 ~a*~ + 1 ~ar~ .

  - Using [[\{n,m\}]] notation, ~\{0,\}~ is equivalent to ~*~.

***** +
Is a postfix operator, similar to ~*~ except that it must match the preceding expression *at least once*.

Thus, ~ca+r~ matches the strings ~car~ and ~caaaar~ but not the string ~cr~, whereas ~ca*r~ matches all three strings.

  - Using [[\{n,m\}]] notation, ~\{1,\}~ is equivalent to ~+~.

***** ?
Is a postfix operator, similar to ~*~ except that it can match the preceding expression *either once or not at all*.

Thus, ~ca?r~ matches ~car~ or ~cr~, and nothing else.

  - Using [[\{n,m\}]] notation, ~\{0,1\}~ is equivalent to ~?~.

**** *? , +? , ??
Are non-greedy variants. The normal operators ~*~, ~+~, ~?~ match as much as they can, as long as the overall regexp can still match. With a following ~?~, they will *match as little as possible* .

For example, ~ab*~ can match the string ~a~ and the string ~abbbb~;
               but  ~ab*?~ match only with ~a~ (the shortest valid match).

Non-greedy operators match the shortest possible string starting at a given starting point; in a forward search, though, the earliest possible starting point for match is always the one chosen. Thus, if you search for ~a.*?$~ against the text ~abbab~ followed by a newline, it matches the whole string. Since it can match starting at the first ~a~, it does.

In the following example you can see the difference when using the normal operators against the non-greedy search (?).

We want to replace the "=" markup with "~" (each match is marked with numbers).

#+begin_example

REGEXP: =\\(.+\\)=

- =/dev/clip= and =/dev/kill=(1) you can redirect shell commands to the emacs clipboard and killring
- REPL alias =alias ffo "find-file-other-window $1"=(2) y proporciona una manera sencilla.
- Puede correr comandos en la shell como =find-file=, =dired=, ...,  también correr funciones =(+ 20 5)=(3) completas.
- Puede usar comandos con pipe para enviar salida a un buffer =echo "Hello" > #<buffer test-buffer>=(4).
- La sintaxis de la subshell es un poco diferente se utiliza =${ }= en vez de =$( )=(5).

MATCHES: 5


REGEXP: =\\(.+?\\)=

- =/dev/clip=(1) and =/dev/kill=(2) you can redirect shell commands to the emacs clipboard and killring
- REPL alias =alias ffo "find-file-other-window $1"=(3) y proporciona una manera sencilla.
- Puede correr comandos en la shell como =find-file=(4), =dired=(5), ...,  también correr funciones =(+ 20 5)=(6) completas.
- Puede usar comandos con pipe para enviar salida a un buffer =echo "Hello" > #<buffer test-buffer>=(7).
- La sintaxis de la subshell es un poco diferente se utiliza =${ }=(8) en vez de =$( )=(9).

MATCHES: 9

#+end_example

**** \{n\}
***** \\{n\\}
Is a postfix operator specifying ~n~ repetitions—that is, the preceding regular expression must match *exactly ~n~ times in a row*.

For example, ~x\\{4\\}~ matches the string ~xxxx~ and nothing else.

Caution: maybe it's just one ~\~ , e.g.  ~x\{4\}~.

***** \\{n,m\\}
Is a postfix operator specifying between ~n~ and ~m~ repetitions—that is, the preceding regular expression must match *at least ~n~ times, but no more than ~m~ times*. If ~m~ is omitted, then there is no upper limit, but the preceding regular expression must match at least ~n~ times.

  -  ~\\{0,1\\}~ is equivalent to ~?~.
  -  ~\\{0,\\}~ is equivalent to ~*~.
  -  ~\\{1,\\}~ is equivalent to ~+~.

Caution: maybe it's just one ~\~ , e.g.  ~\{0,1\}~.

**** [ ... ]
***** [ … ]
The characters between the two brackets are what this set can match.

- ~[ad]~ matches either one ~a~ or one ~d~.
- ~[ad]*~ matches any string composed of just ~a~ s and ~d~ s (including the empty string).
- ~c[ad]*r~ matches ~cr~, ~car~, ~cdr~, ~caddaar~, etc.

You can also include character ranges in a character set, by writing the starting and ending characters with a ~-~ between them. Thus, ~[a-z]~ matches any lower-case ASCII letter.

To include a ~]~ in a character set, you must make it the first character. For example, ~[]a]~ matches ~]~ or ~a~. To include a ~-~, write ~-~ as the last character of the set, tho you can also put it first or after a range. Thus, ~[]-]~ matches both ~]~ and ~-~.

***** [^ … ]
~[^~ begins a *complemented* (caracter complementario como en matemática, el complemento de todos esos caracteres, cualquier caracter menos los que estan en los corchetes, es como un "No estos caracteres") character set, which *matches any character except the ones specified*, even new line (put a newline in the list if you want it not to be matched).

Thus, ~[^a-z0-9A-Z]~ matches all characters except ASCII letters and digits.

~^~ is not special in a character set unless it is the first character. The character following the ~^~ is treated as if it were first (in other words, ~-~ and ~]~ are not special there).

Note: A complemented character set can match a newline, unless newline is mentioned as one of the characters not to match. This is in contrast to the handling of regexps in programs such as grep.

***** \|
*Specifies an alternative*. Two regular expressions ~a~ and ~b~ with ~\|~ in between form an expression that matches some text if either ~a~ matches it or ~b~ matches it. It works by trying to match ~a~, and if that fails, by trying to match ~b~.

Thus, ~foo\|bar~ matches either ~foo~ or ~bar~ but no other string.

**** ^ , $
***** ^
Is a special character that matches the empty string, but *only at the beginning of a line* in the text being matched. Otherwise it fails to match anything.

Thus, ~^foo~ matches a ~foo~ that occurs at the beginning of a line.

***** $
Is similar to ~^~ but matches *only at the end of a line*.

Thus, ~x+$~ matches a string of one ~x~ or more at the end of a line.

**** \
***** \
Has two functions: it *quotes the special characters* (including ~\~), and it introduces additional special constructs.

Because ~\~ quotes special characters, ~\$~ is a regular expression that matches only ~$~, and ~\[~ is a regular expression that matches only ~[~, and so on.

Backslashes must be entered as ~\\~.

Literal backslash with doubling backslash ~\\\\~.

*Caution*: when it's an interactive command search one ~\~ by executing Lisp code two ~\\~.

***** \b
Matches the *empty string*, but only at the *beginning or end of a word*.

  - ~\bfoo\b~ matches any occurrence of ~foo~ as a separate word.
  - ~\bballs?\b~ matches ~ball~ or ~balls~ as a separate word.

~\b~ matches at the beginning or end of the buffer regardless of what text appears next to it.

~\b~ word boundary marker. If you want to match with word boundary, use it, like this ~\bcat\b~. This will find ~cat~ but not ~cats~.

***** \B
Matches the *empty string*, but *NOT at the beginning or end of a word*.

~\Blab\B~ matches of any occurrence of "e~lab~oration" but not for "The ~lab~ is".

***** \( … \)
Is a grouping construct that serves three purposes:

   1. To enclose a set of ~\|~ alternatives for other operations. Thus, ~\(foo\|bar\)x~ matches either ~foox~ or ~barx~.
   2. To enclose a complicated expression for the postfix operators ~*~, ~+~ and ~?~ to operate on. Thus, ~ba\(na\)*~ matches ~bananana~, etc., with any (zero or more) number of ~na~ strings.
   3. To record a <<matched substring>> for future reference.

Capture pattern. ~\\(pattern\\)~

***** \d
Matches the same text that matched the ~dth~ occurrence of a ~\( … \)~ construct. This is called a *back reference*.

After the end of a ~\( … \)~ construct, the matcher remembers the beginning and end of the text matched by that construct. Then, later on in the regular expression, you can use ~\~ followed by the digit ~d~ to mean “match the same text matched the ~dth~ time by the ~\( … \)~ construct”.

For example, ~\(.*\)\1~ matches any newline-free string that is composed of two identical halves. The ~\(.*\)~ matches the first half, which may be anything, but the ~\1~ that follows must match the same exact text.

If a particular ~\( … \)~ construct matches more than once (which can easily happen if it is followed by ~*~), only the last match is recorded.

Note: The construct ~\d~ for any digit is not supported, use ~[0-9]~ or ~[[:digit:]]~ instead.

***** \w
Matches any word-constituent character. The syntax table determines which characters these are.

Note: The construct ~\w~ for any word is not always supported, use ~[[:word:]]~ instead.

***** \W
Matches any character that is not a word-constituent.

**** misc
***** \`
Matches the empty string, but only at the *beginning of the string or buffer* (or its accessible portion) being matched against.

~\`…~ Beginning of {string, buffer}

***** \'
Matches the empty string, but only at the *end of the string or buffer* (or its accessible portion) being matched against.

~…\'~ End of {string, buffer}

***** \(?: … \)
Specifies a shy group that does not record the [[matched substring]]; you can~t refer back to it with ~\d~. This is useful in mechanically combining regular expressions, so that you can add groups for syntactic purposes without interfering with the numbering of the groups that are meant to be referred to.

***** \=
Matches the empty string, but only at point.

***** \<
Matches the *empty string*, but only at the *beginning of a word*.

~\<~ matches at the beginning of the buffer only if a word-constituent character follows.

***** \>
Matches the *empty string*, but only at the *end of a word*.

~\>~ matches at the end of the buffer only if the contents end with a word-constituent character.

***** \sc
Matches any character whose syntax is ~c~. Here ~c~ is a character which represents a syntax code: thus, ~w~ for word constituent, ~-~ for whitespace, ~(~ for open parenthesis, etc.

***** \Sc
Matches any character whose syntax is not ~c~.

*** Commands

| C-M-s                | incremental forward search regexp         |
| C-M-r                | incremental backward search regexp        |
| query-replace-regexp | same, but query before each replacement   |
| replace-regexp       | replace string matching regexp            |
| dired-do-query-re    | replace maked files in dired              |
| replace-string       | find & replace in 1 shot without asking   |
| replace-regexp       | same replace-string but with regexp       |
| highlight-regexp     | highlight strings matching regexp         |
| unhighlight-regexp   | remove highlighting                       |
| occur/list-match lin | show lines containing a match             |
| multi-occur          | show lines in all buffers contain a match |
| how-many             | count the number of strings match regexp  |
| keep-lines           | delete all lines except contain match     |
| flush-lines          | delete lines containing matches           |
| align-regexp         | alig using strings match regex delimiters |

Note that ~list-matching-lines~ is an alias for ~occur~ and ~delete-matching-lines~ is an alias for ~flush-lines~.

*** Examples
**** End of sentence
End of a sentence together with any whitespace that follows. It is the value of the variable ~sentence-end~.

#+begin_src emacs-lisp

"[.?!][]\"')}]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"

;; or in contrast, if you evaluate the variable sentence-end
"[.?!][]\"')}]*\\($\\| $\\|  \\|  \\)[
]*"
;; In this output, tab and newline appear as themselves.


;; With rx expressions
(rx (any ".?!")                    ; Punctuation ending sentence.
    (zero-or-more (any "\"')]}"))  ; Closing quotes or brackets.
    (or line-end
        (seq " " line-end)
        "\t"
        "  ")                      ; Two spaces.
    (zero-or-more (any "\t\n ")))  ; Optional extra whitespace.

;; =>

"[!.?][]\"')}]*\\(?:$\\| $\\|	\\|  \\)[
 ]*"

#+end_src

~[.?!]~ match with one of three characters, a period, a question mark and an exclamation mark.

~[]\"')}]*~ matches any closing braces and quotation marks, zero or more of them, that may follow the period, question mark or exclamation mark.

~\\($\\| \\|\t\\| \\)~ matches the whitespace that follows the end of a sentence: the end of a line, or a tab, or two spaces. The parentheses mark the group and the vertical bars separate alternatives. The dollar sign is used to match the end of a line.

~[ \t\n]*~ matches any additional whitespace beyond the minimum needed to end a sentence.

**** At least one character that is a word or symbol

#+begin_src emacs-lisp

"\\(\\w\\|\\s_\\)+"

#+end_src

The ~\\(~ is the first part of the grouping construct that includes the ~\\w~ and the ~\\s_~ as alternatives, separated by the ~\\|~. The ~\\w~ matches any word-constituent character and the ~\\s_~ matches any character that is part of a symbol name but not a word-constituent character. The ~+~ following the group indicates that the word or symbol constituent characters must be matched at least once.

**** Word or symbol followed optionally by
Word or symbol constituents are followed optionally by characters that are not white space and then followed optionally by white space.

#+begin_src emacs-lisp

"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"

#+end_src

**** Replace the decimal point by a comma
Here are two ways to replace the decimal point by a comma (~1.5 -> 1,5~), first by an interactive command, second by executing Lisp code (type ~C-x C-e~ after the expression to get it executed).

Note: The construct ~\d~ for any digit is not supported, use ~[0-9]~ or ~[:digit:]~ instead.

#+begin_src emacs-lisp

M-x replace-regexp RET \([0-9]+\)\. RET \1, RET

(while (re-search-forward "\\([0-9]+\\)\\." nil t)
             (replace-match "\\1,"))

#+end_src

**** Detect consecutive duplicate words

#+begin_src emacs-lisp

 ;; \\(\\w+[ \t\n]+\\)\\1
 ;; This regexp matches one or more word-constituent characters followed
 ;; by one or more spaces, tabs, or newlines. However, it does not detect
 ;; duplicated words on different lines, since the ending of the first
 ;; word, the end of the line, is different from the ending of the second
 ;; word, a space

;; \\(\\(\\w+\\)\\W*\\)\\1
;; Another possible regexp searches for word-constituent characters
;; followed by non-word-constituent characters, reduplicated. Here,
;; ‘\\w+’ matches one or more word-constituent characters and ‘\\W*’
;; matches zero or more non-word-constituent characters. Again, not
;; useful.

;; Here is the pattern that I use. It is not perfect, but good enough.
\\b\\([^@ \n\t]+\\)[ \n\t]+\\1\\b
;; ‘\\b’ matches the empty string, provided it is at the beginning or end
;; of a word; ‘[^@ \n\t]+’ matches one or more occurrences of any
;; characters that are not an @-sign, space, newline, or tab.

#+end_src

**** Mix

#+begin_src emacs-lisp

;; Delete new lines
;; replacing "\n" by "^$"

;; Empty line
"^$"

;; Word with 20 letters or more
"\\w\\{20,\\}"

;; Year 1900-2099
"\\(19\\|20\\)[0-9]\\{2\\}"

;;At least 6 symbols
"^.\\{6,\\}"

;; Capture text between double quotes.
;; "\([^"]+\)" ;; or ;; "\([^"]+?\)"
;; \"\\([^\"]+\\)\" ;; or ;; \"\\([^\"]+?\\)\"

;; To truncate decimals to 3 places, e.g. 0.123456 -> 0.123
"\([0-9]\)\.\([0-9][0-9][0-9]\)[0-9]+"
;;and replace it with
"\1.\2."

#+end_src

*** rx
A nifty macro that generates regular expressions for you, from reasonably-comprehensible s-expressions. This notation is usually easier to read, write and maintain than regexp strings, and can be indented and commented freely. It requires a conversion into string form since that is what regexp functions expect, but that conversion typically takes place during byte-compilation rather than when the Lisp code using the regexp is run.

The ~rx~ notation is mainly useful in Lisp code; it cannot be used in most interactive situations where a regexp is requested, such as when running ~query-replace-regexp~ or in variable customization.

When given just a single string argument, it acts just like ~regexp-to-string~.

Here is an ~rx~ regexp that matches a block comment in the C programming language:

#+begin_src emacs-lisp

(rx "/*"                          ; Initial /*
    (zero-or-more
     (or (not (any "*"))          ;  Either non-*,
         (seq "*"                 ;  or * followed by
              (not (any "/")))))  ;  non-/
    (one-or-more "*")             ; At least one star,
    "/")                          ; and the final /

;; =>
     "/\\*\\(?:[^*]\\|\\*[^/]\\)*\\*+/"

;; or, using shorter synonyms and written more compactly,
(rx "/*"
    (* (| (not "*")
          (: "*" (not "/"))))
    (+ "*") "/")

;; other example
(rx bol
  (zero-or-more blank)
  (one-or-more digit)
  ":")
;; =>
     "^[[:blank:]]*[[:digit:]]+:"

#+end_src

*** Notes
- By default, the case of the replaced text is smartly dependent on the matched text. For example, if you want to replace ~dragon~ for ~here~ in this ~{here, Here, HERE}~ the result will be ~{dragon, Dragon, DRAGON}~. If you want the letter case of your replacement string be exactly as you have it, you need to set the variable ~case-replace~ to ~nil~.

- When using ~[a-z]~, it is not case sensitive by default. Case sensitivity is controlled by the variable ~case-fold-search~. Call ~toggle-case-fold-search~ to toggle it.

- Do not use ~[A-z]~, because that'll match some punctuation chars too. Use ~[A-Za-z]~.

- To insert a literal tab, ~C-q C-i~.

- To insert a newline, press ~C-q C-j~.

- Regexp commands use regex to search. So, if you simply want to search plain words or phrases, and if your phrase contains any of regex characters, you need to escape them. Here's some commonly used regex characters that you'll need to place a backslash before it: ~[ ] \ + * ?~ .

- If you are doing a regex search, and you want to force the replacement to upper case or lower case, in the replace prompt, give ~\,(upcase \1)~ or ~\,(downcase \1)~. Suppose you want all paragraphs to start with a capital letter. So, you use a pattern that catches the first letter after ~<p>~, like this ~<p>\([a-z]\)~. To make your captured pattern upper case, give your replacement string this expression: ~<p>\,(upcase \1)~. The ~\,~ tells emacs that what follows should be a lisp expression. The ~(upcase \1)~ is a lisp expression. The upcase is a lisp function and the ~\1~ means the 1st captured string in your regex pattern.

- Unicode character can be used literally. But for non-printable ones such as “RIGHT-TO-LEFT MARK”, you can represent them by a code.

- whitespace ~[[:space:]]~

Warning: the meaning of a character class in emacs is dependent on the current major mode's syntax table. For example, what chars are considered “word” in ~[[:word:]]~ depends on how its defined in syntax table of current major mode.

* Notes
** Org
*** Markup
**** Énfasis y monoespacio
Se pueden énfasis en palabras como *bold*, /italic/, _underlined_, =verbatim= and ~code~, y, también, +strike-through+.

Para que no se vea la sintaxis en el documento se puede setear en ~nil~ la variable ~org-fontify-emphasized-text~.

#+begin_example

Se pueden énfasis en palabras como *bold*, /italic/, _underlined_, =verbatim= and ~code~, y, también, +strike-through+.

#+end_example

**** Example
Se pueden incluir ejemplos literales que no deberían ser asunto de marcado.

#+BEGIN_EXAMPLE
Algún ejemplo desde un fichero de texto.
#+END_EXAMPLE

Aquí está un ejemplo
    : Algún ejemplo desde un fichero de texto.

**** Comments
Introduce comentarios que no se exportarán.
# Esto no se exporta

#+BEGIN_COMMENT
Esto tampoco se exporta
#+END_COMMENT

**** Quote
Cuando se cita un pasaje desde otro documento, es un libro de usos y costumbres para formatear esto como un párrafo que se pretende en ambos la izquierda y el margen derecho.

#+BEGIN_QUOTE
Cada cosa debería ser hecha tan simple como sea posible,
pero no simple de cualquier manera -- Albert Einstein
#+END_QUOTE

Si se quisiera centrar algún texto, se puede hacer así:

#+BEGIN_CENTER
Cada cosa debería hecha tan simple como posible \\
pero no simple cualquier manera
#+END_CENTER

**** Include
Durante la exportación, se pueden incluir el contenido de otro fichero. Por ejemplo, para incluir tu fichero ‘.emacs’, se podría usar:

#+INCLUDE: "~/.emacs" src emacs-lisp

**** Latex
Al exportador HTML, se puede usar #+LaTeX: y la siguiente construcción para añadir código LaTeX literal.

#+BEGIN_LaTeX

 \int_{-N}^{N} e^x\, dx

$\sum _{k=1}^{n}m=mn$

#+END_LaTeX

#+begin_src latex

 \int_{-N}^{N} e^x\, dx

$\sum _{k=1}^{n}m=mn$

#+end_src

*** Links
**** Web

#+begin_src org

[[http://orgmode.org/][Org-mode]]
# or
[[http://orgmode.org/]]

#+end_src

**** File

#+begin_src org

[[file:Emacs-guide.org][Emacs-Guide]]
# or
[[file:Emacs-guide.org]]

# Adjuntar una búsqueda a un enlace de fichero, junto con una explicación:
[[file:~/code/main.c::255]]                 Encontrar línea 255
[[file:~/xx.org::Mi Objetivo]]              Encontrar ‘<<Mi Objetivo>>’
[[file:~/xx.org::#mi-id-personal]]          Encontrar entrada con id personal

#+end_src

**** Anchor

#+begin_src org

# Enlaza con el heading que tenga por nombre "Nombre heading"
[[Nombre heading][nombre que sea]]
# or
[[Nombre heading]]

# Enlazar a la entrada con la propiedad CUSTOM_ID
# De esta manera se puede colocar otro nombre diferente al que ya tiene el heading
 * Source Code
   :PROPERTIES:
   :CUSTOM_ID: source-code-layout-organization
   :END:

[[#source-code-layout-organization][Source Code Layout & Organization]]

#+end_src

**** Target

#+begin_src org

# Enlaza con <<target>>
[[target][aquí]]
# or
[[target]]

#+end_src

**** Image

#+begin_src org

[[http://makeapullrequest.com][https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square][image]]
# or
[[http://makeapullrequest.com][https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square]]

#+end_src

**** Footnotes
Una forma de hacer estas cosas en Org[fn:1] la llaman notas al pie.
...
[fn:1]

*** Babel
**** #+PROPERTY:
Propiedad del documento que se usa para exportar todos los bloques de código.

Un argumento de cabecera de ~:tangle yes~ causará que los bloques de código se enlazen a un fichero llamado después del nombre del fichero del búffer. Un nombre de fichero alternativo puede ser especificado con ~:tangle filename~.

#+begin_src emacs-lisp

#+PROPERTY: header-args:emacs-lisp :tangle ./name

#+end_src

**** :tangle ./name.ext
Etiqueta de bloque para exportar solo el bloque.

**** org-babel-tangle
Escribe todos los bloques de códigos etiquetados en un archivo fuente específico.

Nota: debe tener un argumento de cabecera de ~:tangle~.

**** org-edit-special
Abre un nuevo buffer para editar el código de bloque Babel.

*** Letter
**** Sample letter org latex
https://www.miskatonic.org/2022/01/28/latex-letters-in-org/

First, need to turn on the  LaTeX letters in Org in the Emacs init file.

#+begin_src emacs-lisp

;;Activate LaTeX letters in Org
(with-eval-after-load 'ox-latex
  (add-to-list 'org-latex-classes '("letter" "\\documentclass{letter}"))
  )

#+end_src

#+begin_src text

# #+title: Comment out, or do not use
#+date: Wednesday

#+options: toc:nil

#+latex_header: \usepackage[osf]{Baskervaldx}

#+latex_class: letter

#+latex_header: \signature{Lucy}
#+latex_header: \address{17, Chatham Street}

#+latex: \begin{letter}{[s.l.]}
#+latex: \opening{My dearest Mina,---}

I must say you tax me very unfairly with being a bad correspondent.
I wrote to you /twice/ since we parted, and your last letter was only your /second/.
Besides, I have nothing to tell you.  There is really nothing to interest you.
Town is very pleasant just now, and we go a good deal to picture-galleries
and for walks and rides in the park.  As to the tall, curly-haired man,
I suppose it was the one who was with me at the last Pop.  Some one has evidently
been telling tales.  That was Mr. Holmwood.  He often comes to see us, and he and
mamma get on very well together; they have so many things to talk about in common.
We met some time ago a man that would just /do for you/, if you were not already
engaged to Jonathan.  He is an excellent /parti/, being handsome, well off, and
of good birth.  He is a doctor and really clever.  Just fancy!
He is only nine-and-twenty, and he has an immense lunatic asylum all under his own care.

#+latex: \closing{Sincerely,}
#+latex: \ps{P.S.  I need not tell you this is a secret.  Good-night again.}
#+latex: \end{letter}

#+end_src

**** My sample letter
Example of an authorization letter.

#+begin_src text

# #+title: Comment out, or do not use
#+date: 00 abril, 2023

#+options: toc:nil

#+latex_class: letter
#+latex_header: \signature{}
#+latex_header: \address{Ciudad de Panamá}

#+latex: \begin{letter}{}
#+latex: \vspace*{-10cm}
#+latex: \opening{A quien corresponda,---}


Yo Richard Rene Frangie Vera, con cédula de identidad E-8-174108 y número de pasaporte 123406246, en calidad de propietario del vehículo, marca Suzuki, modelo AX4, color negra y placa MF6791, por medio del presente documento, autorizo a:

William Grau XX XX con cédula 00 y número de pasaporte 00, para que cancele los trámites del vehículo reseñado.
Gracias por su atención. Saludos cordiales.


#+latex: \closing{Firma,}
#+latex: \end{letter}

#+end_src

*** Build website
**** Creating project folders
Create a folder called ~my-org-site~ with a subfolder called ~content~ which contains a single ~index.org~ file. This will create a file called ~index.html~.

**** Creating the build script
Create a script that will generate the HTML files for the Org documents.

#+begin_src emacs-lisp

;; ~/my-org-site/build-site.el

;; Load the publishing system
(require 'ox-publish)

(message "Build complete!")

#+end_src

We also need a shell script that can run our Emacs Lisp script (no es necesario pero garantiza que el emac se levante desde cero sin configuraciones o dependencias que puedan causar problemas al generar los archivos)

#+begin_src sh

# ~/my-org-site/build.sh

#!/bin/sh
emacs -Q --script build-site.el

# Dont forget to use chmod +x build.sh to make the script executable!
# The -Q parameter prevents Emacs from loading your own Emacs configuration

#+end_src

Now in the shell, change directory to ~my-org-site~ and run the script ~./build.sh~ to launch emacs with ~build-site.el~

**** Setting up the publish project

#+begin_src emacs-lisp

(require 'ox-publish)

;; set up a Org publishing configuration for our website
;; Define the publishing project
(setq org-publish-project-alist
  (list
   (list "my-org-site"
         :recursive t
         :base-directory "./content"
         :publishing-directory "./public"
         :publishing-function 'org-html-publish-to-html)))
;;publishing-funtion -> we want to publish the files as HTML
;;first list -> list of all project configuration
;;second list -> list configuration one

;; Generate the site output
;;publish every project configured in org-publish-project-alist
(org-publish-all t)
;;t -> don't use any cached files just regenerate everything from scratch

(message "Build complete!")

#+end_src

**** Creating the index.org example to test
Create ~~/my-org-site/content/index.org~ file to test

#+begin_src org

#+title: Org Mode Example Site

 * Overview

This is an *example* of a _website_ written with Org Mode.

 * Links

- [[https://www.google.com][External link]]
- [[file:///home/richard/Test/index.html][Internal pc link]]
- [[./other-page.org][Link to another file in same public folder]]

#+end_src

Run the script ~./build.sh~ to generate the output of our site that are put in ~~/my-org-site/public~ folder. (se debe ejecutar cada vez que se quiera transformar nuevos archivos .org -> .html)

**** Install simple-httpd local server
Host the files as a website on the local machine. Run ~M-x httpd-serve-directory~. It will prompt you for a directory to serve from within Emacs.

Default http://localhost:8080 . Set ~httpd-port~ to change the default port if necessary.

#+begin_src emacs-lisp

(use-package simple-httpd
  :ensure t)

#+end_src

**** Settings customizations
Note: ~C-h v org-publish-project-alist~ da una descripción sobre las variables de personalización y que otras estan disponibles.

#+begin_src emacs-lisp

;;set a different variable to get rid of the validate link at the bottom
(setq org-html-validation-link nil)

(setq org-publish-project-alist
      (list
       (list "org-site:main"
             :recursive t
             :base-directory "./content"
             :publishing-directory "./public"
             :publishing-function 'org-html-publish-to-html
             :with-author nil        ;; Don't include author name
             :with-creator t   ;; Include Emacs and Org versions in footer
             :with-toc t             ;; Include a table of contents
             :section-numbers nil    ;; Don't include section numbers
             :time-stamp-file nil))) ;; Don't include time stamp in file

#+end_src

**** Aditional customizations
We can use a nice stylesheet to give our site a more polished look:

#+begin_src emacs-lisp

;; Customize the HTML output
(setq org-html-validation-link nil            ;; Don't show validation link
      org-html-head-include-scripts nil       ;; Use our own scripts
      org-html-head-include-default-style nil ;; Use our own styles
      org-html-head "<link rel=\"stylesheet\" href=\"https://cdn.simplecss.org/simple.min.css\" />")
;;Place before (setq org-publish-project-alist...

#+end_src

This will remove the default JavaScript and CSS code that gets injected into the HTML output by default and replace it with the link to a nice stylesheet.

Nota: It can use a own css file by adding it in the public folder.

**** Generating pages with code blocks
Enhance the code and avoid the error "Cannot fontify source block (htmlize.el >= 1.34 required)"

#+begin_src emacs-lisp

;; Set the package installation directory so that packages aren't stored in the
;; ~/.emacs.d/elpa path.
(require 'package)
(setq package-user-dir (expand-file-name "./.packages"))
(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                         ("elpa" . "https://elpa.gnu.org/packages/")))

;; Initialize the package system
(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))

;; Install dependencies
(package-install 'htmlize)

#+end_src

**** Linking between pages
One last thing I want to show you is how you can create links between pages on your site. Let's open up ~index.org~ and create a link to the ~Emacs.org~ file.

Inside ~index.org~, we can press /C-c C-l/ (~org-insert-link~), enter the path of the Org file we want to link to (~./Emacs.org~), press Enter, then enter the text for the link ("My Emacs configuration").

**** The final build script

#+begin_src emacs-lisp

;; Set the package installation directory so that packages aren't stored in the
;; ~/.emacs.d/elpa path.
(require 'package)
(setq package-user-dir (expand-file-name "./.packages"))
(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                         ("elpa" . "https://elpa.gnu.org/packages/")))

;; Initialize the package system
(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))

;; Install dependencies
;;(package-install 'htmlize) ;;Enhanced block code

;; Load the publishing system
(require 'ox-publish)

;; Customize the HTML output
(setq org-html-validation-link nil            ;; Don't show validation link
      org-html-head-include-scripts nil       ;; Use our own scripts
      org-html-head-include-default-style nil ;; Use our own styles
      org-html-head "<link rel=\"stylesheet\" href=\"https://cdn.simplecss.org/simple.min.css\" />")

;; set up a Org publishing configuration for our website
;; Define the publishing project
(setq org-publish-project-alist
      (list
       (list "my-org-site"
             :recursive t
             :base-directory "./content"
             :publishing-directory "./public"
             :publishing-function 'org-html-publish-to-html
             :with-author nil ;; Don't include author name
             :with-creator t ;; Include Emacs and Org versions in footer
             :with-toc t     ;; Include a table of contents
             :section-numbers nil    ;; Don't include section numbers
             :time-stamp-file nil))) ;; Don't include time stamp in file
;;publishing-funtion -> we want to publish the files as HTML
;;first list -> list of all project configuration
;;second list -> list configuration one

;; Generate the site output
;;publish every project configured in org-publish-project-alist
(org-publish-all t) ;;t -> don't use any cached files just regenerate everything from scratch

(message "Build complete!")

#+end_src

*** Miscellaneous
**** Etiqueta bloque de código
- <name> :: es una cadena usada para nombrar el bloque de código
- <language> :: especifica el lenguaje del bloque de código
- <switches> :: puede usarse para controlar la exportación del bloque de código
- <header arguments> :: puede usarse para controlar muchos aspectos del comportamiento
- <body> :: contiene el código fuente actual.

#+NAME: <name>
#+begin_src text <language>  <switches> <header arguments>

<body>

#+end_src

**** Local variables
They can be placed at the end of the document

#+begin_src org

-----
# Local Variables:
# fill-column: 80
# eval: (auto-fill-mode 1)
# End:

# or
-----
# ; -*- mode: emacs-lisp; tab-width: 8; -*-

#+end_src

**** Image
Coloca imagenes en org mode, para hacerlas visibles se usa la función ~org-toggle-inline-images~.

#+begin_src org

[[./img/name.jpg]

#+end_src

**** Description list
Descripción de listas, se usa ‘ :: ’ para separar el término de la descripción.

#+begin_src org

   Actores importantes es esta película:
   - Elijah Wood :: En el papel de Frodo
   - Sean Austin :: En el papel de Sam, amigo de Frodo.

#+end_src

**** Labels (tag)
Las etiquetas hacen uso de la estructura jerárquica. Si una cabecera tiene una cierta etiqueta, todas las subcabeceras la heredarán. Útil para agregarlas a listas TODO y así poder filtrar por etiquetas.

~org-set-tags-command~ introduce nuevas etiquetas para la cabecera actual.

~org-sparse-tree~ y luego ~m~ crear un árbol expandido con todas las cabeceras coincidentes con la etiqueta (tag) buscada. Con el prefijo ~C-u~, ignora las cabeceras que no son TODO.

#+begin_src org

 * Encuentro con franceses                  :trabajo:

 * Etiqueta sobre etiqueta                  :una:dos:

#+end_src

** Programming
*** YASnippet
Special Characters

  1. ~$0~ → the position the cursor (after the snippte is inserted). You don't need to put a ~$0~ if you don't need to.
  2. ~$‹n›~ → a field, where the ~‹n›~ is a integer starting with 1. (Example: ~$1~, ~$2~, …). Pressing tab will move cursor to these stops for user to fill in. Multiple occurrence of the same ~$‹n›~ means typing in one field will automatically fill the other.
  3. ~${‹n›:‹default text›}~ → same as ~$‹n›~, but provides a default text.
  4. ~$&~ → means indent the line according to the mode's indentation rule.
  5. ~`…`~ → (backtick) is used to enclose elisp code. The lisp code will be evaluated in the same buffer the snippet is being expanded.

Once you create a template file, you have to load it. Call ~yas-reload-all~.

#+begin_example

Examples of defining HTML tags with field stop points:

<h1>$1</h1>

<img src="$1" class="$2" alt="$3">

You can also include lisp code in your template. For example, you might want to have a date stamp. Here's a example that insert user's email address and datestamp.

`user-mail-address`

`(current-time-string)`

#+end_example

*** IDE package error
Si al usar un IDE como lsp-mode surgen errores al principio, probar actualizar los paquetes. ~auto-package-update-now~
~package-refresh-content~

*** JS typescript error
Si al activar lsp-mode para js no funciona, probar cargando el modo ~typescript~ con esto se apertura el lps server.

*** flymake-mode
Habílita el modo flymake (verificador de sintaxis sobre la marcha).

*** IDE (Daniel)
Option 1, the „cheap“ but good enough option:
- helm-git-grep (with helm, of course), and just typing a few letters of where I want to go. For instance, if I want to go to where a function is defined, I type „name def“ (or „def name“ or „name d“ or „f.name“ or „f na“, … Helm does fuzzy matching and finds it)
- for syntax errors: flymake

Option 2, elegant one:
- lsp and eglot (already integrated into the latest Emacs).  I have a call like (add-hook 'python-mode-hook 'eglot-ensure)  in .emacs, and it enables many features, like going to definition with M-. (and back, with M-,). You need a lsp server, e.g. pyls for Python, ccls for C, etc.

Projectile:
Is a project interaction library for Emacs. Its goal is to provide a nice set of features operating on a project level without introducing external dependencies (when feasible). This library provides easy project management and navigation.

debugging "console.log" ...
Python has a REPL (look this up) where you can run interactive commands. There are JavaScript REPL tools too, e.g. I used the node.js one.
The interesting trick is that in the middle of a program you can invoke the REPL shell. So it stops there (at any point you want) and you can type commands to inspect the variables or even to change them.
And you get extra commands, like „next“ to execute the next line, „cont“ to stop debugging, „where“ to see the stack, „list“ to see the code, etc.
And autocompletion etc.
To do that, you just insert this line in a Python program: from ipdb import set_trace; set_trace()

*** edebug
Depurador a nivel de fuente que requiere de escribir una función antes de poder usarlo.

Es posible desplazarse a través de la ejecución de la función, línea a línea presionando ~SPC~, o ejecutarla rápidamente hasta alcanzar un punto de ruptura donde la ejecución se detenga.

Se instala colocando el cursor dentro o justo después de la definición y escribiendo ~M-x edebug-defun~, esto hará que Emacs cargue Edebug automáticamente si aun no está cargado, y que instrumente correctamente la función. Luego se coloca el cursor después de el llamado a la función que se quiere depurar y se presiona ~eval-last-setup~.

*** Debug
**** dap-node-setup
Descarga de visual studio marketplace los paquetes "node" (previamente configurado) para poder hacer los debugger.

**** dap-debug
Ejecuta el debugger pidiendo cargar el archivo.

**** dap-ui-show-many-window
Muestra todas las ventanas que muestran configuraciones de debugger.

**** dap-ui-hide-many-window
Esconde todas las ventanas que muestran configuraciones de debugger.

**** dap-breakpoints-toggle
Coloca los breakpoints.

**** dap-debug-last
Ejecuta el último debugger sin cargar el archivo otra vez.

**** dap-switch-stack-frame
Cambie el marco de la pila seleccionando otro marco de la pila.

**** dap-disconect
Desconectar la aplicación de debugger.

**** dap-debug-recently
Lista las configurciones reciente.

**** dap-ui-sessions
Muestra las seciones actuales.

**** dap-ui-mode
Enciendo o apaga la ventanas de configuración de debugger tipo UI.

**** dap-debug-edit-template
Edita plantilla.

#+begin_src emacs-lisp

(dap-register-debug-template  "System Crafters" (list :type "node"  :request "launch"  :program "${workspaceFolder}/src/server/index.js" :outFiles ["${workspaceFolder}/public/src/server/**/*.js"]  :name "System Crafters"))
;; luego de crear la plantilla se ejecuta eval-buffer

#+end_src

También se puede poner como una plantilla las configuraciones de debugger de otras personas que usen visual studio code y habilitarlas en este .

**** dap-breakpoint-log-message
Colocar mensajes en los breakpoint , por ejemplo ~Se espera valor 26 en vez de el valor { i }~ (primero debe activarse ~dap-breakpoint-toggle~).

**** dap-next
Ejecuta la siguiente línea (útil para cuando se puso un breakpoint y solo se quiere ejecutar la siguiente línea a ver que sucede).

**** dap-continue
Continua la ejecución desde el punto.

**** dap-breakpoint-condition
Ejecuta el breakpoint según una condición, por ejemplo ~i === 5~ (se detendrá si ~i~ es igual a ~5~).

**** dap-ui-expression-add
Añade expresiones a la ventana local, en el mini-buffer se coloca por ejemplo ~i~ entonces se agrega esa variable a la pantalla local y asi se puede seguir sus cambios mientras se va depurando el código.

**** dap-ui-expression-remove
Remueve la expresión.

**** dap-ui-repl
Abre una vetana donde se puede evaluar código con las variables que se tiene o de manera independiente (útil para probar el comportamiento de una función, que resultados se obtiene o podría obtener o setearle nuevas variables y ver que comportamiento resulta).

**** dap-tooltip-at-point
Muestra información sobre la variable donde esta puesto el cursor.

*** LSP Mode
 [[https://microsoft.github.io/language-server-protocol/][Language Server Protocol]].  Before trying to set up ~lsp-mode~ for a particular language in your init file, check out the [[https://emacs-lsp.github.io/lsp-mode/page/languages/][documentation for your language]] so that you can learn which language servers are available and how to install them.

The ~lsp-keymap-prefix~ setting enables you to define a prefix for where ~lsp-mode~'s default keybindings will be added. I *highly recommend* using the prefix to find out what you can do with ~lsp-mode~ in a buffer.

The ~which-key~ integration adds helpful descriptions of the various keys so you should be able to learn a lot just by pressing ~C-c l~ in a ~lsp-mode~ buffer and trying different things that you find there.

** Terminals
*** eshell
~eshell~ is a shell written entirely in emacs lisp. Note: it is not a bash emulator. Eshell is a shell by itself, but similar to bash or other shells.

~eshell~ is good especially on Microsoft Windows where bash is not installed. Eshell is also super fast on startup. If you are a emacs lisp programer, you might prefer eshell because direct access to emacs lisp and better integration with emacs.

Tricks:
- redirect to buffers - along with the above, you can also do things like ~ls >> #<buffer *scratch*>~ to output the result from ls to the scratch buffer
- ~/dev/clip~ and ~/dev/kill~ - you can redirect shell commands to the emacs clipboard and killring

Personally (Xah Lee), i used shell from 1998 to 2013, and eshell now. But i always have a real terminal app open, for running any command i'm not familiar with. For any serious command, such as starting a server, or any command that has logs, i run it in a real terminal app, with no tie to emacs.

Is Emacs’ own shell implementation written in Emacs Lisp. It provides you with a cross-platform implementation of the common GNU utilities you would find on Linux (~ls~, ~rm~, ~mv~, ~grep~, etc). It also allows you to call Emacs Lisp functions directly from the shell and you can even set up aliases (like aliasing ~vim~ to ~find-file~). Eshell is also an Emacs Lisp REPL which allows you to evaluate full expressions at the shell.

The downsides to Eshell are that it can be harder to configure than other packages due to the particularity of where you need to set some options for them to go into effect, the lack of shell completions (by default) for some useful things like Git commands, and that REPL programs sometimes don’t work as well.

- REPL de Emacs Lisp, permite llamar a las funciones o evaluar comandos de Emacs Lisp directamente desde el shell, incluso puede configurar alias ~alias ffo "find-file-other-window $1"~ y proporciona una manera sencilla de hacer nuestros scripts en elisp en lugar de bash u otros.
- Puede correr comandos en la shell como ~find-file~, ~dired~, ...,  también correr funciones ~(+ 20 5)~  (presionando /TAB/ se puede completar las funciones).
- Puede usar comandos con pipe para enviar salida a un buffer ~echo "Hello" > #<buffer test-buffer>~.
- La sintaxis de la subshell es un poco diferente se utiliza ~${ }~ en vez de ~$( )~.
- Soporta TRAMP (controlar remotamente otra maquina).
- Programas que leen input (como lenguajes REPLs, como por ejemplo "node") y herramientas que dependen de la configuración de los ambientes de shell (nvm, virtualenv) pueden funcionar incorrectamente.
- ~*ls~ (se coloca delante para poderlo usar).

NOTES:
- Los enlaces duros y simbólicos funcionan diferente a lo esperado. Cuando se modifica el archivo original que tiene un hard link creado con eshell, cambia su valor de ~inode~ .
- Los comandos ~trap~ , ~alias~ dan problemas.
- No permite crear redirecciones tales como ~cat << Whatever~ .
- Comandos que impliquen opciones que manipulan enlaces simbólicos como ~cp -a dir dirNew~  dan problema.
- No funciona el comando para asignar variables ~var=variable~ .

*Aliases*:
A common alias for ~ls -l~, and would be defined with the command invocation ~alias ll 'ls -l $*'~ ; with this defined, running ~ll foo~ in Eshell will actually run ~ls -l foo~. 

Aliases defined (or deleted) by the alias command are automatically written to the file named by ~eshell-aliases-file~ (this defaults to something like ~~/.emacs.d/eshell/aliases~), which you can also edit directly (although you will have to manually reload it).

Note that unlike aliases in Bash, arguments must be handled explicitly. Typically the alias definition would end in ~$*~ to pass all arguments along. More selective use of arguments via ~$1~, ~$2~, etc., is also possible. For example, alias ~mcd 'mkdir $1 && cd $1'~ would cause ~mcd foo~ to create and switch to a directory called ~foo~.

*Warning*: if this doesn't work and get the error ~command not found~ , remove the quote, e.g. type the command ~alias ll ls -l $*~  instead of ~alias ll 'ls -l $*'~.

*** vterm
Is an improved terminal emulator package which uses a compiled native module to interact with the underlying terminal applications. This enables it to be much faster than ~term-mode~ and to also provide a more complete terminal emulation experience.

Make sure that you have the necessary dependencies installed before trying to use ~vterm~ because there is a module that will need to be compiled before you can use it successfully.

*** shell
~shell~ is the standard emacs interface to Operating System's command line interface.

~shell~ is the most popular. It is good for general use of classic/standard unix shell commands, such as {grep, du, ls, sort, cat, head, tail, uname, …}.

Es un termino medio entre ~term~ y ~eshell~. No es un emulador de terminal es solo una shell por lo que no se ejecutarán programas de terminal más complejos dentro de él. Tiene de ventaja que no se necesita cambiar de modo para habilitar el minibuffer. (Mejor opción para windows si se quiere usar PowerShell, bash, wsl).

Ejecuta el shell predeterminado del sistema, dentro de un buffer de Emacs, por lo que todas las entradas de comandos en este modo son manejadas por Emacs y luego se envían al shell subyacente una vez se presiona enter. Es una subshell y no podrá ejecutar todos los comandos que se le pasen.

*** term
~term~ is a terminal emulator. It behaves like a dedicated terminal app, such as {~xterm~, ~gnome-terminal~, ~puTTY~}. It is compatible to more shell apps than emacs shell interface, but standard emacs keys such as moving cursor doesn't work here.

~term~ and ~ansi-term~ are good if you want to run stuff like ssh, or other command line interactive interface (such as {python, ruby, lisp} shell), or text based GUI app such as vim.

Emulador de terminal integrado. Esta escrito en Emacs Lisp por lo que es un poco más lento pero se puede usar de inmediato con poca configuración, admite aplicaciones de terminal bastante complejas (htop, vim, etc...).

- Ejecuta el shell que le digamos (bash, zsh, ...). Este comando abre un terminal completo en un buffer de Emacs. Es interactivo, y además funcionarán las aplicaciones basadas en curses.
- Permite realizar conexiones remotas a través de ssh o telnet. Se puede utilizar el terminal a través de un puerto serie con ~M-x serial-term~ y comunicarse con cualquier dispositivo que se tenga conectado a un puerto serie.
- ~line-mode~ utiliza combinaciones de teclas de Emacs. ~char-mode~ manda las pulsaciones de teclas a la terminal subyacente.
- ~eval-expression "(getenv "SHELL")~ ejecuta una terminal no por default

*** ansi-term
Similar a ~term~ con ligeras diferencias. (Útil para abrir varias terminales con nombres distintos).

** Tutorials
*** Abbrev Mode by Commands
**** Turn on Abbrev Mode
~M-x abbrev-mode~ to turn it on. Call again to turn off.

To turn on globally when emacs starts, put this in your Emacs Init File:
~(setq-default abbrev-mode t)~

**** Define Abbrev
Suppose you want to define “bg” → “background”.

 1.  Type “background”.
 2. ~M-x add-global-abbrev~, in the prompt, type “bg”.

Now, when you type “bg” followed by a space or return, it'll expand to “background”.

If you want the abbrev only for the current major mode,

~M-x add-mode-abbrev~

If the expanded text is more than one word, for example, suppose you want to define “faq” → “frequently asked questions”.

  1. Type “frequently asked questions”.
  2. Select the text.
  3. ~C-u 0~
  4. ~M-x add-global-abbrev~, in the prompt, type “faq”.

*NOTE*:
I put “z” in the beginning of my abbrevs. This way, i don't have to worry about clash with short words that i don't want to expand.

#+begin_src emacs-lisp

;; signature
"zxl"   →   "Xah Lee"

;; url
"zuxl"   →   "http://xahlee.info/"

;; emacs regex
"zd"   →   "\\([0-9]+?\\)"
"zstr"   →   "\\([^\"]+?\\)\""

;; shell commands
"zditto"   →   "ditto -ck --sequesterRsrc --keepParent src dest"
"zim"   →   "convert -quality z5% "

;; math/unicode symbols
"zin"   →   "∈"
"znin"   →   "∉"
"zinf"   →   "∞"
"zluv"   →   "♥"
"zsmly"   →   "☺"

;; email
"zme"   →   "someone@example.com"

;; computing tech
"zwp"   →   "Wikipedia"
"zg"   →   "Google"

;; normal english words
"zalt"   →   "alternative"
"zchar"   →   "character"
"zdef"   →   "definition"

#+end_src

**** Remove Abbrev
To remove a definition, give a negative argument to add-global-abbrev or add-mode-abbrev.

For example, to undefine the abbrev “bg”.

  1. ~C-u -1~.
  2. ~M-x add-global-abbrev~, in the prompt, type “bg”.

**** Save Abbrev
When you quit, emacs will ask you if you want to save.

To auto save, put this in your Emacs Init File:

~(setq save-abbrevs 'silently)~

The abbrevs is saved in a file at a path specified by the variable

~abbrev-file-name~

By default, it's at ~~/.emacs.d/abbrev_defs~

**** List and Edit
Display a list of defined abbrevs.
~M-x list-abbrevs~

Edit Abbrevs
~M-x edit-abbrevs~

**** Abbrev File Location
The abbrevs is saved in a file at a path specified by the variable ~abbrev-file-name~

By default, it's at  ~(~/.emacs.d/abbrev_defs)~

You can change it, for example, put this in emacs init:

~(setq abbrev-file-name "~/emacs_abbre.el")~

**** Edit Abbrevs
Call ~edit-abbrevs~ to edit abbrev.

To remove a abbrev, just delete the line.
To add a abbrev, just add a line.

When done, to load and or save, call any of:

~edit-abbrevs-redefine~  → Redefine abbrevs according to current buffer contents.
~abbrev-edit-save-buffer~  → Redefine and save to abbrev file.
~abbrev-edit-save-to-file~ → Redefine and save to abbrev file, but ask for a location.

**** Reference

[[http://xahlee.info/emacs/emacs/emacs_abbrev_mode_tutorial.html]]

https://wilkesley.org/~ian/xah/emacs/emacs_abbrev_mode.html

**** Abbrev Mode by Lisp Code
Emacs's abbrev feature lets you type a short word and expand into a full word or code template.

[[http://xahlee.info/emacs/emacs/emacs_abbrev_mode.html]]

*** Interactively Find/Replace Text in Directory
Suppose you need to do find/replace of a string pattern, for the hundreds of files in a directory. However, you do not want to replace all of them. You need to look at it in a case-by-case basis. What can you do?

   1. Call dired to list files in dir, or call ~find-dired~ if you need all subdirectories.
   2. Mark the files you want. You can mark by regex by typing ~% m~.
   3. Type Q to call ~dired-do-query-replace-regexp~.
   4. Type your find regex and replace string.
   5. For each occurrence, type y to replace, ~n~ to skip.
   6. Type ~!~ to replace all occurrences in current file without asking, ~N~ to skip all possible replacement for rest of the current file. (N is emacs 23 only)
   7. To do the replacement on all files without further asking, type ~Y~. (Emacs 23 only)
   8. Call ~ibuffer~ to list all opened files.
   9. Type ~* u~ to mark all unsaved files, type ~S~ to save all marked files, type ~D~ to close them all.

https://wilkesley.org/~ian/xah/emacs/find_replace_inter.html

*** LaTeX installation
Descargar el paquete ~texlive~, esto debería ser suficiente ya que el paquete trae todos los paquetes necesarios para trabajar con LaTeX, sin embargo debido a un error ~org-compile-file: File "/tmp/orgtexrJsNOr.dvi" wasn’t produced.  Please adjust ‘dvipng’ part of ‘org-preview-latex-process-alist’~ también arrojaba lo siguiente ~! LaTeX Error: File `ulem.sty' not found.,~ se necesito descargar el paquete adicional ~texlive-plain-generic~ para obtener ~ulem~.

Para exportar de org a LaTeX pdf se necesito instalar el paquete ~texlive-latex-extra~ para obtener ~wrapfig~ que soluciona el error ~! LaTeX Error: File `wrapfig.sty' not found~.

*** Edit Column Text, Rectangle Commands
This page shows you how to edit text in a rectangular region.

- Add a prefix to every line (such as # or //)
     1- Move to the beginning of first line you want.
     2- Press ~C-SPC~ (~set-mark-command~) to mark cursor position.
     3- Move cursor to the beginning of the last line.
     4- Then ~M-x string-rectangle~ ( ~C-x r t~ )
     5- Then type what you want to insert, then Enter.
The command ~string-rectangle~ can be used to insert a vertical column of string across mulitple lines at any column position, not just at the beginning of lines.

- Delete the first few n chars of every line ( ~kill-rectangle~o )
- Delete a column of text ( ~kill-rectangle~ )
- replace-rectangle
- Paste Rectangle ( ~yank-rectangle~ )
- Insert a Column of Numbers ( ~rectangle-number-lines~ )

http://xahlee.info/emacs/emacs/emacs_string-rectangle_ascii-art.html


Insert A to Z Vertically:
1- Move cursor to before specific start word.
2- ~set-mark-command~ ( ~C-SPC~ ).
3- Move cursor to before specific end word.
4- ~universal-argument~ ( ~C-u~ ).
5- Now, ~M-x rectangle-number-lines~. It will prompt you to enter arguments.
6- Type ~65~ (Letter ~A~ has Unicode codepoint ~65~. ~a~ is ~97~).
7- Remove the default ~%2d~ , type ~%c~. (the ~%c~ is for character format)

*** Demo Configuration init file
This configuration is not intended to be used! However, if you’re curious:

Put this text in a file called demo.el:

#+begin_src emacs-lisp

;; Make the colors and text less eye-strainy
(load-theme 'tango-dark t)
(set-face-attribute 'default nil :height 200)

;; I mindlessly press ESC, so stop me from wreaking havoc
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)

#+end_src

Run Emacs with the configuration:

#+begin_src shell

emacs -Q -l demo.el

#+end_src

*** Web with example of Calc usage
Useful becase it has some functions to show how to calculate the number of days between two days, and optionally a number of periods of absence to exclude.

https://www.emacswiki.org/emacs/Calc

** Miscellaneous
*** Draw ASCII
**** artist-mode
Lets you draw ASCII pictures with mouse. Permite dibujar líneas, cuadrados, rectángulos y polilíneas, elipses y círculos con el mouse y/o el teclado en formato AsCii.

  - Left mouse button to draw.
  - Right mouse button to erase.
  - Middle click (mouse-2) to switch to rectangle, ellipse, and other tools.

Cuando se utiliza *line* para crear líneas, con el caracter ~>~ y ~<~ se le pueden colocar las flechas.

#+begin_src ditaa :file some_filename.png :cmdline -r -s 0.8

    +-----------+        +---------+
    |    PLC    |        |         |
    |  Network  +<------>+   PLC   +<---=---------+
    |    cRED   |        |  c707   |              |
    +-----------+        +----+----+              |
                              ^                   |
                              |                   |
                              |  +----------------|-----------------+
                              |  |                |                 |
                              v  v                v                 v
      +----------+       +----+--+--+      +-------+---+      +-----+-----+       Windows clients
      |          |       |          |      |           |      |           |      +----+      +----+
      | Database +<----->+  Shared  +<---->+ Executive +<-=-->+ Operator  +<---->|cYEL| . . .|cYEL|
      |   c707   |       |  Memory  |      |   c707    |      | Server    |      |    |      |    |
      +--+----+--+       |{d} cGRE  |      +------+----+      |   c707    |      +----+      +----+
         ^    ^          +----------+             ^           +-------+---+
         |    |                                   |
         |    +--------=--------------------------+
         v
+--------+--------+
|                 |
| Millwide System |            -------- Data ---------
| cBLU            |            --=----- Signals ---=--
+-----------------+

#java -jar ditaaXXX.jar
#java -jar ditaa0_9.jar demo.txt

#+end_src

**** picture-mode
Emacs's picture-mode lets you draw ASCII diagrams.

To see how to use it:

  1. Open a new file.
  2. Alt+x picture-mode,
  3. Alt+x describe-mode

*** Keyboard
**** Keyboard Shortcut vs Launch Buttons
Single Key is Much Better than Key Combinations

For example, say that F6 is launching the Firefox browser. I use 3 browsers daily, because i am a web developer. I might think, that F6 launches Firefox, and Ctrl + F6 launches Microsoft's browser, and Alt + F6 launches Google Chrome web browser. The idea is that the F6 is always associated with launching a browser. This keeps all the hotkeys consistent and easier to remember. My experience tells me that, if these functions are needed frequently (say, even just once per 10 min on average), then, single key hotkeys is much more important than consistency. (So, here it would be better to have F6, F7, F8, to launch each browser.)

[[http://xahlee.info/kbd/keyboard_special_buttons.html]]

**** Keyboards Review
The following are my recommendation, in order of importance:

  1. Mechanical keys
  2. Have physical arrow keys.
  3. Full sized function keys F1 to F12, and they should have gaps between groups of 4, and have a gap between the function key row and the number row. (Extra macro keys is a plus.)
  4. Programable (e.g. make CapsLock do Escape) with Onboard Memory (plug in to any computer to have custom macro/layout. No need to install software.).
  5. Key lable don't wear off.
  6. Spacebar do not make a loud thud noise.
  7. Has physical media keys. Volume wheel is a major plus.
  8. No Fn key. Because it's usually hardwired, meaning, you can't remap it, meaning, a dead horse squatting in front yard.
  9. Short spacebar or split spacebar. So more thumb keys.
  10. Should be one with large Alt and Ctrl keys, and they should be available on both sides (one set for each hand, just like ⇧ Shift key), and the right side's set should be positioned symmetrically. The distance from F to left Alt, and distance from J to the right Alt, should be the same.

Other issues, such as whether it has numerical keypad, how compact it is, how light weight or heavy it is, wired or wireless, what color LED light show it does, is up to you.

http://xahlee.info/kbd/keyboard_review_gallery.html

Some ergonomic keyboard

- X-Bows Keyboard http://xahlee.info/kbd/xbows_keyboard_review.html

*** Packages
**** Keybindings
***** general
Paquete ~general.el~ setea varios key binding globales o de modos.

***** hydra
Vincular comandos relacionados en una familia de enlaces cortos con un prefijo común.

**** Programming IDE
***** lsp
Proporcionar una experiencia similar a IDE al proporcionar integración opcional con los paquetes como ~company~, ~flycheck~, ....

Primero se necesita el modo ~lsp-mode~, que es un cliente Emacs para un servidor LSP. Luego, se debe instalar el servidor LSP específico para el idioma. Finalmente, se debe llamar a ~M-x lsp~ o usar el enlace de modo principal correspondiente para iniciar automáticamente el servidor.

***** lsp-ui
Contiene todos los módulos de interfaz de usuario de nivel superior del modo lsp, con información de los símbolos en la línea actual, diagnósticos de ~flycheck~, acciones de código LSP código (de forma predeterminada ~lsp-mode~ activa automáticamente ~lsp-ui~).

***** lsp-ivy
Integra ~ivy~ con el ~lsp-mode~ para facilitar la búsqueda de cosas por nombre en el código.

***** flycheck
Funciona de verificador de sintaxis sobre la marcha.

***** lsp-treemacs
Proporciona vistas de árbol para diferentes aspectos.

***** company
Proporciona una mejor interfaz de finalización en el búfer.

***** yasnippet
Sistema de plantillas. Permite escribir una abreviatura y expandirla automáticamente.

***** swank-js
Proporciona SLIME REPL y otras herramientas de desarrollo para JavaScript y Node.JS en el navegador. Consiste en el backend de SWANK y la contribución de SLIME que lo acompaña. Socket.IO se utiliza para comunicarse con una amplia gama de navegadores web.

***** js2-refactor
Una biblioteca de refactorización de JavaScript. Esta es una colección de pequeñas funciones de refactorización para promover la idea de un IDE de JavaScript en Emacs que comenzó con js2-mode.

**** Debug
***** dap-mode
Es el cliente/biblioteca de Emacs para el protocolo de adaptador de depuración, es un protocolo de conexión similar a LSP para la comunicación entre el cliente y el servidor de depuración.

***** typescript-mode
Es un ~major-mode~ para editar archivos Typescript o Javascript, ofrece resaltado de sintaxis simple y soporte de sangría, para funciones avanzadas, sin ninguna dependencia externa.

**** Regexp
***** visual-regexp
visual-regexp for Emacs is like replace-regexp or regex-builder, but with live visual feedback directly in the buffer.

https://github.com/benma/visual-regexp.el

**** Help
***** which-key
En una ventana emergente, muestra las combinaciones de teclas que siguen a un comando incompleto (un prefijo).

***** ivy
Es una interfaz interactiva en el minibuffer para completar en Emacs (muestra información de funciones, comandos,...).

***** ivy-rich
Interfaz más amigable (transformador de pantalla) para ~ivy~. Muestra columnas adicionales para ~counsel comands~ proporcione  información adicional.

***** ivy-prescient
Clasifica los candidatos a completar de ~ivy~.

***** counsel
Conjunto de comandos para reemplazar los comandos de finalización predeterminados usando ~ivy~.

***** helpful
Es una alternativa a la ayuda integrada de Emacs que proporciona mucha más información contextual y mejora visual.

***** helm
Mecanismo de completacion terminal que ayuda a completar rápidamente nombres de archivos, nombres de búfer o cualquier otra interacción que requiera seleccionar un elemento de una lista de opciones posibles.

**** Miscellaneous
***** elfeed tube
Youtube on your terms
It's a rss for youtube in emacs. I might like it because it shows the transcript.

https://github.com/karthink/elfeed-tube

** Emacs Lisp
*** Modes
**** Mode
A set of definitions that customize the behavior of Emacs in useful ways. It is basically a collection of features that can be applied to a single buffer or to the entire editor.

There are derived modes, such as HTML mode which is derived from Text mode. When HTML mode is enabled, run ~text-mode-hook~ before running ~html-mode-hook~.

**** Major mode
They provide specialized functions for working on a particular type of file or buffer, used for editing or interacting with a particular type of text. They are mutually exclusive; each buffer has one and only one at any time.

Most modes are divided into three main groups, the first group contains modes for plain text, either plain or markup (Text mode, HTML mode, SGML mode, TeX mode and Outline mode). The second contains modes for specific programming languages (Lisp (which has several variants), C mode, ...). The third consists of main modes that are not directly associated with files; they are used in buffers created for specific purposes by Emacs (Dired mode, Message to Mail mode, Shell mode).

**** Minor mode
Optional editing mode provides functions that users can turn on and off while editing. Unlike the major modes, any number of minor modes can be active at any time. They are independent of each other and of the selected major mode.

*** Hook
Hooks are an important mechanism for customizing Emacs. A hook is a Lisp variable which holds a list of functions, to be called on some well-defined occasion. (This is called running the hook.) The individual functions in the list are called the hook functions of the hook. For example, the hook ~kill-emacs-hook~ runs just before exiting Emacs.

Each hook is designed to “run” when some event happens. When a hook “run”, all functions in that hook are called.

For example,
  - when ~html-mode~ is loaded, ~html-mode-hook~'s functions are run.
  - when any command is called, ~post-command-hook~'s functions are run.

There are hundreds of hooks. Each major mode usually have at least 1 hook, designed to run when the mode is loaded.

A hook is similar to the concept of events in other systems. Adding function to a hook is similar to adding event handlers. (note: emacs lisp manual also uses the term “event”, but that is lower level events to emacs, not events by emacs.)

For example ~prog-mode-hook~ is a hook to any mode of programming languages. It is a main mode that does nothing more than let other main modes inherit from it, exactly for this purpose.

Most hooks are *normal hooks.* This means that when Emacs runs the hook, it calls each hook function in turn, with no arguments. Every variable whose name ends in  ~-hook~  is a normal hook.

A few hooks are *abnormal hooks*. Their names end in  ~-functions~ , instead of ~-hook~. What makes these hooks abnormal is the way its functions are called—perhaps they are given arguments, or perhaps the values they return are used in some way. For example, ~find-file-not-found-functions~ is abnormal because as soon as one hook function returns a non-nil value, the rest are not called at all.

*** keymaps
Internal data structure that records key bindings to commands or other keymap.

When an event type is bound to a keymap, that keymap is used to search for the next input event; this continues until a command is found. Mode-specific keymaps overwrite the global ~(mode-map)~ that all buffers share.

*** Commands
**** Lines
***** list-matching-lines (occur)
Show all lines in the current buffer containing a match for REGEXP.

***** delete-matching-lines (flush-lines)
Delete lines containing matches for REGEXP.

~delete-matching-lines~ starts at the line your cursor is on.

***** delete-non-matching-lines (keep-lines)
Delete all lines except those containing matches for REGEXP.

~delete-non-matching-lines~ starts at the line your cursor is on.

***** delete-duplicate-lines
Delete all but one copy of any identical lines in the region.

***** count-matches (how-many)
Print and return number of matches for REGEXP following point.

***** sort-lines
Sort lines in region alphabetically; REVERSE non-nil means descending order

***** reverse-region
Reverse the order of lines in a region.

***** highlight-lines-matching-regexp
Highlight all lines that match REGEXP using FACE.

***** unhighlight-regexp
Remove highlighting of each match to REGEXP set by hi-lock.

***** fill-paragraph
Fill paragraph at or after point.

It's often used to reduce the lenght of the lines of code documentation.

**** Regex
***** isearch-forward
Do incremental search forward.

***** isearch-backward
Do incremental search backward.

***** highlight-regexp
Set face of each match of REGEXP to FACE.

***** find-dired
Run find and go into Dired mode on a buffer of the output.

***** dired-do-search
Search through all marked files for a match for REGEXP.

While in dired, you can *step thru all files that matches a text pattern*. In dired, call ~dired-do-search A~. It will prompt you for a search string, then open the first file of the match, with your cursor placed at the matching location.

To go to next occurrence, press ~M-,~ (~tags-loop-continue~).

***** dired-do-query-replace-regexp
Do query-replace-regexp of FROM with TO, on all marked files.

***** dired-do-rename-regexp
Rename selected files whose names match REGEXP to NEWNAME.

***** grep
Call ~grep~ to list all matching text of all files in the current directory.

For example, if you give this input ~grep -nH -e "Cheshire" *html~, which will list all files ending in “html” that contains the word “Cheshire”.

If you want case insensitive search, add a ~-i~ in the grep option.

***** rgrep
Search all files in current directory and sub-directory.

***** lgrep
Search only some files of current dir by using a text pattern (regex) on file names first.

***** grep-find
Use a combination of unix's ~grep~ and ~find~ commands..

**** String
***** string-rectangle
Replace rectangle contents with STRING on each line.

*Note*: The command string-rectangle can be used to insert a vertical column of string across mulitple lines at any column position, not just at the beginning of lines.

***** kill-rectangle
Delete the region-rectangle and save it as the last killed one.

~kill-rectangle~ can be used to delete any rectangular block of text, not just at the beginning of lines.

There are others useful command like ~replace-rectangle~, ~yank-rectangle~,...

#+begin_example

try to delete the middle column
3c21 646f 6374
6874 6d6c 3e3c
2063 6861 7273
202f 3e0a 3c6d
6965 7770 6f72
2277 6964 7468

1. Put your cursor before “646f”.
2. Call set-mark-command =C-SPC=.
3. Move cursor to end of “6964”.
4. Call =kill-rectangle=.

#+end_example

***** align-regexp
Align the current region using an ad-hoc rule read from the minibuffer.Align the current region using an ad-hoc rule read from the minibuffer.

There are others useful command like ~align-regexp~, ~sort-regexp-fields~, ~sort-columns~.

Example pressing ~align-regexp~ with "=" align the text.

#+begin_example

align them by the equal sign
tom = 5
jenny = 8
mary = 7

align
California 423,970 km²
Taiwan 36,008 km²
Japan 377,944 km²
Germany 357,021 km²
Iraq 438,317 km²
Iran 1,648,195 km²
Korea (North+South) 219,140 km²
Mexico 1,964,375 km²

Select the text first, then press C-u then call align-regexp, with the regexp .* \([0-9,]+\).* then choose -1 for group, 1 for spacing, and n for repeat.

#+end_example

**** Misc
***** command-history
Examine commands from command-history in a buffer.
***** apropos
 This command is like the ~C-h a~ (command-apropos) command, except that the latter finds only those functions that are commands. The ~M-x apropos~ command lists all symbols that match a regular expression, including functions that are not interactive.

#+begin_src emacs-lisp

;; Example: we want to look for is some command that prints or inserts columns. Very likely, the name of the function will contain either the word “print” or the word “insert” or the word “column”. Therefore, we can simply type:

M-x apropos RET print\|insert\|column RET

#+end_src

***** compare-windows
Compare text in current window with text in another window.

***** custom-reevaluate-setting
Reset the value of SYMBOL by re-evaluating its saved or standard value.

*Note*: "saved or standard value". In that order of precedence. If the user has customized and saved a value for the variable, this function resets it to its saved-value, not its standard-value.

#+begin_src emacs-lisp

(custom-reevaluate-setting 'emms-player-next-function)

#+end_src

***** whitespace-cleanup
Cleanup some blank problems in all buffer or at region.

***** delete-trailing-whitespace
Delete trailing whitespace between START and END.

*** Load file
**** load
You can use a ~load~ command to evaluate a complete file and thereby install all the functions and variables in the file into Emacs.

Load a file by searching thru var ~load-path~. Argument should be just the file name without full path, such as ~(load "undo")~. It'll auto add “.elc” for compiled version if exist, or add “.el”, or with “.gz”.	Use this if the exact file path is not known in advance.

#+begin_src emacs-lisp

;; This evaluates, i.e., loads, the slowsplit.el file or if it exists,
;; the faster, byte compiled slowsplit.elc file from the emacs
;; sub-directory of your home directory.
(load "~/emacs/slowsplit")

#+end_src

**** load-file
Load a specific file. Load one specific file. (“.el” or “.elc” file name extentions are not auto added, but “.gz” is.) Use this when you don't want emacs to guess the file name extention of “.el”, “.elc” or none.

**** require
Load a package if it has not already been loaded. Checks the var ~features~, if symbol is not there, then call ~load~ to load it. File name is guessed from the feature name, or specified in the optional argument. Best used in elisp libraries or scripts, similar to other lang's “require” or “import”.

**** autoload
Load a file only when a function is called. Associate a function name with a file path. When the function is called, load the file, and execute the function. If you are writing a major mode, have your package installation go by ~autoload~ if possible. It saves startup time.

Instead of installing a function by loading the file that contains it, or by evaluating the function definition, you can make the function available but not actually install it until it is first called. This is called *autoloading*.

When you execute an autoloaded function, Emacs automatically evaluates the file that contains the definition, and then calls the function.

 ~autoload~ is a built-in function that takes up to five arguments, the final three of which are optional.

The first argument is the name of the function to be autoloaded.
The second is the name of the file to be loaded.
The third argument is documentation for the function.
The fourth tells whether the function can be called interactively.
The fifth argument tells what type of object.

~autoload~ can handle a keymap or macro as well as a function (the default is a function).

#+begin_src emacs-lisp

;; This expression autoloads the html-helper-mode function. It takes it
;; from the html-helper-mode.el file (or from the byte compiled version
;; html-helper-mode.elc, if that exists.) The file must be located in a
;; directory specified by load-path.
(autoload 'html-helper-mode
  "html-helper-mode" "Edit HTML documents" t)

#+end_src

**** Feature, require, provide
- ~features~ is a elisp symbol that represent a lisp package. It is a global variable, holding a list of elisp symbols that are features.
- A package can call ~(provide 'symbol_name)~. When this code is evaluated, emacs will add the symbol name to the ~features~ list.
- When the code ~(require 'symbol_name)~ is called, emacs check if that symbol name is already in the ~features~ list. If not, load it. (emacs will guess a file name based on the symbol name. Or, the ~require~ function may specify a file name in the 2nd argument.)

The purpose of features is for emacs to know if a package is already loaded.

The ~features~ variable and the functions {~provide~, ~require~}, is the mechanism.

The ~require~ function checks the ~features~ variable to see if a symbol is already there, if not, then load the file.

The ~provide~ function adds a symbol to the ~features~ list.

**** Loading the File
***** Load the File Manually
Suppose you downloaded a simple emacs package on the web named ~xyz.el~. To use the package, all you have to do is to make emacs load the file.

  1. ~M-x load-file~ then give the file path.
  2. Now, emacs is aware of the package. To activate, call the command in the package. For example, if the file name is ~xyz.el~, then the command to activate it is typically ~xyz~ or ~xyz-mode~.

***** Load File at Startup
If you want emacs to load the file when it starts, put the file in the dir ~~/.emacs.d/lisp/~, (create that directory if it doesn't exist, by convention, this dir is for packages you manually installed.) then put the following in your emacs init file:

#+begin_src emacs-lisp

;; Tell emacs where is your personal elisp lib dir
(add-to-list 'load-path "~/.emacs.d/lisp/")

;; load the packaged named xyz.
(load "xyz") ;; best not to include the ending “.el” or “.elc”

#+end_src

***** Byte Compile
Elisp source code can be byte compiled. When a file is byte compiled, it loads faster, and the functions will run faster too (about 6 times faster). For simple packages, the difference in speed is not noticeable.

To compile your code, call ~byte-compile-file~. Once you compiled the code, you'll get a file with suffix ~.elc~.

You can byte-compile multiple files. In dired, press ~m~ to mark them (press ~u~ to unmark), then press ~B~ (~diredp-byte-compile-this-file~).

***** Auto-Activation of Mode When Opening File
This is usually setup by the package, but not always. Here's the basics:

#+begin_src emacs-lisp

;; setup files ending in “.js” to open in js2-mode
(add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))

#+end_src

**** site-wide
In addition to your personal initialization file, Emacs automatically loads various site-wide initialization files, if they exist. These have the same form as your ~.emacs~ file, but are loaded by everyone.

Two site-wide initialization files, ~site-load.el~ and ~site-init.el~, are loaded into Emacs and then dumped if a dumped version of Emacs is created, as is most common.

Three other site-wide initialization files are loaded automatically each time you start Emacs, if they exist. These are ~site-start.el~ (it pretty much means a init file for all users of this emacs installation), which is loaded /before/ your ~.emacs~ file, and ~default.el~, and the terminal type file, which are both loaded /after/ your ~.emacs~ file.

Settings and definitions in your ~.emacs~ file will overwrite conflicting settings and definitions in a ~site-start.el~ file, if it exists; but the settings and definitions in a ~default.el~ or terminal type file will overwrite those in your ~.emacs~ file. (You can prevent interference from a terminal type file by setting ~term-file-prefix~ to ~nil~.)

The ~INSTALL~ file that comes in the distribution contains descriptions of the ~site-init.el~ and ~site-load.el~ files.

The ~loadup.el~, ~startup.el~, and ~loaddefs.el~ files control loading. These files are in the lisp directory of the Emacs distribution and are worth perusing.

The ~loaddefs.el~ file contains a good many suggestions as to what to put into your own ~.emacs~ file, or into a site-wide initialization file.

*** Variables
**** Buffer local variables
You can set the value of a variable for the current buffer only using ~setq-local~. Any code that runs in that buffer will receive the buffer-local value instead of the global value!

Why do this? There are many settings that should only be set per buffer, like editor settings for different programming languages and customization variables for major modes.

If the variable isn’t already buffer-local, ~setq-local~ will make it so, but only for the current buffer!

#+begin_src emacs-lisp

(setq-local tab-width 4)

;; some-value doesn't exist yet!
(setq some-value 2)

;; Make it buffer-local
(setq-local some-value 4)

#+end_src

**** Making a variable local for all buffers
You can make any variable local for all future buffers with the make-variable-buffer-local function:

#+begin_src emacs-lisp

(setq not-local-yet t)
(make-variable-buffer-local 'not-local-yet)

#+end_src

If you are writing an Emacs Lisp package and want to provide a buffer-local variable, this is the way to do it!

#+begin_src emacs-lisp

;; Defining a variable with defvar and then making it buffer local
(defvar new-buffer-local-var 311)
(make-variable-buffer-local 'new-buffer-local-var)

#+end_src

**** Setting default values
You might also want to set the default value for a buffer-local variable with ~setq-default~:

Keep in mind that ~setq-default~ does not set the value in the current buffer, only future buffers!

#+begin_src emacs-lisp

(setq-default not-local-yet nil)

(setq-default tab-width 2
              evil-shift-width 2)

;; BEWARE!  Unexpected results using buffer-local variables:
(setq-default evil-shift-width tab-width)

;; This will create a variable that doesn't exist
(setq-default will-i-be-created t)

#+end_src

**** Defining customization variables
Customizable variables are used to define user-facing settings for customizing the behavior of Emacs and packages.

The primary difference between They show up in the customization UI (users can set them without code)

The ~defcustom~ function allows you to define a customizable variable:

#+begin_src emacs-lisp

(defcustom my-custom-variable 42
  "A variable that you can customize")

#+end_src

~defcustom~ takes some additional parameters after the documentation string:

  -  ~:type~ - The expected value type
  -  ~:group~ - The symbol that identifies the “group” this variable belongs to (defined with ~defgroup~)
  -  ~:options~ - The list of possible values this variable can hold
  -  ~:set~ - A function that will be invoked when this variable is customized
  -  ~:get~ - A function that will be invoked when this variable is resolved
  -  ~:initialize~ - A function to be used to initialize the variable when it gets defined
  -  ~:local~ - When ~t~, automatically marks the variable as buffer-local

**** Useful variables
***** org-structure-template-alist
An alist of keys and block types.

~org-insert-structure-template~ will display a menu with this list of templates to choose from.  The block type is inserted, with ~#+BEGIN_~ and ~#+END_~ added automatically.

*** Customization
**** Keybindings
***** Set key

#+begin_src emacs-lisp

;;Rebind the key C-x l to run the function make-symbolic-link
(global-set-key (kbd "C-x l") 'make-symbolic-link)
;; or
(define-key global-map (kbd "C-x l") 'make-symbolic-link)

;; Rebind for Lisp mode only.
(define-key lisp-mode-map (kbd "C-x l") 'make-symbolic-link)

;; With special characters
(global-set-key (kbd "M-a") 'backward-char) ; Alt+a
(global-set-key (kbd "C-a") 'backward-char) ; Ctrl+a
(global-set-key (kbd "C-c t") 'backward-char) ; Ctrl+c t
(global-set-key (kbd "<f9>") 'calendar) ; F9
(global-set-key (kbd "<f7> <f8>") 'calendar)    ; F7 F8

#+end_src

***** Unset key

#+begin_src emacs-lisp

;; Make C-b undefined.
(global-set-key (kbd "C-b") nil)
(global-unset-key "C-b")

#+end_src

***** With hyper or super key

#+begin_src emacs-lisp

(global-set-key (kbd "H-b") 'backward-word) ; H is for hyper
(global-set-key (kbd "s-b") 'backward-word) ; lower case “s” is for super
(global-set-key (kbd "M-H-b") 'backward-word) ; Meta+Hyper+b

#+end_src

***** Key sequence

#+begin_src emacs-lisp

(progn
  ;; define a prefix keymap
  (define-prefix-command 'my-modes-key-map)
  (define-key my-modes-key-map (kbd "<f6>") 'visual-line-mode)
  (define-key my-modes-key-map (kbd "<f7>") 'linum-mode)
  (define-key my-modes-key-map (kbd "<f8>") 'whitespace-mode)
  )

(global-set-key (kbd "<f9>") my-modes-key-map)

;; now, F9 F6 will call visual-line-mode
;; F9 F7 for linum-mode
;; F9 f8 for whitespace-mode

#+end_src

***** Substitute definition

#+begin_src emacs-lisp

;; Redefine all keys which now run next-line in Fundamental mode
;; so that they run forward-line instead.
(substitute-key-definition 'next-line 'forward-line
                           global-map)

#+end_src

**** Load

#+begin_src emacs-lisp

;; Add a directory to the variable load-path.
(add-to-list 'load-path "/path/to/lisp/libraries")

;; add ~/emacs directory to the existing load path
(setq load-path (cons "~/emacs" load-path))

;; Load the installed Lisp library named foo (actually a file foo.elc or
;; foo.el in a standard Emacs directory).
(load "foo")
;; When the argument to load is a relative file name, not starting
;; with ‘/’ or ‘~’, load searches the directories in load-path

;; Load the compiled Lisp file foo.elc from your home directory.
(load "~/foo.elc")

;; Add personal library path to load-path
(push "~/.dotfiles/.emacs.d/lisp" load-pat)h

#+end_src

**** Major mode add-hook

#+begin_src emacs-lisp

;; Make Text mode the default mode for new buffers.
(setq-default major-mode 'text-mode)


;; turning on line number only for html-mode
(add-hook 'html-mode-hook 'linum-mode)

;; Turn on Auto Fill mode automatically in Text mode and related modes..
(add-hook 'text-mode-hook 'auto-fill-mode)

;; you don’t want Auto Fill mode turned on in LaTeX mode, which is one of
;; the modes based on Text mode
(add-hook 'latex-mode-hook (lambda () (auto-fill-mode -1)))

;; remove a hook
(remove-hook 'html-mode-hook 'linum-mode)


;; binding keys only when Major Mode html-mode is active
(defun my-html-mode-config ()
  "Modify keymaps used by `html-mode'."
  (local-set-key (kbd "C-c w") 'my-bold-word) ; add a key
  (local-set-key (kbd "C-c C-p") nil) ; remove a key
  (local-set-key (kbd "<C-left>") 'my-html-skip-tag-backward)
  ;; more here
  )
;; add to hook
(add-hook 'html-mode-hook 'my-html-mode-config)

#+end_src

**** Minor mode
***** Change minor mode keys
To change minor mode keys, you need to change of the mode's keymap.

#+begin_src emacs-lisp

(progn
  ;; change isearch's keys to arrows
  (define-key isearch-mode-map (kbd "<left>") 'isearch-repeat-backward)
  (define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward))

#+end_src

For some minor modes, you need to load it first, example:

#+begin_src emacs-lisp

(progn
  ;; modify dired keys
  (require 'dired ) ;  (provide 'dired) search name in source code
;; search map in describe-function
;;(define-key keymap_name-map (kbd "key") 'command_name)
  (define-key dired-mode-map (kbd "o") 'other-window)
  (define-key dired-mode-map (kbd "C-o") 'find-file))

#+end_src

***** Modify Keys
~shell~ and ~shell-command~ M-! have many special keys. Suppose you want to change them. They both use a keymap named ~comint-mode-map~. The following is a example of redefining some of its keys.

#+begin_src emacs-lisp

(progn
  ;; "change keybindings for shell related modes."
   (define-key comint-mode-map (kbd "M-p") 'recenter)
   ;; was comint-previous-input
   (define-key comint-mode-map (kbd "M-n") 'nil)
   ;; was comint-next-input

;; rebind displaced commands that i still want a key
(define-key comint-mode-map (kbd "<f11>") 'comint-previous-input)
(define-key comint-mode-map (kbd "<f12>") 'comint-next-input))

;; Here's a example of how to redefine keybinding in minibuffer
(define-key minibuffer-local-map (kbd "M-r") 'kill-word)
(define-key minibuffer-local-map (kbd "M-s") 'other-window)

#+end_src

**** defalias

#+begin_src emacs-lisp

;; Define an alias to be use with the ~query-replace-regexp~ function by
;; typing ~like M-x qrr~.
(defalias 'qrr 'query-replace-regexp)

;; Always use ibuffer
(defalias 'list-buffers 'ibuffer)

#+end_src

**** macro
1. ~M-x name-last-kbd-macro~ and give it a name.
2. ~M-x insert-kbd-macro~ This will insert the lisp code for a named kmacro at the cursor position.
3. Copy ＆ Paste the code into your emacs init file.
4. In any future emacs session, you can call your kmacro by name just like any emacs command.

Once you've saved your macro with a name, you can also give it a keyboard shortcut, such as ~F8~.

#+begin_src emacs-lisp

;; macro for bold region, add two *
(fset 'bold
   (kmacro-lambda-form [?\C-c ?\C-x ?\C-f kp-multiply] 0 "%d"))
(global-set-key (kbd "<f7>") 'bold)

;; macro for code region, add tow =
(fset 'code
   (kmacro-lambda-form [?\C-c ?\C-x ?\C-f ?=] 0 "%d"))
(global-set-key (kbd "<f8>") 'code)

#+end_src

**** External App


#+begin_src emacs-lisp

;; To open the current file or marked dired files in external app. (as if
;; you double-clicked the file on desktop) It's useful for image files,
;; PDF file, video, audio files.
(defun xah-open-in-external-app (&optional Fname)
  "Open the current file or dired marked files in external app.
When called in emacs lisp, if Fname is given, open that.

URL `http://xahlee.info/emacs/emacs/emacs_dired_open_file_in_ext_apps.html'
Version: 2019-11-04 2023-04-05 2023-06-26"
  (interactive)
  (let (xfileList xdoIt)
    (setq xfileList
          (if Fname
              (list Fname)
            (if (string-equal major-mode "dired-mode")
                (dired-get-marked-files)
              (list buffer-file-name))))
    (setq xdoIt (if (<= (length xfileList) 10) t
                  (y-or-n-p "Open more than 10 files? ")))
    (when xdoIt
      (cond
       ((string-equal system-type "windows-nt")
        (let ((xoutBuf (get-buffer-create "*xah open in external app*"))
              (xcmdlist (list "PowerShell" "-Command"
                              "Invoke-Item" "-LiteralPath")))
          (mapc
           (lambda (x)
             (message "%s" x)
             (apply 'start-process
                    (append (list "xah open in external app" xoutBuf)
                            xcmdlist (list
                                      (format "'%s'"
                                              (if (string-match "'" x)
                                                  (replace-match "`'" t t x) x)))
                            nil)))
           xfileList)
          ;; (switch-to-buffer-other-window xoutBuf)
          )
        ;; old code. calling shell. also have a bug if filename contain apostrophe
        ;; (mapc (lambda (xfpath) (shell-command
        ;; (concat "PowerShell -Command \"Invoke-Item -LiteralPath\" " "'"
        ;; (shell-quote-argument (expand-file-name xfpath)) "'"))) xfileList)
        )
       ((string-equal system-type "darwin")
        (mapc (lambda (xfpath) (shell-command
                                (concat "open "(shell-quote-argument xfpath))))
              xfileList))
       ((string-equal system-type "gnu/linux")
        (mapc (lambda (xfpath)
                (call-process shell-file-name nil 0 nil
                              shell-command-switch
                              (format "%s %s"
                                      "xdg-open"
                                      (shell-quote-argument xfpath))))
              xfileList))
       ((string-equal system-type "berkeley-unix")
        (mapc (lambda (xfpath)
                (let ((process-connection-type nil))
                  (start-process "" nil "xdg-open" xfpath))) xfileList))))))

#+end_src

#+RESULTS:

**** Configurations

#+begin_src emacs-lisp

;; flyspell-mode
(add-hook 'text-mode-hook
        '(lambda () (flyspell-mode 1)))

(setq ispell-local-dictionary "espanol")


;; Case conversion can be toggled on/off by typing ‘M-c’ in the
;; minibuffer during search or disable case conversion
(setq case-fold-search nil)

;; In an interactive search, a space character stands for one or more
;; whitespace characters (tabs are whitespace characters). You can use
;; M-s SPC while searching or replacing to toggle between this behavior
;; and treating spaces as literal spaces.
(setq search-whitespace-regexp nil)


;;Adjusting the configuration to various platforms and Emacs versions.
;; Users typically want Emacs to behave the same on all systems, so the
;; same init file is right for all platforms. However, sometimes it
;; happens that a function you use for customizing Emacs is not available
;; on some platforms or in older Emacs versions. To deal with that
;; situation, put the customization inside a conditional that tests
;; whether the function or facility is available, like this:
(if (fboundp 'blink-cursor-mode)
    (blink-cursor-mode 0))

(if (boundp 'coding-category-utf-8)
    (set-coding-priority '(coding-category-utf-8)))

;; You can also simply disregard the errors that occur if the
;; function is not defined.
(ignore-errors (set-face-background 'region "grey75"))

#+end_src

**** Miscellaneous

#+begin_src emacs-lisp

;; Example of how to use Hydra package.
(global-set-key (kbd "C-c m")
 (defhydra hydra-transpose (:color red)
   "Transpose"
    ("w" transpose-words "words")
    ("o" org-transpose-words "Org mode words")
    ("l" transpose-lines "lines")
    ("q" nil "cancel" :color blue)))

;; auto-saves buffers, when certain events happen (e.g. you switch
;; between buffers, an Emacs frame loses focus)
(use-package super-save
  :defer 1
  :diminish super-save-mode
  :config
  (super-save-mode +1))

#+end_src

* use-packages
** Install
*** Install package
Para instalar un paquete deseado sin usar ~use-package~, se puede instalar manualmente desde GitHub y colocarlo en una ruta de carga donde Emacs pueda encontrarlo, por ejemplo con ~(add-to-list 'load-path "/path/to/installed-package-repo")~. Alternativamente, se puede abrir la lista de paquetes en Emacs con ~M-x list-packages~, navegar con el cursor para encontrar el paquete que desea y presionar ~i~ seguido de ~x~ en la fila que contiene el paquete. De cualquier manera, tendría que llamar explícitamente ~(require 'package-name)~ en su ~init.el~ antes de poder hacer cualquier configuración. Por último, cualquier configuración del paquete puede necesitar estar envuelta en un ~(with-eval-after-load 'package-name ...)~ bloque, para evitar encontrarse con variables y funciones indefinidas antes de que su paquete esté completamente cargado.

Todo este procedimiento se puede evitar usando ~(use-package name)~.

*** use-package
Es una macro que permite aislar la configuración de un paquete en el archivo ~init.el~ de una manera ordenada y orientada al rendimiento.

Evita hacer todo el procedimiento tradicional y tedioso de la [[Install package][instalación]] de un paquete, ~use-package~ abstrae todo esto.

No es un administrador de paquetes! Aunque tiene la capacidad de interactuar con los administradores de paquetes, su propósito principal es la configuración y carga de paquetes.

*Warning:* Cuando aparece un error de paquete no encontrado, actualizar paquetes usando ~M-x list-package~ y si es necesario ~M-x package-refresh-contents~.

*** :ensure t
Instala el paquete pero no lo mantiene actualizado.

Asegura que los paquetes se instalen correctamente al inicio, instala automáticamente los que faltan, descargue las dependencias cada vez que se use por primera vez (útil cuando se quiere transferir la configuración entre otras maquinas).

Setear ~(use-package-always-ensure t)~ al inicio, ahorra estar especificando ~:ensure t~ en cualquier paquete que se quiera instalar o declarar.

Setear ~:ensure nil~ evita buscar el paquete en los archivos de internet ya que es un paquete incorporado  en emacs (se usa con ~use-package~ para poder usar las configuraciones de ~use-package~).

** Load
*** use-package name
Carga el paquete ~name~ pero solo si este paquete ya esta disponible en el sistema.

Si se está usando el administrador de paquetes incorporado de Emacs ~paquete.el~, simplemente agregando ~:ensure t~ a un bloque de paquete de uso hará que ~use-package~ descargue e instale el paquete si aún no está allí (esto evita la necesidad de llamar por separado a la función ~install-package~ de ~package.el~ o usar la interfaz ~list-packages~ para instalar un paquete).

El uso de ~:hook~, al igual que con ~:bind~, ~:mode~, ~:interpreter~, ... hace que las funciones enlazadas se lean implícitamente como comandos (lo que significa que establecerán definiciones de carga automática(autoload) interactivas para ese módulo, si aún no están definidas como funciones) .

*** :require
Esto carga el paquete si aún no se ha cargado.

Nunca carga el paquete si las dependencias no están disponibles en el momento en que se encuentra la declaración de uso del paquete.

 #+begin_src emacs-lisp

(use-package abbrev
  :requires foo)
;; Equivalentemente
(use-package abbrev
  :if (featurep 'foo))

 #+end_src

*** :defer
Difiere la carga del paquete (esta de manera implícita en varios keywords ~:bind~ , ~:mode~ , ~:interpreter~, ...).

Solo necesita especificar ~:defer~ si sabe con certeza que algún otro paquete hará algo para que su paquete se cargue en el momento adecuado y, por lo tanto, le gustaría diferir la carga aunque ~use-package~ no esté creando cualquier carga automática para usted.

 #+begin_src emacs-lisp

(use-package ace-jump-mode
  :defer t
  :init  (autoload 'ace-jump-mode "ace-jump-mode" nil t)
         (bind-key "C-." 'ace-jump-mode)) ; El "autoload" setea la carga automática más no carga el paquete
;; Equivalentemente
(use-package ace-jump-mode
  :bind ("C-." . ace-jump-mode))

 #+end_src

*** :after
Carga un paquete después de que se haya cargado otro. Permite una descripción bastante completa de las condiciones exactas cuando debe ocurrir la carga.

#+begin_src emacs-lisp

;; Este caso no es realmente necesario porque se carga hydra de primero
;; pero ilustra el ejemplo
(use-package hydra
  :load-path "site-lisp/hydra")

(use-package ivy-hydra
  :after (hydra))

#+end_src

*** :demand
Obliga a que la carga ocurra de inmediato y no establecerá una carga automática para la key enlazada (anula el emplazamiento de un paquete).

** Config
*** :init
Ejecuta configuraciones antes de que se cargue el paquete. Como lo que contenga ~:init~ siempre se ejecuta incluso si el paquete no esta cargado en el sistema, se debe restringir el código ~:init~ solo a lo que tendría éxito de cualquier manera. (hay paquetes que necesitan configurar variables antes de ser descargados).

Debe mantener los formularios ~:init~ tan simples y rápidos como sea posible, y poner todo lo que pueda en el bloque ~:config~. De esta manera, la carga diferida puede ayudar a que su Emacs se inicie lo más rápido posible. Además, si ocurre un error al inicializar o configurar un paquete, esto no detendrá la carga de Emacs. Más bien, el error será capturado por ~use-package~ y se informará a un búfer emergente especial de *warning*, para que pueda depurar la situación en un Emacs funcional.

*** :config
Ejecuta configuraciones después de que se cargue el paquete.

** Key-binding
*** :command
Crea cargas automáticas para los comandos y difiere la carga del módulo hasta que se usen. Toma un símbolo o una lista de símbolos.

 #+begin_src emacs-lisp

(use-package ace-jump-mode
  :commands ace-jump-mode
  :init (bind-key "C-." 'ace-jump-mode))

 #+end_src

*** :bind
Vincula key bindings a los comandos principales dentro de ese modo. Hace dos cosas, primero crea una carga automática para el comando y difiere la carga del modo hasta que realmente lo use, segundo enlaza el comando a la keybinding. Puede tomar una ~:cons cell~ o una lista de ~cons cell~.

El paquete se cargará la primera vez que se utilice una de las key bindings.

 #+begin_src emacs-lisp

(use-package ace-jump-mode
  :bind ("C-." . ace-jump-mode))

 #+end_src

*** :bind-keymap
Vincula comando a la ~keymap~.

Normalmente, ~:bind~ espera que los comandos sean funciones que se cargarán automáticamente desde el paquete dado. Sin embargo, esto no funciona si uno de esos comandos es en realidad un ~keymap~, ya que los ~keymaps~ no son funciones y no se pueden cargar automáticamente utilizando el mecanismo de carga automática de Emacs. Para manejar este caso, ~use-package~ ofrece una variante especial y limitada de ~:bind~ llamada ~:bind-keymap~.

La única diferencia con ~:bind~ es que los "comandos" enlazados por ~:bind-keymap~ deben ser ~keymap~ definidos en el paquete, en lugar de funciones de comando. Esto se maneja en segundo plano generando un código personalizado que carga el paquete que contiene el ~keymap~ y luego vuelve a ejecutar la pulsación de tecla después de la primera carga, para reinterpretar esa pulsación de tecla como una tecla de prefijo.

#+begin_src emacs-lisp

(use-package helm
  :bind-keymap ("C-c p" . help-command-map))

#+end_src

*** :map
Vincula comando a una función *dentro* de un ~local keymap~ que solo existe después de que se carga el paquete.

 #+begin_src emacs-lisp

(use-package helm
:bind (:map helm-command-map ("C-c h" . helm-execute-persistent-action)))
;;Espera hasta que "helm" se haya cargado y luego vincula la tecla "C-c h"
;;a "helm-execute-persistent-action" dentro del "local keymap" de Helm.

 #+end_src

** Modes - interpretes - hook
*** :mode
Establece enlaces diferidos dentro de estas variables ~auto-mode-alist~ e ~interpreter-mode-alist~. Hace dos cosas, primero crea una carga automática ~autoload~ para el comando y difiere la carga del mode hasta que realmente lo use, segundo enlaza el comando.

El especificador de la keyword puede ser una "cons cell" ~(:mode (a . b))~, una lista de "cons cells" ~(:mode (a . (b . c)))~, o un string ~(:mode "string")~ o regexp ~(:mode ( "\\regexp\\" ) )~.

Emacs por si solo no contiene todos los modos, así que algunos se deben descargar, por ejemplo ~typescript-mode~ , luego se debe añadir a la lista de modos, y por último si es necesario se debe agregar la expresión que reconocera la extensión del archivo, para así reconocerlo automáticamente.

 #+begin_src emacs-lisp

(use-package typescript-mode
  :mode ("\\.tsx?\\'" . typescript-mode))
;; Equivalentemente
(use-package typescript-mode
  :config (add-to-list 'auto-mode-alist '("\\.tsx?\\'" . typescript-mode)))

;; no requiere la modificación de la lista de modos automáticos
;; para el reconocimiento de expresiones regulares de extensión de
;; archivo ya que son manejados por los propios paquetes.
(use-package json-mode)

 #+end_src

*** :interpreter
Similar a [[:mode]] establece enlaces diferidos dentro de estas variables ~auto-mode-alist~ y ~interpreter-mode-alist~.

 #+begin_src emacs-lisp

(use-package python
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python" . python-mode)) ; El paquete es "python" pero el modo es "python-mode"

 #+end_src

*** :magic
Similar a [[:mode]] y a [[:interpreter]] hace que se ejecute cierta función si el comienzo de un archivo coincide con una expresión regular dada.


 #+begin_src emacs-lisp

;; Registra un comando de autocarga autoload para pdf-view-mode
;; difiere la carga de pdf-tools y ejecuta pdf-view-mode
;; si el comienzo de un buffer coincide con el string %PDF
(use-package pdf-tools
  :load-path "site-lisp/pdf-tools/lisp"
  :magic ("%PDF" . pdf-view-mode)
  :config (pdf-tools-install :no-query))

 #+end_src

*** :magic-fallback
Similar a [[:magic]] solo que este tiene menos prioridad que ~:mode~.

*** :hook
Permite agregar funciones en los hooks del paquete.

El uso de ~:hook~, al igual que con ~:bind~, ~:mode~, ~:interpreter~, etc ..., hace que las funciones que se enlazan implícitamente se lean como comandos (lo que significa que establecerán definiciones interactivas de carga automática para ese módulo, si aún no están definidas como funciones) por lo que ~:defer t~ esta de manera implícita en ~:hook~.

El paquete se cargará la primera vez que se invoque uno de los hooks.


 #+begin_src emacs-lisp

;; El :hook difirere la carga de ace-jump-mode hasta que se haya activado
;; el modo prog-mode
(use-package ace-jump-mode
  :hook prog-mode)
;; Equivalentemente
(use-package ace-jump-mode
  :hook (prog-mode . ace-jump-mode))
;; Equivalentemente
(use-package ace-jump-mode
  :commands ace-jump-mode
  :init  (add-hook 'prog-mode-hook #'ace-jump-mode))
;; El : hook (prog-mode . ace-jump-mode) se expande internamente para
;; convertirse en  (add-hook 'prog-mode-hook #'ace-jump-mode)

;; Se pueden aplicar multiples hooks, las siguientes son equivalentes.
(use-package ace-jump-mode
  :hook (prog-mode text-mode))

(use-package ace-jump-mode
  :hook ((prog-mode text-mode) . ace-jump-mode))

(use-package ace-jump-mode
  :hook ((prog-mode . ace-jump-mode) (text-mode . ace-jump-mode)))

(use-package ace-jump-mode
  :commands ace-jump-mode
  :init (add-hook 'prog-mode-hook #'ace-jump-mode)
        (add-hook 'text-mode-hook #'ace-jump-mode))
;; No hace falta :hook ya que se adjunta de forma predeterminada

 #+end_src

** Customizing variables
*** :custom
Permite la personalización de las variables personalizables del paquete.

Los valores personalizados *NO* seran guardados en la ~custom-file~ Emacs. Así que debe usar ~:custom~ option o debe usar ~M-x customize-option~ que guardara valores personalizados en Emacs (no se puede usar ambos).

El único beneficio de usar ~setq~ en un bloque ~:config~ es que las personalizaciones pueden ejecutar código cuando se asignan valores.

 #+begin_src emacs-lisp

(use-package comint
  :custom  (comint-buffer-maximum-size 20000))

 #+end_src

*** :custom-face
Permite la personalización de las fuentes personalizadas del paquete.

 #+begin_src emacs-lisp

(use-package eruby-mode
  :custom-face  (eruby-standard-face ((t (:slant italic)))))

 #+end_src

** Miscellaneous
*** :defines & :function
Para introducir declaraciones ficticias de variables y funciones únicamente porque ~use-package~ siempre carga todos los archivos que puede cuando ~.emacs~ se compila en bytes. Esto ayuda a silenciar las advertencias falsas sobre variables y funciones desconocidas.

*** :load-path
Cuando el paquete necesita un directorio agregado a la ruta de carga.

*** :diminish
Para remover el string de minor mode en la ~mode-line~ (no muestra el modo en la lista de todos los modos, útil para que no aparezcan tantos modos en la lista, es más fácil de buscar uno en específico).

*** :delight
Para cambiar el string minor mode en la ~mode-line~.

* References
  - [[https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html][An Introduction to Programming in Emacs Lisp]]
  - [[https://www.youtube.com/watch?v=48JlgiBpw_I][System Crafters Youtube]]
  - [[https://github.com/daviwil/emacs-from-scratch/blob/master/init.el][System Crafters Scratch]]
  - [[https://config.daviwil.com/emacs][System Crafters Daviwil]]
  - [[https://orgmode.org/orgguide.html][Org Mode Compact Guide]]
  - [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.htm][The GNU Emacs Editor Manual]]
  - [[https://wilkesley.org/~ian/xah/][∑XAH]]
